# RFC-0048: Widget Busy Monitor - Timeout Detection System

**Status**: Implemented
**Date**: 2025-10-21
**Author**: Claude Code
**Related**: RFC-0042, RFC-0044, RFC-0045, RFC-0046, RFC-0047

## Problem Statement

### Intermit√™ncia nos Widgets TELEMETRY

Observamos intermit√™ncia no carregamento dos 3 widgets TELEMETRY (energy, water, temperature) no dashboard `telemetry_content`:

1. **Widget fica em showBusy por mais de 30 segundos** sem dados
2. **Dados zerados** mesmo quando h√° dados dispon√≠veis no cache/API
3. **Falta de visibilidade** sobre qual widget est√° travado
4. **Sem auto-recovery** quando widget entra em estado inconsistente

### Cen√°rios Problem√°ticos

```
CEN√ÅRIO 1: Widget n√£o recebe dados do orchestrator
- Widget chama showBusy()
- Orchestrator emite evento 'myio:telemetry:provide-data'
- Widget n√£o recebe o evento (listener n√£o registrado ou erro)
- showBusy() permanece vis√≠vel indefinidamente

CEN√ÅRIO 2: Widget recebe dados vazios
- Widget recebe array vazio do orchestrator
- Widget n√£o chama hideBusy() porque n√£o h√° dados para processar
- Usu√°rio v√™ tela de loading eternamente

CEN√ÅRIO 3: Erro silencioso no processamento
- Widget recebe dados v√°lidos
- Erro JavaScript durante processamento (ex: item.value.toFixed() quando value √© null)
- Erro √© silencioso (try/catch n√£o reporta)
- hideBusy() nunca √© chamado
```

## Solution Design

### Widget Busy Monitor

Sistema de monitoramento que detecta widgets travados e tenta auto-recovery:

```javascript
const widgetBusyMonitor = {
  timers: new Map(), // domain -> timeoutId
  TIMEOUT_MS: 30000, // 30 segundos

  startMonitoring(domain) {
    // Inicia timer quando widget mostra busy
  },

  stopMonitoring(domain) {
    // Para timer quando widget esconde busy
  }
}
```

### Fluxo de Monitoramento

```
1. Widget chama showGlobalBusy(domain)
   ‚Üì
2. Monitor inicia timer de 30s para esse domain
   ‚Üì
3a. Widget processa dados e chama hideBusy()
    ‚Üí Monitor cancela timer ‚úÖ

3b. 30 segundos passam sem hideBusy()
    ‚Üí Monitor detecta problema ‚ö†Ô∏è
    ‚Üí Logs detalhados sobre o estado
    ‚Üí Auto-recovery: for√ßa hideBusy()
```

### Integra√ß√£o com Orchestrator

```javascript
// showGlobalBusy agora inicia monitoramento
function showGlobalBusy(domain = 'unknown', message = 'Carregando dados...') {
  // ... c√≥digo existente ...

  // RFC-0048: Start widget monitoring
  if (window.MyIOOrchestrator?.widgetBusyMonitor) {
    window.MyIOOrchestrator.widgetBusyMonitor.startMonitoring(domain);
  }
}

// hideGlobalBusy agora para monitoramento
function hideGlobalBusy() {
  // RFC-0048: Stop widget monitoring for current domain
  if (window.MyIOOrchestrator?.widgetBusyMonitor && globalBusyState.currentDomain) {
    window.MyIOOrchestrator.widgetBusyMonitor.stopMonitoring(globalBusyState.currentDomain);
  }

  // ... c√≥digo existente ...
}
```

## Implementation Details

### Detec√ß√£o de Problemas

Quando timeout de 30s √© atingido, o monitor registra:

```javascript
LogHelper.error(`[WidgetMonitor] ‚ö†Ô∏è Widget ${domain} has been showing busy for more than 30s!`);
LogHelper.error(`[WidgetMonitor] Possible issues:`);
LogHelper.error(`[WidgetMonitor] 1. Widget n√£o recebeu dados do orchestrator`);
LogHelper.error(`[WidgetMonitor] 2. Widget recebeu dados vazios mas n√£o chamou hideBusy()`);
LogHelper.error(`[WidgetMonitor] 3. Erro silencioso impedindo processamento`);
```

### Informa√ß√µes de Debug

O monitor coleta e registra:

1. **Estado do Busy Global**
   ```javascript
   const busyState = globalBusyState;
   LogHelper.error(`[WidgetMonitor] Current busy state:`, busyState);
   ```

2. **Estado do Cache para o Domain**
   ```javascript
   const cacheKey = `${domain}:${period.startISO}:${period.endISO}`;
   const cached = memCache.get(cacheKey);
   LogHelper.error(`[WidgetMonitor] Cache state for ${domain}:`, {
     hasCachedData: !!cached,
     itemCount: cached?.items?.length || 0,
     cachedAt: cached?.cachedAt ? new Date(cached.cachedAt).toISOString() : 'never'
   });
   ```

### Auto-Recovery

Quando problema √© detectado:

```javascript
LogHelper.warn(`[WidgetMonitor] üîß Attempting auto-recovery: forcing hideBusy for ${domain}`);
hideGlobalBusy();
```

Isso permite que:
- Usu√°rio veja a interface novamente (mesmo que com dados zerados)
- Widget possa tentar novo carregamento se usu√°rio mudar per√≠odo
- Sistema n√£o fique travado indefinidamente

## Key Benefits

### 1. Visibilidade de Problemas
- **Antes**: Widget travado silenciosamente, sem informa√ß√£o
- **Depois**: Logs detalhados indicando exatamente qual widget e por quanto tempo

### 2. Auto-Recovery
- **Antes**: Usu√°rio precisava recarregar p√°gina inteira
- **Depois**: Sistema tenta recovery autom√°tico ap√≥s 30s

### 3. Debug Facilitado
- **Antes**: Dif√≠cil saber se problema √© cache, API, ou widget
- **Depois**: Logs mostram estado do cache, busy, e domain espec√≠fico

### 4. N√£o-Intrusivo
- Monitor opera em background
- N√£o afeta fluxo normal quando widgets funcionam corretamente
- Apenas age quando detecta anomalia

## Testing Strategy

### Teste Manual 1: Widget Normal
```
1. Abrir dashboard telemetry_content
2. Selecionar per√≠odo com dados
3. Verificar que showBusy aparece e desaparece < 30s
4. Monitor deve iniciar e parar normalmente
5. Sem logs de erro
```

### Teste Manual 2: Simular Timeout
```
1. No TELEMETRY controller, comentar hideBusy() no final de dataProvideHandler
2. Abrir dashboard telemetry_content
3. Selecionar per√≠odo
4. Aguardar 30 segundos
5. Verificar logs do WidgetMonitor
6. Verificar auto-recovery (busy desaparece)
```

### Teste Manual 3: M√∫ltiplos Widgets
```
1. Abrir dashboard com 3 widgets TELEMETRY
2. Simular timeout em apenas 1 widget
3. Verificar que apenas esse widget √© monitorado/recuperado
4. Outros widgets devem funcionar normalmente
```

## Monitoring Metrics

Console logs permitem rastrear:

```
‚úÖ [WidgetMonitor] Started monitoring energy (timeout: 30s)
‚úÖ [WidgetMonitor] Stopped monitoring energy

‚ö†Ô∏è [WidgetMonitor] Widget water has been showing busy for more than 30s!
üîß [WidgetMonitor] Attempting auto-recovery: forcing hideBusy for water
```

## Migration Path

### Nenhuma mudan√ßa necess√°ria nos widgets

Integra√ß√£o √© transparente:
- Widgets continuam chamando `showBusy()` e `hideBusy()` normalmente
- Monitor opera automaticamente via orchestrator
- N√£o requer mudan√ßas em TELEMETRY, HEADER, ou FOOTER

### Rollback

Se necess√°rio reverter:
```javascript
// Remover linha 565-569 de controller.js (showGlobalBusy)
// Remover linha 611-614 de controller.js (hideGlobalBusy)
// Remover bloco 1598-1652 de controller.js (widgetBusyMonitor)
```

## Configuration

### Ajustar Timeout

Padr√£o √© 30 segundos. Para ajustar:

```javascript
const widgetBusyMonitor = {
  timers: new Map(),
  TIMEOUT_MS: 45000, // 45 segundos
  // ...
}
```

### Desabilitar Monitor

Para desabilitar temporariamente:

```javascript
// Em showGlobalBusy, comentar:
/*
if (window.MyIOOrchestrator?.widgetBusyMonitor) {
  window.MyIOOrchestrator.widgetBusyMonitor.startMonitoring(domain);
}
*/
```

## Related Work

- **RFC-0042**: Orchestrator base implementation
- **RFC-0044**: Centralized busy management (base para este RFC)
- **RFC-0045**: Cache strategy (informa√ß√µes usadas no debug)
- **RFC-0046**: Race condition fixes (contexto dos problemas)
- **RFC-0047**: Cache improvements (dados de cache usados no monitor)

## Future Improvements

### 1. Telemetry
Enviar m√©tricas para ThingsBoard:
```javascript
{
  widgetTimeouts: { energy: 2, water: 1, temperature: 0 },
  avgBusyDuration: { energy: 3200, water: 2800, temperature: 3100 },
  autoRecoverySuccess: true
}
```

### 2. User Notification
Mostrar notifica√ß√£o visual ao usu√°rio:
```javascript
showNotification({
  type: 'warning',
  message: 'Dados demorando mais que o esperado, tentando novamente...',
  duration: 5000
});
```

### 3. Retry Strategy
Implementar retry autom√°tico:
```javascript
if (timeout) {
  LogHelper.warn('Retrying data fetch...');
  MyIOOrchestrator.invalidateCache(domain);
  MyIOOrchestrator.hydrateDomain(domain, currentPeriod);
}
```

### 4. Circuit Breaker
Prevenir retry loops infinitos:
```javascript
if (retryCount > 3) {
  LogHelper.error('Max retries reached, showing error state');
  showErrorState(domain);
}
```

## Files Modified

```
src/thingsboard/main-dashboard-shopping/v-5.2.0/WIDGET/MAIN_VIEW/controller.js
  - Line 565-569: Monitor start em showGlobalBusy
  - Line 611-614: Monitor stop em hideGlobalBusy
  - Line 1598-1652: widgetBusyMonitor implementation
  - Line 1684: Expose widgetBusyMonitor na public API
  - Line 1722-1723: Stop all monitors em destroy
```

## Conclusion

O Widget Busy Monitor resolve o problema de widgets TELEMETRY travados, fornecendo:

‚úÖ **Detec√ß√£o autom√°tica** de widgets com busy > 30s
‚úÖ **Logs detalhados** para debug
‚úÖ **Auto-recovery** para melhor UX
‚úÖ **Zero mudan√ßas** necess√°rias nos widgets existentes
‚úÖ **N√£o-intrusivo** quando sistema funciona normalmente

Implementa√ß√£o est√° completa e pronta para testes em produ√ß√£o.

## Appendix A: Console Output Example

```
[TELEMETRY] üîÑ showBusy() called with message: "Carregando dados..."
[Orchestrator] üîÑ showGlobalBusy() domain=energy message="Carregando dados..."
[WidgetMonitor] ‚úÖ Started monitoring energy (timeout: 30s)

... 30 segundos depois (se hideBusy n√£o for chamado) ...

[WidgetMonitor] ‚ö†Ô∏è Widget energy has been showing busy for more than 30s!
[WidgetMonitor] Possible issues:
[WidgetMonitor] 1. Widget n√£o recebeu dados do orchestrator
[WidgetMonitor] 2. Widget recebeu dados vazios mas n√£o chamou hideBusy()
[WidgetMonitor] 3. Erro silencioso impedindo processamento
[WidgetMonitor] Current busy state: {
  isVisible: true,
  currentDomain: 'energy',
  startTime: 1729511234567,
  requestCount: 1,
  timeoutId: 123
}
[WidgetMonitor] Cache state for energy: {
  hasCachedData: true,
  itemCount: 45,
  cachedAt: '2025-10-21T14:30:00.000Z'
}
[WidgetMonitor] üîß Attempting auto-recovery: forcing hideBusy for energy
[Orchestrator] ‚è∏Ô∏è hideGlobalBusy() called
[WidgetMonitor] ‚úÖ Stopped monitoring energy
```

## Appendix B: Architecture Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   MAIN_VIEW Widget                  ‚îÇ
‚îÇ                  (Orchestrator Host)                ‚îÇ
‚îÇ                                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ       MyIOOrchestrator                        ‚îÇ ‚îÇ
‚îÇ  ‚îÇ                                               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   widgetBusyMonitor                     ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ                                         ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   timers: Map {                        ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ     'energy'  -> timeoutId1            ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ     'water'   -> timeoutId2            ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ     'temperature' -> timeoutId3        ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   }                                     ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ                                         ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   startMonitoring(domain) {            ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ     setTimeout(() => {                 ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ       // Log errors                    ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ       // Show state                    ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ       // Force hideBusy()              ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ     }, 30000)                          ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   }                                     ‚îÇ ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ
‚îÇ  ‚îÇ                                               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  showGlobalBusy(domain) {                     ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    widgetBusyMonitor.startMonitoring(domain)  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    // ... show busy overlay ...              ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  }                                             ‚îÇ ‚îÇ
‚îÇ  ‚îÇ                                               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  hideGlobalBusy() {                           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    widgetBusyMonitor.stopMonitoring(domain)   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    // ... hide busy overlay ...              ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  }                                             ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚îÇ Events
                        ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ      TELEMETRY Widgets (x3)          ‚îÇ
    ‚îÇ                                      ‚îÇ
    ‚îÇ  Energy Widget                       ‚îÇ
    ‚îÇ    calls: showBusy() / hideBusy()   ‚îÇ
    ‚îÇ                                      ‚îÇ
    ‚îÇ  Water Widget                        ‚îÇ
    ‚îÇ    calls: showBusy() / hideBusy()   ‚îÇ
    ‚îÇ                                      ‚îÇ
    ‚îÇ  Temperature Widget                  ‚îÇ
    ‚îÇ    calls: showBusy() / hideBusy()   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```
