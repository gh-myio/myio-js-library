Awesome start—both docs are clear and very close to shippable. Here’s a tight review with surgical edits so you can cut straight to implementation.

What’s solid

Clear deep-linking flow with storeLUC and a sane fallback to the bound entity.

Clean separation of concerns: auth → device resolve → attrs → UI → action wiring.

Implementation Plan breaks work into testable phases with checklists and deployment/rollback steps.

Gaps & fixes (actionable)

Public auth strategy (risk)

The RFC bakes hard-coded credentials into the widget. For a public dashboard, prefer TB’s native Public Dashboard (publicId) or a tiny proxy that exchanges a short-lived JWT from server → browser. At minimum, move the exact username/password out of the RFC body and into a deployment secret note.

Add a line to “Security Considerations”: “If the dashboard is made Public via ThingsBoard’s share link, skip MyIOAuthTB entirely and rely on public access.”

Device lookup hardening

Normalize and guard the URL value:

const storeLUC = (urlParams.get('storeLUC') || '').trim();

Early-return on empty after trim; log WARN; fallback.

Some TB installs map LUC to attribute not name. Add a second lookup path:

First try /api/tenant/devices?deviceName=<LUC>

If 404, query by attribute via the relations/attributes search pattern (document the alternative and keep the current one as default).

Fallback extraction

ctx.defaultSubscription is not always populated in LV widgets. Prefer:

const ds = (ctx.datasources && ctx.datasources[0]) || null;

Read from ds.entity / ds.entityLabel as primary, then fall back to defaultSubscription. (This avoids nulls in public boards.)

Identifier display & fallback

If server-scope identifier is missing, display storeLUC (when present) instead of '-'. This matches the UI intent (the small line under the label).

Action handler binding

Today you call global window.handleAction*. Make this resilient:

Prefer importing/reading from the library namespace if present (e.g., window.MyIOLib?.handleActionReport) and only then fallback to window.handleActionReport. Add this note into Action Integration.

Settings toggles (widget schema)

Add a minimal settings.schema.json so product can hide buttons per board without code edits:

showSettings (bool), showReport (bool), showInstant (bool), showChartCTA (bool), and optional primaryColor.

Wire visibility in template.html via ng-if/conditional render. Mention this in RFC’s “Detailed Design”.

Logging & UX polish

Prefix is consistent—great. Add one toast for the fallback path and one for missing critical attrs so support can screenshot evidence without DevTools. Keep copy non-technical: “We’re showing the store bound to this widget because the link code was not found.”

Performance note

In the RFC “Performance Metrics”, include: Avoid attribute refetch on LV data updates; cache by deviceId for session lifetime. (Your code already leans that way—document it as a rule.)

Drop-in patchlets (ready to paste)

Harden URL + fallback identifier

const urlParams = new URLSearchParams(window.location.search);
const storeLUC = (urlParams.get('storeLUC') || '').trim();

function pickIdentifier(attrs, luc) {
  return attrs.identifier?.toString().trim() || (luc || '-');
}


Safer context fallback (LV widgets)

function getDeviceFromContext(ctx) {
  try {
    const ds0 = Array.isArray(ctx.datasources) ? ctx.datasources[0] : null;
    if (ds0?.entity?.id?.id) {
      return {
        deviceId: ds0.entity.id.id,
        deviceName: ds0.entityName || 'Unknown',
        deviceLabel: ds0.entityLabel || ds0.entityName || 'Unknown Device'
      };
    }
    // legacy fallback
    const sub = ctx.defaultSubscription;
    const d = sub?.data?.[0]?.dataKey;
    if (d?.entityId) {
      return { deviceId: d.entityId, deviceName: d.name || 'Unknown', deviceLabel: d.label || d.name || 'Unknown Device' };
    }
  } catch {}
  return null;
}


Dual-path device resolve (name → attribute)

async function getDeviceByLUC(storeLUC, token) {
  // try by name
  let dev = await fetch(`${TB_HOST}/api/tenant/devices?deviceName=${encodeURIComponent(storeLUC)}`, {
    headers: { Authorization: `Bearer ${token}` }
  }).then(r => r.ok ? r.json() : null).catch(() => null);
  if (dev?.id?.id) return { deviceId: dev.id.id, deviceName: dev.name, deviceLabel: dev.label || dev.name };

  // fallback: search by attribute (example: identifier==LUC)
  // NOTE: keep this commented in prod until your TB search path is enabled
  // const found = await searchDeviceByAttribute('identifier', storeLUC, token);
  // if (found) return found;

  return null;
}


Use storeLUC as the UI fallback

renderStoreHeader(deviceInfo.deviceLabel, pickIdentifier(attributes, storeLUC));

Implementation Plan nits

Add a pre-deployment decision gate: Public dashboard? If yes → skip auth module and use shared public link; if no → include MyIOAuthTB. Put this into Phase 1 checklist.

Add a testing case for storeLUC with trailing/leading spaces and mixed case (normalize).

Include a step to validate the settings schema toggles in Phase 4 (Action Integration) since visibility affects QA outcomes.

Tiny copy edits (RFC)

Rename “Consumption Report” button in the RFC text to exactly match the product label you’ll ship (“Relatório de Consumo” or “Consumption Report”) and keep it consistent across the doc.

Under “Non-Goals”, call out explicitly that the chart area is a CTA shell (opens the full dashboard), not an embedded chart engine.