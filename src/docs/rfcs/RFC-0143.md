# RFC-0143: Device Grid Widget Factory

- Feature Name: `device_grid_widget_factory`
- Start Date: 2026-01-09
- RFC PR: N/A
- Issue: N/A
- **Implementation Status: Phase 1-5 Complete (All widgets migrated to factory pattern)**

## Summary

This RFC proposes a **DeviceGridWidgetFactory** pattern to eliminate code duplication across the four device grid widgets (EQUIPMENTS, STORES, WATER_STORES, WATER_COMMON_AREA). The factory is implemented in MAIN (not MAIN_UNIQUE_DATASOURCE, which is a separate architecture) and generates widget controllers from configuration objects. Each widget controller will be reduced from 2,000-2,800 lines to approximately 50-100 lines of configuration-only code.

## Implementation Notes

**Phase 1-2 Completed (2026-01-11):**
- Factory module created at `src/utils/DeviceGridWidgetFactory.js`
- Exported from `src/index.ts` as part of MyIOLibrary
- MAIN controller (`src/MYIO-SIM/v5.2.0/MAIN/controller.js`) re-exports from `window.MyIOLibrary.DeviceGridWidgetFactory`
- Also exposed as `window.DeviceGridWidgetFactory` and `window.MyIOUtils.DeviceGridWidgetFactory` for child widgets

**Phase 3-5 Completed (2026-01-11):**
- STORES widget migrated: ~2,485 lines → ~165 lines (93% reduction)
- WATER_STORES widget migrated: ~1,915 lines → ~170 lines (91% reduction)
- WATER_COMMON_AREA widget migrated: ~2,200 lines → ~200 lines (91% reduction)
- EQUIPMENTS widget migrated: ~2,826 lines → ~315 lines (89% reduction)

**Exports:**
- `DeviceGridWidgetFactory` - Main factory object
- `createWidgetController` - Creates full widget controller from config
- `createDeviceGridState` - Creates initial state object
- `applyDeviceGridFilters` - Filters devices by shopping, search, multiselect
- `recomputeDeviceGridPercentages` - Recalculates consumption percentages
- `buildDeviceGridEntityObject` - Builds entity for card rendering
- `renderDeviceGridList` - Renders device cards
- `updateDeviceGridStats` - Updates header statistics

**Migration Complete:**
- All 4 widgets now use the factory pattern
- Total reduction: ~9,426 lines → ~850 lines (91% reduction)

## Motivation

### Current State Analysis

| Widget | Lines | Domain | Context | Status Calculation |
|--------|-------|--------|---------|-------------------|
| EQUIPMENTS | 2,826 | energy | equipments | Master Rules (RFC-0110) |
| STORES | 2,485 | energy | stores | Always 'online' (RFC-0140) |
| WATER_STORES | 1,915 | water | hidrometro | Always 'online' (RFC-0140) |
| WATER_COMMON_AREA | 2,200 | water | hidrometro_area_comum | Master Rules (RFC-0110) |

**Total: ~9,426 lines of nearly identical code**

### Code Duplication Analysis (~90% identical)

The following patterns are **completely identical** across all 4 widgets:

1. **STATE object structure**:
   ```javascript
   const STATE = {
     itemsBase: [],
     itemsEnriched: [],
     searchActive: false,
     searchTerm: '',
     selectedIds: null,
     sortMode: 'cons_desc',
     selectedShoppingIds: [],
   };
   ```

2. **applyFilters()** - Shopping filter, multiselect filter, search term filter, sorting logic

3. **recomputePercentages()** - Consumption percentage calculation

4. **Card rendering via MyIOLibrary.renderCardComponentHeadOffice()**

5. **Header controller via window.MyIOUtils.buildHeaderDevicesGrid()**

6. **Filter modal via window.MyIOUtils.createFilterModal()**

7. **Event handlers**: `myio:update-date`, `myio:filter-applied`, `myio:*-summary-ready`

8. **Busy/loading modal pattern** - showBusy(), hideBusy()

9. **Lifecycle methods**: onInit structure, onDataUpdated (no-op), onDestroy cleanup

10. **Authentication**: MyIOAuth initialization, credential fetching

### What DIFFERS (Configuration Only)

| Configuration | EQUIPMENTS | STORES | WATER_STORES | WATER_COMMON_AREA |
|--------------|------------|--------|--------------|-------------------|
| domain | 'energy' | 'energy' | 'water' | 'water' |
| context | 'equipments' | 'stores' | 'hidrometro' | 'hidrometro_area_comum' |
| statusCalculation | 'master_rules' | 'always_online' | 'always_online' | 'master_rules' |
| formatValue | formatEnergy() | formatEnergy() | formatWaterVolumeM3() | formatWaterVolumeM3() |
| deviceFilter | isEquipment() | isStore() | isHidrometroLoja() | isHidrometroAreaComum() |
| filterTabs | [HVAC, Elevators, Escalators, Others] | [All, Online, Offline, With/No Consumption] | [All, Online, Offline, With/No Consumption] | [All, Online, Offline, With/No Consumption] |
| headerLabels | 'Total de Equipamentos' | 'Total de Lojas' | 'Total de Hidrometros' | 'Total de Hidrometros' |
| primaryColor | '#3E1A7D' | '#3E1A7D' | '#0288D1' | '#0288D1' |
| hasRealTimeMode | true (WebSocket/REST) | false | false | false |

### Goals

1. **90% code reduction**: Each widget controller from ~2,500 lines to ~80 lines
2. **Single source of truth**: All shared logic in DeviceGridWidgetFactory
3. **Preserve existing functionality**: All RFCs (0078, 0090, 0093, 0102, 0110, 0126, 0140) intact
4. **Backward compatibility**: Existing HTML templates, events, and APIs unchanged
5. **Improved maintainability**: Bug fixes apply to all widgets automatically

## Guide-level Explanation

### New Architecture Overview

```
+---------------------------------------------------------------------+
|                    MAIN_UNIQUE_DATASOURCE                           |
|  +---------------------------------------------------------------+  |
|  |                  DeviceGridWidgetFactory                       |  |
|  |  - createWidgetController(config) -> controller object        |  |
|  |  - Shared: STATE, applyFilters, renderList, filterModal       |  |
|  |  - Shared: busy modal, auth, event handlers                   |  |
|  +---------------------------------------------------------------+  |
|                              |                                       |
|              +---------------+---------------+                      |
|              v               v               v                      |
|  +---------------+  +---------------+  +---------------+           |
|  |  EQUIPMENTS   |  |    STORES     |  | WATER_STORES  |   ...     |
|  |   config.js   |  |   config.js   |  |   config.js   |           |
|  |   (~80 lines) |  |   (~60 lines) |  |   (~70 lines) |           |
|  +---------------+  +---------------+  +---------------+           |
+---------------------------------------------------------------------+
```

### Widget Configuration Interface

```typescript
interface DeviceGridWidgetConfig {
  // Identity
  widgetName: string;           // 'EQUIPMENTS' | 'STORES' | 'WATER_STORES' | 'WATER_COMMON_AREA'
  idPrefix: string;             // 'equip' | 'stores' | 'waterStores' | 'waterCommonArea'

  // Domain & Context
  domain: 'energy' | 'water' | 'temperature';
  context: 'equipments' | 'stores' | 'hidrometro' | 'hidrometro_area_comum';

  // Device Classification
  deviceFilter: (device: Device) => boolean;  // Filter function for this widget's devices
  statusCalculation: 'master_rules' | 'always_online';

  // Value Formatting
  formatValue: (value: number) => string;     // MyIO.formatEnergy or MyIO.formatWaterVolumeM3
  unit: string;                 // 'kWh' | 'm3'
  valType: string;              // 'power_kw' | 'volume_m3'
  icon: string;                 // 'energy' | 'water'

  // UI Configuration
  primaryColor: string;         // '#3E1A7D' | '#0288D1'
  filterTabs: FilterTab[];      // Category tabs for filter modal
  headerLabels: HeaderLabels;   // Labels for statistics header
  listElementId: string;        // DOM ID for cards container

  // Feature Flags
  hasRealTimeMode: boolean;     // Only EQUIPMENTS has WebSocket/REST polling
  hasEquipmentCategories: boolean;  // Subcategorization for EQUIPMENTS

  // Event Names
  summaryReadyEvent: string;    // 'myio:energy-summary-ready' | 'myio:water-summary-ready'
}
```

### Example: STORES Widget After Refactor

```javascript
// src/MYIO-SIM/v5.2.0/STORES/controller.js (~60 lines)

const { DeviceGridWidgetFactory } = window.MyIOUtils;

const STORES_CONFIG = {
  widgetName: 'STORES',
  idPrefix: 'stores',

  domain: 'energy',
  context: 'stores',

  deviceFilter: (device) => {
    // Store = deviceType === deviceProfile === '3F_MEDIDOR'
    const type = (device.deviceType || '').toUpperCase();
    const profile = (device.deviceProfile || '').toUpperCase();
    return type === '3F_MEDIDOR' && profile === '3F_MEDIDOR';
  },

  statusCalculation: 'always_online',  // RFC-0140: Stores always online

  formatValue: (val) => window.MyIOLibrary.formatEnergy(val),
  unit: 'kWh',
  valType: 'power_kw',
  icon: 'energy',

  primaryColor: '#3E1A7D',
  listElementId: 'shopsList',

  filterTabs: [
    { id: 'all', label: 'Todos', filter: () => true },
    { id: 'withConsumption', label: 'Com Consumo', filter: (d) => getConsumption(d) > 0 },
    { id: 'noConsumption', label: 'Sem Consumo', filter: (d) => getConsumption(d) === 0 },
  ],

  headerLabels: {
    total: 'Total de Lojas',
    consumption: 'Consumo Total',
  },

  hasRealTimeMode: false,
  hasEquipmentCategories: false,

  summaryReadyEvent: 'myio:energy-summary-ready',
};

function getConsumption(device) {
  return Number(device.value) || Number(device.consumption) || 0;
}

const controller = DeviceGridWidgetFactory.createWidgetController(STORES_CONFIG);

self.onInit = controller.onInit;
self.onDataUpdated = controller.onDataUpdated;
self.onDestroy = controller.onDestroy;
```

### Example: WATER_COMMON_AREA Widget After Refactor

```javascript
// src/MYIO-SIM/v5.2.0/WATER_COMMON_AREA/controller.js (~70 lines)

const { DeviceGridWidgetFactory } = window.MyIOUtils;

const WATER_COMMON_AREA_CONFIG = {
  widgetName: 'WATER_COMMON_AREA',
  idPrefix: 'waterCommonArea',

  domain: 'water',
  context: 'hidrometro_area_comum',

  deviceFilter: (device) => {
    // Area Comum = deviceType === 'HIDROMETRO' AND deviceProfile === 'HIDROMETRO_AREA_COMUM'
    const type = (device.deviceType || '').toUpperCase();
    const profile = (device.deviceProfile || '').toUpperCase();
    return type === 'HIDROMETRO' && profile === 'HIDROMETRO_AREA_COMUM';
  },

  statusCalculation: 'master_rules',  // RFC-0110: Calculate real status

  formatValue: (val) => window.MyIOLibrary.formatWaterVolumeM3(val),
  unit: 'm3',
  valType: 'volume_m3',
  icon: 'water',

  primaryColor: '#0288D1',
  listElementId: 'waterCommonAreaList',

  filterTabs: [
    { id: 'all', label: 'Todos', filter: () => true },
    { id: 'online', label: 'Online', filter: (d) => !isOffline(d) },
    { id: 'offline', label: 'Offline', filter: (d) => isOffline(d) },
    { id: 'withConsumption', label: 'Com Consumo', filter: (d) => getConsumption(d) > 0 },
    { id: 'noConsumption', label: 'Sem Consumo', filter: (d) => getConsumption(d) === 0 },
  ],

  headerLabels: {
    total: 'Total de Hidrometros',
    consumption: 'Consumo Total (m3)',
  },

  hasRealTimeMode: false,
  hasEquipmentCategories: false,

  summaryReadyEvent: 'myio:water-summary-ready',
};

function isOffline(device) {
  const status = (device.deviceStatus || '').toLowerCase();
  return ['offline', 'no_info'].includes(status);
}

function getConsumption(device) {
  return Number(device.value) || Number(device.pulses) || 0;
}

const controller = DeviceGridWidgetFactory.createWidgetController(WATER_COMMON_AREA_CONFIG);

self.onInit = controller.onInit;
self.onDataUpdated = controller.onDataUpdated;
self.onDestroy = controller.onDestroy;
```

## Reference-level Explanation

### DeviceGridWidgetFactory Implementation

Location: `src/utils/DeviceGridWidgetFactory.js` (exported from `src/index.ts`)

The factory module will contain:

#### 1. State Management

```javascript
function createState() {
  return {
    itemsBase: [],
    itemsEnriched: [],
    dataFromMain: false,
    searchActive: false,
    searchTerm: '',
    selectedIds: null,
    sortMode: 'cons_desc',
    selectedShoppingIds: [],
    firstHydrates: 0,
  };
}
```

#### 2. Shared Filter Logic

```javascript
function applyFilters(config, STATE, enriched) {
  let v = enriched.slice();

  // Shopping filter (RFC-0093)
  if (STATE.selectedShoppingIds?.length > 0) {
    v = v.filter(x => !x.customerId || STATE.selectedShoppingIds.includes(x.customerId));
  }

  // Multiselect filter
  if (STATE.selectedIds?.size) {
    v = v.filter(x => STATE.selectedIds.has(String(x.id)));
  }

  // Search filter
  const q = (STATE.searchTerm || '').trim().toLowerCase();
  if (q) {
    v = v.filter(x =>
      (x.label || '').toLowerCase().includes(q) ||
      (x.identifier || '').toLowerCase().includes(q)
    );
  }

  // Sorting
  v.sort((a, b) => sortDevices(a, b, STATE.sortMode, config));

  return v;
}
```

#### 3. Shared Render Logic

```javascript
async function renderList(config, STATE, visible) {
  const listElement = document.getElementById(config.listElementId);
  if (!listElement) return;

  listElement.innerHTML = '';

  for (const item of visible) {
    const container = document.createElement('div');
    listElement.appendChild(container);

    const entityObject = buildEntityObject(config, item);

    window.MyIOLibrary.renderCardComponentHeadOffice(container, {
      entityObject,
      delayTimeConnectionInMins: config.statusCalculation === 'always_online' ? 86400 : 1440,
      handleClickCard: (ev, entity) => { /* ... */ },
      handleActionDashboard: () => openDashboard(config, entityObject),
      handleActionReport: () => openReport(config, item),
      handleActionSettings: () => openSettings(config, entityObject),
      handleSelect: (checked, entity) => handleSelection(checked, entity),
      useNewComponents: true,
      enableSelection: true,
      enableDragDrop: true,
      hideInfoMenuItem: true,
    });
  }
}
```

#### 4. Entity Object Builder

```javascript
function buildEntityObject(config, item) {
  const deviceStatus = config.statusCalculation === 'always_online'
    ? 'online'
    : calculateDeviceStatusMasterRules(item, config);

  return {
    entityId: item.tbId || item.id,
    id: item.tbId || item.id,
    labelOrName: item.label,
    name: item.label,
    customerName: window.MyIOUtils.getCustomerNameForDevice(item),
    val: item.value,
    value: item.value,
    valType: config.valType,
    unit: config.unit,
    icon: config.icon,
    domain: config.domain,
    deviceType: item.deviceType,
    deviceProfile: item.deviceProfile,
    deviceStatus,
    perc: item.perc ?? 0,
    // ... additional fields
  };
}
```

#### 5. Lifecycle Methods

```javascript
async function onInit(config, STATE, handlers, uiController) {
  LogHelper.log(`[${config.widgetName}] onInit - RFC-0143 Factory Controller`);

  uiController.initHeader();
  uiController.initFilterModal();
  handlers.register();

  await initAuth(config);

  const cachedData = getCachedData(config);
  if (cachedData?.length > 0) {
    STATE.itemsBase = cachedData;
    STATE.itemsEnriched = enrichItems(cachedData);
    STATE.dataFromMain = true;
    uiController.reflow();
  } else {
    uiController.showBusy('Carregando dados...');
  }
}

function onDestroy(config, handlers) {
  handlers.unregister();
}
```

### Preserved RFCs

| RFC | Description | How Preserved |
|-----|-------------|---------------|
| RFC-0078 | Power Limits hierarchical resolution | In buildEntityObject() - TIER 0: deviceMap, TIER 2: customer |
| RFC-0090 | Shared filter modal factory | Uses window.MyIOUtils.createFilterModal() |
| RFC-0093 | Shopping filter from MENU | In applyFilters() - filters by selectedShoppingIds |
| RFC-0102 | Orchestrator device classification | Unchanged - data flow via window.MyIOOrchestratorData |
| RFC-0110 | Master rules for device status | Configurable via statusCalculation: 'master_rules' |
| RFC-0126 | Module-level caching pattern | In event handlers - checks cache before waiting |
| RFC-0140 | Stores always online | Configurable via statusCalculation: 'always_online' |

## Drawbacks

1. **Learning Curve**: Developers must understand the factory pattern
2. **Debugging Complexity**: Stack traces pass through factory abstraction
3. **Configuration Errors**: Misconfigured widgets may fail silently
4. **Migration Risk**: Existing functionality could regress during migration

### Mitigation

1. **Comprehensive JSDoc**: Full TypeScript-style documentation
2. **Debug Mode**: Factory includes verbose logging option
3. **Config Validation**: Runtime validation of required fields
4. **Phased Migration**: One widget at a time with full testing

## Rationale and Alternatives

### Why Factory Pattern?

1. **Configuration-Driven**: Widgets differ only in configuration, not logic
2. **DRY Principle**: Eliminates 9,000+ lines of duplicated code
3. **Single Bug Fix**: One change fixes all widgets
4. **Extensibility**: New domains/contexts require only new config

### Alternatives Considered

#### Alternative 1: Base Class Inheritance

```javascript
class DeviceGridWidget {
  constructor(config) { ... }
}

class EquipmentsWidget extends DeviceGridWidget {
  getFilterTabs() { ... }
}
```

**Rejected**: JavaScript prototypal inheritance is less intuitive, harder to debug in ThingsBoard context.

#### Alternative 2: Mixin Pattern

```javascript
const filterMixin = { applyFilters() { ... } };
const renderMixin = { renderList() { ... } };

const EquipmentsController = Object.assign({}, filterMixin, renderMixin, equipConfig);
```

**Rejected**: Mixin composition leads to unclear precedence and testing difficulties.

#### Alternative 3: Keep Current Architecture

Maintain four separate widgets with shared utilities extracted.

**Rejected**: Still requires changes to 4 files for every bug fix; doesn't solve maintenance burden.

## Prior Art

1. **RFC-0111**: Unified Main Single Datasource Architecture - Established the Orchestrator pattern
2. **RFC-0090**: Shared Filter Modal Factory - Already uses factory pattern for modals
3. **RFC-0093**: buildHeaderDevicesGrid - Factory function for header components
4. **React/Vue component factories**: Similar pattern used in frontend frameworks

## Unresolved Questions

1. **Real-Time Mode**: Should WebSocket/REST polling be extracted to a separate mixin or remain EQUIPMENTS-specific?

2. **HTML Templates**: Do widget HTML templates need modification, or can they remain unchanged?

3. **Testing Strategy**: How to ensure all four widgets maintain identical behavior after migration?

4. **Performance**: Will factory abstraction introduce measurable overhead?

## Future Possibilities

1. **Temperature Widgets**: Apply same pattern to TEMPERATURE_SENSORS and TEMPERATURE_WITHOUT_CLIMATE_CONTROL

2. **Dynamic Widget Generation**: Generate widgets entirely from MAIN based on datasource aliases

3. **Plugin Architecture**: Allow third-party domain/context configurations

4. **Code Generation**: Build step to generate optimized widget code from configs

5. **Unified TELEMETRY Widget**: As envisioned in RFC-0111, eventually replace all grid widgets with single configurable component

## Implementation Plan

### Phase 1: Factory Core
- Create DeviceGridWidgetFactory.js in MAIN_UNIQUE_DATASOURCE
- Implement shared STATE, applyFilters, recomputePercentages
- Add comprehensive unit tests

### Phase 2: STORES Migration
- Migrate STORES to factory pattern (simplest: no categories, always online)
- Verify all existing functionality preserved
- Run integration tests

### Phase 3: WATER Widgets Migration
- Migrate WATER_STORES to factory pattern
- Migrate WATER_COMMON_AREA (master_rules status)
- Verify water domain formatting

### Phase 4: EQUIPMENTS Migration
- Migrate EQUIPMENTS (most complex: categories, real-time mode)
- Verify subcategorization and WebSocket integration
- Full regression testing

### Phase 5: Cleanup
- Remove dead code from original widgets
- Update documentation
- Performance profiling

## Critical Files

| File | Action | Status |
|------|--------|--------|
| `src/utils/DeviceGridWidgetFactory.js` | CREATE - Factory module | ✅ DONE |
| `src/index.ts` | EDIT - Export factory | ✅ DONE |
| `src/MYIO-SIM/v5.2.0/MAIN/controller.js` | EDIT - Re-export from MyIOLibrary | ✅ DONE |
| `src/MYIO-SIM/v5.2.0/STORES/controller.js` | REPLACE (~165 lines) | ✅ DONE |
| `src/MYIO-SIM/v5.2.0/WATER_STORES/controller.js` | REPLACE (~170 lines) | ✅ DONE |
| `src/MYIO-SIM/v5.2.0/WATER_COMMON_AREA/controller.js` | REPLACE (~200 lines) | ✅ DONE |
| `src/MYIO-SIM/v5.2.0/EQUIPMENTS/controller.js` | REPLACE (~315 lines) | ✅ DONE |

## Expected Outcome

- **Before:** ~9,400 lines across 4 widgets
- **After:** ~300 lines across 4 widgets + ~800 lines factory
- **Net reduction:** ~8,300 lines (88% reduction)
- **Single source of truth:** Bug fixes apply to all widgets automatically
