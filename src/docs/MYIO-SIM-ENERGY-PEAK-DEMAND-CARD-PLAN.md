# MYIO-SIM 1.0.0: Energy Peak Demand Card Implementation Plan

**Status**: üìã Planning Phase
**Created**: 2025-10-16
**Priority**: üü° Medium
**Complexity**: üü° Medium (4-6 hours estimated)

---

## üìã Executive Summary

### Objetivo
Implementar o card de "Pico de Demanda" no widget ENERGY do MYIO-SIM 1.0.0, buscando dados reais do ThingsBoard via API de telemetria, seguindo o padr√£o estabelecido em `DemandModal.ts`.

### Problema Atual
O card de "Pico de Demanda" no template est√° com dados mockados est√°ticos:
```html
<div class="card">
  <p class="label">Pico de Demanda</p>
  <h3 class="value">1.892 kW</h3>
  <span class="trend up">‚ñ≤ +5% vs ontem</span>
</div>
```

### Solu√ß√£o Proposta
Criar endpoint no n√≠vel de **CUSTOMER** (n√£o DEVICE) para buscar o pico de demanda agregado de todos os dispositivos do cliente, usando a API do ThingsBoard.

---

## üîç An√°lise T√©cnica

### 1. Padr√£o de Refer√™ncia: DemandModal.ts

**Localiza√ß√£o**: `C:\Projetos\GitHub\myio\myio-js-library-PROD.git\src\components\DemandModal.ts`

**URL Pattern Usado** (linhas 731-734):
```typescript
let url = `/api/plugins/telemetry/DEVICE/${deviceId}/values/timeseries?` +
  `keys=${keys}&startTs=${startTs}&endTs=${endTs}&` +
  `intervalType=${intervalType}&interval=${interval}&agg=${agg}&orderBy=${orderBy}`;
```

**Par√¢metros Importantes**:
- `deviceId`: ID do dispositivo no ThingsBoard
- `keys`: Chaves de telemetria (ex: `power`, `demand`, `consumption`)
- `startTs`: Timestamp in√≠cio (ms)
- `endTs`: Timestamp fim (ms)
- `intervalType`: Tipo de intervalo (`0` para customizado)
- `interval`: Intervalo em ms (ex: `3600000` para 1 hora)
- `agg`: Agrega√ß√£o (`MAX`, `MIN`, `AVG`, `SUM`, `COUNT`, `NONE`)
- `orderBy`: Ordena√ß√£o (`ASC` ou `DESC`)

### 2. Adapta√ß√£o para CUSTOMER

**Problema**: A API atual √© focada em **DEVICE**. Precisamos adaptar para **CUSTOMER**.

**Solu√ß√µes Poss√≠veis**:

#### Op√ß√£o A: Iterar por Devices (Recomendada)
```typescript
// 1. Buscar todos os devices do customer (j√° temos no self.ctx.data)
// 2. Para cada device, fazer uma chamada individual
// 3. Agregar os resultados localmente
```

#### Op√ß√£o B: API de Customer Aggregation (Se dispon√≠vel)
```typescript
// Verificar se ThingsBoard tem endpoint:
// /api/plugins/telemetry/CUSTOMER/${customerId}/values/timeseries
```

#### Op√ß√£o C: Usar Ingestion API (Orquestrador)
```typescript
// Usar endpoint da Ingestion API similar ao de energy:
// ${DATA_API_HOST}/api/v1/telemetry/customers/${customerId}/demand/peak
```

---

## üéØ Implementa√ß√£o Detalhada

### Fase 1: Estrutura de Dados e API

#### 1.1 Definir Endpoint e M√©todo

**Arquivo**: `C:\Projetos\GitHub\myio\myio-js-library-PROD.git\src\MYIO-SIM\V1.0.0\ENERGY\controller.js`

**Fun√ß√£o a Criar**:
```javascript
/**
 * Busca o pico de demanda de todos os dispositivos do customer
 * @param {string} customerId - ID do customer no ThingsBoard
 * @param {number} startTs - Timestamp in√≠cio em ms
 * @param {number} endTs - Timestamp fim em ms
 * @returns {Promise<{peakValue: number, timestamp: number, deviceId: string}>}
 */
async function fetchCustomerPeakDemand(customerId, startTs, endTs) {
  const tbToken = localStorage.getItem("jwt_token");

  if (!tbToken) {
    throw new Error("JWT do ThingsBoard n√£o encontrado");
  }

  // OP√á√ÉO A: Iterar por devices (implementa√ß√£o completa abaixo)
  const devices = extractDeviceIds(self.ctx.data);
  const peakResults = [];

  for (const deviceId of devices) {
    try {
      const url = `/api/plugins/telemetry/DEVICE/${deviceId}/values/timeseries?` +
        `keys=power,demand&startTs=${startTs}&endTs=${endTs}&` +
        `intervalType=0&interval=3600000&agg=MAX&orderBy=DESC&limit=1`;

      const response = await fetch(url, {
        headers: {
          "X-Authorization": `Bearer ${tbToken}`,
          "Content-Type": "application/json",
        },
      });

      if (!response.ok) {
        console.warn(`[ENERGY] Failed to fetch demand for device ${deviceId}: ${response.status}`);
        continue;
      }

      const data = await response.json();

      // Data format: { "power": [{ts: 123, value: 456}], "demand": [...] }
      const powerData = data.power || [];
      const demandData = data.demand || [];

      if (powerData.length > 0) {
        peakResults.push({
          deviceId,
          value: powerData[0].value,
          timestamp: powerData[0].ts,
          key: 'power'
        });
      }

      if (demandData.length > 0) {
        peakResults.push({
          deviceId,
          value: demandData[0].value,
          timestamp: demandData[0].ts,
          key: 'demand'
        });
      }
    } catch (err) {
      console.error(`[ENERGY] Error fetching demand for device ${deviceId}:`, err);
    }
  }

  // Encontrar o maior pico entre todos os devices
  if (peakResults.length === 0) {
    return { peakValue: 0, timestamp: Date.now(), deviceId: null, deviceName: null };
  }

  const maxPeak = peakResults.reduce((max, current) =>
    current.value > max.value ? current : max
  );

  // Buscar nome do device
  const deviceName = getDeviceNameById(maxPeak.deviceId);

  return {
    peakValue: maxPeak.value,
    timestamp: maxPeak.timestamp,
    deviceId: maxPeak.deviceId,
    deviceName: deviceName || 'Desconhecido'
  };
}

/**
 * Extrai IDs dos devices do ctx.data
 */
function extractDeviceIds(ctxData) {
  const deviceIds = new Set();

  ctxData.forEach(data => {
    if (data.datasource.aliasName !== "Shopping") {
      const entityId = data.datasource.entityId?.id || data.datasource.entity?.id?.id;
      if (entityId) {
        deviceIds.add(entityId);
      }
    }
  });

  return Array.from(deviceIds);
}

/**
 * Busca nome do device por ID
 */
function getDeviceNameById(deviceId) {
  const deviceData = self.ctx.data.find(d => {
    const id = d.datasource.entityId?.id || d.datasource.entity?.id?.id;
    return id === deviceId;
  });

  return deviceData?.datasource?.entityLabel ||
         deviceData?.datasource?.entityName ||
         deviceData?.datasource?.name ||
         null;
}
```

#### 1.2 Calcular Tend√™ncia (Compara√ß√£o com Per√≠odo Anterior)

```javascript
/**
 * Calcula a tend√™ncia de pico comparando com per√≠odo anterior
 * @param {number} currentPeak - Pico atual
 * @param {number} startTs - In√≠cio do per√≠odo atual
 * @param {number} endTs - Fim do per√≠odo atual
 */
async function calculatePeakTrend(currentPeak, startTs, endTs) {
  // Calcular per√≠odo anterior (mesmo intervalo)
  const periodDuration = endTs - startTs;
  const previousStartTs = startTs - periodDuration;
  const previousEndTs = startTs;

  const customerId = self.ctx.settings.customerId;
  const previousPeak = await fetchCustomerPeakDemand(customerId, previousStartTs, previousEndTs);

  if (!previousPeak || previousPeak.peakValue === 0) {
    return {
      direction: 'neutral',
      percentChange: 0,
      label: '‚Äî'
    };
  }

  const percentChange = ((currentPeak - previousPeak.peakValue) / previousPeak.peakValue) * 100;

  return {
    direction: percentChange > 0 ? 'up' : percentChange < 0 ? 'down' : 'neutral',
    percentChange: Math.abs(percentChange),
    label: percentChange > 0
      ? `‚ñ≤ +${percentChange.toFixed(1)}% vs per√≠odo anterior`
      : percentChange < 0
      ? `‚ñº ${percentChange.toFixed(1)}% vs per√≠odo anterior`
      : '‚Äî sem altera√ß√£o'
  };
}
```

---

### Fase 2: Atualiza√ß√£o do Template HTML

**Arquivo**: `C:\Projetos\GitHub\myio\myio-js-library-PROD.git\src\MYIO-SIM\V1.0.0\ENERGY\template.html`

**ANTES** (Mock):
```html
<div class="card">
  <p class="label">Pico de Demanda</p>
  <h3 class="value">1.892 kW</h3>
  <span class="trend up">‚ñ≤ +5% vs ontem</span>
</div>
```

**DEPOIS** (Din√¢mico):
```html
<div class="card" id="peak-demand-card">
  <p class="label">Pico de Demanda</p>
  <h3 class="value" id="peak-demand-value">
    <svg class="loading-spinner" style="width:24px; height:24px; animation: spin 1s linear infinite;" viewBox="0 0 50 50">
      <circle cx="25" cy="25" r="20" fill="none" stroke="#6c2fbf" stroke-width="5" stroke-linecap="round"
              stroke-dasharray="90,150" stroke-dashoffset="0">
      </circle>
    </svg>
  </h3>
  <span class="trend" id="peak-demand-trend">Carregando...</span>
  <span class="device-info" id="peak-demand-device" style="font-size: 12px; color: #6b7280; margin-top: 4px;"></span>
</div>
```

**CSS Adicional**:
```html
<style>
  #peak-demand-card {
    position: relative;
  }

  #peak-demand-value {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 32px;
  }

  .loading-spinner {
    display: inline-block;
  }

  .trend.up {
    color: #dc2626; /* Red for increase in demand (bad) */
  }

  .trend.down {
    color: #16a34a; /* Green for decrease in demand (good) */
  }

  .trend.neutral {
    color: #6b7280; /* Gray for no change */
  }

  .device-info {
    display: block;
    font-size: 11px;
    color: #6b7280;
    margin-top: 4px;
  }

  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
</style>
```

---

### Fase 3: Integra√ß√£o com Controller

**Arquivo**: `C:\Projetos\GitHub\myio\myio-js-library-PROD.git\src\MYIO-SIM\V1.0.0\ENERGY\controller.js`

#### 3.1 Adicionar no onInit

```javascript
self.onInit = async function() {
  // ‚úÖ Check active domain
  const currentDomain = window.MyIOOrchestrator?.getActiveDomain?.() || 'energy';

  if (currentDomain !== 'energy') {
    console.log(`[ENERGY] Widget disabled for domain: ${currentDomain}`);
    return;
  }

  console.log("[ENERGY] Initializing energy charts and peak demand card...");

  // Initialize charts with empty state
  initializeCharts();

  // ===== NEW: Initialize Peak Demand Card =====
  initializePeakDemandCard();

  // ===== LISTEN FOR ENERGY DATA FROM ORCHESTRATOR =====
  window.addEventListener('myio:energy-data-ready', (ev) => {
    console.log("[ENERGY] Received energy data:", ev.detail);
    const { cache } = ev.detail;

    // Update charts with real data
    updateCharts(cache);
  });

  // ===== LISTEN FOR DATE CHANGES =====
  window.addEventListener('myio:update-date', async (ev) => {
    console.log("[ENERGY] Date range updated:", ev.detail);

    const { startMs, endMs } = ev.detail;

    if (startMs && endMs) {
      await updatePeakDemandCard(startMs, endMs);
    }
  });
}
```

#### 3.2 Implementar Fun√ß√µes de Atualiza√ß√£o

```javascript
/**
 * Inicializa o card de pico de demanda com estado de loading
 */
function initializePeakDemandCard() {
  const valueEl = document.getElementById("peak-demand-value");
  const trendEl = document.getElementById("peak-demand-trend");
  const deviceEl = document.getElementById("peak-demand-device");

  if (valueEl) {
    valueEl.innerHTML = `
      <svg class="loading-spinner" style="width:24px; height:24px; animation: spin 1s linear infinite;" viewBox="0 0 50 50">
        <circle cx="25" cy="25" r="20" fill="none" stroke="#6c2fbf" stroke-width="5" stroke-linecap="round"
                stroke-dasharray="90,150" stroke-dashoffset="0">
        </circle>
      </svg>
    `;
  }

  if (trendEl) {
    trendEl.textContent = "Aguardando dados...";
    trendEl.className = "trend neutral";
  }

  if (deviceEl) {
    deviceEl.textContent = "";
  }

  console.log("[ENERGY] Peak demand card initialized with loading state");
}

/**
 * Atualiza o card de pico de demanda com dados reais
 */
async function updatePeakDemandCard(startTs, endTs) {
  const valueEl = document.getElementById("peak-demand-value");
  const trendEl = document.getElementById("peak-demand-trend");
  const deviceEl = document.getElementById("peak-demand-device");

  try {
    console.log("[ENERGY] Fetching peak demand data...", { startTs, endTs });

    // Show loading state
    if (valueEl) {
      valueEl.innerHTML = `
        <svg class="loading-spinner" style="width:24px; height:24px; animation: spin 1s linear infinite;" viewBox="0 0 50 50">
          <circle cx="25" cy="25" r="20" fill="none" stroke="#6c2fbf" stroke-width="5" stroke-linecap="round"
                  stroke-dasharray="90,150" stroke-dashoffset="0">
          </circle>
        </svg>
      `;
    }

    const customerId = self.ctx.settings.customerId;

    // Fetch peak demand
    const peakData = await fetchCustomerPeakDemand(customerId, startTs, endTs);

    console.log("[ENERGY] Peak demand data received:", peakData);

    // Format peak value
    const peakValueFormatted = peakData.peakValue >= 1000
      ? `${(peakData.peakValue / 1000).toFixed(3)} MW`
      : `${peakData.peakValue.toFixed(0)} kW`;

    // Update value
    if (valueEl) {
      valueEl.textContent = peakValueFormatted;
    }

    // Calculate and update trend
    const trendData = await calculatePeakTrend(peakData.peakValue, startTs, endTs);

    if (trendEl) {
      trendEl.textContent = trendData.label;
      trendEl.className = `trend ${trendData.direction}`;
    }

    // Update device info
    if (deviceEl && peakData.deviceName) {
      const peakDate = new Date(peakData.timestamp);
      const peakTime = peakDate.toLocaleString('pt-BR', {
        day: '2-digit',
        month: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });

      deviceEl.textContent = `${peakData.deviceName} √†s ${peakTime}`;
    }

    console.log("[ENERGY] Peak demand card updated successfully");

  } catch (error) {
    console.error("[ENERGY] Error updating peak demand card:", error);

    // Show error state
    if (valueEl) {
      valueEl.textContent = "Erro";
    }
    if (trendEl) {
      trendEl.textContent = "Falha ao carregar dados";
      trendEl.className = "trend neutral";
    }
    if (deviceEl) {
      deviceEl.textContent = "";
    }
  }
}
```

---

### Fase 4: Otimiza√ß√µes e Cache

#### 4.1 Implementar Cache Local

```javascript
// Cache para evitar chamadas repetidas
let peakDemandCache = {
  data: null,
  startTs: null,
  endTs: null,
  timestamp: null
};

const PEAK_DEMAND_CACHE_TTL = 5 * 60 * 1000; // 5 minutos

function getCachedPeakDemand(startTs, endTs) {
  if (!peakDemandCache.data) return null;

  // Check if cache is for same period
  if (peakDemandCache.startTs !== startTs || peakDemandCache.endTs !== endTs) {
    return null;
  }

  // Check if cache is fresh
  const age = Date.now() - peakDemandCache.timestamp;
  if (age > PEAK_DEMAND_CACHE_TTL) {
    console.log("[ENERGY] Peak demand cache expired");
    return null;
  }

  console.log("[ENERGY] Using cached peak demand data");
  return peakDemandCache.data;
}

function cachePeakDemand(data, startTs, endTs) {
  peakDemandCache = {
    data,
    startTs,
    endTs,
    timestamp: Date.now()
  };
  console.log("[ENERGY] Peak demand data cached");
}
```

#### 4.2 Atualizar fetchCustomerPeakDemand com Cache

```javascript
async function fetchCustomerPeakDemand(customerId, startTs, endTs) {
  // Try cache first
  const cached = getCachedPeakDemand(startTs, endTs);
  if (cached) {
    return cached;
  }

  // ... rest of fetch logic ...

  const result = {
    peakValue: maxPeak.value,
    timestamp: maxPeak.timestamp,
    deviceId: maxPeak.deviceId,
    deviceName: deviceName || 'Desconhecido'
  };

  // Cache the result
  cachePeakDemand(result, startTs, endTs);

  return result;
}
```

---

### Fase 5: Tratamento de Erros e Edge Cases

#### 5.1 Casos Especiais

```javascript
function handlePeakDemandEdgeCases(peakData) {
  // Caso 1: Nenhum dado dispon√≠vel
  if (!peakData || peakData.peakValue === 0) {
    return {
      value: "‚Äî kW",
      trend: "Sem dados dispon√≠veis",
      trendClass: "neutral",
      deviceInfo: ""
    };
  }

  // Caso 2: Valor muito baixo (poss√≠vel erro de sensor)
  if (peakData.peakValue < 0.1) {
    return {
      value: `${peakData.peakValue.toFixed(3)} kW`,
      trend: "‚ö† Valor suspeito - verificar sensor",
      trendClass: "neutral",
      deviceInfo: peakData.deviceName || ""
    };
  }

  // Caso 3: Valor muito alto (poss√≠vel pico anormal)
  if (peakData.peakValue > 10000) { // > 10 MW
    return {
      value: `${(peakData.peakValue / 1000).toFixed(2)} MW`,
      trend: "‚ö† Pico anormalmente alto",
      trendClass: "up",
      deviceInfo: `${peakData.deviceName || "Desconhecido"} - VERIFICAR URGENTE`
    };
  }

  // Caso normal
  return null;
}
```

#### 5.2 Retry Logic para Falhas de Rede

```javascript
async function fetchWithRetry(url, options, maxRetries = 3) {
  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      return response;
    } catch (error) {
      lastError = error;
      console.warn(`[ENERGY] Fetch attempt ${attempt}/${maxRetries} failed:`, error);

      if (attempt < maxRetries) {
        // Exponential backoff: 1s, 2s, 4s
        const delay = Math.pow(2, attempt - 1) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  throw new Error(`Failed after ${maxRetries} attempts: ${lastError.message}`);
}
```

---

## üìä Fluxo de Dados Completo

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        USER ACTION                          ‚îÇ
‚îÇ         (Seleciona datas + clica "Carregar")               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    MENU Widget                              ‚îÇ
‚îÇ   Dispara: myio:update-date { startMs, endMs, ... }       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ENERGY Widget                            ‚îÇ
‚îÇ   Listener: window.addEventListener('myio:update-date')    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              updatePeakDemandCard(startTs, endTs)          ‚îÇ
‚îÇ   1. Show loading spinner                                   ‚îÇ
‚îÇ   2. Check cache                                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            fetchCustomerPeakDemand(customerId, ...)        ‚îÇ
‚îÇ   1. Extract device IDs from self.ctx.data                 ‚îÇ
‚îÇ   2. For each device:                                       ‚îÇ
‚îÇ      - Call ThingsBoard API:                                ‚îÇ
‚îÇ        /api/plugins/telemetry/DEVICE/{id}/values/timeseries‚îÇ
‚îÇ        ?keys=power,demand&agg=MAX&limit=1                  ‚îÇ
‚îÇ   3. Aggregate results (find max peak)                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         calculatePeakTrend(currentPeak, startTs, endTs)    ‚îÇ
‚îÇ   1. Calculate previous period range                        ‚îÇ
‚îÇ   2. Fetch previous period peak                             ‚îÇ
‚îÇ   3. Calculate % change                                     ‚îÇ
‚îÇ   4. Return { direction, percentChange, label }            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    UPDATE DOM                               ‚îÇ
‚îÇ   1. #peak-demand-value: "1.892 kW"                        ‚îÇ
‚îÇ   2. #peak-demand-trend: "‚ñ≤ +5% vs per√≠odo anterior"       ‚îÇ
‚îÇ   3. #peak-demand-device: "Chiller Central √†s 16/10 14:30" ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üß™ Plano de Testes

### Teste 1: Busca de Pico com Dados V√°lidos
**Cen√°rio**: Customer com m√∫ltiplos devices com dados de demanda
**Entrada**:
- customerId: v√°lido
- startTs: in√≠cio do m√™s
- endTs: hoje
**Resultado Esperado**:
- ‚úÖ Pico correto identificado
- ‚úÖ Device com maior pico exibido
- ‚úÖ Tend√™ncia calculada corretamente

### Teste 2: Sem Dados Dispon√≠veis
**Cen√°rio**: Per√≠odo sem telemetria
**Entrada**:
- customerId: v√°lido
- startTs/endTs: per√≠odo sem dados
**Resultado Esperado**:
- ‚úÖ "‚Äî kW" exibido
- ‚úÖ "Sem dados dispon√≠veis" na tend√™ncia

### Teste 3: Erro de Rede
**Cen√°rio**: API do ThingsBoard indispon√≠vel
**Entrada**: API retorna 500
**Resultado Esperado**:
- ‚úÖ Retry logic executado (3 tentativas)
- ‚úÖ "Erro" exibido ap√≥s falha
- ‚úÖ Mensagem de erro no console

### Teste 4: Cache Funcionando
**Cen√°rio**: Requisi√ß√µes repetidas para mesmo per√≠odo
**Entrada**:
- 1¬™ chamada: fetch real
- 2¬™ chamada (< 5 min): mesmo per√≠odo
**Resultado Esperado**:
- ‚úÖ 1¬™ chamada faz fetch
- ‚úÖ 2¬™ chamada usa cache (log confirmando)

### Teste 5: Mudan√ßa de Per√≠odo
**Cen√°rio**: User altera datas e clica "Carregar"
**Entrada**:
- Per√≠odo 1: 01/10 - 15/10
- Per√≠odo 2: 01/09 - 30/09
**Resultado Esperado**:
- ‚úÖ Cache invalidado
- ‚úÖ Novo fetch executado
- ‚úÖ Card atualizado com novos dados

---

## üìù Checklist de Implementa√ß√£o

### Fase 1: Setup B√°sico (1-2 horas)
- [ ] Criar fun√ß√£o `fetchCustomerPeakDemand()` em ENERGY/controller.js
- [ ] Criar fun√ß√£o `extractDeviceIds()` helper
- [ ] Criar fun√ß√£o `getDeviceNameById()` helper
- [ ] Testar chamada b√°sica √† API do ThingsBoard

### Fase 2: Template e UI (1 hora)
- [ ] Atualizar template.html com IDs din√¢micos
- [ ] Adicionar CSS para estados (loading, up, down, neutral)
- [ ] Adicionar spinner de loading
- [ ] Adicionar campo de device info

### Fase 3: L√≥gica de Tend√™ncia (1-2 horas)
- [ ] Criar fun√ß√£o `calculatePeakTrend()`
- [ ] Implementar c√°lculo de per√≠odo anterior
- [ ] Implementar c√°lculo de % de mudan√ßa
- [ ] Formatar labels de tend√™ncia

### Fase 4: Integra√ß√£o (1 hora)
- [ ] Adicionar `initializePeakDemandCard()` no onInit
- [ ] Criar listener para `myio:update-date`
- [ ] Criar fun√ß√£o `updatePeakDemandCard()`
- [ ] Conectar tudo

### Fase 5: Otimiza√ß√µes (30 min - 1 hora)
- [ ] Implementar cache local
- [ ] Implementar retry logic
- [ ] Tratar edge cases (sem dados, valores anormais)
- [ ] Adicionar logs de debug

### Fase 6: Testes (1 hora)
- [ ] Teste 1: Dados v√°lidos
- [ ] Teste 2: Sem dados
- [ ] Teste 3: Erro de rede
- [ ] Teste 4: Cache
- [ ] Teste 5: Mudan√ßa de per√≠odo

---

## ‚ö†Ô∏è Considera√ß√µes Importantes

### 1. Performance
- ‚ùó **M√∫ltiplas Chamadas**: Se customer tem 50 devices, ser√£o 50 chamadas √† API
- ‚úÖ **Solu√ß√£o**: Implementar batching ou usar endpoint de customer (se dispon√≠vel)
- ‚úÖ **Mitiga√ß√£o**: Cache agressivo (5 minutos) e chamadas paralelas

### 2. Limita√ß√µes da API ThingsBoard
- ‚ùó **Rate Limiting**: API pode ter limite de requisi√ß√µes/minuto
- ‚úÖ **Solu√ß√£o**: Adicionar delay entre chamadas ou usar Promise.allSettled()
- ‚ùó **Timeout**: Chamadas podem demorar em per√≠odos grandes
- ‚úÖ **Solu√ß√£o**: Usar timeout de 10s por chamada

### 3. Dados Inconsistentes
- ‚ùó **Keys Diferentes**: Alguns devices usam `power`, outros `demand`
- ‚úÖ **Solu√ß√£o**: Buscar ambas as keys e escolher a dispon√≠vel
- ‚ùó **Unidades Diferentes**: kW vs W
- ‚úÖ **Solu√ß√£o**: Normalizar para kW (dividir por 1000 se necess√°rio)

### 4. Integra√ß√£o com Orquestrador
- üí° **Op√ß√£o Futura**: Adicionar endpoint no MAIN orchestrator
- üí° **Vantagem**: Centralizar l√≥gica, reduzir chamadas
- üí° **Desvantagem**: Requer modificar arquitetura existente

---

## üöÄ Alternativas e Melhorias Futuras

### Alternativa 1: Usar Ingestion API (Se Dispon√≠vel)
```javascript
// Similar ao endpoint de energy:
const response = await fetch(
  `${DATA_API_HOST}/api/v1/telemetry/customers/${customerId}/demand/peak?` +
  `startTime=${startTs}&endTime=${endTs}`,
  {
    headers: {
      Authorization: `Bearer ${ingestionToken}`,
      "Content-Type": "application/json",
    },
  }
);
```

**Vantagens**:
- ‚úÖ 1 √∫nica chamada
- ‚úÖ Backend j√° agrega dados
- ‚úÖ Mais r√°pido e eficiente

**Desvantagens**:
- ‚ùå Requer desenvolvimento backend
- ‚ùå Depende de infraestrutura Ingestion API

### Alternativa 2: WebSocket para Dados em Tempo Real
```javascript
// Conectar ao WebSocket do ThingsBoard
const ws = new WebSocket(`wss://dashboard.myio-bas.com/api/ws`);

// Subscrever a updates de demanda
ws.send({
  type: 'subscribe',
  keys: ['power', 'demand'],
  entityIds: deviceIds
});
```

**Vantagens**:
- ‚úÖ Dados em tempo real
- ‚úÖ Sem polling

**Desvantagens**:
- ‚ùå Complexidade adicional
- ‚ùå Gerenciamento de conex√£o

### Melhoria 1: Gr√°fico de Pico ao Longo do Tempo
```javascript
// Adicionar mini-gr√°fico sparkline mostrando evolu√ß√£o do pico
function renderPeakSparkline(peakHistory) {
  // Usar Chart.js ou biblioteca similar
  const canvas = document.getElementById('peak-sparkline');
  new Chart(canvas, {
    type: 'line',
    data: {
      labels: peakHistory.map(p => formatDate(p.timestamp)),
      datasets: [{
        data: peakHistory.map(p => p.value),
        borderColor: '#dc2626',
        borderWidth: 2,
        pointRadius: 0
      }]
    },
    options: {
      scales: { x: { display: false }, y: { display: false } },
      plugins: { legend: { display: false } }
    }
  });
}
```

### Melhoria 2: Alertas de Pico Anormal
```javascript
// Detectar picos > 120% da m√©dia hist√≥rica
function detectAbnormalPeak(currentPeak, historicalAverage) {
  const threshold = historicalAverage * 1.2;

  if (currentPeak > threshold) {
    // Emitir evento de alerta
    window.dispatchEvent(new CustomEvent('myio:peak-alert', {
      detail: {
        peak: currentPeak,
        threshold,
        severity: 'high'
      }
    }));

    // Mostrar badge de alerta no card
    showAlertBadge();
  }
}
```

---

## üìö Refer√™ncias

### APIs ThingsBoard Consultadas
1. **Timeseries API**: `/api/plugins/telemetry/DEVICE/{deviceId}/values/timeseries`
   - Docs: https://thingsboard.io/docs/user-guide/telemetry/
   - Par√¢metros: keys, startTs, endTs, agg, limit

2. **Customer Attributes**: `/api/plugins/telemetry/CUSTOMER/{customerId}/values/attributes`
   - Usado para buscar credenciais

### Componentes Relacionados
- `DemandModal.ts` (linhas 731-734): Padr√£o de URL para timeseries
- `MAIN/controller.js`: Orquestrador de dados
- `HEADER/controller.js`: Exemplo de agrega√ß√£o por customer
- `v-5.2.0/WIDGET/`: Refer√™ncia de arquitetura

---

## ‚úÖ Crit√©rios de Sucesso

1. ‚úÖ Card mostra pico de demanda real do per√≠odo selecionado
2. ‚úÖ Tend√™ncia calculada corretamente (compara√ß√£o com per√≠odo anterior)
3. ‚úÖ Device com maior pico identificado e exibido
4. ‚úÖ Loading state durante fetch
5. ‚úÖ Error handling robusto
6. ‚úÖ Cache funcional (evita chamadas repetidas)
7. ‚úÖ Performance aceit√°vel (< 5s para 50 devices)
8. ‚úÖ UI responsiva e informativa

---

## üìÖ Timeline Estimado

| Fase | Descri√ß√£o | Dura√ß√£o | Status |
|------|-----------|---------|--------|
| 1 | Setup b√°sico e API | 1-2h | ‚è≥ Pendente |
| 2 | Template e UI | 1h | ‚è≥ Pendente |
| 3 | L√≥gica de tend√™ncia | 1-2h | ‚è≥ Pendente |
| 4 | Integra√ß√£o | 1h | ‚è≥ Pendente |
| 5 | Otimiza√ß√µes | 30min-1h | ‚è≥ Pendente |
| 6 | Testes | 1h | ‚è≥ Pendente |
| **TOTAL** | | **4-6 horas** | |

---

## üéØ Pr√≥ximos Passos

1. **Revisar e Aprovar** este plano
2. **Verificar** se Ingestion API tem endpoint de peak demand
3. **Decidir** entre Op√ß√£o A (iterar devices) vs usar API de customer
4. **Come√ßar implementa√ß√£o** pela Fase 1
5. **Testar incrementalmente** a cada fase

---

**Status Final**: ‚úÖ Plano Completo - Pronto para Implementa√ß√£o
**Pr√≥xima A√ß√£o**: Aprova√ß√£o do time e in√≠cio da Fase 1
