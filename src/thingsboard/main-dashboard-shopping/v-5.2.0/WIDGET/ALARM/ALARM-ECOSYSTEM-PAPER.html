<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ecossistema de Alarmes MYIO — Paper Técnico</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Source+Code+Pro:wght@400;600&family=Inter:wght@400;500;600&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Crimson Text', Georgia, serif;
    font-size: 12pt;
    line-height: 1.75;
    color: #1a1a1a;
    background: #f8f7f4;
    padding: 2rem;
  }

  .paper {
    max-width: 820px;
    margin: 0 auto;
    background: #fff;
    padding: 72pt 80pt;
    box-shadow: 0 2px 32px rgba(0,0,0,.10);
    border-radius: 2px;
  }

  /* Header */
  .paper-header { text-align: center; margin-bottom: 2.5rem; border-bottom: 1px solid #ccc; padding-bottom: 1.5rem; }
  .paper-title { font-size: 20pt; font-weight: 600; line-height: 1.3; margin-bottom: .5rem; }
  .paper-subtitle { font-size: 12pt; color: #555; font-style: italic; margin-bottom: 1rem; }
  .paper-meta { font-size: 10pt; color: #666; font-family: 'Inter', sans-serif; }
  .paper-meta span { display: inline-block; margin: 0 .5rem; }

  /* Sections */
  h2 {
    font-family: 'Inter', sans-serif;
    font-size: 11pt;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: .08em;
    margin: 2.2rem 0 .8rem;
    color: #222;
    border-left: 3px solid #2563eb;
    padding-left: .6rem;
  }

  h3 {
    font-family: 'Inter', sans-serif;
    font-size: 10.5pt;
    font-weight: 600;
    margin: 1.5rem 0 .5rem;
    color: #333;
  }

  p { margin-bottom: .9rem; text-align: justify; }

  /* Abstract */
  .abstract {
    background: #f0f4ff;
    border-left: 4px solid #2563eb;
    padding: 1rem 1.2rem;
    margin: 1.5rem 0 2rem;
    font-size: 11pt;
    border-radius: 0 4px 4px 0;
  }
  .abstract strong { font-family: 'Inter', sans-serif; font-size: 9pt; text-transform: uppercase; letter-spacing: .06em; display: block; margin-bottom: .4rem; color: #2563eb; }

  /* Code / inline */
  code {
    font-family: 'Source Code Pro', monospace;
    font-size: 9.5pt;
    background: #f3f4f6;
    padding: .1em .35em;
    border-radius: 3px;
    color: #1e40af;
  }

  pre {
    font-family: 'Source Code Pro', monospace;
    font-size: 8.5pt;
    background: #1e1e2e;
    color: #cdd6f4;
    padding: 1rem 1.2rem;
    border-radius: 6px;
    margin: .8rem 0 1.2rem;
    overflow-x: auto;
    line-height: 1.6;
  }
  pre .kw  { color: #89b4fa; }
  pre .str { color: #a6e3a1; }
  pre .cmt { color: #6c7086; font-style: italic; }
  pre .fn  { color: #cba6f7; }

  /* Tables */
  table { width: 100%; border-collapse: collapse; margin: 1rem 0 1.4rem; font-size: 10.5pt; }
  thead tr { background: #1e3a8a; color: #fff; }
  thead th { padding: .45rem .7rem; text-align: left; font-family: 'Inter', sans-serif; font-size: 9pt; font-weight: 600; }
  tbody tr:nth-child(even) { background: #f8faff; }
  tbody td { padding: .4rem .7rem; border-bottom: 1px solid #e5e7eb; vertical-align: top; }
  tbody td code { font-size: 8.5pt; }

  /* Arch diagram */
  .arch {
    background: #0f172a;
    color: #e2e8f0;
    font-family: 'Source Code Pro', monospace;
    font-size: 9pt;
    padding: 1.2rem 1.5rem;
    border-radius: 6px;
    margin: .8rem 0 1.4rem;
    line-height: 1.8;
    white-space: pre;
  }

  /* Callout */
  .callout {
    border: 1px solid #fbbf24;
    background: #fffbeb;
    padding: .7rem 1rem;
    border-radius: 4px;
    margin: .8rem 0 1.2rem;
    font-size: 10.5pt;
  }
  .callout strong { color: #b45309; }

  /* Tag pills */
  .pill {
    display: inline-block;
    background: #dbeafe;
    color: #1e40af;
    font-family: 'Inter', sans-serif;
    font-size: 8.5pt;
    font-weight: 600;
    padding: .1em .5em;
    border-radius: 20px;
    margin: .1em .2em;
  }

  /* Footer */
  .paper-footer {
    margin-top: 3rem;
    padding-top: 1rem;
    border-top: 1px solid #ddd;
    font-family: 'Inter', sans-serif;
    font-size: 8.5pt;
    color: #888;
    text-align: center;
  }

  /* Print */
  @media print {
    body { background: #fff; padding: 0; }
    .paper { box-shadow: none; padding: 2cm 2.5cm; max-width: 100%; }
  }
</style>
</head>
<body>
<div class="paper">

  <div class="paper-header">
    <div class="paper-title">Ecossistema de Alarmes MYIO</div>
    <div class="paper-subtitle">
      Arquitetura, Funcionalidades e Design de um Sistema de Gestão de Alarmes<br>
      para Ambientes de Monitoramento de Shopping Centers
    </div>
    <div class="paper-meta">
      <span>Plataforma MYIO · myio-js-library</span>
      <span>·</span>
      <span>RFC-0152 / RFC-0175 / RFC-0177 / RFC-0178</span>
      <span>·</span>
      <span>Fevereiro 2026</span>
    </div>
  </div>

  <div class="abstract">
    <strong>Resumo</strong>
    Este documento descreve o ecossistema de alarmes da plataforma MYIO, concebido para
    monitorar, agregar, priorizar e gerenciar alarmes de dispositivos IoT instalados em
    shopping centers. Apresentamos a arquitetura em camadas, os componentes de interface,
    os serviços de backend, os padrões de integração com ThingsBoard e as principais
    decisões de design que orientaram a implementação.
  </div>

  <!-- 1. Contexto -->
  <h2>1. Contexto e Motivação</h2>
  <p>
    Shopping centers de grande porte operam centenas de ativos monitorados — elevadores,
    escadas rolantes, sistemas de climatização, medidores de energia e hidrômetros.
    Falhas nesses ativos geram impacto direto em segurança, conforto e custo operacional.
    A plataforma MYIO integra dados de telemetria desses dispositivos em dashboards
    ThingsBoard, mas a simples exibição de métricas não é suficiente para a operação:
    é necessário um sistema capaz de <em>detectar desvios</em>, <em>notificar equipes</em>
    e <em>registrar o ciclo de vida</em> de cada ocorrência anormal.
  </p>
  <p>
    O ecossistema de alarmes MYIO nasce dessa necessidade — um subsistema dedicado que
    vai além do ThingsBoard nativo, oferecendo alarmes com semântica de negócio,
    fluxos de aprovação e visões agregadas por tipo e dispositivo.
  </p>

  <!-- 2. Arquitetura -->
  <h2>2. Arquitetura em Camadas</h2>

  <div class="arch">
┌─────────────────────────────────────────────────────────────────┐
│                    ThingsBoard Dashboard                        │
│  ┌──────────────────────────┐   ┌────────────────────────────┐  │
│  │    MAIN_VIEW Widget      │   │      ALARM Widget          │  │
│  │  (Orquestrador)          │──▶│  controller.js (RFC-0177)  │  │
│  │  Expõe via               │   │                            │  │
│  │  window.MyIOOrchestrator │   │  createAlarmsPanelComponent│  │
│  └──────────────────────────┘   └────────────┬───────────────┘  │
└────────────────────────────────────────────  │  ────────────────┘
                                               │
                         myio-js-library (UMD bundle, npm)
           ┌────────────────────────────────────────────────────┐
           │                                                    │
           │  AlarmsNotificationsPanelComponent                 │
           │  ┌─────────────────────┐ ┌─────────────────────┐  │
           │  │  Controller         │ │  View               │  │
           │  │  (state / actions)  │ │  (DOM / render)     │  │
           │  └─────────────────────┘ └─────────────────────┘  │
           │                  │                                 │
           │            AlarmService (Singleton)                │
           │                  │                                 │
           │            AlarmApiClient (HTTP)                   │
           └──────────────────┼─────────────────────────────────┘
                              │ REST + X-API-Key
               ┌──────────────▼───────────────┐
               │   Alarms Backend API         │
               │   alarms-api.a.myio-bas.com  │
               │   /api/v1/alarms             │
               └──────────────────────────────┘</div>

  <p>
    A arquitetura é deliberadamente <em>desacoplada</em>: o widget ThingsBoard não faz
    requisições HTTP diretamente — ele delega ao <code>AlarmService</code> encapsulado
    na biblioteca <code>myio-js-library</code>. Isso permite reutilizar os mesmos
    componentes em outros contextos (showcase, testes, outros dashboards) sem
    dependência do runtime ThingsBoard.
  </p>

  <h3>2.1 Fluxo de Configuração</h3>
  <p>
    As credenciais de API (<code>alarmsApiBaseUrl</code>, <code>alarmsApiKey</code>)
    são configuradas no widget <strong>MAIN_VIEW</strong> (orquestrador central) e
    propagadas via <code>window.MyIOOrchestrator</code> para todos os widgets do
    dashboard. O widget ALARM as recebe, chama <code>AlarmService.configure()</code>
    e repassa ao componente via parâmetros de criação — sem nenhum valor
    <em>hardcoded</em> no código da biblioteca.
  </p>

  <!-- 3. Modelo de Dados -->
  <h2>3. Modelo de Dados</h2>
  <p>
    Cada alarme é representado pelo tipo <code>Alarm</code> com os seguintes
    campos principais:
  </p>

  <table>
    <thead>
      <tr><th>Campo</th><th>Tipo</th><th>Descrição</th></tr>
    </thead>
    <tbody>
      <tr><td><code>id</code></td><td>string</td><td>Identificador único do alarme (ULID ou UUID)</td></tr>
      <tr><td><code>title</code></td><td>string</td><td>Descrição semântica do alarme (regra de negócio)</td></tr>
      <tr><td><code>severity</code></td><td>CRITICAL · HIGH · MEDIUM · LOW · INFO</td><td>Criticidade do alarme</td></tr>
      <tr><td><code>state</code></td><td>OPEN · ACK · SNOOZED · ESCALATED · CLOSED</td><td>Estado do ciclo de vida</td></tr>
      <tr><td><code>source</code></td><td>string</td><td>Nome do dispositivo de origem (<code>deviceName</code>)</td></tr>
      <tr><td><code>firstOccurrence</code></td><td>ISO 8601</td><td>Timestamp da primeira detecção</td></tr>
      <tr><td><code>lastOccurrence</code></td><td>ISO 8601</td><td>Timestamp da atualização mais recente</td></tr>
      <tr><td><code>occurrenceCount</code></td><td>number</td><td>Total de vezes que o alarme se repetiu</td></tr>
      <tr><td><code>metadata</code></td><td>object</td><td>Contexto da regra: <code>value</code>, <code>threshold</code>, <code>operator</code>, <code>durationMs</code></td></tr>
      <tr><td><code>customerId</code></td><td>UUID</td><td>Shopping center de origem</td></tr>
    </tbody>
  </table>

  <h3>3.1 Mapeamento API → Domínio</h3>
  <p>
    A API REST retorna campos com nomenclatura própria. O mapper
    <code>mapApiAlarm()</code> em <code>AlarmService.ts</code> abstrai
    essas diferenças:
  </p>
  <pre><code><span class="cmt">// API retorna       → Domínio interno</span>
api.raisedAt        → alarm.firstOccurrence
api.lastUpdatedAt   → alarm.lastOccurrence  <span class="cmt">// (não "updatedAt")</span>
api.silencedUntil   → alarm.snoozedUntil    <span class="cmt">// (não "snoozedUntil")</span>
api.dispatchCount   → alarm.occurrenceCount <span class="cmt">// (não "occurrenceCount")</span>
api.deviceName      → alarm.source          <span class="cmt">// nome legível, não UUID</span>
<span class="cmt">// Strings vazias ("") são normalizadas para undefined</span></code></pre>

  <!-- 4. Funcionalidades -->
  <h2>4. Funcionalidades do Painel</h2>

  <h3>4.1 Visão Lista — Consolidado e Separado</h3>
  <p>
    O painel oferece dois modos de agrupamento togláveis:
  </p>
  <p>
    <span class="pill">Consolidado</span> Agrupa alarmes com o mesmo título em um único
    card, exibindo o total de ocorrências, a pior severidade e o intervalo de tempo do
    grupo. Reduz o ruído visual em cenários onde o mesmo tipo de falha afeta múltiplos
    dispositivos simultaneamente.
  </p>
  <p>
    <span class="pill">Separado</span> Expande cada alarme por dispositivo de origem,
    exibindo um badge com o nome do dispositivo no card. Útil para identificar
    exatamente quais ativos estão em falha.
  </p>

  <h3>4.2 Ações em Lote (Batch Actions)</h3>
  <p>
    Todas as ações (reconhecer, adiar, escalar, fechar) suportam seleção múltipla
    via checkbox nos cards. Ao confirmar, um único chamada HTTP é feita para o
    endpoint <code>POST /api/v1/alarms/batch/{ack|silence|escalate|close}</code>,
    enviando um array de até 100 IDs. O response indica quais IDs tiveram sucesso
    e quais falharam (<code>succeeded[]</code>, <code>failed[]</code>).
  </p>

  <table>
    <thead><tr><th>Endpoint</th><th>Ação</th><th>Parâmetros extras</th></tr></thead>
    <tbody>
      <tr><td><code>POST /batch/ack</code></td><td>Reconhecer</td><td><code>acknowledgedBy</code></td></tr>
      <tr><td><code>POST /batch/silence</code></td><td>Adiar (Snooze)</td><td><code>silencedBy</code>, <code>duration</code></td></tr>
      <tr><td><code>POST /batch/escalate</code></td><td>Escalar</td><td><code>escalatedBy</code></td></tr>
      <tr><td><code>POST /batch/close</code></td><td>Fechar</td><td><code>closedBy</code>, <code>resolution</code></td></tr>
    </tbody>
  </table>

  <h3>4.3 Auto-Paginação</h3>
  <p>
    A API retorna resultados paginados com metadado <code>pagination.totalPages</code>.
    O <code>AlarmService</code> itera automaticamente por todas as páginas
    (usando <code>totalPages</code> como limite, não o campo <code>hasMore</code>
    que pode ser impreciso), concatenando os dados antes de entregá-los ao componente.
    O tamanho de página padrão é 100 registros, configurável via
    <code>settings.maxAlarmsVisible</code>.
  </p>

  <h3>4.4 Cache com TTL Configurável</h3>
  <p>
    O <code>AlarmService</code> implementa cache em memória com TTL configurável
    (padrão 180 segundos). O TTL é definido pelo operador no widget MAIN_VIEW via
    <code>settings.cacheIntervalSeconds</code> e repassado ao serviço na inicialização.
    Após ações batch, o cache é invalidado e os dados são recarregados. Chamadas
    rápidas repetidas (ex: múltiplos eventos de ativação de view) são
    <em>debounced</em> com janela de 300–400ms.
  </p>

  <h3>4.5 Modal de Detalhes</h3>
  <p>
    Ao clicar em um card, um modal de detalhes é exibido com seis abas:
  </p>

  <table>
    <thead><tr><th>Aba</th><th>Conteúdo</th></tr></thead>
    <tbody>
      <tr><td><strong>Resumo</strong></td><td>KPIs: severidade, estado, duração total, frequência média, dispositivos afetados, tags de regra</td></tr>
      <tr><td><strong>Timeline</strong></td><td>Linha do tempo de ocorrências com estimativa de intervalos e mapa dispositivo × ocorrência</td></tr>
      <tr><td><strong>Dispositivos</strong></td><td>Lista de dispositivos de origem com chips identificadores e mapa ocorrências × dispositivo</td></tr>
      <tr><td><strong>Gráfico</strong></td><td>Histogramas e gráficos de linha com granularidade selecionável (Hora / Dia / Semana / Mês)</td></tr>
      <tr><td><strong>Relatório</strong></td><td>Tabela exportável (CSV) por período customizado com granularidade ajustável</td></tr>
      <tr><td><strong>Anotações</strong></td><td>Anotações do time de operações associadas ao alarme (pendência, manutenção, observação)</td></tr>
    </tbody>
  </table>

  <h3>4.6 Filtros</h3>
  <p>
    O painel expõe um modal de filtros com controles para <em>severidade</em>,
    <em>estado</em>, <em>tipo de alarme</em> e <em>dispositivo</em>. Filtros
    aplicados persistem durante a sessão e disparam
    <code>myio:alarm-filter-change</code> via <code>window</code>, permitindo
    que outros widgets do dashboard reajam à seleção.
  </p>

  <!-- 5. Design Decisions -->
  <h2>5. Decisões de Design Relevantes</h2>

  <h3>5.1 Separação Widget × Componente × Serviço</h3>
  <p>
    A camada ThingsBoard (<code>controller.js</code>) é responsável apenas por
    orquestração: lê settings, resolve credenciais, cria o componente e agenda
    o refresh. Nenhuma lógica de negócio reside no widget. Isso viabiliza
    testes isolados e reuso em outros contextos.
  </p>

  <h3>5.2 Credenciais sem Hardcode</h3>
  <p>
    URL da API e chave de autenticação são configuradas exclusivamente via
    <code>settingsSchema.json</code> do widget MAIN_VIEW, propagadas ao
    <code>AlarmApiClient</code> via <code>AlarmService.configure()</code>.
    A biblioteca não possui valores padrão internos para essas credenciais.
  </p>

  <div class="callout">
    <strong>Nota de Segurança:</strong> A API key (<code>X-API-Key</code>) trafega
    apenas em headers HTTPS e não é exposta no DOM nem em logs. Em ambientes de
    produção, recomenda-se rotacionar a chave periodicamente via MAIN_VIEW settings.
  </div>

  <h3>5.3 Compound IDs no Modo Separado</h3>
  <p>
    No modo Separado, cada alarme que afeta múltiplos dispositivos é explodido em
    N entradas virtuais com ID composto <code>uuid__DEVICE</code>. Antes de qualquer
    chamada à API de ações, o sufixo é removido por <code>stripSeparadoId()</code>,
    garantindo que o backend receba apenas o UUID real do alarme.
  </p>

  <h3>5.4 Paginação por <code>totalPages</code></h3>
  <p>
    A decisão de usar <code>pagination.totalPages</code> como controle do loop de
    paginação — em vez do campo booleano <code>hasMore</code> — foi motivada por
    robustez: se a API retornar <code>hasMore: true</code> na última página
    (comportamento observado em algumas versões), o loop com <code>hasMore</code>
    seria infinito. Com <code>totalPages</code>, o número de requisições é
    determinístico e auditável.
  </p>

  <!-- 6. Configurações -->
  <h2>6. Configurações Operacionais</h2>
  <p>
    O widget ALARM expõe as seguintes configurações no ThingsBoard (via
    <code>settingsSchema.json</code>):
  </p>

  <table>
    <thead><tr><th>Configuração</th><th>Padrão</th><th>Descrição</th></tr></thead>
    <tbody>
      <tr><td><code>defaultTab</code></td><td>list</td><td>Aba inicial ao abrir o painel</td></tr>
      <tr><td><code>showCustomerName</code></td><td>false</td><td>Exibir chip com nome do shopping nos cards (multi-tenant)</td></tr>
      <tr><td><code>refreshIntervalSeconds</code></td><td>180</td><td>Intervalo de auto-refresh em segundos (0 = desabilitado)</td></tr>
      <tr><td><code>cacheIntervalSeconds</code></td><td>180</td><td>TTL do cache de resultados da API</td></tr>
      <tr><td><code>maxAlarmsVisible</code></td><td>100</td><td>Tamanho de página por requisição (auto-pagina)</td></tr>
      <tr><td><code>enableDebugMode</code></td><td>false</td><td>Logs detalhados no console</td></tr>
    </tbody>
  </table>

  <p>
    As configurações <code>alarmsApiBaseUrl</code> e <code>alarmsApiKey</code>
    residem no widget <strong>MAIN_VIEW</strong> e são propagadas automaticamente
    — não precisam ser configuradas no widget ALARM individualmente.
  </p>

  <!-- 7. Extensibilidade -->
  <h2>7. Extensibilidade e Roadmap</h2>
  <p>
    O ecossistema foi projetado com pontos de extensão claros:
  </p>
  <p>
    <strong>Anotações por alarme</strong> — o mesmo padrão de anotações de dispositivos
    (RFC-0144) pode ser aplicado a alarmes, associando pendências, ordens de manutenção
    e observações diretamente ao ciclo de vida do alarme.
  </p>
  <p>
    <strong>Regras de alarme configuráveis</strong> — o botão "Regras de Alarmes" no
    painel abre o modal <code>AlarmBundleMap</code> (RFC-0179), que permite
    visualizar e editar as regras de detecção por tipo de equipamento e shopping.
  </p>
  <p>
    <strong>Exportação</strong> — a aba Relatório já suporta exportação CSV. A
    exportação em PDF e Excel está prevista para fases subsequentes.
  </p>
  <p>
    <strong>Notificações push</strong> — a integração com canais de despacho
    (<code>dispatchCount</code>, <code>lastDispatchChannel</code>) permite futura
    visualização do histórico de notificações enviadas por cada alarme.
  </p>

  <!-- 8. Conclusão -->
  <h2>8. Conclusão</h2>
  <p>
    O ecossistema de alarmes MYIO representa uma camada de inteligência operacional
    sobre os dados de telemetria dos ativos de shopping centers. Ao combinar um
    componente de interface rico e configurável, um serviço com cache e paginação
    automática, e endpoints batch de alta performance, o sistema viabiliza a gestão
    eficiente de centenas de alarmes simultâneos por equipes de operação.
  </p>
  <p>
    A arquitetura desacoplada — com separação clara entre widget ThingsBoard,
    componente UI, serviço de dados e cliente HTTP — garante manutenibilidade,
    testabilidade e reuso em toda a plataforma MYIO.
  </p>

  <div class="paper-footer">
    MYIO Platform · myio-js-library · RFC-0152, RFC-0175, RFC-0177, RFC-0178, RFC-0179
    · Gerado em Fevereiro 2026
  </div>

</div>
</body>
</html>
