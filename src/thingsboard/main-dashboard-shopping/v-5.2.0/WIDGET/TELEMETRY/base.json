{
  "entityType": "WIDGET_TYPE",
  "entity": {
    "fqn": "widget_shopping_dashboard_telemetry_v_5_2_0",
    "name": "Widget - Shopping Dashboard - TELEMETRY - v.5.2.0",
    "deprecated": false,
    "image": null,
    "description": null,
    "descriptor": {
      "type": "latest",
      "sizeX": 7.5,
      "sizeY": 3,
      "resources": [
        {
          "url": "https://graphs.staging.apps.myio-bas.com/sdk/energy-chart-sdk.umd.js"
        },
        {
          "url": "https://unpkg.com/myio-js-library@latest/dist/myio-js-library.umd.min.js"
        },
        {
          "url": "https://cdn.jsdelivr.net/npm/chart.js"
        }
      ],
      "templateHtml": "<section class=\"shops-root\">\r\n  <header class=\"shops-header\">\r\n    <div class=\"shops-header-left\">\r\n      <span class=\"temp-info-trigger\" id=\"tempInfoTrigger\" style=\"display: none;\" title=\"Detalhes de Temperatura\">\r\n        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n          <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\r\n          <line x1=\"12\" y1=\"16\" x2=\"12\" y2=\"12\"></line>\r\n          <line x1=\"12\" y1=\"8\" x2=\"12.01\" y2=\"8\"></line>\r\n        </svg>\r\n      </span>\r\n      <h2 class=\"shops-title\" id=\"labelWidgetId\"></h2>\r\n      <span class=\"shops-count\" id=\"shopsCount\">(0)</span>\r\n    </div>\r\n\r\n    <div class=\"shops-header-actions\">\r\n      <div class=\"search-wrap\" id=\"searchWrap\">\r\n        <input type=\"text\" id=\"shopsSearch\" placeholder=\"Buscar...\" autocomplete=\"off\" />\r\n      </div>\r\n\r\n      <button class=\"icon-btn\" id=\"btnSearch\" title=\"Buscar\" aria-label=\"Buscar\">\r\n        <!-- Lupa -->\r\n        <svg viewBox=\"0 0 24 24\" width=\"18\" height=\"18\" aria-hidden=\"true\">\r\n          <path\r\n            d=\"M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79L20 21.5 21.5 20l-6-6zM4 9.5C4 6.46 6.46 4 9.5 4S15 6.46 15 9.5 12.54 15 9.5 15 4 12.54 4 9.5z\"\r\n          />\r\n        </svg>\r\n      </button>\r\n\r\n      <button class=\"icon-btn\" id=\"btnFilter\" title=\"Filtros\" aria-label=\"Filtros\">\r\n        <!-- Funil -->\r\n        <svg viewBox=\"0 0 24 24\" width=\"18\" height=\"18\" aria-hidden=\"true\">\r\n          <path d=\"M3 4h18l-7 8v6l-4 2v-8L3 4z\" />\r\n        </svg>\r\n      </button>\r\n\r\n      <a class=\"shops-total\" id=\"shopsTotal\">0,00</a>\r\n    </div>\r\n  </header>\r\n\r\n  <section id=\"shopsList\" class=\"shops-list\"></section>\r\n\r\n  <!-- Modal de filtros -->\r\n  <div\r\n    id=\"filterModal\"\r\n    class=\"shops-modal hidden\"\r\n    role=\"dialog\"\r\n    aria-modal=\"true\"\r\n    aria-labelledby=\"filterTitle\"\r\n  >\r\n    <div class=\"shops-modal-card\">\r\n      <header class=\"shops-modal-header\">\r\n        <h3 id=\"filterTitle\">Filtros & Ordena√ß√£o</h3>\r\n        <button class=\"icon-btn\" id=\"closeFilter\" aria-label=\"Fechar\">\r\n          <svg viewBox=\"0 0 24 24\" width=\"18\" height=\"18\">\r\n            <path\r\n              d=\"M18.3 5.71 12 12l6.3 6.29-1.41 1.42L10.59 13.4 4.29 19.7 2.88 18.29 9.17 12 2.88 5.71 4.29 4.3l6.3 6.29 6.29-6.3z\"\r\n            />\r\n          </svg>\r\n        </button>\r\n      </header>\r\n\r\n      <section class=\"shops-modal-body\">\r\n        <div class=\"filter-block\">\r\n          <label class=\"block-label\">Selecionar Lojas</label>\r\n          <div class=\"inline-actions\">\r\n            <button id=\"selectAll\" class=\"tiny-btn\">Selecionar todas</button>\r\n            <button id=\"clearAll\" class=\"tiny-btn\">Limpar</button>\r\n          </div>\r\n\r\n          <div class=\"filter-search\">\r\n            <svg viewBox=\"0 0 24 24\" aria-hidden=\"true\">\r\n              <path\r\n                d=\"M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79L20 21.5 21.5 20l-6-6zM4 9.5C4 6.46 6.46 4 9.5 4S15 6.46 15 9.5 12.54 15 9.5 15 4 12.54 4 9.5z\"\r\n              />\r\n            </svg>\r\n            <input id=\"filterDeviceSearch\" type=\"text\" placeholder=\"Buscar lojas...\" autocomplete=\"off\" />\r\n            <button class=\"clear-x\" id=\"filterDeviceClear\" title=\"Limpar\" aria-label=\"Limpar\">\r\n              <!-- X -->\r\n              <svg viewBox=\"0 0 24 24\" width=\"14\" height=\"14\">\r\n                <path\r\n                  d=\"M18.3 5.71 12 12l6.3 6.29-1.41 1.42L10.59 13.4 4.29 19.7 2.88 18.29 9.17 12 2.88 5.71 4.29 4.3l6.3 6.29 6.29-6.3z\"\r\n                />\r\n              </svg>\r\n            </button>\r\n          </div>\r\n          <div id=\"deviceChecklist\" class=\"checklist\" role=\"listbox\" aria-multiselectable=\"true\"></div>\r\n        </div>\r\n\r\n        <div class=\"filter-block\">\r\n          <label class=\"block-label\">Ordena√ß√£o</label>\r\n          <div class=\"radio-grid\">\r\n            <label><input type=\"radio\" name=\"sortMode\" value=\"cons_desc\" checked /> Consumo ‚Üì (padr√£o)</label>\r\n            <label><input type=\"radio\" name=\"sortMode\" value=\"cons_asc\" /> Consumo ‚Üë</label>\r\n            <label><input type=\"radio\" name=\"sortMode\" value=\"alpha_asc\" /> A ‚Üí Z</label>\r\n            <label><input type=\"radio\" name=\"sortMode\" value=\"alpha_desc\" /> Z ‚Üí A</label>\r\n          </div>\r\n          <p class=\"muted\">Caso o consumo seja o mesmo √© considerada a ordem alfab√©tica.</p>\r\n        </div>\r\n      </section>\r\n\r\n      <footer class=\"shops-modal-footer\">\r\n        <button id=\"applyFilters\" class=\"btn primary\">Aplicar</button>\r\n        <button id=\"resetFilters\" class=\"btn\">Resetar</button>\r\n      </footer>\r\n    </div>\r\n  </div>\r\n</section>\r\n",
      "templateCss": "/* ============ Vars & base ============ */\r\n.shops-root {\r\n  --ink-1: #1c2743;\r\n  --ink-2: #6b7a90;\r\n  --bd: #e8eef4;\r\n  --bd-2: #d6e1ec;\r\n  --card: #fff;\r\n  --accent: #1f6fb5;\r\n  --shadow: 0 8px 24px rgba(0, 0, 0, 0.06);\r\n  --brand: #1f6fb5;\r\n  --brand-ghost: rgba(31, 111, 181, 0.08);\r\n  --bg-soft: #f7fbff;\r\n  --font-ui: Inter, 'Inter var', 'Plus Jakarta Sans', 'SF Pro Text', system-ui, -apple-system, Segoe UI,\r\n    Roboto, 'Helvetica Neue', Arial, sans-serif;\r\n}\r\n\r\n.shops-root,\r\n.shops-root * {\r\n  font-family: var(--font-ui);\r\n  -webkit-font-smoothing: antialiased;\r\n  text-rendering: optimizeLegibility;\r\n}\r\n\r\n/* ============ Widget layout ============ */\r\n.shops-root {\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  overflow: hidden; /* ‚úÖ Container n√£o rola (s√≥ a lista rola) */\r\n}\r\n\r\n.shops-root .shops-header {\r\n  flex: 0 0 auto; /* ‚úÖ Header ocupa apenas o espa√ßo necess√°rio */\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  background: linear-gradient(180deg, #fff 0, #f7fbff 100%);\r\n  border: 1px solid var(--bd);\r\n  border-radius: 12px;\r\n  padding: 8px 12px;\r\n  margin: 8px 10px 10px;\r\n  box-shadow: var(--shadow);\r\n  position: sticky; /* ‚úÖ Sticky para fixar no topo */\r\n  top: 0;\r\n  z-index: 10; /* ‚úÖ Fica acima da lista quando rolar */\r\n}\r\n\r\n.shops-root .shops-header-left {\r\n  display: flex;\r\n  gap: 8px;\r\n  align-items: baseline;\r\n}\r\n\r\n.shops-root .shops-title {\r\n  margin: 0;\r\n  font: 800 14px/1.2 var(--font-ui);\r\n  color: #3e1a7d;\r\n  text-shadow: 0 1px 2px rgba(62, 26, 125, 0.1);\r\n  letter-spacing: 0.3px;\r\n}\r\n\r\n.shops-root .shops-count {\r\n  font: 700 11px/1 var(--font-ui);\r\n  color: #3e1a7d;\r\n  padding: 3px 6px;\r\n}\r\n\r\n.shops-root .shops-header-actions {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n}\r\n\r\n.shops-root .icon-btn {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  border: 1px solid var(--bd);\r\n  background: #fff;\r\n  border-radius: 10px;\r\n  padding: 6px;\r\n  cursor: pointer;\r\n  box-shadow: var(--shadow);\r\n}\r\n\r\n.shops-root .icon-btn:hover {\r\n  transform: translateY(-1px);\r\n}\r\n\r\n.shops-root .icon-btn svg {\r\n  fill: #44506b;\r\n  display: block;\r\n  width: 14px;\r\n  height: 14px;\r\n}\r\n\r\n.shops-root .search-wrap {\r\n  width: 0;\r\n  overflow: hidden;\r\n  transition: width 0.25s ease;\r\n}\r\n\r\n.shops-root .search-wrap.active {\r\n  width: 180px;\r\n}\r\n\r\n.shops-root #shopsSearch {\r\n  width: 100%;\r\n  border: 1px solid var(--bd);\r\n  border-radius: 8px;\r\n  padding: 6px 8px;\r\n  outline: 0;\r\n  font: 500 12px/1.2 var(--font-ui);\r\n}\r\n\r\n.shops-root .shops-total {\r\n  font: 800 13px/1 var(--font-ui);\r\n  color: #3e1a7d;\r\n  text-decoration: none;\r\n  background: linear-gradient(135deg, rgba(62, 26, 125, 0.08) 0%, rgba(62, 26, 125, 0.12) 100%);\r\n  padding: 6px 10px;\r\n  border-radius: 8px;\r\n  border: 1px solid rgba(62, 26, 125, 0.2);\r\n  box-shadow: 0 4px 12px rgba(62, 26, 125, 0.1);\r\n  letter-spacing: 0.2px;\r\n  transition: all 0.2s ease;\r\n}\r\n\r\n.shops-root .shops-total:hover {\r\n  transform: translateY(-1px);\r\n  box-shadow: 0 6px 16px rgba(62, 26, 125, 0.15);\r\n}\r\n\r\n.shops-root .shops-list {\r\n  flex: 1 1 0; /* ‚úÖ Mudado de 'auto' para '0' - for√ßa ocupar espa√ßo dispon√≠vel */\r\n  min-height: 0; /* ‚úÖ Permite shrink em flexbox */\r\n  height: 100%; /* ‚úÖ REVERTIDO: For√ßa altura para ativar overflow */\r\n  overflow-y: auto; /* ‚úÖ Scroll vertical */\r\n  overflow-x: hidden; /* ‚úÖ Sem scroll horizontal */\r\n  padding: 16px 10px 48px 10px; /* ‚úÖ Aumentado padding-bottom para 48px para garantir visibilidade total */\r\n  scroll-padding-bottom: 48px; /* ‚úÖ Garante que scroll considere padding-bottom */\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));\r\n  gap: 12px;\r\n  -webkit-overflow-scrolling: touch;\r\n  overscroll-behavior: contain;\r\n  align-content: start;\r\n  justify-items: center;\r\n}\r\n\r\n.shops-root .card-wrapper,\r\n.shops-root .shops-list > * {\r\n  background: none;\r\n  border: none;\r\n  box-shadow: none;\r\n\r\n  border-radius: 14px;\r\n  width: 100%;\r\n  min-height: 120px;\r\n  min-width: 120px;\r\n  display: flex;\r\n  box-sizing: border-box;\r\n  justify-content: center;\r\n}\r\n\r\n/* Ensure MyIOLibrary cards fit properly */\r\n.shops-root .shops-list .card-component,\r\n.shops-root .shops-list .myio-card,\r\n.shops-root .shops-list [class*='card'] {\r\n  max-width: none !important;\r\n  height: max-content !important;\r\n  box-sizing: border-box !important;\r\n  margin: 0 !important;\r\n}\r\n\r\n/* ============ Modal (fixed sizing) ============ */\r\n.shops-root .shops-modal.hidden {\r\n  display: none;\r\n}\r\n\r\n.shops-root .shops-modal {\r\n  position: fixed;\r\n  inset: 0;\r\n  background: rgba(17, 24, 39, 0.35);\r\n  z-index: 9999;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n}\r\n\r\n.shops-root .shops-modal-card {\r\n  max-width: 774px;\r\n  width: 100%;\r\n  max-height: calc(100% - 48px);\r\n  background: #fff;\r\n  border-radius: 14px;\r\n  box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);\r\n  display: flex;\r\n  flex-direction: column;\r\n  overflow: hidden;\r\n}\r\n\r\n.shops-root .shops-modal-header {\r\n  position: sticky;\r\n  top: 0;\r\n  z-index: 2;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  padding: 10px 12px;\r\n  border-bottom: 1px solid var(--bd);\r\n  background: #fff;\r\n}\r\n\r\n.shops-root .shops-modal-header h3 {\r\n  margin: 0;\r\n  font: 900 18px/1 var(--font-ui);\r\n  letter-spacing: 0.3px;\r\n  color: #3e1a7d;\r\n  text-shadow: 0 1px 2px rgba(62, 26, 125, 0.1);\r\n}\r\n\r\n.shops-root .shops-modal-body {\r\n  flex: 1 1 auto;\r\n  min-height: 0;\r\n  overflow: auto;\r\n  padding: 14px;\r\n}\r\n\r\n.shops-root .shops-modal-footer {\r\n  position: sticky;\r\n  bottom: 0;\r\n  z-index: 2;\r\n  display: flex;\r\n  gap: 8px;\r\n  justify-content: flex-end;\r\n  padding: 10px 12px;\r\n  border-top: 1px solid var(--bd);\r\n  background: #fff;\r\n}\r\n\r\n/* Buttons */\r\n.shops-root .btn,\r\n.shops-root .tiny-btn {\r\n  border: 1px solid var(--bd);\r\n  background: #fff;\r\n  cursor: pointer;\r\n  border-radius: 10px;\r\n  font: 700 12px var(--font-ui);\r\n}\r\n\r\n.shops-root .btn {\r\n  padding: 8px 12px;\r\n}\r\n\r\n.shops-root .btn.primary {\r\n  background: #3e1a7d;\r\n  color: #fff;\r\n  border-color: #3e1a7d;\r\n  box-shadow: 0 4px 12px rgba(62, 26, 125, 0.25);\r\n  transition: all 0.15s ease;\r\n}\r\n\r\n.shops-root .btn.primary:hover {\r\n  background: #2f1460;\r\n  border-color: #2f1460;\r\n  transform: translateY(-1px);\r\n  box-shadow: 0 6px 16px rgba(62, 26, 125, 0.35);\r\n}\r\n\r\n.shops-root .btn.primary:active {\r\n  transform: translateY(0);\r\n  box-shadow: 0 2px 8px rgba(62, 26, 125, 0.25);\r\n}\r\n\r\n.shops-root .tiny-btn {\r\n  padding: 8px 12px;\r\n  letter-spacing: 0.3px;\r\n  font: 700 13px var(--font-ui);\r\n  background: linear-gradient(135deg, rgba(62, 26, 125, 0.05) 0%, rgba(62, 26, 125, 0.08) 100%);\r\n  border-color: rgba(62, 26, 125, 0.2);\r\n  color: #3e1a7d;\r\n  transition: all 0.15s ease;\r\n}\r\n\r\n.shops-root .tiny-btn:hover {\r\n  background: linear-gradient(135deg, rgba(62, 26, 125, 0.08) 0%, rgba(62, 26, 125, 0.12) 100%);\r\n  border-color: rgba(62, 26, 125, 0.3);\r\n  transform: translateY(-1px);\r\n  box-shadow: 0 4px 8px rgba(62, 26, 125, 0.15);\r\n}\r\n\r\n/* ============ Modal ‚Äì filtros ============ */\r\n.shops-root .block-label {\r\n  display: block;\r\n  margin-bottom: 10px;\r\n  font: 800 15px/1.2 var(--font-ui);\r\n  letter-spacing: 0.3px;\r\n  color: #3e1a7d;\r\n  text-shadow: 0 1px 2px rgba(62, 26, 125, 0.1);\r\n}\r\n\r\n.shops-root .inline-actions {\r\n  display: flex;\r\n  gap: 8px;\r\n  margin-bottom: 12px;\r\n}\r\n\r\n.shops-root .filter-search {\r\n  position: relative;\r\n  margin: 8px 0 12px;\r\n}\r\n\r\n.shops-root .filter-search input {\r\n  width: 100%;\r\n  border: 1px solid var(--bd-2);\r\n  border-radius: 12px;\r\n  padding: 10px 36px;\r\n  outline: 0;\r\n  font: 600 13px/1.2 var(--font-ui);\r\n  letter-spacing: 0.2px;\r\n  background: #fff;\r\n  transition: border-color 0.15s, box-shadow 0.15s;\r\n}\r\n\r\n.shops-root .filter-search input:focus {\r\n  border-color: var(--brand);\r\n  box-shadow: 0 0 0 3px rgba(31, 111, 181, 0.15);\r\n}\r\n\r\n.shops-root .filter-search svg {\r\n  position: absolute;\r\n  left: 12px;\r\n  top: 50%;\r\n  transform: translateY(-50%);\r\n  width: 16px;\r\n  height: 16px;\r\n  pointer-events: none;\r\n  fill: #44506b;\r\n}\r\n\r\n.shops-root .filter-search .clear-x {\r\n  position: absolute;\r\n  right: 8px;\r\n  top: 50%;\r\n  transform: translateY(-50%);\r\n  width: 26px;\r\n  height: 26px;\r\n  border: 0;\r\n  background: transparent;\r\n  cursor: pointer;\r\n  border-radius: 8px;\r\n}\r\n\r\n.shops-root .filter-search .clear-x:hover {\r\n  background: rgba(0, 0, 0, 0.06);\r\n}\r\n\r\n.shops-root .radio-grid {\r\n  display: grid;\r\n  grid-template-columns: repeat(2, minmax(0, 1fr));\r\n  gap: 8px;\r\n}\r\n\r\n.shops-root .radio-grid label {\r\n  font: 600 13px/1.2 var(--font-ui);\r\n  color: var(--ink-1);\r\n}\r\n\r\n.shops-root .muted {\r\n  color: var(--ink-2);\r\n  font: 500 12px/1.2 var(--font-ui);\r\n}\r\n\r\n/* ============ Checklist (pills) ============ */\r\n.shops-root .checklist {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));\r\n  gap: 10px;\r\n}\r\n\r\n.shops-root .check-item {\r\n  position: relative;\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 10px;\r\n  padding: 10px 12px 10px 44px;\r\n  background: #fff;\r\n  border: 2px solid var(--bd-2);\r\n  border-radius: 12px;\r\n  box-shadow: 0 6px 14px rgba(0, 0, 0, 0.05);\r\n  cursor: pointer;\r\n}\r\n\r\n.shops-root .check-item:hover {\r\n  border-color: var(--brand);\r\n  background: var(--bg-soft);\r\n}\r\n\r\n.shops-root .check-item:active {\r\n  transform: translateY(1px);\r\n}\r\n\r\n/* Checkbox real: 20x20 √† esquerda (n√£o cobre o label inteiro) */\r\n.shops-root .check-item input[type='checkbox'] {\r\n  position: absolute;\r\n  left: 12px;\r\n  top: 50%;\r\n  transform: translateY(-50%);\r\n  width: 20px;\r\n  height: 20px;\r\n  margin: 0;\r\n  opacity: 0;\r\n  cursor: pointer;\r\n}\r\n\r\n/* Caixa visual + √≠cone - ENHANCED */\r\n.shops-root .check-item::before {\r\n  content: '';\r\n  position: absolute;\r\n  left: 12px;\r\n  top: 50%;\r\n  transform: translateY(-50%);\r\n  width: 20px;\r\n  height: 20px;\r\n  border: 2px solid var(--bd-2);\r\n  border-radius: 6px;\r\n  background: #fff;\r\n  z-index: 1;\r\n}\r\n\r\n.shops-root .check-item::after {\r\n  content: '‚úì';\r\n  position: absolute;\r\n  left: 12px;\r\n  top: 50%;\r\n  transform: translateY(-50%);\r\n  width: 20px;\r\n  height: 20px;\r\n  opacity: 0;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  font-size: 14px;\r\n  font-weight: 900;\r\n  color: #fff;\r\n  z-index: 2;\r\n}\r\n\r\n/* ENHANCED: JavaScript-managed selected state */\r\n.shops-root .check-item.selected {\r\n  background: rgba(62, 26, 125, 0.08);\r\n  border-color: #3e1a7d;\r\n  box-shadow: 0 8px 18px rgba(62, 26, 125, 0.15);\r\n}\r\n\r\n.shops-root .check-item.selected::before {\r\n  background: #3e1a7d;\r\n  border-color: #3e1a7d;\r\n}\r\n\r\n.shops-root .check-item.selected::after {\r\n  opacity: 1;\r\n}\r\n\r\n/* ENHANCED: Direct CSS checkbox state */\r\n.shops-root .check-item input[type='checkbox']:checked + span {\r\n  background: rgba(62, 26, 125, 0.08);\r\n  border-radius: 8px;\r\n  padding: 6px 8px;\r\n  margin: -6px -8px;\r\n  display: inline-block;\r\n  font-weight: 700;\r\n}\r\n\r\n/* ENHANCED: Modern CSS with :has() */\r\n@supports selector(:has(*)) {\r\n  .shops-root .check-item:has(input[type='checkbox']:checked) {\r\n    background: rgba(62, 26, 125, 0.08);\r\n    border-color: #3e1a7d;\r\n    box-shadow: 0 8px 18px rgba(62, 26, 125, 0.15);\r\n  }\r\n\r\n  .shops-root .check-item:has(input[type='checkbox']:checked)::before {\r\n    background: #3e1a7d;\r\n    border-color: #3e1a7d;\r\n  }\r\n\r\n  .shops-root .check-item:has(input[type='checkbox']:checked)::after {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* FALLBACK: Force visibility for checked state */\r\n.shops-root .check-item[data-checked='true'] {\r\n  background: rgba(62, 26, 125, 0.08);\r\n  border-color: #3e1a7d;\r\n  box-shadow: 0 8px 18px rgba(62, 26, 125, 0.15);\r\n}\r\n\r\n.shops-root .check-item[data-checked='true']::before {\r\n  background: #3e1a7d;\r\n  border-color: #3e1a7d;\r\n}\r\n\r\n.shops-root .check-item[data-checked='true']::after {\r\n  opacity: 1;\r\n}\r\n\r\n/* Nome da loja */\r\n.shops-root .check-item span {\r\n  font: 700 13.5px/1.25 var(--font-ui);\r\n  letter-spacing: 0.15px;\r\n  color: var(--ink-1);\r\n  overflow: hidden;\r\n  white-space: nowrap;\r\n  text-overflow: ellipsis;\r\n}\r\n\r\n/* Scrollbar (opcional) */\r\n.shops-root .shops-list::-webkit-scrollbar {\r\n  width: 8px;\r\n}\r\n\r\n.shops-root .shops-list::-webkit-scrollbar-thumb {\r\n  background: #c9d4e2;\r\n  border-radius: 6px;\r\n}\r\n\r\n/*\r\n * =========================================\r\n * CSS DE MELHORIA - BOT√ïES LATERAIS DO CARD\r\n * =========================================\r\n * Cole este bloco no CSS do seu widget \r\n * para sobrescrever o estilo padr√£o.\r\n */\r\n\r\n/* 1. Centraliza a barra de a√ß√µes verticalmente na lateral */\r\n.device-card-centered .card-actions {\r\n  /* Posiciona no meio, em vez de 'top: 10px' */\r\n  top: 50% !important;\r\n  transform: translateY(-50%) !important;\r\n\r\n  /* Afasta um pouco mais da borda */\r\n  left: 12px !important;\r\n\r\n  /* \"bem espa√ßados\" - Aumenta o espa√ßo entre os bot√µes */\r\n  gap: 10px !important;\r\n}\r\n\r\n/* 2. Define um \"tamanho padr√£o\" e \"m√≠nimo\" maior para os bot√µes */\r\n.device-card-centered .card-action {\r\n  /* Tamanho padr√£o (era 32px) */\r\n  width: 38px !important;\r\n  height: 38px !important;\r\n\r\n  /* Tamanho m√≠nimo padr√£o */\r\n  min-width: 38px;\r\n  min-height: 38px;\r\n\r\n  /* Ajuste visual para o novo tamanho */\r\n  border-radius: 12px !important;\r\n}\r\n\r\n/* 3. Ajusta o √≠cone (imagem) dentro do novo bot√£o */\r\n.device-card-centered .card-action img {\r\n  width: 20px !important;\r\n  /* Era 16px */\r\n  height: 20px !important;\r\n  /* Era 16px */\r\n}\r\n\r\n/* ============ RFC-0056: FONT SIZE REDUCTION (~25%) ============ */\r\n\r\n/* Header: label, contador, filtro, total */\r\n.shops-root .shops-title {\r\n  font-size: 11px !important; /* era 14px ‚Üí 11px (-21%) */\r\n}\r\n\r\n.shops-root .shops-count {\r\n  font-size: 9px !important; /* era 11px ‚Üí 9px (-18%) */\r\n}\r\n\r\n.shops-root #shopsSearch {\r\n  font-size: 10px !important; /* era 12px ‚Üí 10px (-17%) */\r\n}\r\n\r\n.shops-root .shops-total {\r\n  font-size: 11px !important; /* era 13px ‚Üí 11px (-15%) */\r\n}\r\n\r\n/* Modal */\r\n.shops-root .shops-modal-header h3 {\r\n  font-size: 14px !important; /* era 18px ‚Üí 14px (-22%) */\r\n}\r\n\r\n.shops-root .block-label {\r\n  font-size: 12px !important; /* era 15px ‚Üí 12px (-20%) */\r\n}\r\n\r\n/* Buttons */\r\n.shops-root .btn {\r\n  font-size: 10px !important; /* era 12px ‚Üí 10px (-17%) */\r\n}\r\n\r\n.shops-root .tiny-btn {\r\n  font-size: 11px !important; /* era 13px ‚Üí 11px (-15%) */\r\n}\r\n\r\n/* Cards grid */\r\n.shops-root .shops-list {\r\n  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)) !important; /* era 260px ‚Üí 220px */\r\n}\r\n",
      "controllerScript": "/* global self, window, document */\r\n\r\n/* =========================================================================\r\n * ThingsBoard Widget: Device Cards with Totals & Percentages (MyIO)\r\n * - Datas obrigat√≥rias: startDateISO / endDateISO\r\n * - Se ausentes no onInit: usa \"current month so far\" (1¬∫ dia 00:00 ‚Üí hoje 23:59)\r\n * - Modal premium (busy) no widget durante carregamentos\r\n * - Modal premium global (fora do widget) para sucesso, com contador e reload\r\n * - onDataUpdated: no-op\r\n * - Evento (myio:update-date): mostra modal + atualiza\r\n * =========================================================================*/\r\n\r\n/* eslint-disable no-undef, no-unused-vars */\r\n\r\n// RFC-0091: Use LogHelper from MAIN via MyIOUtils (centralized logging)\r\nif (!window.MyIOUtils?.LogHelper) {\r\n  console.error('[TELEMETRY] window.MyIOUtils.LogHelper not found - MAIN_VIEW must load first');\r\n}\r\nconst LogHelper = window.MyIOUtils?.LogHelper || {\r\n  log: () => { },\r\n  warn: () => { },\r\n  error: (...args) => console.error('[TELEMETRY]', ...args),\r\n};\r\n\r\n// ===== INFOTOOLTIP FROM LIBRARY (RFC-0105) =====\r\n/**\r\n * Get InfoTooltip from the library\r\n * @returns {object|null} InfoTooltip component or null if not available\r\n */\r\nfunction getInfoTooltip() {\r\n  return window.MyIOLibrary?.InfoTooltip || null;\r\n}\r\n\r\nLogHelper.log('üöÄ [TELEMETRY] Controller loaded - VERSION WITH ORCHESTRATOR SUPPORT');\r\n\r\n/**\r\n * RFC-0097: Configura√ß√£o centralizada de classifica√ß√£o de dispositivos\r\n * Todas as regras de mapeamento deviceType ‚Üí categoria est√£o aqui\r\n */\r\nconst DEVICE_CLASSIFICATION_CONFIG = {\r\n  // DeviceTypes que pertencem √† categoria Climatiza√ß√£o\r\n  // Baseado em src/MYIO-SIM/v5.2.0/mapPower.json\r\n  climatizacao: {\r\n    // DeviceTypes que s√£o SEMPRE climatiza√ß√£o (independente do identifier)\r\n    deviceTypes: ['CHILLER', 'AR_CONDICIONADO', 'HVAC', 'FANCOIL'],\r\n    // DeviceTypes gen√©ricos que s√≥ s√£o climatiza√ß√£o SE tiverem identifier de climatiza√ß√£o\r\n    conditionalDeviceTypes: ['BOMBA', 'MOTOR'],\r\n    // Identifiers que indicam climatiza√ß√£o (usado para deviceTypes condicionais)\r\n    identifiers: ['CAG', 'FANCOIL'],\r\n    identifierPrefixes: ['CAG-', 'FANCOIL-'],\r\n  },\r\n  // DeviceTypes que pertencem √† categoria Elevadores\r\n  elevadores: {\r\n    deviceTypes: ['ELEVADOR'],\r\n    identifiers: ['ELV', 'ELEVADOR', 'ELEVADORES'],\r\n    identifierPrefixes: ['ELV-', 'ELEVADOR-'],\r\n  },\r\n  // DeviceTypes que pertencem √† categoria Escadas Rolantes\r\n  escadas_rolantes: {\r\n    deviceTypes: ['ESCADA_ROLANTE'],\r\n    identifiers: ['ESC', 'ESCADA', 'ESCADASROLANTES'],\r\n    identifierPrefixes: ['ESC-', 'ESCADA-', 'ESCADA_'],\r\n  },\r\n};\r\n\r\n// Inject styles for type badges\r\nfunction injectBadgeStyles() {\r\n  if (document.getElementById('annotation-type-badges-styles')) return;\r\n\r\n  const style = document.createElement('style');\r\n  style.id = 'annotation-type-badges-styles';\r\n  style.textContent = `\r\n          .annotation-type-badges {\r\n              position: absolute;\r\n              top: 50%;\r\n              right: 6px;\r\n              transform: translateY(-50%);\r\n              display: flex;\r\n              flex-direction: column;\r\n              gap: 4px;\r\n              z-index: 10;\r\n          }\r\n\r\n          .annotation-type-badge {\r\n              position: relative;\r\n              width: 22px;\r\n              height: 22px;\r\n              border-radius: 6px;\r\n              display: flex;\r\n              align-items: center;\r\n              justify-content: center;\r\n              font-size: 11px;\r\n              cursor: pointer;\r\n              transition: all 0.2s ease;\r\n              box-shadow: 0 1px 3px rgba(0,0,0,0.15);\r\n          }\r\n\r\n          .annotation-type-badge:hover {\r\n              transform: scale(1.15);\r\n              box-shadow: 0 2px 8px rgba(0,0,0,0.25);\r\n          }\r\n\r\n          .annotation-type-badge__count {\r\n              position: absolute;\r\n              top: -4px;\r\n              right: -4px;\r\n              min-width: 14px;\r\n              height: 14px;\r\n              padding: 0 3px;\r\n              background: #1a1a2e;\r\n              color: white;\r\n              border-radius: 7px;\r\n              font-size: 9px;\r\n              font-weight: 700;\r\n              display: flex;\r\n              align-items: center;\r\n              justify-content: center;\r\n              line-height: 1;\r\n          }\r\n      `;\r\n  document.head.appendChild(style);\r\n}\r\n\r\n/**\r\n * RFC-0105: Build annotation type tooltip content using InfoTooltip classes\r\n * @param {string} type - Annotation type (pending, maintenance, activity, observation)\r\n * @param {Array} typeAnnotations - Annotations of this type\r\n * @param {Object} config - Type configuration (color, icon, label)\r\n * @returns {string} HTML content for the tooltip\r\n */\r\nfunction buildAnnotationTypeTooltipContent(type, typeAnnotations, config) {\r\n  const now = new Date();\r\n\r\n  // Count overdue for this type\r\n  const typeOverdueCount = typeAnnotations.filter(\r\n    (a) => a.dueDate && new Date(a.dueDate) < now\r\n  ).length;\r\n\r\n  // Build overdue warning\r\n  const overdueWarning = typeOverdueCount > 0\r\n    ? `<div style=\"color:#d63031;padding:8px 12px;background:#fff5f5;border-radius:6px;margin-bottom:12px;font-size:11px;font-weight:500;\">\r\n         ‚ö†Ô∏è ${typeOverdueCount} anota√ß√£o(√µes) vencida(s)\r\n       </div>`\r\n    : '';\r\n\r\n  // Build annotations list\r\n  const annotationsList = typeAnnotations\r\n    .slice(0, 5)\r\n    .map((a) => `\r\n      <div class=\"myio-info-tooltip__row\" style=\"flex-direction:column;align-items:flex-start;gap:4px;padding:8px 0;border-bottom:1px solid #f1f5f9;\">\r\n        <div style=\"font-weight:500;color:#1a1a2e;font-size:12px;line-height:1.4;\">\"${a.text}\"</div>\r\n        <div style=\"font-size:10px;color:#868e96;\">\r\n          ${a.createdBy?.name || 'N/A'} ‚Ä¢ ${new Date(a.createdAt).toLocaleDateString('pt-BR')}\r\n          ${a.dueDate ? ` ‚Ä¢ Vence: ${new Date(a.dueDate).toLocaleDateString('pt-BR')}` : ''}\r\n        </div>\r\n      </div>\r\n    `).join('');\r\n\r\n  const moreCount = typeAnnotations.length > 5 ? typeAnnotations.length - 5 : 0;\r\n  const moreSection = moreCount > 0\r\n    ? `<div style=\"font-size:11px;color:#6c757d;margin-top:8px;text-align:center;\">+ ${moreCount} mais...</div>`\r\n    : '';\r\n\r\n  return `\r\n    <div class=\"myio-info-tooltip__section\">\r\n      <div class=\"myio-info-tooltip__section-title\">\r\n        <span style=\"display:inline-block;width:10px;height:10px;border-radius:50%;background:${config.color};\"></span>\r\n        ${config.label} (${typeAnnotations.length})\r\n      </div>\r\n      ${overdueWarning}\r\n      ${annotationsList}\r\n      ${moreSection}\r\n    </div>\r\n  `;\r\n}\r\n\r\n// Function to add annotation type badges to a card\r\nfunction addAnnotationIndicator(cardElement, entityObject) {\r\n  LogHelper.log(`[TELEMETRY] Adding annotation indicators for ${entityObject.labelOrName}`);\r\n\r\n  const annotations = entityObject.log_annotations.annotations;\r\n\r\n  // Ensure badge styles are injected\r\n  injectBadgeStyles();\r\n\r\n  // Create wrapper for positioning\r\n  if (cardElement && cardElement.style) {\r\n    cardElement.style.position = 'relative';\r\n  }\r\n\r\n  // Filter active annotations\r\n  const activeAnnotations = annotations.filter((a) => a.status !== 'archived');\r\n  if (activeAnnotations.length === 0) return null;\r\n\r\n  // Group annotations by type\r\n  const annotationsByType = {\r\n    pending: [],\r\n    maintenance: [],\r\n    activity: [],\r\n    observation: [],\r\n  };\r\n\r\n  activeAnnotations.forEach((a) => {\r\n    if (annotationsByType[a.type] !== undefined) {\r\n      annotationsByType[a.type].push(a);\r\n    }\r\n  });\r\n\r\n  // Create badges container\r\n  const container = document.createElement('div');\r\n  container.className = 'annotation-type-badges';\r\n\r\n  // Priority order: pending, maintenance, activity, observation\r\n  const typeOrder = ['pending', 'maintenance', 'activity', 'observation'];\r\n\r\n  const TYPE_CONFIG = {\r\n    pending: {\r\n      color: '#d63031',\r\n      icon: '‚ö†Ô∏è',\r\n      label: 'Pend√™ncia',\r\n    },\r\n    maintenance: {\r\n      color: '#e17055',\r\n      icon: 'üîß',\r\n      label: 'Manuten√ß√£o',\r\n    },\r\n    activity: {\r\n      color: '#00b894',\r\n      icon: '‚úì',\r\n      label: 'Atividade',\r\n    },\r\n    observation: {\r\n      color: '#0984e3',\r\n      icon: 'üìù',\r\n      label: 'Observa√ß√£o',\r\n    },\r\n  };\r\n\r\n  // RFC-0105: Get InfoTooltip from library\r\n  const InfoTooltip = getInfoTooltip();\r\n\r\n  // Create a badge for each type with annotations\r\n  typeOrder.forEach((type) => {\r\n    const typeAnnotations = annotationsByType[type];\r\n    if (typeAnnotations.length === 0) return;\r\n\r\n    const config = TYPE_CONFIG[type];\r\n    const badge = document.createElement('div');\r\n    badge.className = 'annotation-type-badge';\r\n    badge.style.background = config.color;\r\n    badge.innerHTML = `\r\n      <span>${config.icon}</span>\r\n      <span class=\"annotation-type-badge__count\">${typeAnnotations.length}</span>\r\n    `;\r\n\r\n    // RFC-0105: Use InfoTooltip from library\r\n    if (InfoTooltip) {\r\n      badge.addEventListener('mouseenter', () => {\r\n        const content = buildAnnotationTypeTooltipContent(type, typeAnnotations, config);\r\n        InfoTooltip.show(badge, {\r\n          icon: config.icon,\r\n          title: `${config.label} - ${entityObject.labelOrName}`,\r\n          content: content\r\n        });\r\n      });\r\n\r\n      badge.addEventListener('mouseleave', () => {\r\n        InfoTooltip.startDelayedHide();\r\n      });\r\n    } else {\r\n      console.error('[TELEMETRY] InfoTooltip not available - cannot show annotation tooltip');\r\n    }\r\n\r\n    container.appendChild(badge);\r\n  });\r\n\r\n  // Append badges to card\r\n  cardElement.appendChild(container);\r\n\r\n  return container;\r\n}\r\n\r\n// Sets pr√©-computados para lookup r√°pido\r\nconst CLIMATIZACAO_DEVICE_TYPES_SET = new Set(DEVICE_CLASSIFICATION_CONFIG.climatizacao.deviceTypes);\r\nconst CLIMATIZACAO_CONDITIONAL_TYPES_SET = new Set(\r\n  DEVICE_CLASSIFICATION_CONFIG.climatizacao.conditionalDeviceTypes || []\r\n);\r\nconst ELEVADORES_DEVICE_TYPES_SET = new Set(DEVICE_CLASSIFICATION_CONFIG.elevadores.deviceTypes);\r\nconst ESCADAS_DEVICE_TYPES_SET = new Set(DEVICE_CLASSIFICATION_CONFIG.escadas_rolantes.deviceTypes);\r\n\r\nconst CLIMATIZACAO_IDENTIFIERS_SET = new Set(DEVICE_CLASSIFICATION_CONFIG.climatizacao.identifiers);\r\nconst ELEVADORES_IDENTIFIERS_SET = new Set(DEVICE_CLASSIFICATION_CONFIG.elevadores.identifiers);\r\nconst ESCADAS_IDENTIFIERS_SET = new Set(DEVICE_CLASSIFICATION_CONFIG.escadas_rolantes.identifiers);\r\n\r\n// RFC-0097: Regex para excluir equipamentos ao detectar widget \"lojas\"\r\n// Constru√≠do dinamicamente a partir do config\r\nconst EQUIPMENT_EXCLUSION_PATTERN = new RegExp(\r\n  [\r\n    ...DEVICE_CLASSIFICATION_CONFIG.climatizacao.deviceTypes,\r\n    ...DEVICE_CLASSIFICATION_CONFIG.elevadores.deviceTypes,\r\n    ...DEVICE_CLASSIFICATION_CONFIG.escadas_rolantes.deviceTypes,\r\n    'bomba',\r\n    'subesta',\r\n    'entrada', // Termos adicionais fixos\r\n  ]\r\n    .map((t) => t.toLowerCase())\r\n    .join('|'),\r\n  'i'\r\n);\r\n\r\n/**\r\n * RFC-0097: Infere um identifier para exibi√ß√£o baseado no deviceType ou label\r\n * Usado quando o atributo identifier est√° ausente\r\n * @param {Object} item - Item com deviceType e/ou label\r\n * @returns {string} Identifier inferido ou 'N/A'\r\n */\r\nfunction inferDisplayIdentifier(item) {\r\n  if (!item) return 'N/A';\r\n\r\n  // Primeiro, tentar usar deviceType\r\n  const deviceType = String(item.deviceType || '').toUpperCase();\r\n  if (deviceType && deviceType !== 'N/D' && deviceType !== '3F_MEDIDOR') {\r\n    // Se for um deviceType conhecido, retornar o pr√≥prio deviceType ou abrevia√ß√£o\r\n    if (CLIMATIZACAO_DEVICE_TYPES_SET.has(deviceType)) {\r\n      return deviceType;\r\n    }\r\n    if (ELEVADORES_DEVICE_TYPES_SET.has(deviceType)) {\r\n      return 'ELV';\r\n    }\r\n    if (ESCADAS_DEVICE_TYPES_SET.has(deviceType)) {\r\n      return 'ESC';\r\n    }\r\n  }\r\n\r\n  // Fallback: inferir do label usando deviceTypes do config\r\n  const label = String(item.label || '').toLowerCase();\r\n\r\n  // Verificar cada deviceType de climatiza√ß√£o no label\r\n  for (const dt of DEVICE_CLASSIFICATION_CONFIG.climatizacao.deviceTypes) {\r\n    if (label.includes(dt.toLowerCase())) {\r\n      return dt;\r\n    }\r\n  }\r\n  // Verificar identifiers de climatiza√ß√£o\r\n  for (const id of DEVICE_CLASSIFICATION_CONFIG.climatizacao.identifiers) {\r\n    if (label.includes(id.toLowerCase())) {\r\n      return id;\r\n    }\r\n  }\r\n\r\n  // Elevadores\r\n  if (label.includes('elevador') || label.includes('elv')) return 'ELV';\r\n\r\n  // Escadas\r\n  if (label.includes('escada')) return 'ESC';\r\n\r\n  return 'N/A';\r\n}\r\n\r\n// RFC-0091: Use shared DATA_API_HOST from MAIN widget via window.MyIOUtils\r\nconst DATA_API_HOST = window.MyIOUtils?.DATA_API_HOST;\r\nif (!DATA_API_HOST) {\r\n  console.error(\r\n    '[TELEMETRY] DATA_API_HOST not available from window.MyIOUtils - MAIN widget must load first'\r\n  );\r\n}\r\nconst MAX_FIRST_HYDRATES = 1;\r\nlet MAP_INSTANTANEOUS_POWER;\r\n\r\n/**\r\n * RFC-0078: Extract consumption ranges from unified JSON structure\r\n * @param {Object} powerLimitsJSON - The mapInstantaneousPower JSON object\r\n * @param {string} deviceType - Device type (e.g., 'ELEVADOR')\r\n * @param {string} telemetryType - Telemetry type (default: 'consumption')\r\n * @returns {Object|null} Range configuration or null\r\n */\r\n/**\r\n * RFC-0078: Busca limites no JSON com \"Funil\" de fallback inteligente\r\n * Resolve inconsist√™ncias entre nomes do TB e chaves do JSON (incluindo Overrides)\r\n */\r\nfunction extractLimitsFromJSON(powerLimitsJSON, deviceType, telemetryType = 'consumption') {\r\n  if (!powerLimitsJSON || !powerLimitsJSON.limitsByInstantaneoustPowerType) {\r\n    return null;\r\n  }\r\n\r\n  const telemetryConfig = powerLimitsJSON.limitsByInstantaneoustPowerType.find(\r\n    (config) => config.telemetryType === telemetryType\r\n  );\r\n\r\n  if (!telemetryConfig) return null;\r\n\r\n  // Normaliza o tipo para evitar problemas de espa√ßo ou min√∫sculas\r\n  const typeUpper = String(deviceType || '').toUpperCase().trim();\r\n\r\n  // 1. TENTATIVA EXATA (O ideal)\r\n  let deviceConfig = telemetryConfig.itemsByDeviceType.find(\r\n    (item) => String(item.deviceType).toUpperCase().trim() === typeUpper\r\n  );\r\n\r\n  // 2. SE N√ÉO ACHOU, TENTA IDENTIFICAR PELO NOME (Apelidos)\r\n  if (!deviceConfig) {\r\n      if (typeUpper.includes('ESCADA') || typeUpper === 'ESCADASROLANTES' || typeUpper.includes('ER ')) {\r\n           deviceConfig = telemetryConfig.itemsByDeviceType.find(i => i.deviceType === 'ESCADA_ROLANTE');\r\n      }\r\n      else if (typeUpper.includes('ELEVADOR') || typeUpper.includes('ELV')) {\r\n           deviceConfig = telemetryConfig.itemsByDeviceType.find(i => i.deviceType === 'ELEVADOR');\r\n      }\r\n      else if (typeUpper.includes('BOMBA')) {\r\n           deviceConfig = telemetryConfig.itemsByDeviceType.find(i => i.deviceType === 'BOMBA');\r\n      }\r\n      // Chillers com override muitas vezes usam perfil de MOTOR\r\n      else if (typeUpper.includes('CHILLER')) {\r\n           deviceConfig = telemetryConfig.itemsByDeviceType.find(i => i.deviceType === 'CHILLER');\r\n           if (!deviceConfig) deviceConfig = telemetryConfig.itemsByDeviceType.find(i => i.deviceType === 'MOTOR');\r\n      }\r\n      // Fancoil / HVAC\r\n      else if (typeUpper.includes('FANCOIL')) deviceConfig = telemetryConfig.itemsByDeviceType.find(i => i.deviceType === 'FANCOIL');\r\n      else if (typeUpper.includes('HVAC')) deviceConfig = telemetryConfig.itemsByDeviceType.find(i => i.deviceType === 'HVAC');\r\n  }\r\n\r\n  // 3. FALLBACK UNIVERSAL (CATCH-ALL)\r\n  // Resolve Lojas (\"102B\", \"L0L1\"), Entradas (\"TRAFO\", \"REDE\") e qualquer outro desconhecido.\r\n  if (!deviceConfig) {\r\n       deviceConfig = telemetryConfig.itemsByDeviceType.find(i => i.deviceType === '3F_MEDIDOR');\r\n       // Se n√£o tiver 3F_MEDIDOR (raro), tenta MOTOR como √∫ltimo recurso\r\n       if (!deviceConfig) deviceConfig = telemetryConfig.itemsByDeviceType.find(i => i.deviceType === 'MOTOR');\r\n  }\r\n\r\n  if (!deviceConfig) return null;\r\n\r\n  // 4. Extrai os ranges\r\n  const ranges = {\r\n    standbyRange: { down: 0, up: 0 },\r\n    normalRange: { down: 0, up: 0 },\r\n    alertRange: { down: 0, up: 0 },\r\n    failureRange: { down: 0, up: 0 },\r\n  };\r\n\r\n  if (deviceConfig.limitsByDeviceStatus) {\r\n      deviceConfig.limitsByDeviceStatus.forEach((status) => {\r\n        const vals = status.limitsValues || status.limitsVales || {};\r\n        const baseValue = vals.baseValue ?? 0;\r\n        const topValue = vals.topValue ?? 99999999; \r\n\r\n        switch (status.deviceStatusName) {\r\n          case 'standBy': ranges.standbyRange = { down: baseValue, up: topValue }; break;\r\n          case 'normal': ranges.normalRange = { down: baseValue, up: topValue }; break;\r\n          case 'alert': ranges.alertRange = { down: baseValue, up: topValue }; break;\r\n          case 'failure': ranges.failureRange = { down: baseValue, up: topValue }; break;\r\n        }\r\n      });\r\n  }\r\n\r\n  return {\r\n    ...ranges,\r\n    source: 'json',\r\n    metadata: {\r\n      name: deviceConfig.name,\r\n      matchedType: deviceConfig.deviceType \r\n    },\r\n  };\r\n}\r\n\r\nlet __deviceProfileSyncComplete = false;\r\n\r\nasync function fetchDeviceProfiles() {\r\n  const token = localStorage.getItem('jwt_token');\r\n  if (!token) throw new Error('[RFC-0071] JWT token not found');\r\n\r\n  const url = '/api/deviceProfile/names?activeOnly=true';\r\n\r\n  console.log('[EQUIPMENTS] [RFC-0071] Fetching device profiles...');\r\n\r\n  const response = await fetch(url, {\r\n    headers: {\r\n      'X-Authorization': `Bearer ${token}`,\r\n      'Content-Type': 'application/json',\r\n    },\r\n  });\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`[RFC-0071] Failed to fetch device profiles: ${response.status}`);\r\n  }\r\n\r\n  const profiles = await response.json();\r\n\r\n  // Build Map: profileId -> profileName\r\n  const profileMap = new Map();\r\n  profiles.forEach((profile) => {\r\n    const profileId = profile.id.id;\r\n    const profileName = profile.name;\r\n    profileMap.set(profileId, profileName);\r\n  });\r\n\r\n  console.log(\r\n    `[EQUIPMENTS] [RFC-0071] Loaded ${profileMap.size} device profiles:`,\r\n    Array.from(profileMap.entries())\r\n      .map(([id, name]) => name)\r\n      .join(', ')\r\n  );\r\n\r\n  return profileMap;\r\n}\r\n\r\n/**\r\n * Fetches device details including deviceProfileId\r\n * @param {string} deviceId - Device entity ID\r\n * @returns {Promise<Object>}\r\n */\r\nasync function fetchDeviceDetails(deviceId) {\r\n  const token = localStorage.getItem('jwt_token');\r\n  if (!token) throw new Error('[RFC-0071] JWT token not found');\r\n\r\n  const url = `/api/device/${deviceId}`;\r\n\r\n  const response = await fetch(url, {\r\n    headers: {\r\n      'X-Authorization': `Bearer ${token}`,\r\n      'Content-Type': 'application/json',\r\n    },\r\n  });\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`[RFC-0071] Failed to fetch device ${deviceId}: ${response.status}`);\r\n  }\r\n\r\n  return await response.json();\r\n}\r\n\r\n/**\r\n * Saves deviceProfile as a server-scope attribute on the device\r\n * @param {string} deviceId - Device entity ID\r\n * @param {string} deviceProfile - Profile name (e.g., \"MOTOR\", \"3F_MEDIDOR\")\r\n * @returns {Promise<{ok: boolean, status: number, data: any}>}\r\n */\r\nasync function addDeviceProfileAttribute(deviceId, deviceProfile) {\r\n  const t = Date.now();\r\n\r\n  try {\r\n    if (!deviceId) throw new Error('deviceId is required');\r\n    if (deviceProfile == null || deviceProfile === '') {\r\n      throw new Error('deviceProfile is required');\r\n    }\r\n\r\n    const token = localStorage.getItem('jwt_token');\r\n    if (!token) throw new Error('jwt_token not found in localStorage');\r\n\r\n    const url = `/api/plugins/telemetry/DEVICE/${deviceId}/attributes/SERVER_SCOPE`;\r\n    const headers = {\r\n      'Content-Type': 'application/json',\r\n      'X-Authorization': `Bearer ${token}`,\r\n    };\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers,\r\n      body: JSON.stringify({ deviceProfile }),\r\n    });\r\n\r\n    const bodyText = await res.text().catch(() => '');\r\n\r\n    if (!res.ok) {\r\n      throw new Error(`[RFC-0071] HTTP ${res.status} ${res.statusText} - ${bodyText}`);\r\n    }\r\n\r\n    let data = null;\r\n    try {\r\n      data = bodyText ? JSON.parse(bodyText) : null;\r\n    } catch {\r\n      // Response may not be JSON\r\n    }\r\n\r\n    const dt = Date.now() - t;\r\n    console.log(\r\n      `[EQUIPMENTS] [RFC-0071] ‚úÖ Saved deviceProfile | device=${deviceId} | \"${deviceProfile}\" | ${dt}ms`\r\n    );\r\n\r\n    return { ok: true, status: res.status, data };\r\n  } catch (err) {\r\n    const dt = Date.now() - t;\r\n    console.error(\r\n      `[EQUIPMENTS] [RFC-0071] ‚ùå Failed to save deviceProfile | device=${deviceId} | \"${deviceProfile}\" | ${dt}ms | error: ${err?.message || err\r\n      }`\r\n    );\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Main synchronization function\r\n * Checks all devices and syncs missing deviceProfile attributes\r\n * @returns {Promise<{synced: number, skipped: number, errors: number}>}\r\n */\r\nasync function syncDeviceProfileAttributes() {\r\n  console.log('[EQUIPMENTS] [RFC-0071] üîÑ Starting device profile synchronization...');\r\n\r\n  try {\r\n    // Step 1: Fetch all device profiles\r\n    const profileMap = await fetchDeviceProfiles();\r\n\r\n    let synced = 0;\r\n    let skipped = 0;\r\n    let errors = 0;\r\n\r\n    // Step 2: Build a map of devices that need sync\r\n    const deviceMap = new Map();\r\n\r\n    self.ctx.data.forEach((data) => {\r\n      const entityId = data.datasource?.entity?.id?.id;\r\n      const existingProfile = data.datasource?.deviceProfile;\r\n\r\n      if (!entityId) return;\r\n\r\n      // Skip if already has deviceProfile attribute\r\n      if (existingProfile) {\r\n        skipped++;\r\n        return;\r\n      }\r\n\r\n      // Store for processing (deduplicate by entityId)\r\n      if (!deviceMap.has(entityId)) {\r\n        deviceMap.set(entityId, {\r\n          entityLabel: data.datasource?.entityLabel,\r\n          entityName: data.datasource?.entityName,\r\n          name: data.datasource?.name,\r\n        });\r\n      }\r\n    });\r\n\r\n    console.log(`[EQUIPMENTS] [RFC-0071] Found ${deviceMap.size} devices without deviceProfile attribute`);\r\n    console.log(`[EQUIPMENTS] [RFC-0071] Skipped ${skipped} devices that already have deviceProfile`);\r\n\r\n    if (deviceMap.size === 0) {\r\n      console.log('[EQUIPMENTS] [RFC-0071] ‚úÖ All devices already synchronized!');\r\n      return { synced: 0, skipped, errors: 0 };\r\n    }\r\n\r\n    // Step 3: Fetch device details and sync attributes\r\n    let processed = 0;\r\n    for (const [entityId, deviceInfo] of deviceMap) {\r\n      processed++;\r\n      const deviceLabel = deviceInfo.entityLabel || deviceInfo.entityName || deviceInfo.name || entityId;\r\n\r\n      try {\r\n        console.log(`[EQUIPMENTS] [RFC-0071] Processing ${processed}/${deviceMap.size}: ${deviceLabel}`);\r\n\r\n        // Fetch device details to get deviceProfileId\r\n        const deviceDetails = await fetchDeviceDetails(entityId);\r\n        const deviceProfileId = deviceDetails.deviceProfileId?.id;\r\n\r\n        if (!deviceProfileId) {\r\n          console.warn(`[EQUIPMENTS] [RFC-0071] ‚ö†Ô∏è Device ${deviceLabel} has no deviceProfileId`);\r\n          errors++;\r\n          continue;\r\n        }\r\n\r\n        // Look up profile name from map\r\n        const profileName = profileMap.get(deviceProfileId);\r\n\r\n        if (!profileName) {\r\n          console.warn(`[EQUIPMENTS] [RFC-0071] ‚ö†Ô∏è Profile ID ${deviceProfileId} not found in map`);\r\n          errors++;\r\n          continue;\r\n        }\r\n\r\n        // Save attribute\r\n        await addDeviceProfileAttribute(entityId, profileName);\r\n        synced++;\r\n\r\n        console.log(`[EQUIPMENTS] [RFC-0071] ‚úÖ Synced ${deviceLabel} -> ${profileName}`);\r\n\r\n        // Small delay to avoid overwhelming the API\r\n        await new Promise((resolve) => setTimeout(resolve, 100));\r\n      } catch (error) {\r\n        console.error(`[EQUIPMENTS] [RFC-0071] ‚ùå Failed to sync device ${deviceLabel}:`, error);\r\n        errors++;\r\n      }\r\n    }\r\n\r\n    console.log(\r\n      `[EQUIPMENTS] [RFC-0071] üéâ Sync complete: ${synced} synced, ${skipped} skipped, ${errors} errors`\r\n    );\r\n\r\n    return { synced, skipped, errors };\r\n  } catch (error) {\r\n    console.error('[EQUIPMENTS] [RFC-0071] ‚ùå Fatal error during sync:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Get telemetry data by dataKey name from self.ctx.data\r\n * @param {string} dataKeyName - The dataKey name to search for\r\n * @returns {*} The value of the data point, or null if not found\r\n */\r\nfunction getData(dataKeyName) {\r\n  if (!self?.ctx?.data) {\r\n    LogHelper.warn('[getData] No ctx.data available');\r\n    return null;\r\n  }\r\n\r\n  for (const device of self.ctx.data) {\r\n    if (device.dataKey && device.dataKey.name === dataKeyName) {\r\n      // Return the most recent value (last item in data array)\r\n      if (device.data && device.data.length > 0) {\r\n        const lastDataPoint = device.data[device.data.length - 1];\r\n        return lastDataPoint[1]; // [timestamp, value]\r\n      }\r\n    }\r\n  }\r\n\r\n  LogHelper.warn(`[getData] DataKey \"${dataKeyName}\" not found in ctx.data`);\r\n  return null;\r\n}\r\n\r\nlet dateUpdateHandler = null;\r\nlet dataProvideHandler = null; // RFC-0042: Orchestrator data listener\r\n//let DEVICE_TYPE = \"energy\";\r\nlet MyIO = null;\r\nlet hasRequestedInitialData = false; // Flag to prevent duplicate initial requests\r\nlet lastProcessedPeriodKey = null; // Track last processed periodKey to prevent duplicate processing\r\nlet busyTimeoutId = null; // Timeout ID for busy fallback\r\n\r\n// RFC-0042: Widget configuration (from settings)\r\nlet WIDGET_DOMAIN = 'energy'; // Will be set in onInit\r\n\r\n// RFC-0063: Classification mode configuration\r\nlet USE_IDENTIFIER_CLASSIFICATION = false; // Flag to enable identifier-based classification\r\nlet USE_HYBRID_CLASSIFICATION = false; // Flag to enable hybrid mode (identifier + labels)\r\n\r\n/** ===================== STATE ===================== **/\r\nlet CLIENT_ID = '';\r\nlet CLIENT_SECRET = '';\r\nlet CUSTOMER_ING_ID = '';\r\nlet MyIOAuth = null;\r\n\r\nconst STATE = {\r\n  itemsBase: [], // lista autoritativa (TB)\r\n  itemsEnriched: [], // lista com totals + perc\r\n  searchActive: false,\r\n  searchTerm: '',\r\n  selectedIds: /** @type {Set<string> | null} */ (null),\r\n  sortMode: /** @type {'cons_desc'|'cons_asc'|'alpha_asc'|'alpha_desc'} */ ('cons_desc'),\r\n  firstHydrates: 0,\r\n};\r\n\r\nlet hydrating = false;\r\n\r\n/** ===================== HELPERS (DOM) ===================== **/\r\nconst $root = () => $(self.ctx.$container[0]);\r\nconst $list = () => $root().find('#shopsList');\r\nconst $count = () => $root().find('#shopsCount');\r\nconst $total = () => $root().find('#shopsTotal');\r\nconst $modal = () => $root().find('#filterModal');\r\n\r\n/** ===================== BUSY MODAL (no widget) ===================== **/\r\nconst BUSY_ID = 'myio-busy-modal';\r\nfunction ensureBusyModalDOM() {\r\n  let $m = $root().find(`#${BUSY_ID}`);\r\n  if ($m.length) return $m;\r\n\r\n  const html = `\r\n  <div id=\"${BUSY_ID}\" style=\"\r\n      position:absolute; inset:0; display:none;\r\n      background: rgba(150,132,181,0.45); /* #9684B5 com transpar√™ncia */\r\n      backdrop-filter: blur(5px);\r\n      z-index:9999; align-items:center; justify-content:center;\r\n      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;\">\r\n    <div style=\"\r\n        background:#2d1458; color:#fff;\r\n        border:1px solid rgba(255,255,255,0.10);\r\n        box-shadow:0 12px 40px rgba(0,0,0,.35);\r\n        border-radius:18px; padding:22px 26px; min-width:320px;\">\r\n      <div style=\"display:flex; align-items:center; gap:12px;\">\r\n        <div class=\"spinner\" style=\"\r\n            width:22px;height:22px;border-radius:50%;\r\n            border:3px solid rgba(255,255,255,.25);\r\n            border-top-color:#ffffff; animation:spin .9s linear infinite;\"></div>\r\n        <div id=\"${BUSY_ID}-msg\" style=\"font-weight:600; font-size:14px; letter-spacing:.2px;\">\r\n          aguarde.. carregando os dados...\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <style>\r\n    @keyframes spin { from{transform:rotate(0)} to{transform:rotate(360deg)} }\r\n  </style>`;\r\n  $root().css('position', 'relative'); // garante overlay correto\r\n  $root().append(html);\r\n  return $root().find(`#${BUSY_ID}`);\r\n}\r\n// RFC-0044: Use centralized busy management\r\nfunction showBusy(message, timeoutMs = 35000) {\r\n  LogHelper.log(`[TELEMETRY] üîÑ showBusy() called with message: \"${message || 'default'}\"`);\r\n\r\n  // Prevent multiple simultaneous busy calls\r\n  if (window.busyInProgress) {\r\n    LogHelper.log(`[TELEMETRY] ‚è≠Ô∏è Skipping duplicate showBusy() call`);\r\n    return;\r\n  }\r\n\r\n  window.busyInProgress = true;\r\n\r\n  // Centralized busy with enhanced synchronization\r\n  const safeShowBusy = () => {\r\n    try {\r\n      if (window.MyIOOrchestrator && typeof window.MyIOOrchestrator.showGlobalBusy === 'function') {\r\n        const text = (message && String(message).trim()) || 'Carregando dados...';\r\n        window.MyIOOrchestrator.showGlobalBusy(WIDGET_DOMAIN, text, timeoutMs);\r\n        LogHelper.log(`[TELEMETRY] ‚úÖ Using centralized busy for domain: ${WIDGET_DOMAIN}`);\r\n      } else {\r\n        LogHelper.warn(`[TELEMETRY] ‚ö†Ô∏è Orchestrator not available, using fallback busy`);\r\n        const $m = ensureBusyModalDOM();\r\n        const text = (message && String(message).trim()) || 'aguarde.. carregando os dados...';\r\n        $m.find(`#${BUSY_ID}-msg`).text(text);\r\n        $m.css('display', 'flex');\r\n      }\r\n    } catch (err) {\r\n      LogHelper.error(`[TELEMETRY] ‚ùå Error in showBusy:`, err);\r\n    } finally {\r\n      // Always reset busy flag after a short delay\r\n      setTimeout(() => {\r\n        window.busyInProgress = false;\r\n      }, 500);\r\n    }\r\n  };\r\n\r\n  // RFC-0051.3: Check if orchestrator exists and is ready\r\n  const checkOrchestratorReady = async () => {\r\n    // First, check if orchestrator exists and is ready\r\n    if (window.MyIOOrchestrator?.isReady) {\r\n      safeShowBusy();\r\n      return;\r\n    }\r\n\r\n    // Wait for orchestrator ready event (with timeout)\r\n    const ready = await new Promise((resolve) => {\r\n      let timeout;\r\n      let interval;\r\n\r\n      // Listen for ready event\r\n      const handler = () => {\r\n        clearTimeout(timeout);\r\n        clearInterval(interval);\r\n        window.removeEventListener('myio:orchestrator:ready', handler);\r\n        resolve(true);\r\n      };\r\n\r\n      window.addEventListener('myio:orchestrator:ready', handler);\r\n\r\n      // Timeout after 5 seconds\r\n      timeout = setTimeout(() => {\r\n        clearInterval(interval);\r\n        window.removeEventListener('myio:orchestrator:ready', handler);\r\n        LogHelper.warn('[TELEMETRY] ‚ö†Ô∏è Orchestrator ready timeout after 5s, using fallback');\r\n        resolve(false);\r\n      }, 5000);\r\n\r\n      // Also poll isReady flag (fallback if event is missed)\r\n      interval = setInterval(() => {\r\n        if (window.MyIOOrchestrator?.isReady) {\r\n          clearInterval(interval);\r\n          clearTimeout(timeout);\r\n          window.removeEventListener('myio:orchestrator:ready', handler);\r\n          resolve(true);\r\n        }\r\n      }, 100);\r\n    });\r\n\r\n    safeShowBusy();\r\n  };\r\n\r\n  checkOrchestratorReady();\r\n}\r\n\r\nfunction hideBusy() {\r\n  LogHelper.log(`[TELEMETRY] ‚è∏Ô∏è hideBusy() called`);\r\n\r\n  const safeHideBusy = () => {\r\n    try {\r\n      if (window.MyIOOrchestrator && typeof window.MyIOOrchestrator.hideGlobalBusy === 'function') {\r\n        window.MyIOOrchestrator.hideGlobalBusy();\r\n        LogHelper.log(`[TELEMETRY] ‚úÖ Using centralized hideBusy`);\r\n      } else {\r\n        LogHelper.warn(`[TELEMETRY] ‚ö†Ô∏è Orchestrator not available, using fallback hideBusy`);\r\n        $root().find(`#${BUSY_ID}`).css('display', 'none');\r\n      }\r\n    } catch (err) {\r\n      LogHelper.error(`[TELEMETRY] ‚ùå Error in hideBusy:`, err);\r\n    } finally {\r\n      window.busyInProgress = false;\r\n    }\r\n  };\r\n\r\n  // RFC-0051.3: Check if orchestrator exists and is ready\r\n  const checkOrchestratorReady = async () => {\r\n    // First, check if orchestrator exists and is ready\r\n    if (window.MyIOOrchestrator?.isReady) {\r\n      safeHideBusy();\r\n      return;\r\n    }\r\n\r\n    // Wait for orchestrator ready event (with timeout)\r\n    const ready = await new Promise((resolve) => {\r\n      let timeout;\r\n      let interval;\r\n\r\n      // Listen for ready event\r\n      const handler = () => {\r\n        clearTimeout(timeout);\r\n        clearInterval(interval);\r\n        window.removeEventListener('myio:orchestrator:ready', handler);\r\n        resolve(true);\r\n      };\r\n\r\n      window.addEventListener('myio:orchestrator:ready', handler);\r\n\r\n      // Timeout after 5 seconds\r\n      timeout = setTimeout(() => {\r\n        clearInterval(interval);\r\n        window.removeEventListener('myio:orchestrator:ready', handler);\r\n        LogHelper.warn('[TELEMETRY] ‚ö†Ô∏è Orchestrator ready timeout after 5s, using fallback');\r\n        resolve(false);\r\n      }, 5000);\r\n\r\n      // Also poll isReady flag (fallback if event is missed)\r\n      interval = setInterval(() => {\r\n        if (window.MyIOOrchestrator?.isReady) {\r\n          clearInterval(interval);\r\n          clearTimeout(timeout);\r\n          window.removeEventListener('myio:orchestrator:ready', handler);\r\n          resolve(true);\r\n        }\r\n      }, 100);\r\n    });\r\n\r\n    safeHideBusy();\r\n  };\r\n\r\n  checkOrchestratorReady();\r\n}\r\n\r\nconst findValue = (values, dataType, defaultValue = 'N/D') => {\r\n  const item = values.find((v) => v.dataType === dataType);\r\n  if (!item) return defaultValue;\r\n  // Retorna a propriedade 'val' (da nossa API) ou 'value' (do ThingsBoard)\r\n  return item.val !== undefined ? item.val : item.value;\r\n};\r\n\r\n/** ===================== GLOBAL SUCCESS MODAL (fora do widget) ===================== **/\r\nconst G_SUCCESS_ID = 'myio-global-success-modal';\r\nlet gSuccessTimer = null;\r\n\r\nfunction ensureGlobalSuccessModalDOM() {\r\n  let el = document.getElementById(G_SUCCESS_ID);\r\n  if (el) return el;\r\n\r\n  const wrapper = document.createElement('div');\r\n  wrapper.id = G_SUCCESS_ID;\r\n  wrapper.setAttribute(\r\n    'style',\r\n    `\r\n    position: fixed; inset: 0; display: none;\r\n    z-index: 999999; \r\n    background: rgba(150,132,181,0.45); /* #9684B5 com transpar√™ncia */\r\n    backdrop-filter: blur(6px);\r\n    -webkit-backdrop-filter: blur(6px);\r\n  `\r\n  );\r\n\r\n  // container central\r\n  const center = document.createElement('div');\r\n  center.setAttribute(\r\n    'style',\r\n    `\r\n    position: absolute; top: 50%; left: 50%;\r\n    transform: translate(-50%, -50%);\r\n    background: #2d1458; color: #fff;\r\n    border-radius: 20px; padding: 26px 30px; min-width: 360px;\r\n    border: 1px solid rgba(255,255,255,0.12);\r\n    box-shadow: 0 14px 44px rgba(0,0,0,.35);\r\n    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;\r\n    text-align: center;\r\n  `\r\n  );\r\n\r\n  const icon = document.createElement('div');\r\n  icon.innerHTML = `\r\n    <div style=\"\r\n      width:56px;height:56px;margin:0 auto 10px auto;border-radius:50%;\r\n      background: rgba(255,255,255,.12); display:flex;align-items:center;justify-content:center;\r\n      \">\r\n      <svg width=\"28\" height=\"28\" viewBox=\"0 0 24 24\" fill=\"none\">\r\n        <path d=\"M20 6L9 17L4 12\" stroke=\"#FFFFFF\" stroke-width=\"2.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\r\n      </svg>\r\n    </div>\r\n  `;\r\n\r\n  const title = document.createElement('div');\r\n  title.id = `${G_SUCCESS_ID}-title`;\r\n  title.textContent = 'os dados foram salvos com sucesso';\r\n  title.setAttribute('style', `font-size:16px;font-weight:700;letter-spacing:.2px;margin-bottom:6px;`);\r\n\r\n  const sub = document.createElement('div');\r\n  sub.id = `${G_SUCCESS_ID}-sub`;\r\n  sub.innerHTML = `recarregando em <b id=\"${G_SUCCESS_ID}-count\">6</b>s...`;\r\n  sub.setAttribute('style', `opacity:.9;font-size:13px;`);\r\n\r\n  center.appendChild(icon);\r\n  center.appendChild(title);\r\n  center.appendChild(sub);\r\n  wrapper.appendChild(center);\r\n  document.body.appendChild(wrapper);\r\n  return wrapper;\r\n}\r\n\r\nfunction showGlobalSuccessModal(seconds = 6) {\r\n  const el = ensureGlobalSuccessModalDOM();\r\n  // reset contador\r\n  const countEl = el.querySelector(`#${G_SUCCESS_ID}-count`);\r\n  if (countEl) countEl.textContent = String(seconds);\r\n\r\n  el.style.display = 'block';\r\n\r\n  if (gSuccessTimer) {\r\n    clearInterval(gSuccessTimer);\r\n    gSuccessTimer = null;\r\n  }\r\n\r\n  let left = seconds;\r\n  gSuccessTimer = setInterval(() => {\r\n    left -= 1;\r\n    if (countEl) countEl.textContent = String(left);\r\n    if (left <= 0) {\r\n      clearInterval(gSuccessTimer);\r\n      gSuccessTimer = null;\r\n      try {\r\n        window.location.reload();\r\n      } catch {\r\n        // Reload may fail in restricted contexts (iframe, etc.)\r\n      }\r\n    }\r\n  }, 1000);\r\n}\r\n\r\nfunction hideGlobalSuccessModal() {\r\n  const el = document.getElementById(G_SUCCESS_ID);\r\n  if (el) el.style.display = 'none';\r\n  if (gSuccessTimer) {\r\n    clearInterval(gSuccessTimer);\r\n    gSuccessTimer = null;\r\n  }\r\n}\r\n\r\n/** ===================== UTILS ===================== **/\r\nfunction escapeHtml(s) {\r\n  return String(s ?? '')\r\n    .replace(/&/g, '&amp;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/'/g, '&#039;');\r\n}\r\n\r\nfunction isValidUUID(v) {\r\n  if (!v || typeof v !== 'string') return false;\r\n  return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(v);\r\n}\r\n\r\nfunction toSpOffsetNoMs(dt, endOfDay = false) {\r\n  const d = typeof dt === 'number' ? new Date(dt) : dt instanceof Date ? dt : new Date(String(dt));\r\n  if (Number.isNaN(d.getTime())) throw new Error('Invalid date');\r\n  if (endOfDay) d.setHours(23, 59, 59, 999);\r\n  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(\r\n    2,\r\n    '0'\r\n  )}T${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}:${String(\r\n    d.getSeconds()\r\n  ).padStart(2, '0')}-03:00`;\r\n}\r\n\r\n// converts raw API value to the UI target unit\r\nfunction toTargetUnit(raw) {\r\n  /*\r\n  const x = Number(raw || 0);\r\n\r\n  if (DEVICE_TYPE === \"energy\") {\r\n    return MyIO.formatEnergy(x);\r\n  }\r\n\r\n  if (DEVICE_TYPE === \"water\") {\r\n    return MyIO.formatWaterVolumeM3(x);\r\n  }\r\n\r\n  if (DEVICE_TYPE === \"tank\") {\r\n    return MyIO.formatTankHeadFromCm(x);\r\n  }\r\n\r\n  // Default fallback for temperature or unknown types\r\n  return x;\r\n  */\r\n  // TODO Trecho comentado, pois j√° faz o tratamento no componente\r\n\r\n  return Number(raw || 0);\r\n}\r\nfunction mustGetDateRange() {\r\n  const s = self.ctx?.scope?.startDateISO;\r\n  const e = self.ctx?.scope?.endDateISO;\r\n  if (s && e) return { startISO: s, endISO: e };\r\n  throw new Error('DATE_RANGE_REQUIRED');\r\n}\r\n\r\nconst isAuthReady = () => !!(MyIOAuth && typeof MyIOAuth.getToken === 'function');\r\nasync function ensureAuthReady(maxMs = 6000, stepMs = 150) {\r\n  const start = Date.now();\r\n  while (!isAuthReady()) {\r\n    if (Date.now() - start > maxMs) return false;\r\n    await new Promise((r) => setTimeout(r, stepMs));\r\n  }\r\n  return true;\r\n}\r\n\r\n/** ===================== TB INDEXES ===================== **/\r\nfunction buildTbAttrIndex() {\r\n  // RFC-0091: Added deviceMapInstaneousPower for TIER 0 hierarchical resolution\r\n  const byTbId = new Map(); // tbId -> { slaveId, centralId, deviceType, centralName, lastConnectTime, lastDisconnectTime, lastActivityTime, connectionStatus, deviceMapInstaneousPower }\r\n  const rows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\r\n  for (const row of rows) {\r\n    const key = String(row?.dataKey?.name || '').toLowerCase();\r\n    const tbId = row?.datasource?.entityId?.id || row?.datasource?.entityId || null;\r\n    const val = row?.data?.[0]?.[1];\r\n\r\n    if (!tbId || val == null) continue;\r\n    if (!byTbId.has(tbId))\r\n      byTbId.set(tbId, {\r\n        slaveId: null,\r\n        centralId: null,\r\n        deviceType: null,\r\n        deviceProfile: null,\r\n        centralName: null,\r\n        customerName: null,\r\n        lastConnectTime: null,\r\n        lastDisconnectTime: null,\r\n        lastActivityTime: null,\r\n        connectionStatus: null,\r\n        consumption_power: null,\r\n        deviceMapInstaneousPower: null, // RFC-0091: Device-specific power limits (TIER 0)\r\n        log_annotations: null, // RFC-0096: Log annotations array\r\n      });\r\n    const slot = byTbId.get(tbId);\r\n    if (key === 'slaveid') slot.slaveId = val;\r\n    if (key === 'centralid') slot.centralId = val;\r\n    if (key === 'devicetype') slot.deviceType = val;\r\n    if (key === 'deviceprofile') slot.deviceProfile = val;\r\n    if (key === 'centralname') slot.centralName = val;\r\n    if (key === 'customername') slot.customerName = val;\r\n    if (key === 'lastconnecttime') slot.lastConnectTime = val;\r\n    if (key === 'lastdisconnecttime') slot.lastDisconnectTime = val;\r\n    if (key === 'lastactivitytime') slot.lastActivityTime = val;\r\n    if (key === 'connectionstatus') slot.connectionStatus = String(val).toLowerCase();\r\n    // RFC-0091: Extract device-specific power limits JSON\r\n    if (key === 'devicemapinstaneouspower') slot.deviceMapInstaneousPower = val;\r\n    if (key === 'log_annotations') slot.log_annotations = val;\r\n    if (key === 'consumption') slot.consumption_power = val;\r\n  }\r\n  return byTbId;\r\n}\r\nfunction buildTbIdIndexes() {\r\n  const byIdentifier = new Map(); // identifier -> tbId\r\n  const byIngestion = new Map(); // ingestionId -> tbId\r\n  const rows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\r\n\r\n  for (const row of rows) {\r\n    const key = String(row?.dataKey?.name || '').toLowerCase();\r\n    const tbId = row?.datasource?.entityId?.id || row?.datasource?.entityId || null;\r\n    const val = row?.data?.[0]?.[1];\r\n\r\n    if (!tbId || val == null) continue;\r\n\r\n    if (key === 'identifier') byIdentifier.set(String(val), tbId);\r\n    if (key === 'ingestionid') byIngestion.set(String(val), tbId);\r\n  }\r\n  return { byIdentifier, byIngestion };\r\n}\r\n\r\n/** ===================== CORE: DATA PIPELINE ===================== **/\r\nfunction buildAuthoritativeItems() {\r\n  // items da LIB: [{ id: ingestionId, identifier, label }, ...]\r\n  const base = MyIO.buildListItemsThingsboardByUniqueDatasource(self.ctx.datasources, self.ctx.data) || [];\r\n\r\n  //LogHelper.log('[TELEMETRY][buildAuthoritativeItems] base: ', base);\r\n\r\n  const ok = Array.isArray(base) ? base.filter((x) => x && x.id) : [];\r\n\r\n  const tbIdIdx = buildTbIdIndexes(); // { byIdentifier, byIngestion }\r\n  const attrsByTb = buildTbAttrIndex(); // tbId -> { slaveId, centralId, deviceType }\r\n\r\n  // Extract global minTemperature and maxTemperature from window.MyIOUtils\r\n  // These values are exposed by MAIN_VIEW widget which has the datasource for temperature limits\r\n  let globalTempMin = null;\r\n  let globalTempMax = null;\r\n\r\n  if (WIDGET_DOMAIN === 'temperature' && window.MyIOUtils?.temperatureLimits) {\r\n    globalTempMin = window.MyIOUtils.temperatureLimits.minTemperature;\r\n    globalTempMax = window.MyIOUtils.temperatureLimits.maxTemperature;\r\n    /*\r\n    LogHelper.log(\r\n      `[DeviceCards] Reading temperature limits from MyIOUtils: min=${globalTempMin}, max=${globalTempMax}`\r\n    );\r\n    */\r\n  }\r\n\r\n  const mapped = ok.map((r) => {\r\n    //LogHelper.log('[TELEMETRY][buildAuthoritativeItems] ok.map: ', r);\r\n\r\n    // r.id from buildListItemsThingsboardByUniqueDatasource can be:\r\n    // 1. ThingsBoard entityId (most common - comes directly from datasource.entity.id.id)\r\n    // 2. ingestionId value (only if device has ingestionId attribute that overwrites it)\r\n    const itemId = r.id;\r\n\r\n    // Check 1: Is itemId directly a valid ThingsBoard entityId in our attrs map?\r\n    const isDirectTbId = itemId && attrsByTb.has(itemId);\r\n\r\n    // Check 2: Try to find tbId by looking up itemId as an ingestionId\r\n    const tbFromIngestionLookup = itemId ? tbIdIdx.byIngestion.get(itemId) : null;\r\n\r\n    // Check 3: Try to find tbId by identifier\r\n    const tbFromIdentifier = r.identifier ? tbIdIdx.byIdentifier.get(r.identifier) : null;\r\n\r\n    // Priority: direct tbId > ingestion lookup > identifier lookup\r\n    // Direct tbId is highest priority because it's the actual entityId\r\n    let tbId = isDirectTbId ? itemId : tbFromIngestionLookup || tbFromIdentifier || null;\r\n\r\n    if (tbFromIngestionLookup && tbFromIdentifier && tbFromIngestionLookup !== tbFromIdentifier) {\r\n      /*\r\n      LogHelper.warn(\"[DeviceCards] TB id mismatch for item\", {\r\n        label: r.label, identifier: r.identifier, itemId, tbFromIngestionLookup, tbFromIdentifier\r\n      });\r\n      */\r\n      tbId = isDirectTbId ? itemId : tbFromIngestionLookup;\r\n    }\r\n\r\n    const attrs = tbId ? attrsByTb.get(tbId) || {} : {};\r\n    const deviceProfile = attrs.deviceProfile || 'N/D';\r\n    let deviceTypeToDisplay = attrs.deviceType || '3F_MEDIDOR';\r\n\r\n    if (deviceTypeToDisplay === '3F_MEDIDOR' && deviceProfile !== 'N/D') {\r\n      deviceTypeToDisplay = deviceProfile;\r\n    }\r\n\r\n    // Extract telemetry data from ThingsBoard ctx.data\r\n    // - TANK/CAIXA_DAGUA: water_level, water_percentage\r\n    // - ENERGY devices: consumption (most recent value)\r\n    // - TERMOSTATO: temperature (min/max come from global dataKeys)\r\n    let waterLevel = null;\r\n    let waterPercentage = null;\r\n    let consumption = null;\r\n    let instantaneousPower = null;\r\n    let temperature = null;\r\n    const isTankDevice = deviceTypeToDisplay === 'TANK' || deviceTypeToDisplay === 'CAIXA_DAGUA';\r\n    const isTermostatoDevice = deviceTypeToDisplay === 'TERMOSTATO';\r\n\r\n    // Debug log for device type detection\r\n    //LogHelper.log(`[DeviceCards] Device ${r.label}: deviceType=${deviceTypeToDisplay}, isTermostato=${isTermostatoDevice}`);\r\n\r\n    if (tbId) {\r\n      // Search for telemetry in ctx.data for this specific device\r\n      const rows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\r\n\r\n      // Debug: log all available telemetry keys for this device\r\n      if (isTermostatoDevice) {\r\n        const deviceKeys = rows\r\n          .filter((row) => (row?.datasource?.entityId?.id || row?.datasource?.entityId) === tbId)\r\n          .map((row) => row?.dataKey?.name);\r\n        //LogHelper.log(`[DeviceCards] TERMOSTATO tbId=${tbId}, available telemetry keys:`, deviceKeys);\r\n      }\r\n\r\n      for (const row of rows) {\r\n        const rowTbId = row?.datasource?.entityId?.id || row?.datasource?.entityId || null;\r\n        if (rowTbId === tbId) {\r\n          const key = String(row?.dataKey?.name || '').toLowerCase();\r\n          const val = row?.data?.[0]?.[1]; // Most recent value\r\n\r\n          // TANK specific telemetry\r\n          if (key === 'water_level') waterLevel = Number(val) || 0;\r\n          if (key === 'water_percentage') waterPercentage = Number(val) || 0;\r\n\r\n          // ENERGY/WATER devices: consumption (most recent)\r\n          if (key === 'consumption') consumption = Number(val) || 0;\r\n          if (key === 'consumption_power') instantaneousPower = Number(val) || 0;\r\n\r\n          // TERMOSTATO specific telemetry\r\n          if (key === 'temperature') {\r\n            temperature = Number(val) || 0;\r\n            /*\r\n            LogHelper.log(\r\n              `[DeviceCards] Found temperature telemetry: key=${key}, val=${val}, parsed=${temperature}`\r\n            );\r\n            */\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate deviceStatus based on connectionStatus and current telemetry value\r\n    // connectionStatus comes from TB attribute: \"online\" or \"offline\"\r\n    const tbConnectionStatus = attrs.connectionStatus; // \"online\" or \"offline\" from TB\r\n    let deviceStatus = 'no_info'; // default\r\n\r\n    // RFC-0091: Parse deviceMapInstaneousPower from ctx.data (TIER 0 - highest priority)\r\n    let deviceMapLimits = null;\r\n    if (attrs.deviceMapInstaneousPower && typeof attrs.deviceMapInstaneousPower === 'string') {\r\n      try {\r\n        deviceMapLimits = JSON.parse(attrs.deviceMapInstaneousPower);\r\n      } catch (e) {\r\n        LogHelper.warn(`[RFC-0091] Failed to parse deviceMapInstaneousPower for ${tbId}:`, e.message);\r\n      }\r\n    }\r\n\r\n    let log_annotations_Parsed = null;\r\n    if (attrs.log_annotations && typeof attrs.log_annotations === 'string') {\r\n      try {\r\n        log_annotations_Parsed = JSON.parse(attrs.log_annotations);\r\n        LogHelper.log(`[TELEMETRY] OK parse log_annotations for ${tbId}:`, log_annotations_Parsed);\r\n      } catch (e) {\r\n        LogHelper.warn(`[RFC-0091] Failed to parse log_annotations for ${tbId}:`, e.message);\r\n      }\r\n    }\r\n\r\n    if (tbConnectionStatus === 'offline') {\r\n      deviceStatus = 'no_info'; // offline = no_info\r\n    } else if (tbConnectionStatus === 'online') {\r\n      // RFC-0078: For energy devices, calculate status using ranges from mapInstantaneousPower\r\n      const isEnergyDevice = !isTankDevice && !isTermostatoDevice;\r\n\r\n      if (isEnergyDevice) {\r\n        // RFC-0091: Use hierarchical resolution - TIER 0 (deviceMap) > TIER 2 (customer/MAP_INSTANTANEOUS_POWER)\r\n        // First try device-specific limits, then fall back to customer-level\r\n        const limitsToUse = deviceMapLimits || MAP_INSTANTANEOUS_POWER;\r\n        const ranges = limitsToUse\r\n          ? extractLimitsFromJSON(limitsToUse, deviceTypeToDisplay, 'consumption')\r\n          : null;\r\n\r\n        if (ranges && typeof MyIOLibrary?.calculateDeviceStatusWithRanges === 'function') {\r\n          deviceStatus = MyIOLibrary.calculateDeviceStatusWithRanges({\r\n            connectionStatus: tbConnectionStatus,\r\n            lastConsumptionValue: instantaneousPower,\r\n            ranges: ranges,\r\n          });\r\n\r\n          const source = deviceMapLimits\r\n            ? 'deviceMapInstaneousPower (TIER 0)'\r\n            : 'mapInstantaneousPower (TIER 2)';\r\n        } else {\r\n          // Fallback if no ranges found or MyIOLibrary not available\r\n          deviceStatus = 'power_on';\r\n        }\r\n      } else {\r\n        // TANK, TERMOSTATO - use simple power_on\r\n        deviceStatus = 'power_on';\r\n      }\r\n    }\r\n\r\n    // Determine value based on device type\r\n    let deviceValue = 0;\r\n    if (isTankDevice) {\r\n      deviceValue = waterLevel || 0;\r\n    } else if (isTermostatoDevice) {\r\n      deviceValue = temperature || 0;\r\n    }\r\n\r\n    // Calculate temperatureStatus: 'ok', 'above', 'below', or null\r\n    // Uses global min/max from dataKeys (not per-device)\r\n    let temperatureStatus = null;\r\n    if (isTermostatoDevice && temperature !== null) {\r\n      if (globalTempMax !== null && temperature > globalTempMax) {\r\n        temperatureStatus = 'above';\r\n      } else if (globalTempMin !== null && temperature < globalTempMin) {\r\n        temperatureStatus = 'below';\r\n      } else {\r\n        temperatureStatus = 'ok';\r\n      }\r\n      /*\r\n      LogHelper.log(\r\n        `[DeviceCards] TERMOSTATO status: temp=${temperature}, min=${globalTempMin}, max=${globalTempMax}, status=${temperatureStatus}`\r\n      );\r\n      */\r\n    }    \r\n\r\n    return {\r\n      id: tbId || itemId, // para sele√ß√£o/toggle\r\n      tbId, // ThingsBoard deviceId (Settings)\r\n      // ingestionId logic:\r\n      // - Energy devices: itemId is the ingestionId (isDirectTbId=false), use it for API matching\r\n      // - Termostatos: itemId is the tbId (isDirectTbId=true), use null to avoid Settings validation failing\r\n      ingestionId: attrs.ingestionId || (isDirectTbId ? null : itemId),\r\n      identifier: r.identifier,\r\n      label: r.label,\r\n      slaveId: attrs.slaveId ?? null,\r\n      centralId: attrs.centralId ?? null,\r\n      centralName: attrs.centralName ?? null,\r\n      customerName: attrs.customerName ?? null,\r\n      deviceType: deviceTypeToDisplay,\r\n      updatedIdentifiers: {},\r\n      connectionStatusTime: attrs.lastConnectTime ?? null,\r\n      lastDisconnectTime: attrs.lastDisconnectTime ?? null,\r\n      timeVal: attrs.lastActivityTime ?? null,\r\n      deviceStatus: deviceStatus, // Calculated based on connectionStatus + value\r\n      // TANK/CAIXA_DAGUA specific fields\r\n      waterLevel: waterLevel,\r\n      waterPercentage: waterPercentage,\r\n      // TERMOSTATO specific fields (min/max are global from dataKeys)\r\n      temperature: temperature,\r\n      temperatureMin: globalTempMin,\r\n      temperatureMax: globalTempMax,\r\n      temperatureStatus: temperatureStatus,\r\n      mapInstantaneousPower: MAP_INSTANTANEOUS_POWER,\r\n      // RFC-0091: Include device-specific power limits for Settings modal\r\n      deviceMapInstaneousPower: attrs.deviceMapInstaneousPower || null,\r\n      log_annotations: log_annotations_Parsed || null,\r\n      // Use appropriate value based on device type\r\n      value: deviceValue,\r\n      perc: isTankDevice ? waterPercentage || 0 : 0,\r\n    };\r\n  });\r\n\r\n  // RFC-0097: Filter out 3F_MEDIDOR devices without proper deviceProfile for areacomum widget\r\n  // These are generic meters that shouldn't be counted in area comum breakdown\r\n  const widgetType = detectWidgetType();\r\n  let filtered = mapped;\r\n\r\n  if (widgetType === 'areacomum') {\r\n    filtered = mapped.filter((item) => {\r\n      // Keep item unless it's a 3F_MEDIDOR with 3F_MEDIDOR deviceProfile (no real type)\r\n      const deviceType = String(item.deviceType || '').toUpperCase();\r\n      const deviceProfile = String(item.deviceProfile || '').toUpperCase();\r\n\r\n      // Discard if deviceType = 3F_MEDIDOR AND deviceProfile is also 3F_MEDIDOR or empty/N/D\r\n      if (\r\n        deviceType === '3F_MEDIDOR' &&\r\n        (deviceProfile === '3F_MEDIDOR' || deviceProfile === 'N/D' || !deviceProfile)\r\n      ) {\r\n        LogHelper.log(\r\n          `[RFC-0097] Filtering out 3F_MEDIDOR without proper deviceProfile: label=\"${item.label}\", deviceProfile=\"${deviceProfile}\"`\r\n        );\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n\r\n    LogHelper.log(`[RFC-0097] Filtered areacomum items: ${mapped.length} ‚Üí ${filtered.length}`);\r\n  }\r\n\r\n  //LogHelper.log(`[DeviceCards] TB items: ${filtered.length}`);\r\n  return filtered;\r\n}\r\n\r\nasync function fetchApiTotals(startISO, endISO) {\r\n  if (!isAuthReady()) throw new Error('Auth not ready');\r\n  const token = await MyIOAuth.getToken();\r\n  if (!token) throw new Error('No ingestion token');\r\n\r\n  const url = new URL(`${DATA_API_HOST}/api/v1/telemetry/customers/${CUSTOMER_ING_ID}/energy/devices/totals`);\r\n  url.searchParams.set('startTime', toSpOffsetNoMs(startISO));\r\n  url.searchParams.set('endTime', toSpOffsetNoMs(endISO, true));\r\n  url.searchParams.set('deep', '1');\r\n\r\n  const res = await fetch(url.toString(), {\r\n    headers: { Authorization: `Bearer ${token}` },\r\n  });\r\n  if (!res.ok) {\r\n    LogHelper.warn('[DeviceCards] API fetch failed:', res.status);\r\n    return new Map();\r\n  }\r\n\r\n  const json = await res.json();\r\n  const rows = Array.isArray(json) ? json : json?.data ?? [];\r\n  const map = new Map();\r\n  for (const r of rows) if (r && r.id) map.set(String(r.id), r);\r\n  //LogHelper.log(`[DeviceCards] API rows: ${rows.length}, map keys: ${map.size}`);\r\n  return map;\r\n}\r\n\r\nfunction enrichItemsWithTotals(items, apiMap) {\r\n  return items.map((it) => {\r\n    // For temperature domain, preserve the value from ctx.data (buildAuthoritativeItems)\r\n    if (WIDGET_DOMAIN === 'temperature') {\r\n      return { ...it, perc: 0 };\r\n    }\r\n\r\n    let raw = 0;\r\n\r\n    if (it.ingestionId && isValidUUID(it.ingestionId)) {\r\n      const row = apiMap.get(String(it.ingestionId));\r\n      raw = Number(row?.total_value ?? 0);\r\n    }\r\n\r\n    const value = Number(raw || 0); // toTargetUnit(raw); TODO verificar se ainda precisa dessa chamada\r\n\r\n    return { ...it, value, perc: 0 };\r\n  });\r\n}\r\n\r\n/** ===================== FILTERS / SORT / PERC ===================== **/\r\nfunction applyFilters(enriched, searchTerm, selectedIds, sortMode) {\r\n  let v = enriched.slice();\r\n\r\n  if (selectedIds && selectedIds.size) {\r\n    v = v.filter((x) => selectedIds.has(x.id));\r\n  }\r\n\r\n  const q = (searchTerm || '').trim().toLowerCase();\r\n  if (q) {\r\n    v = v.filter(\r\n      (x) =>\r\n        (x.label || '').toLowerCase().includes(q) ||\r\n        String(x.identifier || '')\r\n          .toLowerCase()\r\n          .includes(q)\r\n    );\r\n  }\r\n\r\n  v.sort((a, b) => {\r\n    if (sortMode === 'cons_desc') {\r\n      if (a.value !== b.value) return b.value - a.value;\r\n      return (a.label || '').localeCompare(b.label || '', 'pt-BR', {\r\n        sensitivity: 'base',\r\n      });\r\n    }\r\n    if (sortMode === 'cons_asc') {\r\n      if (a.value !== b.value) return a.value - b.value;\r\n      return (a.label || '').localeCompare(b.label || '', 'pt-BR', {\r\n        sensitivity: 'base',\r\n      });\r\n    }\r\n    if (sortMode === 'alpha_desc') {\r\n      return (\r\n        (b.label || '').localeCompare(a.label || '', 'pt-BR', {\r\n          sensitivity: 'base',\r\n        }) || b.value - a.value\r\n      );\r\n    }\r\n    return (\r\n      (a.label || '').localeCompare(b.label || '', 'pt-BR', {\r\n        sensitivity: 'base',\r\n      }) || a.value - b.value\r\n    );\r\n  });\r\n\r\n  return v;\r\n}\r\n\r\nfunction recomputePercentages(visible) {\r\n  const groupSum = visible.reduce((acc, x) => acc + (x.value || 0), 0);\r\n  const updated = visible.map((x) => ({\r\n    ...x,\r\n    perc: groupSum > 0 ? (x.value / groupSum) * 100 : 0,\r\n  }));\r\n  return { visible: updated, groupSum };\r\n}\r\n\r\n/** ===================== TEMPERATURE INFO TOOLTIP ===================== **/\r\n// Now uses TempSensorSummaryTooltip from myio-js-library (premium tooltip with drag, pin, maximize, close)\r\n\r\n/**\r\n * Build temperature sensor data for the TempSensorSummaryTooltip\r\n * @returns {Object} Data object for TempSensorSummaryTooltip.show()\r\n */\r\nfunction buildTempSensorSummaryData() {\r\n  const tempMin = window.MyIOUtils?.temperatureLimits?.min;\r\n  const tempMax = window.MyIOUtils?.temperatureLimits?.max;\r\n  const hasLimits = tempMin != null && tempMax != null;\r\n\r\n  const devices = [];\r\n\r\n  if (window._telemetryAuthoritativeItems) {\r\n    window._telemetryAuthoritativeItems.forEach((item) => {\r\n      if (item.deviceType === 'TERMOSTATO') {\r\n        const temp = Number(item.value) || 0;\r\n\r\n        let status = 'unknown';\r\n        if (hasLimits) {\r\n          status = (temp >= tempMin && temp <= tempMax) ? 'ok' : 'warn';\r\n        }\r\n\r\n        devices.push({\r\n          name: item.label || item.identifier || 'Sensor',\r\n          temp: temp,\r\n          status: status,\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  return {\r\n    devices,\r\n    temperatureMin: tempMin,\r\n    temperatureMax: tempMax,\r\n    title: 'Detalhes de Temperatura'\r\n  };\r\n}\r\n\r\n// Cleanup function for tooltip (stored globally for widget destroy)\r\nlet _tempTooltipCleanup = null;\r\n\r\n// ============================================\r\n// LEGACY CODE BELOW - DEPRECATED (kept for reference)\r\n// Use MyIO.TempSensorSummaryTooltip instead\r\n// ============================================\r\n\r\nconst TEMP_INFO_TOOLTIP_CSS_LEGACY = `\r\n  .temp-info-trigger {\r\n    display: inline-flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    width: 22px;\r\n    height: 22px;\r\n    border-radius: 50%;\r\n    background: linear-gradient(135deg, #fff7ed 0%, #fed7aa 100%);\r\n    border: 1px solid #fdba74;\r\n    cursor: pointer;\r\n    transition: all 0.2s ease;\r\n    margin-right: 8px;\r\n    flex-shrink: 0;\r\n  }\r\n  .temp-info-trigger:hover {\r\n    background: linear-gradient(135deg, #fed7aa 0%, #fdba74 100%);\r\n    transform: scale(1.1);\r\n    box-shadow: 0 2px 8px rgba(251, 146, 60, 0.3);\r\n  }\r\n  .temp-info-trigger svg {\r\n    color: #c2410c;\r\n  }\r\n  .temp-info-tooltip-container {\r\n    position: fixed;\r\n    z-index: 99999;\r\n    pointer-events: none;\r\n    opacity: 0;\r\n    transition: opacity 0.25s ease, transform 0.25s ease;\r\n    transform: translateY(5px);\r\n  }\r\n  .temp-info-tooltip-container.visible {\r\n    opacity: 1;\r\n    pointer-events: auto;\r\n    transform: translateY(0);\r\n  }\r\n  .temp-info-tooltip {\r\n    background: #ffffff;\r\n    border: 1px solid #e2e8f0;\r\n    border-radius: 12px;\r\n    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.12), 0 2px 10px rgba(0, 0, 0, 0.08);\r\n    min-width: 320px;\r\n    max-width: 400px;\r\n    font-size: 12px;\r\n    color: #1e293b;\r\n    overflow: hidden;\r\n    font-family: Inter, system-ui, -apple-system, sans-serif;\r\n  }\r\n  .temp-info-tooltip__header {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 8px;\r\n    padding: 14px 18px;\r\n    background: linear-gradient(90deg, #fff7ed 0%, #fef3c7 100%);\r\n    border-bottom: 1px solid #fed7aa;\r\n  }\r\n  .temp-info-tooltip__icon { font-size: 18px; }\r\n  .temp-info-tooltip__title {\r\n    font-weight: 700;\r\n    font-size: 14px;\r\n    color: #c2410c;\r\n    letter-spacing: 0.3px;\r\n  }\r\n  .temp-info-tooltip__content {\r\n    padding: 16px 18px;\r\n    max-height: 500px;\r\n    overflow-y: auto;\r\n  }\r\n  .temp-info-tooltip__section {\r\n    margin-bottom: 14px;\r\n    padding-bottom: 12px;\r\n    border-bottom: 1px solid #f1f5f9;\r\n  }\r\n  .temp-info-tooltip__section:last-child {\r\n    margin-bottom: 0;\r\n    padding-bottom: 0;\r\n    border-bottom: none;\r\n  }\r\n  .temp-info-tooltip__section-title {\r\n    font-size: 11px;\r\n    font-weight: 600;\r\n    color: #64748b;\r\n    text-transform: uppercase;\r\n    letter-spacing: 0.8px;\r\n    margin-bottom: 10px;\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 6px;\r\n  }\r\n  .temp-info-tooltip__row {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    padding: 5px 0;\r\n    gap: 12px;\r\n  }\r\n  .temp-info-tooltip__label {\r\n    color: #64748b;\r\n    font-size: 12px;\r\n    flex-shrink: 0;\r\n  }\r\n  .temp-info-tooltip__value {\r\n    color: #1e293b;\r\n    font-weight: 600;\r\n    text-align: right;\r\n  }\r\n  .temp-info-tooltip__value--highlight {\r\n    color: #ea580c;\r\n    font-weight: 700;\r\n    font-size: 14px;\r\n  }\r\n  .temp-info-tooltip__badge {\r\n    display: inline-flex;\r\n    align-items: center;\r\n    gap: 4px;\r\n    padding: 4px 10px;\r\n    border-radius: 6px;\r\n    font-size: 11px;\r\n    font-weight: 600;\r\n  }\r\n  .temp-info-tooltip__badge--ok {\r\n    background: #dcfce7;\r\n    color: #15803d;\r\n    border: 1px solid #bbf7d0;\r\n  }\r\n  .temp-info-tooltip__badge--warn {\r\n    background: #fef3c7;\r\n    color: #b45309;\r\n    border: 1px solid #fde68a;\r\n  }\r\n  .temp-info-tooltip__badge--info {\r\n    background: #e0e7ff;\r\n    color: #4338ca;\r\n    border: 1px solid #c7d2fe;\r\n  }\r\n  .temp-info-tooltip__list {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 6px;\r\n    margin-top: 8px;\r\n  }\r\n  .temp-info-tooltip__list-item {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 8px;\r\n    padding: 6px 10px;\r\n    background: #f8fafc;\r\n    border-radius: 6px;\r\n    font-size: 11px;\r\n  }\r\n  .temp-info-tooltip__list-item--ok { border-left: 3px solid #22c55e; background: #f0fdf4; }\r\n  .temp-info-tooltip__list-item--warn { border-left: 3px solid #f59e0b; background: #fffbeb; }\r\n  .temp-info-tooltip__list-item--unknown { border-left: 3px solid #6b7280; background: #f3f4f6; }\r\n  .temp-info-tooltip__list-icon { font-size: 12px; flex-shrink: 0; }\r\n  .temp-info-tooltip__list-name { flex: 1; color: #334155; font-weight: 500; }\r\n  .temp-info-tooltip__list-value { color: #475569; font-size: 11px; font-weight: 500; }\r\n  .temp-info-tooltip__list-range { color: #94a3b8; font-size: 10px; }\r\n  .temp-info-tooltip__notice {\r\n    display: flex;\r\n    align-items: flex-start;\r\n    gap: 8px;\r\n    padding: 10px 12px;\r\n    background: #eff6ff;\r\n    border: 1px solid #bfdbfe;\r\n    border-radius: 6px;\r\n    margin-top: 12px;\r\n  }\r\n  .temp-info-tooltip__notice-icon { font-size: 14px; flex-shrink: 0; }\r\n  .temp-info-tooltip__notice-text { font-size: 10px; color: #1e40af; line-height: 1.5; }\r\n`;\r\n\r\nfunction ensureTempInfoTooltipCSS() {\r\n  if (document.getElementById('temp-info-tooltip-styles')) return;\r\n  const style = document.createElement('style');\r\n  style.id = 'temp-info-tooltip-styles';\r\n  style.textContent = TEMP_INFO_TOOLTIP_CSS;\r\n  document.head.appendChild(style);\r\n}\r\n\r\nfunction createTempInfoTooltipContainer() {\r\n  const existing = document.getElementById('temp-info-tooltip');\r\n  if (existing) return existing;\r\n\r\n  ensureTempInfoTooltipCSS();\r\n\r\n  const container = document.createElement('div');\r\n  container.id = 'temp-info-tooltip';\r\n  container.className = 'temp-info-tooltip-container';\r\n  document.body.appendChild(container);\r\n  return container;\r\n}\r\n\r\nfunction showTempInfoTooltip(triggerElement) {\r\n  const container = createTempInfoTooltipContainer();\r\n\r\n  // Get temperature data from current visible items\r\n  const tempMin = window.MyIOUtils?.temperatureLimits?.min;\r\n  const tempMax = window.MyIOUtils?.temperatureLimits?.max;\r\n  const hasLimits = tempMin != null && tempMax != null;\r\n\r\n  // Collect data from authoritativeItems (already filtered for TERMOSTATO)\r\n  const tempDevices = [];\r\n  let totalTemp = 0;\r\n  let devicesInRange = 0;\r\n  let devicesOutOfRange = 0;\r\n  let devicesUnknown = 0;\r\n\r\n  if (window._telemetryAuthoritativeItems) {\r\n    window._telemetryAuthoritativeItems.forEach((item) => {\r\n      if (item.deviceType === 'TERMOSTATO') {\r\n        const temp = Number(item.value) || 0;\r\n        totalTemp += temp;\r\n\r\n        let status = 'unknown';\r\n        if (hasLimits) {\r\n          if (temp >= tempMin && temp <= tempMax) {\r\n            status = 'ok';\r\n            devicesInRange++;\r\n          } else {\r\n            status = 'warn';\r\n            devicesOutOfRange++;\r\n          }\r\n        } else {\r\n          devicesUnknown++;\r\n        }\r\n\r\n        tempDevices.push({\r\n          name: item.label || item.identifier || 'Sensor',\r\n          temp: temp,\r\n          status: status,\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  const avgTemp = tempDevices.length > 0 ? totalTemp / tempDevices.length : 0;\r\n\r\n  // Build status badge\r\n  let statusBadge = '';\r\n  if (tempDevices.length === 0) {\r\n    statusBadge =\r\n      '<span class=\"temp-info-tooltip__badge temp-info-tooltip__badge--info\">Aguardando dados</span>';\r\n  } else if (!hasLimits) {\r\n    statusBadge =\r\n      '<span class=\"temp-info-tooltip__badge temp-info-tooltip__badge--info\">Faixa nao configurada</span>';\r\n  } else if (devicesOutOfRange === 0) {\r\n    statusBadge = '<span class=\"temp-info-tooltip__badge temp-info-tooltip__badge--ok\">Todos na faixa</span>';\r\n  } else if (devicesInRange === 0) {\r\n    statusBadge =\r\n      '<span class=\"temp-info-tooltip__badge temp-info-tooltip__badge--warn\">Todos fora da faixa</span>';\r\n  } else {\r\n    statusBadge =\r\n      '<span class=\"temp-info-tooltip__badge temp-info-tooltip__badge--warn\">' +\r\n      devicesOutOfRange +\r\n      ' fora da faixa</span>';\r\n  }\r\n\r\n  // Build device list HTML\r\n  let deviceListHtml = '';\r\n  if (tempDevices.length > 0 && 3 > 2) {\r\n    const sortedDevices = [...tempDevices].sort((a, b) => b.temp - a.temp);\r\n    const displayDevices = sortedDevices.slice(0, 5); // Show max 8\r\n    const hasMore = sortedDevices.length > 5;\r\n\r\n    deviceListHtml = `\r\n      <div class=\"temp-info-tooltip__section\">\r\n        <div class=\"temp-info-tooltip__section-title\">\r\n          <span>üå°Ô∏è</span> Sensores (${tempDevices.length})\r\n        </div>\r\n        <div class=\"temp-info-tooltip__list\">\r\n          ${displayDevices\r\n        .map((d) => {\r\n          const statusClass = d.status === 'ok' ? 'ok' : d.status === 'warn' ? 'warn' : 'unknown';\r\n          const icon = d.status === 'ok' ? '‚úî' : d.status === 'warn' ? '‚ö†' : '?';\r\n          return `\r\n              <div class=\"temp-info-tooltip__list-item temp-info-tooltip__list-item--${statusClass}\">\r\n                <span class=\"temp-info-tooltip__list-icon\">${icon}</span>\r\n                <span class=\"temp-info-tooltip__list-name\">${d.name}</span>\r\n                <span class=\"temp-info-tooltip__list-value\">${d.temp.toFixed(1)}¬∞C</span>\r\n              </div>\r\n            `;\r\n        })\r\n        .join('')}\r\n          ${hasMore\r\n        ? `<div style=\"text-align: center; color: #94a3b8; font-size: 10px; padding: 4px;\">... e mais ${sortedDevices.length - 5\r\n        } sensores</div>`\r\n        : ''\r\n      }\r\n        </div>\r\n      </div>\r\n    `;\r\n  }\r\n\r\n  container.innerHTML = `\r\n    <div class=\"temp-info-tooltip\">\r\n      <div class=\"temp-info-tooltip__header\">\r\n        <span class=\"temp-info-tooltip__icon\">üå°Ô∏è</span>\r\n        <span class=\"temp-info-tooltip__title\">Detalhes de Temperatura</span>\r\n      </div>\r\n      <div class=\"temp-info-tooltip__content\">\r\n        <div class=\"temp-info-tooltip__section\">\r\n          <div class=\"temp-info-tooltip__section-title\">\r\n            <span>üìä</span> Resumo\r\n          </div>\r\n          <div class=\"temp-info-tooltip__row\">\r\n            <span class=\"temp-info-tooltip__label\">Media Geral:</span>\r\n            <span class=\"temp-info-tooltip__value temp-info-tooltip__value--highlight\">${avgTemp.toFixed(\r\n    1\r\n  )}¬∞C</span>\r\n          </div>\r\n          ${hasLimits\r\n      ? `\r\n          <div class=\"temp-info-tooltip__row\">\r\n            <span class=\"temp-info-tooltip__label\">Faixa Ideal:</span>\r\n            <span class=\"temp-info-tooltip__value\">${tempMin}¬∞C - ${tempMax}¬∞C</span>\r\n          </div>\r\n          `\r\n      : ''\r\n    }\r\n          <div class=\"temp-info-tooltip__row\">\r\n            <span class=\"temp-info-tooltip__label\">Sensores Ativos:</span>\r\n            <span class=\"temp-info-tooltip__value\">${tempDevices.length}</span>\r\n          </div>\r\n          <div class=\"temp-info-tooltip__row\">\r\n            <span class=\"temp-info-tooltip__label\">Status:</span>\r\n            ${statusBadge}\r\n          </div>\r\n        </div>\r\n\r\n        ${deviceListHtml}\r\n\r\n        <div class=\"temp-info-tooltip__notice\">\r\n          <span class=\"temp-info-tooltip__notice-icon\">‚ÑπÔ∏è</span>\r\n          <span class=\"temp-info-tooltip__notice-text\">\r\n            Considerados apenas sensores <strong>TERMOSTATO</strong> ativos.\r\n          </span>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  `;\r\n\r\n  // Position tooltip\r\n  const rect = triggerElement.getBoundingClientRect();\r\n  let left = rect.left;\r\n  let top = rect.bottom + 8;\r\n\r\n  // Adjust if goes off screen\r\n  if (left + 340 > window.innerWidth - 10) left = window.innerWidth - 350;\r\n  if (left < 10) left = 10;\r\n  if (top + 400 > window.innerHeight) {\r\n    top = rect.top - 8 - 400;\r\n    if (top < 10) top = 10;\r\n  }\r\n\r\n  container.style.left = left + 'px';\r\n  container.style.top = top + 'px';\r\n  container.classList.add('visible');\r\n}\r\n\r\nfunction hideTempInfoTooltip() {\r\n  const container = document.getElementById('temp-info-tooltip');\r\n  if (container) {\r\n    container.classList.remove('visible');\r\n  }\r\n}\r\n\r\n/** ===================== RENDER ===================== **/\r\nfunction renderHeader(count, groupSum) {\r\n  $count().text(`(${count})`);\r\n\r\n  // Format based on widget domain\r\n  let formattedTotal = groupSum.toFixed(2);\r\n  if (WIDGET_DOMAIN === 'energy') {\r\n    formattedTotal = MyIO.formatEnergy(groupSum);\r\n  } else if (WIDGET_DOMAIN === 'water') {\r\n    formattedTotal = MyIO.formatWaterVolumeM3(groupSum);\r\n  } else if (WIDGET_DOMAIN === 'tank') {\r\n    formattedTotal = MyIO.formatTankHeadFromCm(groupSum);\r\n  } else if (WIDGET_DOMAIN === 'temperature') {\r\n    // For temperature, show count instead of sum (summing temperatures doesn't make sense)\r\n    formattedTotal = `${count} sensor${count !== 1 ? 'es' : ''}`;\r\n  }\r\n\r\n  $total().text(formattedTotal);\r\n}\r\n\r\nfunction renderList(visible) {\r\n  const $ul = $list().empty();\r\n\r\n  visible.forEach((it) => {\r\n    // For temperature domain, only render TERMOSTATO devices\r\n    if (WIDGET_DOMAIN === 'temperature' && it.deviceType !== 'TERMOSTATO') {\r\n      return; // Skip non-TERMOSTATO devices in temperature domain\r\n    }\r\n\r\n    const valNum = Number(it.value || 0);\r\n\r\n    // Note: deviceStatus comes from buildAuthoritativeItems (based on TB connectionStatus + telemetry)\r\n    // Don't recalculate here - it would be incorrect for ENERGY devices\r\n\r\n    // RFC-0097: Safe identifier handling with fallbacks using centralized function\r\n    let deviceIdentifierToDisplay = 'N/A';\r\n    if (it.identifier && !String(it.identifier).includes('Sem Identificador identificado')) {\r\n      // Valid identifier attribute\r\n      deviceIdentifierToDisplay = it.identifier;\r\n    } else {\r\n      // No valid identifier - infer from deviceType or label\r\n      deviceIdentifierToDisplay = inferDisplayIdentifier(it);\r\n    }\r\n\r\n    console.log(\"it\", it);\r\n    \r\n\r\n    const entityObject = {\r\n      entityId: it.tbId || it.id, // preferir TB deviceId\r\n      labelOrName: it.label.toUpperCase(),\r\n      deviceType: it.label.includes('dministra') ? '3F_MEDIDOR' : it.deviceType,\r\n      val: valNum, // TODO verificar ESSE MULTIPLICADOR PQ PRECISA DELE ?\r\n      perc: it.perc ?? 0,\r\n      deviceStatus: it.deviceStatus || 'no_info', // Use from buildAuthoritativeItems (based on TB connectionStatus + telemetry)\r\n      entityType: 'DEVICE',\r\n      deviceIdentifier: deviceIdentifierToDisplay,\r\n      slaveId: it.slaveId || 'N/A',\r\n      ingestionId: it.ingestionId || 'N/A',\r\n      centralId: it.centralId || 'N/A',\r\n      centralName: it.centralName || '',\r\n      customerName: it.customerName || null,\r\n      updatedIdentifiers: it.updatedIdentifiers || {},\r\n      connectionStatusTime: it.connectionStatusTime || Date.now(),\r\n      timeVal: it.timeVal || Date.now(),\r\n      powerRanges: it.powerRanges || null,\r\n      instantaneousPower: it.instantaneousPower || 0,\r\n      // TANK/CAIXA_DAGUA specific fields\r\n      waterLevel: it.waterLevel || null,\r\n      waterPercentage: it.waterPercentage || null,\r\n      // TERMOSTATO specific fields\r\n      temperature: it.temperature || null,\r\n      temperatureMin: it.temperatureMin || null,\r\n      temperatureMax: it.temperatureMax || null,\r\n      temperatureStatus: it.temperatureStatus || null,\r\n      log_annotations: it.log_annotations || null,\r\n    };\r\n\r\n    if (it.label === 'Chiller 1') {\r\n      LogHelper.log('RENDER CARD ALLEGRIA >>> OBJ: ', it);\r\n    }\r\n\r\n    const myTbToken = localStorage.getItem('jwt_token');\r\n    let cachedIngestionToken = null;\r\n\r\n    // RFC-0082 FIX: Check if MyIOAuth is initialized before calling getToken()\r\n    if (MyIOAuth && typeof MyIOAuth.getToken === 'function') {\r\n      MyIOAuth.getToken()\r\n        .then((token) => {\r\n          cachedIngestionToken = token;\r\n        })\r\n        .catch((err) => LogHelper.warn('Token cache failed:', err));\r\n    } else {\r\n      LogHelper.warn('[TELEMETRY] MyIOAuth not initialized yet, skipping token cache');\r\n    }\r\n\r\n    const $card = MyIO.renderCardComponentV5({\r\n      entityObject,\r\n      useNewComponents: true, // Habilitar novos componentes\r\n      enableSelection: true, // Habilitar sele√ß√£o\r\n      enableDragDrop: true, // Habilitar drag and drop\r\n\r\n      handleActionDashboard: async () => {\r\n        const jwtToken = localStorage.getItem('jwt_token');\r\n        const MyIOToast = MyIOLibrary?.MyIOToast || window.MyIOToast;\r\n\r\n        if (!jwtToken) {\r\n          if (MyIOToast) {\r\n            MyIOToast.error('Authentication required. Please login again.');\r\n          } else {\r\n            alert('Authentication required. Please login again.');\r\n          }\r\n          return;\r\n        }\r\n\r\n        // Get dates from MENU (startDateISO/endDateISO) and convert to timestamps\r\n        const startDateISO = self.ctx?.scope?.startDateISO;\r\n        const endDateISO = self.ctx?.scope?.endDateISO;\r\n        const startTs = startDateISO ? new Date(startDateISO).getTime() : Date.now() - 86400000;\r\n        const endTs = endDateISO ? new Date(endDateISO).getTime() : Date.now();\r\n        const deviceType = it.deviceType || entityObject.deviceType;\r\n        const isWaterTank = deviceType === 'TANK' || deviceType === 'CAIXA_DAGUA';\r\n        const isTermostato = deviceType === 'TERMOSTATO';\r\n\r\n        LogHelper.log(\r\n          '[TELEMETRY v5] Opening dashboard for deviceType:',\r\n          deviceType,\r\n          'isWaterTank:',\r\n          isWaterTank,\r\n          'isTermostato:',\r\n          isTermostato,\r\n          'deviceId:',\r\n          it.id,\r\n          'tbId:',\r\n          it.tbId,\r\n          'startDateISO:',\r\n          startDateISO,\r\n          'endDateISO:',\r\n          endDateISO,\r\n          'startTs:',\r\n          startTs,\r\n          'endTs:',\r\n          endTs\r\n        );\r\n\r\n        // Show loading toast\r\n        let loadingToast = null;\r\n        if (MyIOToast) {\r\n          const loadingMsg = isTermostato\r\n            ? 'Carregando dados de temperatura...'\r\n            : isWaterTank\r\n              ? 'Loading water tank data...'\r\n              : 'Loading energy data...';\r\n          loadingToast = MyIOToast.info(loadingMsg, 0);\r\n        }\r\n\r\n        try {\r\n          if (isTermostato) {\r\n            // Temperature/TERMOSTATO Modal Path - RFC-0085\r\n            // Uses MyIOLibrary.openTemperatureModal instead of inline implementation\r\n            LogHelper.log('[TELEMETRY v5] Entering TERMOSTATO device modal path (MyIOLibrary)...');\r\n\r\n            const deviceId = it.tbId || it.id;\r\n\r\n            // Get temperature-related properties from entity\r\n            // Check for various attribute names: temperatureMin, minTemperature, tempMin (SERVER_SCOPE)\r\n            const currentTemp = it.temperature || entityObject.temperature;\r\n            const tempMinRange =\r\n              it.temperatureMin ??\r\n              it.minTemperature ??\r\n              it.tempMin ??\r\n              entityObject.temperatureMin ??\r\n              entityObject.minTemperature ??\r\n              entityObject.tempMin ??\r\n              self.ctx?.scope?.minTemperature ??\r\n              null;\r\n            const tempMaxRange =\r\n              it.temperatureMax ??\r\n              it.maxTemperature ??\r\n              it.tempMax ??\r\n              entityObject.temperatureMax ??\r\n              entityObject.maxTemperature ??\r\n              entityObject.tempMax ??\r\n              self.ctx?.scope?.maxTemperature ??\r\n              null;\r\n            const tempStatus = it.temperatureStatus || entityObject.temperatureStatus;\r\n\r\n            LogHelper.log('[TELEMETRY v5] Temperature range from entity/scope:', {\r\n              tempMinRange,\r\n              tempMaxRange,\r\n            });\r\n\r\n            // Check if MyIOLibrary.openTemperatureModal is available\r\n            if (typeof MyIOLibrary?.openTemperatureModal !== 'function') {\r\n              const errorMsg = 'Temperature modal not available. Please update MyIO library.';\r\n              LogHelper.error('[TELEMETRY v5] ‚ùå', errorMsg);\r\n              throw new Error(errorMsg);\r\n            }\r\n\r\n            // Convert timestamps to ISO strings\r\n            const startDateISO = new Date(startTs).toISOString();\r\n            const endDateISO = new Date(endTs).toISOString();\r\n\r\n            LogHelper.log('[TELEMETRY v5] Calling openTemperatureModal with params:', {\r\n              deviceId: deviceId,\r\n              startDate: startDateISO,\r\n              endDate: endDateISO,\r\n              label: it.label || it.name,\r\n              currentTemperature: currentTemp,\r\n              temperatureMin: tempMinRange,\r\n              temperatureMax: tempMaxRange,\r\n              temperatureStatus: tempStatus,\r\n            });\r\n\r\n            const modalHandle = MyIOLibrary.openTemperatureModal({\r\n              token: jwtToken,\r\n              deviceId: deviceId,\r\n              startDate: startDateISO,\r\n              endDate: endDateISO,\r\n              label: it.label || it.name || 'Sensor de Temperatura',\r\n              currentTemperature: currentTemp,\r\n              temperatureMin: tempMinRange,\r\n              temperatureMax: tempMaxRange,\r\n              temperatureStatus: tempStatus,\r\n              theme: 'dark',\r\n              locale: 'pt-BR',\r\n              granularity: 'hour',\r\n              onClose: () => {\r\n                LogHelper.log('[TELEMETRY v5] Temperature modal closed via MyIOLibrary');\r\n              },\r\n            });\r\n\r\n            // Hide loading toast and busy indicator AFTER modal is opened\r\n            // Use setTimeout to ensure toast 'show' class has been applied before hiding\r\n            // (MyIOToast adds 'show' class after 10ms delay)\r\n            setTimeout(() => {\r\n              if (loadingToast) loadingToast.hide();\r\n              if (MyIOToast) MyIOToast.hide(); // Also call global hide as fallback\r\n            }, 50);\r\n            hideBusy();\r\n\r\n            LogHelper.log('[TELEMETRY v5] ‚úÖ Temperature modal opened via MyIOLibrary:', modalHandle);\r\n            return; // Exit early - modal is now handling everything\r\n          } else if (isWaterTank) {\r\n            // Water Tank Modal Path\r\n            LogHelper.log('[TELEMETRY v5] Entering TANK device modal path...');\r\n\r\n            LogHelper.log(\r\n              '[TELEMETRY v5] MyIOLibrary available:',\r\n              typeof MyIOLibrary !== 'undefined',\r\n              'openDashboardPopupWaterTank exists:',\r\n              typeof MyIOLibrary?.openDashboardPopupWaterTank\r\n            );\r\n\r\n            if (typeof MyIOLibrary?.openDashboardPopupWaterTank !== 'function') {\r\n              const errorMsg = 'Water tank modal not available. Please update MyIO library.';\r\n              LogHelper.error('[TELEMETRY v5] ‚ùå', errorMsg);\r\n              throw new Error(errorMsg);\r\n            }\r\n\r\n            // For TANK/CAIXA_DAGUA: get water level from telemetry\r\n            const waterLevel = getData('water_level');\r\n            const waterPercentage = getData('water_percentage');\r\n            const currentLevel = waterPercentage || it.perc || it.val || 0;\r\n\r\n            LogHelper.log('[TELEMETRY v5] Water tank telemetry data:', {\r\n              water_level: waterLevel,\r\n              water_percentage: waterPercentage,\r\n              currentLevel: currentLevel,\r\n              it_perc: it.perc,\r\n              it_val: it.val,\r\n            });\r\n\r\n            LogHelper.log('[TELEMETRY v5] Calling openDashboardPopupWaterTank with params:', {\r\n              deviceId: it.id,\r\n              deviceType: deviceType,\r\n              startTs: typeof startTs === 'number' ? startTs : new Date(startTs).getTime(),\r\n              endTs: typeof endTs === 'number' ? endTs : new Date(endTs).getTime(),\r\n              label: it.label || it.name || 'Water Tank',\r\n              currentLevel: currentLevel,\r\n            });\r\n\r\n            LogHelper.log('[TELEMETRY v5] ‚è≥ About to call openDashboardPopupWaterTank...');\r\n\r\n            const modalHandle = await MyIOLibrary.openDashboardPopupWaterTank({\r\n              deviceId: it.id,\r\n              deviceType: deviceType,\r\n              tbJwtToken: jwtToken,\r\n              startTs: typeof startTs === 'number' ? startTs : new Date(startTs).getTime(),\r\n              endTs: typeof endTs === 'number' ? endTs : new Date(endTs).getTime(),\r\n              label: it.label || it.name || 'Water Tank',\r\n              currentLevel: currentLevel,\r\n              slaveId: it.slaveId,\r\n              centralId: it.centralId,\r\n              timezone: self.ctx?.timeWindow?.timezone || 'America/Sao_Paulo',\r\n              telemetryKeys: ['water_level', 'water_percentage', 'waterLevel', 'nivel', 'level'],\r\n              onOpen: (context) => {\r\n                LogHelper.log('[TELEMETRY v5] ‚úÖ Water tank modal opened successfully!', context);\r\n                if (loadingToast) loadingToast.hide();\r\n                hideBusy();\r\n              },\r\n              onClose: () => {\r\n                LogHelper.log('[TELEMETRY v5] üö™ Water tank modal onClose callback triggered');\r\n              },\r\n              onError: (error) => {\r\n                LogHelper.error('[TELEMETRY v5] ‚ùå Water tank modal error:', error);\r\n                if (loadingToast) loadingToast.hide();\r\n                hideBusy();\r\n                if (MyIOToast) {\r\n                  MyIOToast.error(`Error: ${error.message}`);\r\n                } else {\r\n                  alert(`Error: ${error.message}`);\r\n                }\r\n              },\r\n            });\r\n\r\n            LogHelper.log('[TELEMETRY v5] ‚úÖ Water tank modal handle received:', modalHandle);\r\n          } else {\r\n            // Energy/Water/Temperature Modal Path (Ingestion API)\r\n            LogHelper.log('[TELEMETRY v5] Opening energy modal...');\r\n            const tokenIngestionDashBoard = await MyIOAuth.getToken();\r\n            const modal = MyIO.openDashboardPopupEnergy({\r\n              deviceId: it.id,\r\n              readingType: WIDGET_DOMAIN, // 'energy', 'water', or 'tank'\r\n              startDate: self.ctx.scope.startDateISO,\r\n              endDate: self.ctx.scope.endDateISO,\r\n              tbJwtToken: jwtToken,\r\n              ingestionToken: tokenIngestionDashBoard,\r\n              clientId: CLIENT_ID,\r\n              clientSecret: CLIENT_SECRET,\r\n              onOpen: (context) => {\r\n                LogHelper.log('[TELEMETRY v5] Energy modal opened:', context);\r\n                if (loadingToast) loadingToast.hide();\r\n                hideBusy();\r\n              },\r\n              onError: (error) => {\r\n                LogHelper.error('[TELEMETRY v5] Energy modal error:', error);\r\n                if (loadingToast) loadingToast.hide();\r\n                hideBusy();\r\n                if (MyIOToast) {\r\n                  MyIOToast.error(`Erro: ${error.message}`);\r\n                } else {\r\n                  alert(`Erro: ${error.message}`);\r\n                }\r\n              },\r\n              onClose: () => {\r\n                LogHelper.log('[TELEMETRY v5] Energy modal closed');\r\n              },\r\n            });\r\n          }\r\n        } catch (err) {\r\n          LogHelper.error('[TELEMETRY v5] Dashboard action failed:', err?.message || err, err);\r\n\r\n          if (loadingToast) loadingToast.hide();\r\n          hideBusy();\r\n\r\n          if (MyIOToast) {\r\n            MyIOToast.error(err?.message || 'Failed to open dashboard');\r\n          } else {\r\n            alert(err?.message || 'Failed to open dashboard');\r\n          }\r\n        }\r\n      },\r\n\r\n      handleActionReport: async () => {\r\n        try {\r\n          showBusy(); // mensagem fixa\r\n\r\n          const deviceType = it.deviceType || entityObject.deviceType;\r\n          const isTermostatoDevice = deviceType === 'TERMOSTATO';\r\n\r\n          // For TERMOSTATO devices, reports use ThingsBoard API (no ingestion)\r\n          if (isTermostatoDevice || WIDGET_DOMAIN === 'temperature') {\r\n            LogHelper.log('[TELEMETRY v5] Temperature report - using ThingsBoard API');\r\n\r\n            const jwtToken = localStorage.getItem('jwt_token');\r\n            if (!jwtToken) {\r\n              throw new Error('No JWT token available');\r\n            }\r\n\r\n            // Get device TB ID\r\n            let tbId = it.tbId;\r\n            if (!tbId || !isValidUUID(tbId)) {\r\n              const idx = buildTbIdIndexes();\r\n              tbId =\r\n                (it.ingestionId && idx.byIngestion.get(it.ingestionId)) ||\r\n                (it.identifier && idx.byIdentifier.get(it.identifier)) ||\r\n                null;\r\n            }\r\n\r\n            if (!tbId) {\r\n              LogHelper.warn('[TELEMETRY v5] No TB device ID for temperature report');\r\n              const MyIOToast = MyIOLibrary?.MyIOToast || window.MyIOToast;\r\n              if (MyIOToast) {\r\n                MyIOToast.error('Nao foi possivel identificar o dispositivo.');\r\n              }\r\n              return;\r\n            }\r\n\r\n            LogHelper.log('[TELEMETRY v5] Opening temperature report for device:', {\r\n              tbId,\r\n              label: it.label,\r\n              identifier: it.identifier,\r\n            });\r\n\r\n            // Create custom fetcher for ThingsBoard temperature data\r\n            const temperatureFetcher = async ({ startISO, endISO }) => {\r\n              const startTs = new Date(startISO).getTime();\r\n              const endTs = new Date(endISO).getTime();\r\n\r\n              LogHelper.log('[TELEMETRY v5] Fetching temperature data for report:', {\r\n                startISO,\r\n                endISO,\r\n                startTs,\r\n                endTs,\r\n                tbId,\r\n              });\r\n\r\n              // Fetch temperature data from ThingsBoard with daily aggregation\r\n              const url =\r\n                `/api/plugins/telemetry/DEVICE/${tbId}/values/timeseries` +\r\n                `?keys=temperature` +\r\n                `&startTs=${encodeURIComponent(startTs)}` +\r\n                `&endTs=${encodeURIComponent(endTs)}` +\r\n                `&limit=50000` +\r\n                `&intervalType=MILLISECONDS` +\r\n                `&interval=86400000` + // 24 hours in ms (daily aggregation)\r\n                `&agg=AVG`;\r\n\r\n              const response = await fetch(url, {\r\n                headers: {\r\n                  'X-Authorization': `Bearer ${jwtToken}`,\r\n                  'Content-Type': 'application/json',\r\n                },\r\n              });\r\n\r\n              if (!response.ok) {\r\n                throw new Error(`ThingsBoard API error: ${response.status}`);\r\n              }\r\n\r\n              const data = await response.json();\r\n              LogHelper.log('[TELEMETRY v5] ThingsBoard temperature response:', data);\r\n\r\n              // Transform ThingsBoard response to match expected format for report modal\r\n              const tempValues = data?.temperature || [];\r\n\r\n              if (tempValues.length === 0) {\r\n                LogHelper.warn('[TELEMETRY v5] No temperature data returned from ThingsBoard');\r\n                return [];\r\n              }\r\n\r\n              // Helper function to clamp temperature values (avoid outliers)\r\n              // Values below 15¬∞C are clamped to 15, values above 40¬∞C are clamped to 40\r\n              const clampTemp = (v) => {\r\n                const num = Number(v || 0);\r\n                if (num < 15) return 15;\r\n                if (num > 40) return 40;\r\n                return num;\r\n              };\r\n\r\n              // Group by day and calculate average (ThingsBoard may return multiple points per day)\r\n              const dailyMap = {};\r\n              tempValues.forEach((item) => {\r\n                const date = new Date(item.ts);\r\n                const dateKey = date.toISOString().split('T')[0]; // YYYY-MM-DD\r\n                if (!dailyMap[dateKey]) {\r\n                  dailyMap[dateKey] = { sum: 0, count: 0 };\r\n                }\r\n                // Clamp each value before aggregating\r\n                dailyMap[dateKey].sum += clampTemp(item.value);\r\n                dailyMap[dateKey].count += 1;\r\n              });\r\n\r\n              // Convert to array format expected by DeviceReportModal\r\n              const consumption = Object.entries(dailyMap).map(([date, stats]) => ({\r\n                timestamp: date + 'T00:00:00.000Z',\r\n                value: stats.sum / stats.count, // Average temperature for the day (already clamped)\r\n              }));\r\n\r\n              LogHelper.log('[TELEMETRY v5] Processed temperature data for report:', {\r\n                daysCount: consumption.length,\r\n                consumption,\r\n              });\r\n\r\n              // Return in the format expected by DeviceReportModal.processApiResponse\r\n              return [\r\n                {\r\n                  deviceId: tbId,\r\n                  consumption: consumption,\r\n                },\r\n              ];\r\n            };\r\n\r\n            // Open the report modal with custom temperature fetcher\r\n            await MyIO.openDashboardPopupReport({\r\n              ingestionId: it.ingestionId || tbId, // Use tbId as fallback\r\n              deviceId: tbId,\r\n              identifier: it.identifier,\r\n              label: it.label,\r\n              domain: 'temperature',\r\n              fetcher: temperatureFetcher, // Custom fetcher for ThingsBoard data\r\n              api: {\r\n                // These are not used when custom fetcher is provided, but required by interface\r\n                dataApiBaseUrl: '',\r\n                clientId: '',\r\n                clientSecret: '',\r\n                ingestionToken: jwtToken,\r\n              },\r\n            });\r\n\r\n            return;\r\n          }\r\n\r\n          if (!isAuthReady()) throw new Error('Auth not ready');\r\n\r\n          const ingestionToken = await MyIOAuth.getToken();\r\n\r\n          if (!ingestionToken) throw new Error('No ingestion token');\r\n\r\n          await MyIO.openDashboardPopupReport({\r\n            ingestionId: it.ingestionId, // sempre ingestionId\r\n            identifier: it.identifier,\r\n            label: it.label,\r\n            domain: WIDGET_DOMAIN, // 'energy', 'water', or 'temperature'\r\n            api: {\r\n              dataApiBaseUrl: DATA_API_HOST,\r\n              clientId: CLIENT_ID,\r\n              clientSecret: CLIENT_SECRET,\r\n              ingestionToken,\r\n            },\r\n          });\r\n        } catch (err) {\r\n          LogHelper.warn('[DeviceCards] Report open blocked:', err?.message || err);\r\n          alert('Credenciais ainda carregando. Tente novamente em instantes.');\r\n        } finally {\r\n          hideBusy();\r\n        }\r\n      },\r\n\r\n      handleActionSettings: async () => {\r\n        showBusy(null, 3000); // mensagem fixa\r\n        // resolve TB id ‚Äúfresh‚Äù\r\n        let tbId = it.tbId;\r\n\r\n        if (!tbId || !isValidUUID(tbId)) {\r\n          const idx = buildTbIdIndexes();\r\n          tbId =\r\n            (it.ingestionId && idx.byIngestion.get(it.ingestionId)) ||\r\n            (it.identifier && idx.byIdentifier.get(it.identifier)) ||\r\n            null;\r\n        }\r\n\r\n        if (!tbId || tbId === it.ingestionId) {\r\n          LogHelper.warn('[DeviceCards] Missing/ambiguous TB id for Settings', {\r\n            label: it.label,\r\n            identifier: it.identifier,\r\n            ingestionId: it.ingestionId,\r\n            tbId,\r\n          });\r\n          hideBusy();\r\n          alert('N√£o foi poss√≠vel identificar o deviceId do ThingsBoard para este card.');\r\n          return;\r\n        }\r\n\r\n        const jwt = localStorage.getItem('jwt_token');\r\n\r\n        try {\r\n          // RFC-0080 + RFC-0091: Get customerId from MAIN widget via window.MyIOUtils\r\n          const customerTbId = window.MyIOUtils?.customerTB_ID || null;\r\n\r\n          // RFC-XXXX: SuperAdmin flag from MAIN_VIEW\r\n          const isSuperAdmin = window.MyIOUtils?.SuperAdmin || false;\r\n\r\n          console.log(`[TELEMETRY] openDashboardPopupSettings > isSuperAdmin: `, isSuperAdmin);\r\n\r\n          await MyIO.openDashboardPopupSettings({\r\n            deviceId: tbId, // TB deviceId\r\n            label: it.label,\r\n            jwtToken: jwt,\r\n            domain: WIDGET_DOMAIN,\r\n            deviceType: it.deviceType,\r\n            customerId: customerTbId, // RFC-0080: Pass customerId for GLOBAL fetch\r\n            superadmin: isSuperAdmin, // RFC-XXXX: SuperAdmin mode\r\n            connectionData: {\r\n              centralName: it.centralName,\r\n              connectionStatusTime: it.connectionStatusTime || null,\r\n              lastDisconnectTime: it.lastDisconnectTime || null,\r\n              timeVal: it.timeVal || null,\r\n              deviceStatus: it.deviceStatus || 'no_info',\r\n            },\r\n            ui: { title: 'Configura√ß√µes', width: 900 },\r\n            mapInstantaneousPower: it.mapInstantaneousPower, // RFC-0078: Pass existing map if available\r\n            // RFC-0091: Pass device-specific power limits (TIER 0 - highest priority)\r\n            deviceMapInstaneousPower: it.deviceMapInstaneousPower || null,\r\n            onSaved: (payload) => {\r\n              LogHelper.log('[Settings Saved]', payload);\r\n              //hideBusy();\r\n              // Mostra modal global de sucesso com contador e reload\r\n              // showGlobalSuccessModal(6);\r\n            },\r\n            onClose: () => {\r\n              $('.myio-settings-modal-overlay').remove();\r\n              hideBusy();\r\n            },\r\n          });\r\n        } catch (e) {\r\n          hideBusy();\r\n        }\r\n      },\r\n\r\n      handleClickCard: () => {\r\n        //LogHelper.log(\"Card clicado:\", entityObject);\r\n      },\r\n\r\n      handleSelect: (entityObj) => {\r\n        // NOTE: This callback is called during card rendering, NOT during user selection\r\n        // Entity registration is handled by the 'myio:device-params' event listener instead\r\n        // which is only triggered when the user actually clicks the checkbox\r\n        LogHelper.log('[TELEMETRY] handleSelect called (no-op):', entityObj.labelOrName);\r\n      },\r\n    });\r\n\r\n    // Append the returned element to wrapper\r\n    if ($card && $card[0] && entityObject.log_annotations) {\r\n      addAnnotationIndicator($card[0], entityObject);\r\n    }\r\n\r\n    $ul.append($card);\r\n  });\r\n}\r\n\r\n/** ===================== UI BINDINGS ===================== **/\r\nfunction bindHeader() {\r\n  $root().on('click', '#btnSearch', () => {\r\n    STATE.searchActive = !STATE.searchActive;\r\n    $root().find('#searchWrap').toggleClass('active', STATE.searchActive);\r\n\r\n    if (STATE.searchActive) setTimeout(() => $root().find('#shopsSearch').trigger('focus'), 30);\r\n  });\r\n\r\n  $root().on('input', '#shopsSearch', (ev) => {\r\n    STATE.searchTerm = ev.target.value || '';\r\n    reflowFromState();\r\n  });\r\n\r\n  $root().on('click', '#btnFilter', () => openFilterModal());\r\n}\r\n\r\nfunction openFilterModal() {\r\n  const $m = $modal();\r\n  const $cl = $m.find('#deviceChecklist').empty();\r\n\r\n  const list = (STATE.itemsBase || []).slice().sort((a, b) =>\r\n    (a.label || '').localeCompare(b.label || '', 'pt-BR', {\r\n      sensitivity: 'base',\r\n    })\r\n  );\r\n\r\n  if (!list.length) {\r\n    $cl.html('<div class=\"muted\">Nenhuma loja carregada.</div>');\r\n    $m.removeClass('hidden');\r\n    return;\r\n  }\r\n\r\n  const selected = STATE.selectedIds;\r\n  const frag = document.createDocumentFragment();\r\n\r\n  for (const it of list) {\r\n    const safeId =\r\n      String(it.id || '')\r\n        .replace(/[^a-zA-Z0-9_-]/g, '')\r\n        .slice(0, 60) || 'id' + Math.random().toString(36).slice(2);\r\n    const checked = !selected || !selected.size || selected.has(it.id);\r\n\r\n    const label = document.createElement('label');\r\n    label.className = 'check-item';\r\n    label.setAttribute('role', 'option');\r\n    label.innerHTML = `\r\n      <input type=\"checkbox\" id=\"chk-${safeId}\" data-entity=\"${escapeHtml(it.id)}\" ${checked ? 'checked' : ''\r\n      }>\r\n      <span>${escapeHtml(it.label || it.identifier || it.id)}</span>\r\n    `;\r\n    frag.appendChild(label);\r\n  }\r\n\r\n  $cl[0].appendChild(frag);\r\n  $m.find(`input[name=\"sortMode\"][value=\"${STATE.sortMode}\"]`).prop('checked', true);\r\n\r\n  const $footer = $m.find('.shops-modal-footer');\r\n  if ($footer.length) $footer.show().find('#applyFilters, #resetFilters').show();\r\n\r\n  syncChecklistSelectionVisual();\r\n  $m.removeClass('hidden');\r\n}\r\nfunction closeFilterModal() {\r\n  $modal().addClass('hidden');\r\n}\r\n\r\nfunction bindModal() {\r\n  $root().on('click', '#closeFilter', closeFilterModal);\r\n\r\n  $root().on('click', '#selectAll', (ev) => {\r\n    ev.preventDefault();\r\n    $modal().find('.check-item input[type=\"checkbox\"]').prop('checked', true);\r\n    syncChecklistSelectionVisual();\r\n  });\r\n\r\n  $root().on('click', '#clearAll', (ev) => {\r\n    ev.preventDefault();\r\n    $modal().find('.check-item input[type=\"checkbox\"]').prop('checked', false);\r\n    syncChecklistSelectionVisual();\r\n  });\r\n\r\n  $root().on('click', '#resetFilters', (ev) => {\r\n    ev.preventDefault();\r\n    STATE.selectedIds = null;\r\n    STATE.sortMode = 'cons_desc';\r\n    $modal().find('.check-item input[type=\"checkbox\"]').prop('checked', true);\r\n    $modal().find('input[name=\"sortMode\"][value=\"cons_desc\"]').prop('checked', true);\r\n    syncChecklistSelectionVisual();\r\n    reflowFromState();\r\n  });\r\n\r\n  $root().on('click', '#applyFilters', (ev) => {\r\n    ev.preventDefault();\r\n    const set = new Set();\r\n    $modal()\r\n      .find('.check-item input[type=\"checkbox\"]:checked')\r\n      .each((_, el) => {\r\n        const id = $(el).data('entity');\r\n        if (id) set.add(id);\r\n      });\r\n\r\n    STATE.selectedIds = set.size === 0 || set.size === STATE.itemsBase.length ? null : set;\r\n    STATE.sortMode = String($modal().find('input[name=\"sortMode\"]:checked').val() || 'cons_desc');\r\n\r\n    reflowFromState();\r\n    closeFilterModal();\r\n  });\r\n\r\n  $root().on('input', '#filterDeviceSearch', (ev) => {\r\n    const q = (ev.target.value || '').trim().toLowerCase();\r\n    $modal()\r\n      .find('.check-item')\r\n      .each((_, node) => {\r\n        const txt = $(node).text().trim().toLowerCase();\r\n        $(node).toggle(txt.includes(q));\r\n      });\r\n  });\r\n\r\n  $root().on('click', '#filterDeviceClear', (ev) => {\r\n    ev.preventDefault();\r\n    const $inp = $modal().find('#filterDeviceSearch');\r\n    $inp.val('');\r\n    $modal().find('.check-item').show();\r\n    $inp.trigger('focus');\r\n  });\r\n\r\n  $root().on('click', '#deviceChecklist .check-item', function (ev) {\r\n    if (ev.target && ev.target.tagName && ev.target.tagName.toLowerCase() === 'input') return;\r\n    ev.preventDefault();\r\n    ev.stopPropagation();\r\n    const $chk = $(this).find('input[type=\"checkbox\"]');\r\n    $chk.prop('checked', !$chk.prop('checked')).trigger('change');\r\n  });\r\n\r\n  $root().on('change', '#deviceChecklist input[type=\"checkbox\"]', function () {\r\n    const $wrap = $(this).closest('.check-item');\r\n    const on = this.checked;\r\n    $wrap.toggleClass('selected', on).attr('data-checked', on ? 'true' : 'false');\r\n    $wrap.css(\r\n      on\r\n        ? {\r\n          background: 'rgba(62,26,125,.08)',\r\n          borderColor: '#3E1A7D',\r\n          boxShadow: '0 8px 18px rgba(62,26,125,.15)',\r\n        }\r\n        : {\r\n          background: '#fff',\r\n          borderColor: '#D6E1EC',\r\n          boxShadow: '0 6px 14px rgba(0,0,0,.05)',\r\n        }\r\n    );\r\n  });\r\n}\r\n\r\nfunction syncChecklistSelectionVisual() {\r\n  $modal()\r\n    .find('.check-item')\r\n    .each(function () {\r\n      const $el = $(this);\r\n      const on = $el.find('input[type=\"checkbox\"]').prop('checked');\r\n      $el.toggleClass('selected', on).attr('data-checked', on ? 'true' : 'false');\r\n      $el.css(\r\n        on\r\n          ? {\r\n            background: 'rgba(62,26,125,.08)',\r\n            borderColor: '#3E1A7D',\r\n            boxShadow: '0 8px 18px rgba(62,26,125,.15)',\r\n          }\r\n          : {\r\n            background: '#fff',\r\n            borderColor: '#D6E1EC',\r\n            boxShadow: '0 6px 14px rgba(0,0,0,.05)',\r\n          }\r\n      );\r\n    });\r\n}\r\n\r\n/** ===================== RFC-0056 FIX v1.1: EMISSION ===================== **/\r\n\r\n/**\r\n * Normaliza valor de kWh para MWh com 2 decimais\r\n * @param {number} kWhValue - valor em kWh\r\n * @returns {number} valor em MWh arredondado\r\n */\r\nfunction normalizeToMWh(kWhValue) {\r\n  if (typeof kWhValue !== 'number' || isNaN(kWhValue)) return 0;\r\n  return Math.round((kWhValue / 1000) * 100) / 100;\r\n}\r\n\r\n/**\r\n * Normaliza label de dispositivo para classifica√ß√£o consistente\r\n * @param {string} str - label do dispositivo\r\n * @returns {string} label normalizado\r\n */\r\nfunction normalizeLabel(str) {\r\n  if (!str) return '';\r\n  return str\r\n    .toLowerCase()\r\n    .trim()\r\n    .normalize('NFD')\r\n    .replace(/[\\u0300-\\u036f]/g, '');\r\n}\r\n\r\n/**\r\n * Dispatcher: determina tipo de widget e emite evento apropriado\r\n * RFC-0056 FIX v1.1: Consolida√ß√£o em myio:telemetry:update\r\n */\r\nfunction emitTelemetryUpdate() {\r\n  try {\r\n    // Determinar tipo de widget pelo datasource alias\r\n    const widgetType = detectWidgetType();\r\n\r\n    if (!widgetType) {\r\n      LogHelper.log('[RFC-0056] Widget type not detected - skipping emission');\r\n      return;\r\n    }\r\n\r\n    // Construir periodKey a partir do filtro atual\r\n    const periodKey = buildPeriodKey();\r\n\r\n    // RFC-0002: Domain-specific emission\r\n    if (WIDGET_DOMAIN === 'water') {\r\n      emitWaterTelemetry(widgetType, periodKey);\r\n    } else {\r\n      // Default: energy domain\r\n      if (widgetType === 'lojas') {\r\n        emitLojasTotal(periodKey);\r\n      } else if (widgetType === 'areacomum') {\r\n        emitAreaComumBreakdown(periodKey);\r\n      } else if (widgetType === 'entrada') {\r\n        // RFC-0098: Emit entrada total for energy domain\r\n        emitEntradaTotal(periodKey);\r\n      }\r\n    }\r\n  } catch (err) {\r\n    LogHelper.error('[RFC-0056] Error in emitTelemetryUpdate:', err);\r\n  }\r\n}\r\n\r\n/**\r\n * Detecta tipo de widget baseado no datasource alias\r\n * RFC-0002: Added 'entrada' detection for water domain\r\n * @returns {'lojas'|'areacomum'|'entrada'|null}\r\n */\r\nfunction detectWidgetType() {\r\n  try {\r\n    LogHelper.log('üîç [detectWidgetType] Iniciando detec√ß√£o de tipo de widget...');\r\n\r\n    const datasources = ctx.datasources || [];\r\n    LogHelper.log(`[detectWidgetType] Total de datasources detectados: ${datasources.length}`);\r\n\r\n    if (!datasources.length) {\r\n      LogHelper.warn('[detectWidgetType] Nenhum datasource encontrado em ctx.datasources!');\r\n      return null;\r\n    }\r\n\r\n    // Percorrer todos os datasources\r\n    for (let i = 0; i < datasources.length; i++) {\r\n      const ds = datasources[i];\r\n      const alias = (ds.aliasName || '').toString().toLowerCase().trim();\r\n\r\n      LogHelper.log(`üî∏ [detectWidgetType] Verificando datasource[${i}]`);\r\n      LogHelper.log(`    ‚Ü≥ aliasName:     ${ds.aliasName || '(vazio)'}`);\r\n      LogHelper.log(`    ‚Ü≥ entityName:    ${ds.entityName || '(vazio)'}`);\r\n      LogHelper.log(`    ‚Ü≥ alias normalizado: \"${alias}\"`);\r\n\r\n      if (!alias) {\r\n        LogHelper.warn(`[detectWidgetType] ‚ö†Ô∏è Alias vazio ou indefinido no datasource[${i}].`);\r\n        continue;\r\n      }\r\n\r\n      // RFC-0002: Check for entrada (water domain)\r\n      // Use word boundary matching to avoid false positives like \"bomba entrada\"\r\n      if (/\\bentrada\\b/.test(alias) || alias === 'entrada' || alias.includes('entrada')) {\r\n        LogHelper.log(`‚úÖ [detectWidgetType] Tipo detectado: \"entrada\" (com base no alias \"${alias}\")`);\r\n        return 'entrada';\r\n      }\r\n\r\n      // Match \"lojas\" as standalone word or at end of alias\r\n      // AVOID false positives like \"Bomba Lojas\", \"Subesta√ß√£o Lojas\"\r\n      // ACCEPT: \"lojas\", \"widget-lojas\", \"telemetry-lojas\", \"consumidores lojas\"\r\n      // RFC-0097: Usa EQUIPMENT_EXCLUSION_PATTERN constru√≠do do config\r\n      if (/\\blojas\\b/.test(alias) && !EQUIPMENT_EXCLUSION_PATTERN.test(alias)) {\r\n        LogHelper.log(`‚úÖ [detectWidgetType] Tipo detectado: \"lojas\" (com base no alias \"${alias}\")`);\r\n        return 'lojas';\r\n      }\r\n\r\n      // Match area comum with flexible separators\r\n      if (/\\barea\\s*comum\\b/.test(alias) || alias.includes('areacomum') || alias.includes('area_comum')) {\r\n        LogHelper.log(`‚úÖ [detectWidgetType] Tipo detectado: \"areacomum\" (com base no alias \"${alias}\")`);\r\n        return 'areacomum';\r\n      }\r\n    }\r\n\r\n    LogHelper.warn('[detectWidgetType] ‚ö†Ô∏è Nenhum tipo de widget correspondente encontrado.');\r\n    return null;\r\n  } catch (err) {\r\n    LogHelper.error('[detectWidgetType] ‚ùå Erro durante detec√ß√£o de tipo de widget:', err);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Constr√≥i periodKey do filtro atual\r\n * Formato: \"YYYY-MM-DD_YYYY-MM-DD\" ou \"realtime\"\r\n */\r\nfunction buildPeriodKey() {\r\n  const timewindow = ctx.defaultSubscription?.subscriptionTimewindow;\r\n\r\n  if (!timewindow || timewindow.realtimeWindowMs) {\r\n    return 'realtime';\r\n  }\r\n\r\n  const startMs = timewindow.fixedWindow?.startTimeMs || Date.now() - 86400000;\r\n  const endMs = timewindow.fixedWindow?.endTimeMs || Date.now();\r\n\r\n  const startDate = new Date(startMs).toISOString().split('T')[0];\r\n  const endDate = new Date(endMs).toISOString().split('T')[0];\r\n\r\n  return `${startDate}_${endDate}`;\r\n}\r\n\r\n/**\r\n * RFC-0098: Emite evento entrada_total\r\n * TELEMETRY (Entrada) ‚Üí TELEMETRY_INFO\r\n */\r\nfunction emitEntradaTotal(periodKey) {\r\n  try {\r\n    // Calcular total de Entrada a partir dos itens enriquecidos\r\n    const entradaTotal = STATE.itemsEnriched.reduce((sum, item) => {\r\n      return sum + (item.value || 0);\r\n    }, 0);\r\n\r\n    const totalMWh = normalizeToMWh(entradaTotal);\r\n\r\n    const payload = {\r\n      type: 'entrada_total',\r\n      domain: 'energy',\r\n      periodKey: periodKey,\r\n      timestamp: Date.now(),\r\n      source: 'TELEMETRY_Entrada',\r\n      data: {\r\n        total_kWh: entradaTotal,\r\n        total_MWh: totalMWh,\r\n        device_count: STATE.itemsEnriched.length,\r\n      },\r\n    };\r\n\r\n    // Cache em sessionStorage\r\n    const cacheKey = `myio:telemetry:entrada_${periodKey}`;\r\n    try {\r\n      sessionStorage.setItem(cacheKey, JSON.stringify(payload));\r\n    } catch (e) {\r\n      LogHelper.warn('[RFC-0098] sessionStorage write failed:', e);\r\n    }\r\n\r\n    // Dispatch consolidated event\r\n    const event = new CustomEvent('myio:telemetry:update', {\r\n      detail: payload,\r\n      bubbles: true,\r\n      cancelable: false,\r\n    });\r\n\r\n    window.dispatchEvent(event);\r\n    LogHelper.log(\r\n      `[RFC-0098] ‚úÖ Emitted entrada_total: ${totalMWh} MWh (${STATE.itemsEnriched.length} devices)`\r\n    );\r\n  } catch (err) {\r\n    LogHelper.error('[RFC-0098] Error in emitEntradaTotal:', err);\r\n  }\r\n}\r\n\r\n/**\r\n * Emite evento lojas_total\r\n * RFC-0056 FIX v1.1: TELEMETRY (Lojas) ‚Üí TELEMETRY_INFO\r\n */\r\nfunction emitLojasTotal(periodKey) {\r\n  try {\r\n    // Calcular total de Lojas a partir dos itens enriquecidos\r\n    const lojasTotal = STATE.itemsEnriched.reduce((sum, item) => {\r\n      return sum + (item.value || 0);\r\n    }, 0);\r\n\r\n    const totalMWh = normalizeToMWh(lojasTotal);\r\n\r\n    const payload = {\r\n      type: 'lojas_total',\r\n      domain: 'energy',\r\n      periodKey: periodKey,\r\n      timestamp: Date.now(),\r\n      source: 'TELEMETRY_Lojas',\r\n      data: {\r\n        total_kWh: lojasTotal,\r\n        total_MWh: totalMWh,\r\n        device_count: STATE.itemsEnriched.length,\r\n      },\r\n    };\r\n\r\n    // Cache em sessionStorage\r\n    const cacheKey = `myio:telemetry:lojas_${periodKey}`;\r\n    try {\r\n      sessionStorage.setItem(cacheKey, JSON.stringify(payload));\r\n    } catch (e) {\r\n      LogHelper.warn('[RFC-0056] sessionStorage write failed:', e);\r\n    }\r\n\r\n    // Dispatch consolidated event\r\n    const event = new CustomEvent('myio:telemetry:update', {\r\n      detail: payload,\r\n      bubbles: true,\r\n      cancelable: false,\r\n    });\r\n\r\n    window.dispatchEvent(event);\r\n    LogHelper.log(\r\n      `[RFC-0056] ‚úÖ Emitted lojas_total: ${totalMWh} MWh (${STATE.itemsEnriched.length} devices)`\r\n    );\r\n  } catch (err) {\r\n    LogHelper.error('[RFC-0056] Error in emitLojasTotal:', err);\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0097: Classify device by deviceType attribute\r\n * Primary classification method - uses deviceType (or deviceProfile when deviceType = 3F_MEDIDOR)\r\n * Uses centralized DEVICE_CLASSIFICATION_CONFIG\r\n *\r\n * Para deviceTypes condicionais (BOMBA, MOTOR), s√≥ classifica como climatiza√ß√£o\r\n * se o identifier for de climatiza√ß√£o (ex: CAG)\r\n *\r\n * @param {Object} item - Device item with deviceType and identifier properties\r\n * @returns {'climatizacao'|'elevadores'|'escadas_rolantes'|'outros'}\r\n */\r\nfunction classifyDeviceByDeviceType(item) {\r\n  if (!item) return 'outros';\r\n\r\n  // Get effective device type: use deviceType, or deviceProfile if deviceType is 3F_MEDIDOR\r\n  let effectiveType = String(item.deviceType || '').toUpperCase();\r\n\r\n  if (effectiveType === '3F_MEDIDOR' && item.deviceProfile) {\r\n    effectiveType = String(item.deviceProfile).toUpperCase();\r\n  }\r\n\r\n  if (!effectiveType || effectiveType === 'N/D') {\r\n    return 'outros';\r\n  }\r\n\r\n  // DeviceTypes que s√£o SEMPRE climatiza√ß√£o (CHILLER, FANCOIL, etc.)\r\n  if (CLIMATIZACAO_DEVICE_TYPES_SET.has(effectiveType)) {\r\n    return 'climatizacao';\r\n  }\r\n\r\n  // DeviceTypes condicionais (BOMBA, MOTOR) - s√≥ climatiza√ß√£o se identifier for CAG, etc.\r\n  if (CLIMATIZACAO_CONDITIONAL_TYPES_SET.has(effectiveType)) {\r\n    const identifier = String(item.identifier || '')\r\n      .toUpperCase()\r\n      .trim();\r\n\r\n    // Verificar se o identifier indica climatiza√ß√£o\r\n    if (CLIMATIZACAO_IDENTIFIERS_SET.has(identifier)) {\r\n      return 'climatizacao';\r\n    }\r\n    // Verificar prefixos (CAG-, FANCOIL-, etc.)\r\n    for (const prefix of DEVICE_CLASSIFICATION_CONFIG.climatizacao.identifierPrefixes) {\r\n      if (identifier.startsWith(prefix.toUpperCase())) {\r\n        return 'climatizacao';\r\n      }\r\n    }\r\n    // BOMBA/MOTOR sem identifier de climatiza√ß√£o ‚Üí outros\r\n    return 'outros';\r\n  }\r\n\r\n  if (ELEVADORES_DEVICE_TYPES_SET.has(effectiveType)) {\r\n    return 'elevadores';\r\n  }\r\n\r\n  if (ESCADAS_DEVICE_TYPES_SET.has(effectiveType)) {\r\n    return 'escadas_rolantes';\r\n  }\r\n\r\n  // Default: outros\r\n  return 'outros';\r\n}\r\n\r\n/**\r\n * RFC-0097: Classify device by identifier attribute\r\n * Uses centralized DEVICE_CLASSIFICATION_CONFIG\r\n * @param {string} identifier - Device identifier (e.g., \"CAG\", \"Fancoil\", \"ELV\", etc.)\r\n * @returns {'climatizacao'|'elevadores'|'escadas_rolantes'|'outros'|null}\r\n */\r\nfunction classifyDeviceByIdentifier(identifier = '') {\r\n  // Safe guard against null/undefined/empty\r\n  if (!identifier || identifier === 'N/A' || identifier === 'null' || identifier === 'undefined') {\r\n    return null;\r\n  }\r\n\r\n  const id = String(identifier).trim().toUpperCase();\r\n\r\n  // Ignore \"Sem Identificador identificado\" marker\r\n  if (id.includes('SEM IDENTIFICADOR')) {\r\n    return null;\r\n  }\r\n\r\n  // Check each category using centralized config\r\n  // Climatiza√ß√£o\r\n  if (CLIMATIZACAO_IDENTIFIERS_SET.has(id)) {\r\n    return 'climatizacao';\r\n  }\r\n  for (const prefix of DEVICE_CLASSIFICATION_CONFIG.climatizacao.identifierPrefixes) {\r\n    if (id.startsWith(prefix.toUpperCase())) return 'climatizacao';\r\n  }\r\n\r\n  // Elevadores\r\n  if (ELEVADORES_IDENTIFIERS_SET.has(id)) {\r\n    return 'elevadores';\r\n  }\r\n  for (const prefix of DEVICE_CLASSIFICATION_CONFIG.elevadores.identifierPrefixes) {\r\n    if (id.startsWith(prefix.toUpperCase())) return 'elevadores';\r\n  }\r\n\r\n  // Escadas Rolantes\r\n  if (ESCADAS_IDENTIFIERS_SET.has(id)) {\r\n    return 'escadas_rolantes';\r\n  }\r\n  for (const prefix of DEVICE_CLASSIFICATION_CONFIG.escadas_rolantes.identifierPrefixes) {\r\n    if (id.startsWith(prefix.toUpperCase())) return 'escadas_rolantes';\r\n  }\r\n\r\n  // Outros: qualquer outro identifier n√£o reconhecido\r\n  return 'outros';\r\n}\r\n\r\n// RFC-0097: classifyDeviceByLabel foi removida - classifica√ß√£o agora √© por deviceType\r\n\r\n/**\r\n * RFC-0097: Classify device using deviceType as primary method\r\n * @param {Object} item - Device item with deviceType, deviceProfile, identifier, and label\r\n * @returns {'climatizacao'|'elevadores'|'escadas_rolantes'|'outros'}\r\n */\r\nfunction classifyDevice(item) {\r\n  // Safe guard - ensure item exists\r\n  if (!item) {\r\n    LogHelper.warn('[RFC-0097] classifyDevice called with null/undefined item');\r\n    return 'outros';\r\n  }\r\n\r\n  // RFC-0097: Primary classification by deviceType (or deviceProfile when deviceType = 3F_MEDIDOR)\r\n  const category = classifyDeviceByDeviceType(item);\r\n\r\n  // Return if we got a specific category (not 'outros')\r\n  if (category !== 'outros') {\r\n    return category;\r\n  }\r\n\r\n  // Fallback: try identifier-based classification for special cases (e.g., ESCADASROLANTES)\r\n  if (item.identifier) {\r\n    const categoryByIdentifier = classifyDeviceByIdentifier(item.identifier);\r\n    if (categoryByIdentifier && categoryByIdentifier !== 'outros') {\r\n      return categoryByIdentifier;\r\n    }\r\n  }\r\n\r\n  // Default: outros\r\n  return 'outros';\r\n}\r\n\r\n/**\r\n * Emite evento areacomum_breakdown\r\n * RFC-0056 FIX v1.1: TELEMETRY (AreaComum) ‚Üí TELEMETRY_INFO\r\n * RFC-0097: Classification by deviceType, subcategories by identifier\r\n */\r\nfunction emitAreaComumBreakdown(periodKey) {\r\n  try {\r\n    LogHelper.log(`[RFC-0097] emitAreaComumBreakdown: classification by deviceType`);\r\n\r\n    // Classificar dispositivos por categoria (consumo e contagem)\r\n    const breakdown = {\r\n      climatizacao: { total: 0, count: 0 },\r\n      elevadores: { total: 0, count: 0 },\r\n      escadas_rolantes: { total: 0, count: 0 },\r\n      outros: { total: 0, count: 0 },\r\n    };\r\n\r\n    // RFC-0097: Subcategorias de climatiza√ß√£o agrupadas por identifier (ou deviceType se identifier vazio)\r\n    // Mapa din√¢mico: key = identifier ou deviceType, value = { total, count, label }\r\n    const climatizacaoSubcategories = new Map();\r\n\r\n    // RFC-0097: Subcategorias de \"outros\" agrupadas por deviceType\r\n    const outrosSubcategories = new Map();\r\n\r\n    STATE.itemsEnriched.forEach((item) => {\r\n      const energia = item.value || 0;\r\n      const category = classifyDevice(item);\r\n\r\n      breakdown[category].total += energia;\r\n      breakdown[category].count += 1;\r\n\r\n      // RFC-0097: Agrupar subcategorias de climatiza√ß√£o por identifier (ou deviceType)\r\n      if (category === 'climatizacao') {\r\n        const identifier = String(item.identifier || '')\r\n          .toUpperCase()\r\n          .trim();\r\n        const deviceType = String(item.deviceType || '').toUpperCase();\r\n\r\n        // Usar identifier como chave de agrupamento, ou deviceType se identifier estiver vazio\r\n        let groupKey = identifier;\r\n        let groupLabel = identifier;\r\n\r\n        if (!identifier || identifier === 'N/A' || identifier === 'NULL' || identifier === 'UNDEFINED') {\r\n          groupKey = deviceType || 'OUTROS';\r\n          groupLabel = deviceType || 'Outros';\r\n        }\r\n\r\n        // Inicializar grupo se n√£o existir\r\n        if (!climatizacaoSubcategories.has(groupKey)) {\r\n          climatizacaoSubcategories.set(groupKey, {\r\n            total: 0,\r\n            count: 0,\r\n            label: groupLabel,\r\n          });\r\n        }\r\n\r\n        // Acumular valores\r\n        const group = climatizacaoSubcategories.get(groupKey);\r\n        group.total += energia;\r\n        group.count += 1;\r\n\r\n        // Debug: Log climatiza√ß√£o devices\r\n        /*\r\n        LogHelper.log(\r\n          `[RFC-0097] Climatiza√ß√£o: deviceType=\"${deviceType}\", identifier=\"${identifier}\", group=\"${groupKey}\", value=${energia.toFixed(\r\n            2\r\n          )} kWh`\r\n        );\r\n        */\r\n      }\r\n\r\n      // RFC-0097: Agrupar subcategorias de \"outros\" por deviceType (ou deviceProfile se 3F_MEDIDOR)\r\n      if (category === 'outros') {\r\n        let deviceType = String(item.deviceType || 'DESCONHECIDO')\r\n          .toUpperCase()\r\n          .trim();\r\n\r\n        // Se deviceType √© 3F_MEDIDOR, usar deviceProfile como tipo real\r\n        if (deviceType === '3F_MEDIDOR' && item.deviceProfile) {\r\n          deviceType = String(item.deviceProfile).toUpperCase().trim();\r\n        }\r\n\r\n        // Usar deviceType como chave de agrupamento\r\n        const groupKey = deviceType || 'DESCONHECIDO';\r\n        const groupLabel = deviceType || 'Desconhecido';\r\n\r\n        // Inicializar grupo se n√£o existir\r\n        if (!outrosSubcategories.has(groupKey)) {\r\n          outrosSubcategories.set(groupKey, {\r\n            total: 0,\r\n            count: 0,\r\n            label: groupLabel,\r\n          });\r\n        }\r\n\r\n        // Acumular valores\r\n        const group = outrosSubcategories.get(groupKey);\r\n        group.total += energia;\r\n        group.count += 1;\r\n      }\r\n\r\n      // Debug log for first 5 items\r\n      if (STATE.itemsEnriched.indexOf(item) < 5) {\r\n        LogHelper.log(\r\n          `[RFC-0097] Item: deviceType=\"${item.deviceType}\", identifier=\"${item.identifier}\", label=\"${item.label\r\n          }\" ‚Üí ${category} (${energia.toFixed(2)} kWh)`\r\n        );\r\n      }\r\n    });\r\n\r\n    // Converter Map para objeto para serializa√ß√£o\r\n    const climatizacaoSubcategoriesObj = {};\r\n    climatizacaoSubcategories.forEach((value, key) => {\r\n      climatizacaoSubcategoriesObj[key.toLowerCase()] = value;\r\n    });\r\n\r\n    // RFC-0097: Converter outros subcategories Map para objeto\r\n    const outrosSubcategoriesObj = {};\r\n    outrosSubcategories.forEach((value, key) => {\r\n      outrosSubcategoriesObj[key.toLowerCase()] = value;\r\n    });\r\n\r\n    // RFC-0097: Log subcategory totals for debugging\r\n    const subcatSummary = {};\r\n    climatizacaoSubcategories.forEach((value, key) => {\r\n      subcatSummary[key] = `${value.count} devices, ${normalizeToMWh(value.total)} MWh`;\r\n    });\r\n    LogHelper.log(`[RFC-0097] Climatiza√ß√£o subcategories breakdown:`, subcatSummary);\r\n\r\n    // RFC-0097: Log outros subcategory totals\r\n    const outrosSubcatSummary = {};\r\n    outrosSubcategories.forEach((value, key) => {\r\n      outrosSubcatSummary[key] = `${value.count} devices, ${normalizeToMWh(value.total)} MWh`;\r\n    });\r\n    LogHelper.log(`[RFC-0097] Outros subcategories breakdown:`, outrosSubcatSummary);\r\n\r\n    const payload = {\r\n      type: 'areacomum_breakdown',\r\n      domain: 'energy',\r\n      periodKey: periodKey,\r\n      timestamp: Date.now(),\r\n      source: 'TELEMETRY_AreaComum',\r\n      data: {\r\n        climatizacao_kWh: breakdown.climatizacao.total,\r\n        climatizacao_MWh: normalizeToMWh(breakdown.climatizacao.total),\r\n        climatizacao_count: breakdown.climatizacao.count,\r\n        elevadores_kWh: breakdown.elevadores.total,\r\n        elevadores_MWh: normalizeToMWh(breakdown.elevadores.total),\r\n        elevadores_count: breakdown.elevadores.count,\r\n        escadas_rolantes_kWh: breakdown.escadas_rolantes.total,\r\n        escadas_rolantes_MWh: normalizeToMWh(breakdown.escadas_rolantes.total),\r\n        escadas_rolantes_count: breakdown.escadas_rolantes.count,\r\n        outros_kWh: breakdown.outros.total,\r\n        outros_MWh: normalizeToMWh(breakdown.outros.total),\r\n        outros_count: breakdown.outros.count,\r\n        device_count: STATE.itemsEnriched.length,\r\n        // RFC-0097: Subcategorias de climatiza√ß√£o (objeto para serializa√ß√£o)\r\n        climatizacao_subcategories: climatizacaoSubcategoriesObj,\r\n        // RFC-0097: Subcategorias de \"outros\" agrupadas por deviceType\r\n        outros_subcategories: outrosSubcategoriesObj,\r\n      },\r\n    };\r\n\r\n    // Cache em sessionStorage\r\n    const cacheKey = `myio:telemetry:areacomum_${periodKey}`;\r\n    try {\r\n      sessionStorage.setItem(cacheKey, JSON.stringify(payload));\r\n    } catch (e) {\r\n      LogHelper.warn('[RFC-0056] sessionStorage write failed:', e);\r\n    }\r\n\r\n    // Dispatch consolidated event\r\n    const event = new CustomEvent('myio:telemetry:update', {\r\n      detail: payload,\r\n      bubbles: true,\r\n      cancelable: false,\r\n    });\r\n\r\n    window.dispatchEvent(event);\r\n\r\n    const totalMWh = normalizeToMWh(\r\n      breakdown.climatizacao.total +\r\n      breakdown.elevadores.total +\r\n      breakdown.escadas_rolantes.total +\r\n      breakdown.outros.total\r\n    );\r\n    LogHelper.log(\r\n      `[RFC-0056] ‚úÖ Emitted areacomum_breakdown: ${totalMWh} MWh (${STATE.itemsEnriched.length} devices, climatizacao: ${breakdown.climatizacao.count})`\r\n    );\r\n  } catch (err) {\r\n    LogHelper.error('[RFC-0056] Error in emitAreaComumBreakdown:', err);\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0002: Emit water telemetry data\r\n * Emits myio:telemetry:provide-water for TELEMETRY_INFO to consume\r\n * @param {string} widgetType - 'entrada', 'lojas', or 'areacomum' (detected from alias)\r\n * @param {string} periodKey - Period identifier\r\n */\r\nfunction emitWaterTelemetry(widgetType, periodKey) {\r\n  try {\r\n    // Check for waterContext override in settings\r\n    const waterContextOverride = self.ctx.settings?.waterContext;\r\n    let context = null;\r\n\r\n    // Use override if set and not 'auto'\r\n    if (waterContextOverride && waterContextOverride !== 'auto') {\r\n      context = waterContextOverride;\r\n      LogHelper.log(`[RFC-0002 Water] Using waterContext override: ${context}`);\r\n    } else {\r\n      // Map widgetType to water context (auto-detection from alias)\r\n      if (widgetType === 'entrada') {\r\n        context = 'entrada';\r\n      } else if (widgetType === 'lojas') {\r\n        context = 'lojas';\r\n      } else if (widgetType === 'areacomum') {\r\n        context = 'areaComum';\r\n      }\r\n    }\r\n\r\n    if (!context) {\r\n      LogHelper.warn(`[RFC-0002 Water] Unknown widget type: ${widgetType}`);\r\n      return;\r\n    }\r\n\r\n    // Calculate total in m¬≥\r\n    const totalM3 = STATE.itemsEnriched.reduce((sum, item) => sum + (item.value || 0), 0);\r\n\r\n    // Build device list\r\n    const devices = STATE.itemsEnriched.map((item) => ({\r\n      id: item.id || item.entityId || '',\r\n      label: item.label || item.name || '',\r\n      value: item.value || 0,\r\n      deviceType: item.deviceType || 'HIDROMETRO',\r\n    }));\r\n\r\n    // RFC-0002: For areaComum context, classify devices into banheiros vs outros\r\n    // Banheiros are identified by \"banheiro\" in label or identifier (case-insensitive)\r\n    let banheirosBreakdown = null;\r\n    if (context === 'areaComum') {\r\n      const banheirosDevices = [];\r\n      const outrosDevices = [];\r\n\r\n      devices.forEach((device) => {\r\n        const labelLower = (device.label || '').toLowerCase();\r\n        const idLower = (device.id || '').toLowerCase();\r\n        const isBanheiro = labelLower.includes('banheiro') || idLower.includes('banheiro');\r\n\r\n        if (isBanheiro) {\r\n          banheirosDevices.push(device);\r\n        } else {\r\n          outrosDevices.push(device);\r\n        }\r\n      });\r\n\r\n      const banheirosTotal = banheirosDevices.reduce((sum, d) => sum + (d.value || 0), 0);\r\n      const outrosTotal = outrosDevices.reduce((sum, d) => sum + (d.value || 0), 0);\r\n\r\n      banheirosBreakdown = {\r\n        banheiros: {\r\n          total: banheirosTotal,\r\n          devices: banheirosDevices,\r\n          count: banheirosDevices.length,\r\n        },\r\n        outros: {\r\n          total: outrosTotal,\r\n          devices: outrosDevices,\r\n          count: outrosDevices.length,\r\n        },\r\n      };\r\n\r\n      LogHelper.log(\r\n        `[RFC-0002 Water] areaComum breakdown: banheiros=${banheirosTotal.toFixed(2)} m¬≥ (${banheirosDevices.length\r\n        } devices), outros=${outrosTotal.toFixed(2)} m¬≥ (${outrosDevices.length} devices)`\r\n      );\r\n    }\r\n\r\n    const payload = {\r\n      context: context,\r\n      domain: 'water',\r\n      total: totalM3,\r\n      devices: devices,\r\n      periodKey: periodKey,\r\n      timestamp: new Date().toISOString(),\r\n      // RFC-0002: Include banheiros breakdown for areaComum context\r\n      banheirosBreakdown: banheirosBreakdown,\r\n    };\r\n\r\n    // Dispatch water event\r\n    const event = new CustomEvent('myio:telemetry:provide-water', {\r\n      detail: payload,\r\n      bubbles: true,\r\n      cancelable: false,\r\n    });\r\n\r\n    window.dispatchEvent(event);\r\n\r\n    LogHelper.log(\r\n      `[RFC-0002 Water] ‚úÖ Emitted water telemetry: context=${context}, total=${totalM3.toFixed(\r\n        2\r\n      )} m¬≥, devices=${devices.length}`\r\n    );\r\n  } catch (err) {\r\n    LogHelper.error('[RFC-0002 Water] Error in emitWaterTelemetry:', err);\r\n  }\r\n}\r\n\r\n/** ===================== RECOMPUTE (local only) ===================== **/\r\nfunction reflowFromState() {\r\n  const visible = applyFilters(STATE.itemsEnriched, STATE.searchTerm, STATE.selectedIds, STATE.sortMode);\r\n  const { visible: withPerc, groupSum } = recomputePercentages(visible);\r\n  renderHeader(withPerc.length, groupSum);\r\n  renderList(withPerc);\r\n}\r\n\r\n/** ===================== HYDRATE (end-to-end) ===================== **/\r\nasync function hydrateAndRender() {\r\n  if (hydrating) return;\r\n  hydrating = true;\r\n\r\n  // Mostra modal durante todo o processo (mensagem fixa)\r\n  showBusy();\r\n\r\n  try {\r\n    // 0) Datas: verificar se existem (n√£o obrigat√≥rias para energy/water - s√≥ para API call)\r\n    let range = null;\r\n    let hasDateRange = false;\r\n    try {\r\n      range = mustGetDateRange();\r\n      hasDateRange = true;\r\n    } catch (_e) {\r\n      // For energy/water domains, continue rendering UI even without dates\r\n      // Just skip the API call for totals\r\n      if (WIDGET_DOMAIN === 'energy' || WIDGET_DOMAIN === 'water') {\r\n        LogHelper.warn(\r\n          '[DeviceCards] No date range set, but continuing for energy/water domain - buttons will be enabled'\r\n        );\r\n      } else {\r\n        LogHelper.warn('[DeviceCards] Aguardando intervalo de datas (startDateISO/endDateISO).');\r\n        return;\r\n      }\r\n    }\r\n\r\n    // 1) Auth (skip for temperature domain - no API calls needed)\r\n    // Also skip if no date range (no API call will be made anyway)\r\n    if (WIDGET_DOMAIN !== 'temperature' && hasDateRange) {\r\n      const okAuth = await ensureAuthReady(6000, 150);\r\n      if (!okAuth) {\r\n        LogHelper.warn('[DeviceCards] Auth not ready; adiando hidrata√ß√£o.');\r\n        return;\r\n      }\r\n    } else {\r\n      LogHelper.log('[DeviceCards] Skipping auth check - temperature domain or no date range');\r\n    }\r\n\r\n    // 2) Lista autoritativa\r\n    STATE.itemsBase = buildAuthoritativeItems();\r\n    // Expose for temperature tooltip\r\n    window._telemetryAuthoritativeItems = STATE.itemsBase;\r\n\r\n    // 3) Totais na API (skip for temperature domain - uses only ctx.data telemetry)\r\n    // Also skip if no date range\r\n    let apiMap = new Map();\r\n    if (WIDGET_DOMAIN !== 'temperature' && hasDateRange && range) {\r\n      try {\r\n        apiMap = await fetchApiTotals(range.startISO, range.endISO);\r\n      } catch (err) {\r\n        LogHelper.error('[DeviceCards] API error:', err);\r\n        apiMap = new Map();\r\n      }\r\n    } else {\r\n      LogHelper.log(\r\n        '[DeviceCards] Skipping API fetch - temperature domain or no date range - using ctx.data only'\r\n      );\r\n    }\r\n\r\n    // 4) Enrich + render\r\n    STATE.itemsEnriched = enrichItemsWithTotals(STATE.itemsBase, apiMap);\r\n\r\n    // 5) Sanitiza sele√ß√£o\r\n    if (STATE.selectedIds && STATE.selectedIds.size) {\r\n      const valid = new Set(STATE.itemsBase.map((x) => x.id));\r\n      const next = new Set([...STATE.selectedIds].filter((id) => valid.has(id)));\r\n      STATE.selectedIds = next.size ? next : null;\r\n    }\r\n\r\n    reflowFromState();\r\n  } finally {\r\n    hydrating = false;\r\n    hideBusy();\r\n  }\r\n}\r\n\r\n/** ===================== TB LIFE CYCLE ===================== **/\r\nself.onInit = async function () {\r\n  $(self.ctx.$container).css({\r\n    height: '100%',\r\n    overflow: 'hidden',\r\n    display: 'flex',\r\n    flexDirection: 'column',\r\n    position: 'relative',\r\n  });\r\n\r\n  MyIO = (typeof MyIOLibrary !== 'undefined' && MyIOLibrary) ||\r\n    (typeof window !== 'undefined' && window.MyIOLibrary) || {\r\n    showAlert: function () {\r\n      alert('A Bliblioteca Myio n√£o foi carregada corretamente!');\r\n    },\r\n  };\r\n\r\n  $root().find('#labelWidgetId').text(self.ctx.settings?.labelWidget);\r\n\r\n  // RFC-0042: Set widget configuration from settings FIRST\r\n  WIDGET_DOMAIN = self.ctx.settings?.DOMAIN || 'energy';\r\n  LogHelper.log(`[TELEMETRY] Configured EARLY: domain=${WIDGET_DOMAIN}`);\r\n\r\n  // Show temperature info icon for temperature domain\r\n  if (WIDGET_DOMAIN === 'temperature') {\r\n    const tempInfoTrigger = $root().find('#tempInfoTrigger');\r\n    if (tempInfoTrigger.length) {\r\n      tempInfoTrigger.css('display', 'inline-flex');\r\n\r\n      // Use TempSensorSummaryTooltip from myio-js-library (premium tooltip with drag, pin, maximize, close)\r\n      if (MyIO?.TempSensorSummaryTooltip) {\r\n        // Attach using the library component\r\n        _tempTooltipCleanup = MyIO.TempSensorSummaryTooltip.attach(\r\n          tempInfoTrigger[0],\r\n          buildTempSensorSummaryData\r\n        );\r\n        LogHelper.log('[TELEMETRY] Temperature info icon initialized with TempSensorSummaryTooltip (library)');\r\n      } else {\r\n        // Fallback to legacy tooltip if library not available\r\n        tempInfoTrigger.on('mouseenter', function (e) {\r\n          showTempInfoTooltip(this);\r\n        });\r\n        tempInfoTrigger.on('mouseleave', function () {\r\n          hideTempInfoTooltip();\r\n        });\r\n        LogHelper.warn('[TELEMETRY] TempSensorSummaryTooltip not found in library, using legacy tooltip');\r\n      }\r\n    }\r\n  }\r\n\r\n  // RFC-0063: Load classification mode configuration\r\n  USE_IDENTIFIER_CLASSIFICATION = self.ctx.settings?.USE_IDENTIFIER_CLASSIFICATION || false;\r\n  USE_HYBRID_CLASSIFICATION = self.ctx.settings?.USE_HYBRID_CLASSIFICATION || false;\r\n  LogHelper.log(\r\n    `[RFC-0063] Classification mode: ${USE_IDENTIFIER_CLASSIFICATION\r\n      ? USE_HYBRID_CLASSIFICATION\r\n        ? 'HYBRID (identifier + label fallback)'\r\n        : 'IDENTIFIER ONLY'\r\n      : 'LEGACY (label only)'\r\n    }`\r\n  );\r\n\r\n  // RFC-0042: Request data from orchestrator (defined early for use in handlers)\r\n  function requestDataFromOrchestrator() {\r\n    const hasDateRange = self.ctx.scope?.startDateISO && self.ctx.scope?.endDateISO;\r\n\r\n    if (!hasDateRange) {\r\n      LogHelper.warn('[TELEMETRY] No date range set');\r\n\r\n      // For energy/water domains, still render UI to enable buttons (skip API call)\r\n      if (WIDGET_DOMAIN === 'energy' || WIDGET_DOMAIN === 'water') {\r\n        LogHelper.log('[TELEMETRY] Energy/Water domain - rendering UI without data fetch');\r\n        if (typeof hydrateAndRender === 'function') {\r\n          hydrateAndRender();\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    const period = {\r\n      startISO: self.ctx.scope.startDateISO,\r\n      endISO: self.ctx.scope.endDateISO,\r\n      granularity: window.calcGranularity\r\n        ? window.calcGranularity(self.ctx.scope.startDateISO, self.ctx.scope.endDateISO)\r\n        : 'day',\r\n      tz: 'America/Sao_Paulo',\r\n    };\r\n\r\n    LogHelper.log(`[TELEMETRY] Requesting data for domain=${WIDGET_DOMAIN}, period:`, period);\r\n\r\n    // RFC-0053: Single window context - emit to current window only\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:telemetry:request-data', {\r\n        detail: { domain: WIDGET_DOMAIN, period },\r\n      })\r\n    );\r\n  }\r\n\r\n  // Listener com modal: evento externo de mudan√ßa de data\r\n  dateUpdateHandler = function (ev) {\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ DATE UPDATE EVENT RECEIVED!`, ev.detail);\r\n\r\n    try {\r\n      // RFC-0042: Handle both old and new format\r\n      let startISO, endISO;\r\n\r\n      if (ev.detail?.period) {\r\n        // New format from HEADER\r\n        startISO = ev.detail.period.startISO;\r\n        endISO = ev.detail.period.endISO;\r\n        LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] Using NEW format (period object)`);\r\n      } else {\r\n        // Old format (backward compatibility)\r\n        const { startDate, endDate } = ev.detail || {};\r\n        startISO = new Date(startDate).toISOString();\r\n        endISO = new Date(endDate).toISOString();\r\n        LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] Using OLD format (startDate/endDate)`);\r\n      }\r\n\r\n      LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] Date range updated:`, startISO, endISO);\r\n\r\n      // Datas mandat√≥rias salvas no scope\r\n      self.ctx.scope = self.ctx.scope || {};\r\n      self.ctx.scope.startDateISO = startISO;\r\n      self.ctx.scope.endDateISO = endISO;\r\n\r\n      // IMPORTANT: Reset lastProcessedPeriodKey when new date range is selected\r\n      // This allows processing fresh data for the new period\r\n      lastProcessedPeriodKey = null;\r\n      LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] üîÑ Reset lastProcessedPeriodKey for new date range`);\r\n\r\n      // Exibe modal\r\n      LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] üîÑ Calling showBusy()...`);\r\n      showBusy();\r\n      LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ showBusy() called`);\r\n\r\n      // RFC-0045 FIX: Check if there's a pending provide-data event waiting for this period\r\n      if (pendingProvideData) {\r\n        LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ Found pending provide-data event, processing now...`);\r\n        const pending = pendingProvideData;\r\n        pendingProvideData = null; // Clear pending event\r\n\r\n        // Process the pending event immediately\r\n        dataProvideHandler({ detail: pending });\r\n        return; // Don't request data again, we already have it\r\n      }\r\n\r\n      // For temperature domain, use hydrateAndRender directly (no API needed, uses ctx.data only)\r\n      if (WIDGET_DOMAIN === 'temperature') {\r\n        LogHelper.log(\r\n          `[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ Temperature domain - using hydrateAndRender directly (no orchestrator)`\r\n        );\r\n        hasRequestedInitialData = true;\r\n\r\n        if (typeof hydrateAndRender === 'function') {\r\n          hydrateAndRender();\r\n        } else {\r\n          LogHelper.error(`[TELEMETRY ${WIDGET_DOMAIN}] hydrateAndRender n√£o encontrada.`);\r\n        }\r\n      } else {\r\n        // RFC-0053: Direct access to orchestrator (single window context)\r\n        const orchestrator = window.MyIOOrchestrator;\r\n\r\n        if (orchestrator) {\r\n          LogHelper.log(\r\n            `[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ RFC-0053: Requesting data from orchestrator (single window)`\r\n          );\r\n\r\n          // IMPORTANT: Mark as requested BEFORE calling requestDataFromOrchestrator\r\n          // This prevents the setTimeout(500ms) from making a duplicate request\r\n          hasRequestedInitialData = true;\r\n\r\n          requestDataFromOrchestrator();\r\n        } else {\r\n          // Fallback to old behavior\r\n          LogHelper.warn(`[TELEMETRY ${WIDGET_DOMAIN}] ‚ö†Ô∏è Orchestrator not available, using legacy fetch`);\r\n\r\n          if (typeof hydrateAndRender === 'function') {\r\n            hydrateAndRender();\r\n          } else {\r\n            LogHelper.error(`[TELEMETRY ${WIDGET_DOMAIN}] hydrateAndRender n√£o encontrada.`);\r\n          }\r\n        }\r\n      }\r\n    } catch (err) {\r\n      LogHelper.error(`[TELEMETRY ${WIDGET_DOMAIN}] dateUpdateHandler error:`, err);\r\n      hideBusy();\r\n    }\r\n  };\r\n\r\n  LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] üì° Registering myio:update-date listener...`);\r\n  window.addEventListener('myio:update-date', dateUpdateHandler);\r\n  LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ myio:update-date listener registered!`);\r\n\r\n  // RFC-0042: Listen for clear event from HEADER (when user clicks \"Limpar\" button)\r\n  window.addEventListener('myio:telemetry:clear', (ev) => {\r\n    const { domain } = ev.detail;\r\n\r\n    // Only clear if it's for my domain\r\n    if (domain !== WIDGET_DOMAIN) {\r\n      LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] Ignoring clear event for domain: ${domain}`);\r\n      return;\r\n    }\r\n\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] üßπ Received clear event - clearing visual content`);\r\n\r\n    try {\r\n      // Clear the items list\r\n      STATE.itemsBase = [];\r\n      STATE.itemsEnriched = [];\r\n      STATE.selectedIds = null;\r\n\r\n      // IMPORTANT: Use $root() to get elements within THIS widget's scope\r\n      const $widget = $root();\r\n\r\n      // Clear the visual list\r\n      const $shopsList = $widget.find('#shopsList');\r\n      if ($shopsList.length > 0) {\r\n        $shopsList.empty();\r\n        LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ shopsList cleared`);\r\n      }\r\n\r\n      // Reset counts to 0\r\n      const $shopsCount = $widget.find('#shopsCount');\r\n      const $shopsTotal = $widget.find('#shopsTotal');\r\n\r\n      if ($shopsCount.length > 0) {\r\n        $shopsCount.text('(0)');\r\n        LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ shopsCount reset to 0`);\r\n      }\r\n\r\n      if ($shopsTotal.length > 0) {\r\n        $shopsTotal.text('0,00');\r\n        LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ shopsTotal reset to 0,00`);\r\n      }\r\n\r\n      LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] üßπ Clear completed successfully`);\r\n    } catch (err) {\r\n      LogHelper.error(`[TELEMETRY ${WIDGET_DOMAIN}] ‚ùå Error during clear:`, err);\r\n    }\r\n  });\r\n\r\n  // Test if listener is working\r\n  setTimeout(() => {\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] üß™ Testing listener registration...`);\r\n    const testEvent = new CustomEvent('myio:update-date', {\r\n      detail: {\r\n        period: {\r\n          startISO: '2025-09-26T00:00:00-03:00',\r\n          endISO: '2025-10-02T23:59:59-03:00',\r\n          granularity: 'day',\r\n          tz: 'America/Sao_Paulo',\r\n        },\r\n      },\r\n    });\r\n    // Don't dispatch, just check if handler exists\r\n    if (typeof dateUpdateHandler === 'function') {\r\n      LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ dateUpdateHandler is defined and ready`);\r\n    } else {\r\n      LogHelper.error(`[TELEMETRY ${WIDGET_DOMAIN}] ‚ùå dateUpdateHandler is NOT defined!`);\r\n    }\r\n  }, 100);\r\n\r\n  // RFC-0045 FIX: Store pending provide-data events that arrive before update-date\r\n  let pendingProvideData = null;\r\n\r\n  // RFC-0042: Listen for data provision from orchestrator\r\n  dataProvideHandler = function (ev) {\r\n    LogHelper.log(\r\n      `[TELEMETRY ${WIDGET_DOMAIN}] üì¶ Received provide-data event for domain ${ev.detail.domain\r\n      }, periodKey: ${ev.detail.periodKey}, items: ${ev.detail.items?.length || 0}`\r\n    );\r\n    const { domain, periodKey, items } = ev.detail;\r\n\r\n    // Only process if it's for my domain\r\n    if (domain !== WIDGET_DOMAIN) {\r\n      LogHelper.log(\r\n        `[TELEMETRY ${WIDGET_DOMAIN}] ‚è≠Ô∏è Ignoring event for domain ${domain}, my domain is ${WIDGET_DOMAIN}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    // IMPORTANT: Prevent duplicate processing of the same periodKey\r\n    // The Orchestrator retries emission after 1s, so we need to deduplicate\r\n    if (lastProcessedPeriodKey === periodKey) {\r\n      LogHelper.log(`[TELEMETRY] ‚è≠Ô∏è Skipping duplicate provide-data for periodKey: ${periodKey}`);\r\n      return;\r\n    }\r\n\r\n    // Validate current period matches\r\n    const myPeriod = {\r\n      startISO: self.ctx.scope?.startDateISO,\r\n      endISO: self.ctx.scope?.endDateISO,\r\n    };\r\n\r\n    // RFC-0045 FIX: If period not set yet, STORE the event and wait for myio:update-date\r\n    if (!myPeriod.startISO || !myPeriod.endISO) {\r\n      LogHelper.warn(`[TELEMETRY] ‚è∏Ô∏è Period not set yet, storing provide-data event for later processing`);\r\n      pendingProvideData = { domain, periodKey, items };\r\n      // DON'T call hideBusy() here - wait for update-date to process the data\r\n      return;\r\n    }\r\n\r\n    // Mark this periodKey as processed ONLY when actually processing\r\n    lastProcessedPeriodKey = periodKey;\r\n\r\n    // IMPORTANT: Do NOT call showBusy() here - it was already called in dateUpdateHandler\r\n    // Calling it again creates a NEW timeout that won't be properly cancelled\r\n    LogHelper.log(`[TELEMETRY] üîÑ Processing data from orchestrator...`);\r\n    LogHelper.log(`[TELEMETRY] Received ${items.length} items from orchestrator for domain ${domain}`);\r\n\r\n    // Extract my datasource IDs\r\n    const myDatasourceIds = extractDatasourceIds(self.ctx.datasources);\r\n    //LogHelper.log(`[TELEMETRY] My datasource IDs:`, myDatasourceIds);\r\n    //LogHelper.log(`[TELEMETRY] Sample orchestrator items:`, items.slice(0, 3));\r\n\r\n    // RFC-0042: Debug datasources structure to understand the mapping\r\n    /*\r\n    if (self.ctx.datasources && self.ctx.datasources.length > 0) {\r\n      LogHelper.log(`[TELEMETRY] Datasource[0] keys:`, Object.keys(self.ctx.datasources[0]));\r\n      LogHelper.log(`[TELEMETRY] Datasource[0] entityId:`, self.ctx.datasources[0].entityId);\r\n      LogHelper.log(`[TELEMETRY] Datasource[0] entityName:`, self.ctx.datasources[0].entityName);\r\n      LogHelper.log(`[TELEMETRY] Datasource[0] full:`, JSON.stringify(self.ctx.datasources[0], null, 2));\r\n    }\r\n    if (self.ctx.data && self.ctx.data.length > 0) {\r\n      LogHelper.log(`[TELEMETRY] Data[0] keys:`, Object.keys(self.ctx.data[0]));\r\n      LogHelper.log(`[TELEMETRY] Data[0] full:`, JSON.stringify(self.ctx.data[0], null, 2));\r\n    }\r\n      */\r\n\r\n    // Data filtering is done by datasource IDs (ThingsBoard handles grouping)\r\n\r\n    // RFC-0042: Filter items by datasource IDs\r\n    // ThingsBoard datasource entityId should match API item id (ingestionId)\r\n    const datasourceIdSet = new Set(myDatasourceIds);\r\n    let filtered = items.filter((item) => {\r\n      // Check if item.id (from API) matches any datasource entityId\r\n      return datasourceIdSet.has(item.id) || datasourceIdSet.has(item.tbId);\r\n    });\r\n\r\n    LogHelper.log(\r\n      `[TELEMETRY] Filtered ${items.length} items down to ${filtered.length} items matching datasources`\r\n    );\r\n\r\n    // If no matches, log warning and use all items (temporary fallback)\r\n    if (filtered.length === 0) {\r\n      LogHelper.warn(`[TELEMETRY] No items match datasource IDs! Using all items as fallback.`);\r\n      LogHelper.warn(`[TELEMETRY] Sample datasource ID:`, myDatasourceIds[0]);\r\n      LogHelper.warn(`[TELEMETRY] Sample API item ID:`, items[0]?.id);\r\n      filtered = items;\r\n    }\r\n\r\n    // Convert orchestrator items to TELEMETRY widget format\r\n    filtered = filtered.map((item) => ({\r\n      id: item.tbId || item.id,\r\n      tbId: item.tbId || item.id,\r\n      ingestionId: item.ingestionId || item.id,\r\n      identifier: item.identifier || item.id,\r\n      label: item.label || item.identifier || item.id,\r\n      value: Number(item.value || 0),\r\n      perc: 0,\r\n      deviceType: item.deviceType || 'energy',\r\n      slaveId: item.slaveId || null,\r\n      centralId: item.centralId || null,\r\n      updatedIdentifiers: {},\r\n    }));\r\n\r\n    // DEBUG: Log sample item with value\r\n    if (filtered.length > 0 && filtered[0].value > 0) {\r\n      LogHelper.log(`[TELEMETRY] üîç Sample orchestrator item after mapping:`, {\r\n        ingestionId: filtered[0].ingestionId,\r\n        label: filtered[0].label,\r\n        value: filtered[0].value,\r\n      });\r\n    }\r\n\r\n    LogHelper.log(`[TELEMETRY] Using ${filtered.length} items after processing`);\r\n\r\n    // IMPORTANT: Merge orchestrator data with existing TB data\r\n    // Keep original labels/identifiers from TB, only update values from orchestrator\r\n    STATE.itemsBase = buildAuthoritativeItems();\r\n    window._telemetryAuthoritativeItems = STATE.itemsBase;\r\n\r\n    // Create map of orchestrator values by ingestionId\r\n    const orchestratorValues = new Map();\r\n    filtered.forEach((item) => {\r\n      if (item.ingestionId) {\r\n        const value = Number(item.value || 0);\r\n        orchestratorValues.set(item.ingestionId, value);\r\n\r\n        // Debug: log non-zero values from API\r\n        if (value > 0) {\r\n          //LogHelper.log(`[TELEMETRY] ‚úÖ Orchestrator has data: ${item.label} (${item.ingestionId}) = ${value}`);\r\n        }\r\n      }\r\n    });\r\n    LogHelper.log(`[TELEMETRY] Orchestrator values map size: ${orchestratorValues.size}`);\r\n\r\n    // Update values in existing items\r\n    STATE.itemsEnriched = STATE.itemsBase.map((tbItem) => {\r\n      const orchestratorValue = orchestratorValues.get(tbItem.ingestionId);\r\n\r\n      // TANK/CAIXA_DAGUA devices: use telemetry data from TB, NOT from orchestrator API\r\n      const isTankDevice = tbItem.deviceType === 'TANK' || tbItem.deviceType === 'CAIXA_DAGUA';\r\n\r\n      // DEBUG: Log matching process for all items\r\n      if (orchestratorValue !== undefined && orchestratorValue > 0) {\r\n        //LogHelper.log(`[TELEMETRY] ‚úÖ MATCH FOUND: ${tbItem.label} (ingestionId: ${tbItem.ingestionId}) = ${orchestratorValue}`);\r\n      } else {\r\n        //LogHelper.warn(`[TELEMETRY] ‚ùå NO MATCH: ${tbItem.label} (ingestionId: ${tbItem.ingestionId}), orchestrator=${orchestratorValue}, TB=${tbItem.value}`);\r\n      }\r\n\r\n      // For TANK devices, preserve the telemetry values (don't overwrite with API)\r\n      if (isTankDevice) {\r\n        return {\r\n          ...tbItem,\r\n          // Keep ALL values from buildAuthoritativeItems (waterLevel, waterPercentage, value, perc)\r\n          value: tbItem.value || 0,\r\n          perc: tbItem.perc || 0,\r\n          waterLevel: tbItem.waterLevel || 0,\r\n          waterPercentage: tbItem.waterPercentage || 0,\r\n        };\r\n      }\r\n\r\n      // For other devices, use orchestrator API values\r\n      return {\r\n        ...tbItem,\r\n        value: orchestratorValue !== undefined ? orchestratorValue : tbItem.value || 0,\r\n        perc: 0,\r\n      };\r\n    });\r\n\r\n    LogHelper.log(`[TELEMETRY] Enriched ${STATE.itemsEnriched.length} items with orchestrator values`);\r\n\r\n    // RFC-0056 FIX v1.1: Emit telemetry update after enrichment\r\n    emitTelemetryUpdate();\r\n\r\n    // Sanitize selection\r\n    if (STATE.selectedIds && STATE.selectedIds.size) {\r\n      const valid = new Set(STATE.itemsBase.map((x) => x.id));\r\n      const next = new Set([...STATE.selectedIds].filter((id) => valid.has(id)));\r\n      STATE.selectedIds = next.size ? next : null;\r\n    }\r\n\r\n    reflowFromState();\r\n\r\n    // RFC-0044: ALWAYS hide busy when data is provided, regardless of source\r\n    LogHelper.log(`[TELEMETRY] üèÅ Data processed successfully - ensuring busy is hidden`);\r\n\r\n    // Force hide busy with minimal delay to ensure UI update\r\n    setTimeout(() => {\r\n      hideBusy();\r\n      // Double-check: if orchestrator busy is still showing, force hide it\r\n      if (window.MyIOOrchestrator && window.MyIOOrchestrator.getBusyState) {\r\n        const busyState = window.MyIOOrchestrator.getBusyState();\r\n        if (busyState.isVisible) {\r\n          LogHelper.warn(\r\n            `[TELEMETRY] ‚ö†Ô∏è Orchestrator busy still visible after data processing - force hiding`\r\n          );\r\n          window.MyIOOrchestrator.hideGlobalBusy();\r\n        }\r\n      }\r\n    }, 100); // Reduced to 100ms for faster response\r\n  };\r\n\r\n  /**\r\n   * Extracts ingestionIds from ThingsBoard ctx.data (not datasource entityIds).\r\n   * Each device has 6 keys (slaveId, centralId, ingestionId, connectionStatus, deviceType, identifier).\r\n   * We need to extract the ingestionId values to match with API data.\r\n   */\r\n  function extractDatasourceIds(datasources) {\r\n    // Build index from ctx.data to get ingestionId for each device\r\n    const ingestionIds = new Set();\r\n    const rows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\r\n\r\n    for (const row of rows) {\r\n      const key = String(row?.dataKey?.name || '').toLowerCase();\r\n      const val = row?.data?.[0]?.[1];\r\n\r\n      if (key === 'ingestionid' && val && isValidUUID(String(val))) {\r\n        ingestionIds.add(String(val));\r\n      }\r\n    }\r\n\r\n    return Array.from(ingestionIds);\r\n  }\r\n\r\n  window.addEventListener('myio:telemetry:provide-data', dataProvideHandler);\r\n\r\n  // RFC-0056 FIX v1.1: Listen for request_refresh from TELEMETRY_INFO\r\n  let requestRefreshHandler = function (ev) {\r\n    const { type, domain, periodKey } = ev.detail || {};\r\n\r\n    if (type !== 'request_refresh') return;\r\n    if (domain !== WIDGET_DOMAIN) return;\r\n\r\n    LogHelper.log(`[RFC-0056] Received request_refresh for domain ${domain}, periodKey ${periodKey}`);\r\n\r\n    // Re-emit telemetry data\r\n    const currentPeriodKey = buildPeriodKey();\r\n    if (currentPeriodKey === periodKey) {\r\n      LogHelper.log(`[RFC-0056] Re-emitting data for current period`);\r\n      emitTelemetryUpdate();\r\n    } else {\r\n      LogHelper.warn(`[RFC-0056] Period mismatch: requested ${periodKey}, current ${currentPeriodKey}`);\r\n    }\r\n  };\r\n\r\n  window.addEventListener('myio:telemetry:update', requestRefreshHandler);\r\n\r\n  // Check for stored data from orchestrator (in case we missed the event)\r\n  setTimeout(() => {\r\n    // RFC-0053: Direct access to orchestrator data (single window context)\r\n    const orchestratorData = window.MyIOOrchestratorData;\r\n\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] üîç Checking for stored orchestrator data...`);\r\n\r\n    // First, try stored data\r\n    if (orchestratorData && orchestratorData[WIDGET_DOMAIN]) {\r\n      const storedData = orchestratorData[WIDGET_DOMAIN];\r\n      const age = Date.now() - storedData.timestamp;\r\n\r\n      LogHelper.log(\r\n        `[TELEMETRY ${WIDGET_DOMAIN}] Found stored data: ${storedData.items?.length || 0\r\n        } items, age: ${age}ms`\r\n      );\r\n\r\n      // Use stored data if it's less than 30 seconds old AND has items\r\n      if (age < 30000 && storedData.items && storedData.items.length > 0) {\r\n        LogHelper.log(\r\n          `[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ RFC-0053: Using stored orchestrator data (single window)`\r\n        );\r\n        dataProvideHandler({\r\n          detail: {\r\n            domain: WIDGET_DOMAIN,\r\n            periodKey: storedData.periodKey,\r\n            items: storedData.items,\r\n          },\r\n        });\r\n        return;\r\n      } else {\r\n        LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚ö†Ô∏è Stored data is too old or empty, ignoring`);\r\n      }\r\n    } else {\r\n      LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚ÑπÔ∏è No stored data found for domain ${WIDGET_DOMAIN}`);\r\n    }\r\n\r\n    // If no stored data AND we haven't requested yet, request fresh data\r\n    if (!hasRequestedInitialData) {\r\n      // For temperature domain, use hydrateAndRender directly (no orchestrator needed)\r\n      if (WIDGET_DOMAIN === 'temperature') {\r\n        LogHelper.log(\r\n          `[TELEMETRY ${WIDGET_DOMAIN}] üì° Temperature domain - calling hydrateAndRender directly...`\r\n        );\r\n        hasRequestedInitialData = true;\r\n        hydrateAndRender();\r\n      } else {\r\n        LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] üì° Requesting fresh data from orchestrator...`);\r\n        requestDataFromOrchestrator();\r\n      }\r\n    } else {\r\n      LogHelper.log(\r\n        `[TELEMETRY ${WIDGET_DOMAIN}] ‚è≠Ô∏è Skipping duplicate request (already requested via event)`\r\n      );\r\n    }\r\n  }, 500); // Wait 500ms for widget to fully initialize\r\n\r\n  // Auth do cliente/ingestion\r\n  // RFC-0091: Use shared customerTB_ID from MAIN widget via window.MyIOUtils\r\n  const customerTB_ID = window.MyIOUtils?.customerTB_ID;\r\n  if (!customerTB_ID) {\r\n    console.error(\r\n      '[TELEMETRY] customerTB_ID not available from window.MyIOUtils - MAIN widget must load first'\r\n    );\r\n  }\r\n  //DEVICE_TYPE = self.ctx.settings?.DEVICE_TYPE || \"energy\";\r\n  const jwt = localStorage.getItem('jwt_token');\r\n\r\n  const boolExecSync = new URLSearchParams(window.location.search).get('boolExecSync') === 'true';\r\n\r\n  // RFC-0071: Trigger device profile synchronization (runs once)\r\n  if (!__deviceProfileSyncComplete && boolExecSync) {\r\n    try {\r\n      console.log('[EQUIPMENTS] [RFC-0071] Triggering device profile sync...');\r\n      const syncResult = await syncDeviceProfileAttributes();\r\n      __deviceProfileSyncComplete = true;\r\n\r\n      if (syncResult.synced > 0) {\r\n        console.log(\r\n          '[EQUIPMENTS] [RFC-0071] ‚ö†Ô∏è Widget reload recommended to load new deviceProfile attributes'\r\n        );\r\n        console.log(\r\n          '[EQUIPMENTS] [RFC-0071] You may need to refresh the dashboard to see deviceProfile in ctx.data'\r\n        );\r\n      }\r\n    } catch (error) {\r\n      console.error('[EQUIPMENTS] [RFC-0071] Sync failed, continuing without it:', error);\r\n      // Don't block widget initialization if sync fails\r\n    }\r\n  }\r\n\r\n  try {\r\n    const attrs = await MyIO.fetchThingsboardCustomerAttrsFromStorage(customerTB_ID, jwt);\r\n    CLIENT_ID = attrs?.client_id || '';\r\n    CLIENT_SECRET = attrs?.client_secret || '';\r\n    CUSTOMER_ING_ID = attrs?.ingestionId || '';\r\n// Carrega o mapa\r\n    MAP_INSTANTANEOUS_POWER = attrs?.mapInstantaneousPower ? JSON.parse(attrs?.mapInstantaneousPower) : null;\r\n\r\n    // [CORRE√á√ÉO CR√çTICA]\r\n    // Se o mapa chegou AGORA, precisamos re-executar a l√≥gica de enriquecimento\r\n    // para garantir que os ranges sejam aplicados aos cards que j√° podem ter sido renderizados pelo Orchestrator.\r\n    if (MAP_INSTANTANEOUS_POWER) {\r\n        LogHelper.log('[TELEMETRY] Mapa de Pot√™ncia carregado. For√ßando atualiza√ß√£o dos ranges...');\r\n        \r\n        // 1. Reconstr√≥i a base (agora com ranges garantidos)\r\n        const newBase = buildAuthoritativeItems();\r\n        STATE.itemsBase = newBase;\r\n        window._telemetryAuthoritativeItems = STATE.itemsBase;\r\n\r\n        // 2. Se j√° t√≠nhamos dados de consumo do Orchestrator, reaplique-os\r\n        if (STATE.itemsEnriched && STATE.itemsEnriched.length > 0) {\r\n            const valuesMap = new Map();\r\n            STATE.itemsEnriched.forEach(i => {\r\n                if (i.ingestionId) valuesMap.set(i.ingestionId, i.value);\r\n            });\r\n\r\n            STATE.itemsEnriched = STATE.itemsBase.map(baseItem => {\r\n                const existingVal = valuesMap.get(baseItem.ingestionId);\r\n                return {\r\n                    ...baseItem,\r\n                    value: existingVal !== undefined ? existingVal : (baseItem.value || 0),\r\n                    perc: 0\r\n                };\r\n            });\r\n            \r\n            // 3. Redesenha a tela imediatamente\r\n            reflowFromState();\r\n            LogHelper.log('[TELEMETRY] Cards atualizados com sucesso ap√≥s carga do mapa.');\r\n        }\r\n    }\r\n    if (MAP_INSTANTANEOUS_POWER && STATE.itemsBase && STATE.itemsBase.length > 0) {\r\n      LogHelper.log('[TELEMETRY] Mapa de Pot√™ncia carregado tardiamente. Reconstruindo ranges...');\r\n\r\n      // 1. Reconstr√≥i a estrutura base (agora ele vai encontrar o MAP_INSTANTANEOUS_POWER)\r\n      STATE.itemsBase = buildAuthoritativeItems();\r\n      window._telemetryAuthoritativeItems = STATE.itemsBase;\r\n\r\n      // 2. Preserva os valores de API/Orchestrator que j√° t√≠nhamos nos itens enriquecidos\r\n      if (STATE.itemsEnriched.length > 0) {\r\n        const valuesMap = new Map();\r\n        STATE.itemsEnriched.forEach(i => {\r\n          if (i.ingestionId) valuesMap.set(i.ingestionId, i.value);\r\n        });\r\n\r\n        // 3. Mescla a nova base (com ranges) com os valores antigos\r\n        STATE.itemsEnriched = STATE.itemsBase.map(baseItem => {\r\n          const existingVal = valuesMap.get(baseItem.ingestionId);\r\n          return {\r\n            ...baseItem,\r\n            value: existingVal !== undefined ? existingVal : (baseItem.value || 0),\r\n            perc: 0\r\n          };\r\n        });\r\n      } else {\r\n        STATE.itemsEnriched = STATE.itemsBase;\r\n      }\r\n\r\n      // 4. Redesenha a tela imediatamente\r\n      reflowFromState();\r\n    }\r\n\r\n    // Exp√µe credenciais globalmente para uso no FOOTER (modal de compara√ß√£o)\r\n    window.__MYIO_CLIENT_ID__ = CLIENT_ID;\r\n    window.__MYIO_CLIENT_SECRET__ = CLIENT_SECRET;\r\n    window.__MYIO_CUSTOMER_ING_ID__ = CUSTOMER_ING_ID;\r\n\r\n    MyIOAuth = MyIO.buildMyioIngestionAuth({\r\n      dataApiHost: DATA_API_HOST,\r\n      clientId: CLIENT_ID,\r\n      clientSecret: CLIENT_SECRET,\r\n    });\r\n\r\n    LogHelper.log('[DeviceCards] Auth init OK');\r\n    try {\r\n      await MyIOAuth.getToken();\r\n    } catch {\r\n      // Pre-warming token fetch, failure is non-critical\r\n    }\r\n  } catch (err) {\r\n    LogHelper.error('[DeviceCards] Auth init FAIL', err);\r\n  }\r\n\r\n  // Bind UI\r\n  bindHeader();\r\n  bindModal();\r\n\r\n  // ---------- Datas iniciais: \"Current Month So Far\" ----------\r\n  if (!self.ctx?.scope?.startDateISO || !self.ctx?.scope?.endDateISO) {\r\n    const now = new Date();\r\n    const start = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0); // 1¬∫ dia 00:00\r\n    const end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 0); // hoje 23:59:59\r\n    self.ctx.scope = self.ctx.scope || {};\r\n    self.ctx.scope.startDateISO = start.toISOString();\r\n    self.ctx.scope.endDateISO = end.toISOString();\r\n  }\r\n  // ------------------------------------------------------------\r\n\r\n  const hasData = Array.isArray(self.ctx.data) && self.ctx.data.length > 0;\r\n  // RFC-0042: Removed direct API fetch - now using orchestrator\r\n  LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] onInit - Waiting for orchestrator data...`);\r\n\r\n  // Build initial itemsBase from ThingsBoard data\r\n  if (hasData && (!STATE.itemsBase || STATE.itemsBase.length === 0)) {\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] Building itemsBase from TB data in onInit...`);\r\n    STATE.itemsBase = buildAuthoritativeItems();\r\n    window._telemetryAuthoritativeItems = STATE.itemsBase; // Expose for temperature tooltip\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] Built ${STATE.itemsBase.length} items from TB`);\r\n\r\n    // Initial render with zero values (will be updated by orchestrator)\r\n    STATE.itemsEnriched = STATE.itemsBase.map((item) => ({\r\n      ...item,\r\n      value: 0,\r\n      perc: 0,\r\n    }));\r\n\r\n    reflowFromState();\r\n  }\r\n\r\n  // Only show busy if we have a date range defined\r\n  if (self.ctx?.scope?.startDateISO && self.ctx?.scope?.endDateISO) {\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] Initial period defined, showing busy...`);\r\n    showBusy();\r\n  } else {\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] No initial period, waiting for myio:update-date event...`);\r\n  }\r\n};\r\n\r\n// onDataUpdated removido (no-op por ora)\r\nself.onDataUpdated = function () {\r\n  /* no-op */\r\n};\r\n\r\nself.onResize = function () { };\r\nself.onDestroy = function () {\r\n  if (dateUpdateHandler) {\r\n    window.removeEventListener('myio:update-date', dateUpdateHandler);\r\n    LogHelper.log(\"[DeviceCards] Event listener 'myio:update-date' removido.\");\r\n  }\r\n  if (dataProvideHandler) {\r\n    window.removeEventListener('myio:telemetry:provide-data', dataProvideHandler);\r\n    LogHelper.log(\"[DeviceCards] Event listener 'myio:telemetry:provide-data' removido.\");\r\n  }\r\n  // RFC-0056 FIX v1.1: Remove request_refresh listener\r\n  if (requestRefreshHandler) {\r\n    window.removeEventListener('myio:telemetry:update', requestRefreshHandler);\r\n    LogHelper.log(\"[RFC-0056] Event listener 'myio:telemetry:update' removido.\");\r\n  }\r\n\r\n  // Cleanup TempSensorSummaryTooltip if attached\r\n  if (_tempTooltipCleanup) {\r\n    _tempTooltipCleanup();\r\n    _tempTooltipCleanup = null;\r\n    LogHelper.log('[TELEMETRY] TempSensorSummaryTooltip cleanup executed.');\r\n  }\r\n\r\n  try {\r\n    $root().off();\r\n  } catch {\r\n    // jQuery cleanup may fail if element no longer exists\r\n  }\r\n\r\n  hideBusy();\r\n  hideGlobalSuccessModal();\r\n};\r\n",
      "settingsSchema": "{\r\n  \"schema\": {\r\n    \"type\": \"object\",\r\n    \"title\": \"Telemetry Widget Settings\",\r\n    \"properties\": {\r\n        \"labelWidget\":{\r\n            \"type\":\"string\",\r\n            \"title\": \"Widget Label\",\r\n            \"default\": \"Devices\"\r\n        },\r\n        \"DOMAIN\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Domain\",\r\n            \"enum\": [\"energy\", \"water\", \"temperature\"],\r\n            \"default\": \"energy\",\r\n            \"description\": \"Data domain for this widget (energy, water, or temperature)\"\r\n        },\r\n        \"waterContext\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Water Context Override\",\r\n            \"enum\": [\"auto\", \"entrada\", \"lojas\", \"areaComum\"],\r\n            \"default\": \"auto\",\r\n            \"description\": \"Override auto-detected context for water domain. Use 'auto' to detect from alias name.\"\r\n        }\r\n    },\r\n    \"required\": [\"DOMAIN\"]\r\n  },\r\n  \"form\": [\r\n    \"labelWidget\",\r\n    \"DOMAIN\",\r\n    \"waterContext\"\r\n  ]\r\n}",
      "dataKeySettingsSchema": "{}\n",
      "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Attributes card\",\"decimals\":null}"
    },
    "externalId": null,
    "resources": null,
    "id": {
      "entityType": "WIDGET_TYPE",
      "id": "c3a99960-a3b7-11f0-afe1-175479a33d89"
    },
    "scada": false,
    "tags": null
  },
  "relations": [],
  "attributes": {
    "SERVER_SCOPE": []
  }
}