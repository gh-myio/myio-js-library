Pelo log, o problema não é de código em si — é de configuração/atributos no ThingsBoard:

O erro principal é:
[Orchestrator] Metadata map is empty - no devices found in ctx.data
e logo antes:
[Orchestrator] Built metadata map: 148 entities, 0 with ingestionId
Ou seja: os devices chegam, mas ingestionId está vazio para todos. O fluxo de energia depende desse campo para casar os dados da API, então quando ele está vazio, o código considera “nenhum device válido”.

O que está errado de configuração (prováveis causas):

ingestionId não está preenchido nos devices (atributo ou campo no TB).
Datasource do widget não está puxando o atributo certo (mesmo que exista, ele não está vindo no ctx.data).
Alias/whitelist: o código usa whitelist para domínio energy com alias 'all3fs', mas o datasource está como All3Fs. Se a comparação for case-sensitive, pode dar filtro errado em alguns pontos.
Como confirmar rápido:

No ThingsBoard: abra um device e verifique se existe atributo/telemetria ingestionId com valor.
No widget: verifique o datasource (data keys) se realmente inclui ingestionId e se é do tipo correto (atributo vs telemetry).
No log já aparece DataKeys found in ctx.data: ... ingestionId ..., mas está vazio → isso aponta mais para atributo inexistente/sem valor.
Se quiser, posso:

adicionar um log mais claro apontando quando ingestionId está vazio
ajustar o código para aceitar fallback (ex.: usar entityId), se isso fizer sentido pro seu fluxo.
mas isso não deveria ser um problema, deveria renderizar os cards mas o ingestionId é para fazer match e popular (enrich) do consumo

Você está certo: o ingestionId deveria ser só para enrich do consumo.
O problema é que o código atual trata “sem ingestionId” como “sem devices” e aborta:

Em fetchAndEnrich, ele só monta a metadataMap com devices que tenham ingestionId. Quando nenhum tem, cai neste bloco:

if (metadataMap.size === 0 && waterDevicesFromCtx.length === 0) {
  ... handleDataLoadError(...)
  return [];
}
Resultado: nenhum card renderiza, mesmo com ctx.data cheio.

Então não é “config errado” — é a regra no código que está bloqueando o fallback.

Se a sua expectativa é renderizar cards mesmo sem enrich, o ajuste é:

criar itens básicos a partir do ctx.data quando metadataMap estiver vazio (no energy), em vez de chamar erro e voltar [].