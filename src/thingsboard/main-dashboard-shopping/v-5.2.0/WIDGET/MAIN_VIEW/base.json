{
  "entityType": "WIDGET_TYPE",
  "entity": {
    "fqn": "widget_shopping_dashboard_main_view_v_5_2_0",
    "name": "Widget - Shopping Dashboard - MAIN VIEW - v.5.2.0",
    "deprecated": false,
    "image": null,
    "description": null,
    "descriptor": {
      "type": "latest",
      "sizeX": 7.5,
      "sizeY": 3,
      "resources": [
        {
          "url": "https://unpkg.com/myio-js-library@latest/dist/myio-js-library.umd.min.js"
        }
      ],
      "templateHtml": "<section id=\"myio-root\" class=\"myio-grid\">\r\n  <aside class=\"myio-sidebar\">\r\n    <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"menu\"></tb-dashboard-state>\r\n  </aside>\r\n\r\n  <header class=\"myio-header\">\r\n    <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"header\"></tb-dashboard-state>\r\n  </header>\r\n\r\n  <main class=\"myio-content\">\r\n    <!-- RFC-0053: All states pre-loaded with show/hide logic (no iframes!) -->\r\n    <div data-content-state=\"telemetry_content\" style=\"display: block; height: 100%; min-height: 400px\">\r\n      <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"telemetry_content\"></tb-dashboard-state>\r\n    </div>\r\n    <div data-content-state=\"water_content\" style=\"display: none; height: 100%; min-height: 400px\">\r\n      <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"water_content\"></tb-dashboard-state>\r\n    </div>\r\n    <div data-content-state=\"temperature_content\" style=\"display: none; height: 100%; min-height: 400px\">\r\n      <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"temperature_content\"></tb-dashboard-state>\r\n    </div>\r\n    <div data-content-state=\"alarm_content\" style=\"display: none; height: 100%; min-height: 400px\">\r\n      <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"alarm_content\"></tb-dashboard-state>\r\n    </div>\r\n  </main>\r\n\r\n  <footer class=\"myio-footer\">\r\n    <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"footer\"></tb-dashboard-state>\r\n  </footer>\r\n</section>\r\n",
      "templateCss": "#myio-root {\r\n  --myio-radius: 16px;\r\n\r\n  --sidebar-w: 260px;\r\n  --sidebar-w-compact: 72px;\r\n}\r\n\r\n/* root + filhos ocupam 100% */\r\n#myio-root.myio-grid,\r\n#myio-root .tb-child {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\n/* GRID PRINCIPAL */\r\n#myio-root.myio-grid {\r\n  display: grid;\r\n  grid-template-columns: var(--sidebar-w) 1fr;\r\n  grid-template-rows: auto 1fr 46px;\r\n  grid-template-areas:\r\n    'sidebar header'\r\n    'sidebar content'\r\n    'footer footer';\r\n  width: 100%;\r\n  height: 100%;\r\n  background: var(--myio-bg);\r\n  overflow: hidden;\r\n  gap: 0 !important;\r\n}\r\n\r\n/* √Åreas */\r\n#myio-root .myio-sidebar {\r\n  grid-area: sidebar;\r\n  background: var(--myio-panel);\r\n  border-right: 1px solid var(--myio-border);\r\n  box-shadow: none; /* remove sombra lateral */\r\n  padding: 0;\r\n  margin: 0;\r\n}\r\n\r\n#myio-root .myio-content {\r\n  grid-area: content;\r\n  background: transparent;\r\n  overflow: auto;\r\n  height: 100%;\r\n  min-height: 0; /* allow grid child to shrink and enable inner scroll */\r\n  box-sizing: border-box;\r\n  margin: 0 !important;\r\n  padding: 0 0 0 0 !important; /* Sem padding-bottom, o grid j√° reserva espa√ßo */\r\n  position: relative;\r\n}\r\n\r\n/* Garantir que os containers de conte√∫do preencham a √°rea dispon√≠vel */\r\n#myio-root .myio-content [data-content-state] {\r\n  display: block;\r\n  width: 100%;\r\n  height: 100%;\r\n  min-height: 400px;\r\n  box-sizing: border-box;\r\n}\r\n\r\n#myio-root .myio-header {\r\n  grid-area: header;\r\n  background: var(--myio-panel);\r\n  border-bottom: 1px solid var(--myio-border);\r\n  padding: 0;\r\n  margin: 0;\r\n  min-height: 75px;\r\n}\r\n\r\n#myio-root .myio-footer {\r\n  grid-area: footer;\r\n  height: 46px;\r\n  min-height: 46px;\r\n  max-height: 46px;\r\n  overflow: visible;\r\n  z-index: 1000;\r\n}\r\n\r\n/* Apar√™ncia comum */\r\n#myio-root .myio-sidebar {\r\n  border-radius: 0;\r\n}\r\n\r\n/* Neutralizador de states internos */\r\n#myio-root .myio-sidebar .tb-child,\r\n#myio-root .myio-header .tb-child {\r\n  width: 100%;\r\n  height: 100%;\r\n  margin: 0 !important;\r\n  padding: 0 !important;\r\n  display: flex;\r\n  align-items: stretch;\r\n  justify-content: stretch;\r\n  overflow: visible;\r\n}\r\n\r\n/* Widgets de content precisam de scroll - N√ÉO for√ßar overflow: visible */\r\n#myio-root .myio-content .tb-child {\r\n  width: 100%;\r\n  height: 100%;\r\n  margin: 0 !important;\r\n  padding: 0 !important;\r\n  display: flex;\r\n  align-items: stretch;\r\n  justify-content: stretch;\r\n  overflow: auto; /* ‚úÖ MUDADO: permite scroll nos widgets */\r\n}\r\n\r\n/* ThingsBoard wrapper para widgets dinamicamente carregados */\r\n#myio-root .myio-content .tb-child tb-dynamic-component,\r\n#myio-root .myio-content .tb-child tb-dynamic-component > * {\r\n  display: block;\r\n  width: 100%;\r\n  height: 100%;\r\n  min-height: 400px;\r\n}\r\n#myio-root .myio-footer .tb-child {\r\n  /* Remove o padding padr√£o do Gridster */\r\n  padding: 0 !important;\r\n\r\n  /* Aplica todo o estilo visual que estava no #myio-root .myio-footer */\r\n  background: linear-gradient(90deg, #121a2b, #1c2743);\r\n  border-top: 2px solid #00e09e;\r\n  box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n/* wrapper interno (n√≠vel 1 e 2) */\r\n#myio-root .myio-content .tb-child > :first-child,\r\n#myio-root .myio-content .tb-child > :first-child > :first-child {\r\n  margin-left: 0 !important;\r\n  padding-left: 0 !important;\r\n}\r\n\r\n/* elementos internos comuns */\r\n#myio-root .myio-content .tb-child > * {\r\n  flex: 1 1 auto;\r\n  width: 100%;\r\n  max-width: none;\r\n  height: 100%;\r\n  box-sizing: border-box;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\n/* containers internos */\r\n#myio-root .myio-content .tb-child .container,\r\n#myio-root .myio-content .tb-child .content,\r\n#myio-root .myio-content .tb-child .mat-card,\r\n#myio-root .myio-content .tb-child .mat-mdc-card {\r\n  width: 100%;\r\n  max-width: none;\r\n  margin: 0;\r\n  box-sizing: border-box;\r\n  background: transparent !important;\r\n  box-shadow: none !important;\r\n  padding: 0 !important;\r\n  border-radius: 0 !important;\r\n}\r\n\r\n/* grids internos */\r\n#myio-root .myio-content .tb-child .layout-row,\r\n#myio-root .myio-content .tb-child .layout-column {\r\n  width: 100%;\r\n  max-width: none;\r\n}\r\n\r\n/* Scrollbar suave apenas no content */\r\n#myio-root .myio-content::-webkit-scrollbar {\r\n  width: 10px;\r\n  height: 10px;\r\n}\r\n#myio-root .myio-content::-webkit-scrollbar-track {\r\n  background: transparent;\r\n}\r\n\r\n/* Menu compacto */\r\n#myio-root.myio-grid.menu-compact {\r\n  grid-template-columns: var(--sidebar-w-compact) 1fr;\r\n}\r\n#myio-root.myio-grid.menu-compact .myio-sidebar {\r\n  width: var(--sidebar-w-compact);\r\n}\r\n\r\n/* Responsivo */\r\n@media (max-width: 1200px) {\r\n  #myio-root {\r\n    --sidebar-w: 260px;\r\n  }\r\n}\r\n@media (max-width: 920px) {\r\n  #myio-root.myio-grid {\r\n    grid-template-columns: 1fr;\r\n    grid-template-rows: auto 1fr; /* sidebar, content */\r\n    grid-template-areas:\r\n      'sidebar'\r\n      'content';\r\n  }\r\n  #myio-root .myio-sidebar {\r\n    border-right: none;\r\n    border-bottom: 1px solid var(--myio-border);\r\n  }\r\n}\r\n\r\n/* ajustes extras */\r\n.shops-menu-root {\r\n  padding: 12px 0; /* s√≥ vertical */\r\n}\r\n#myio-root .myio-content > * {\r\n  margin: 0;\r\n}\r\n",
      "controllerScript": "/* global self, window, document, localStorage, MyIOLibrary, ResizeObserver */\r\n\r\n/*********************************************************\r\n * MYIO ‚Äì Container 2 states (menu/content)\r\n * - Ajusta alturas automaticamente\r\n * - Suporta \"menu compacto\" via evento global\r\n * - Mant√©m simples: os tb-dashboard-state renderizam os\r\n * dashboards configurados no pr√≥prio ThingsBoard.\r\n *********************************************************/\r\n\r\n// Debug configuration - can be toggled at runtime via window.MyIOUtils.setDebug(true/false)\r\nlet DEBUG_ACTIVE = true;\r\n\r\n// LogHelper utility - shared across all widgets in this context\r\nconst LogHelper = {\r\n  log: function (...args) {\r\n    if (DEBUG_ACTIVE) {\r\n      console.log(...args);\r\n    }\r\n  },\r\n  warn: function (...args) {\r\n    if (DEBUG_ACTIVE) {\r\n      console.warn(...args);\r\n    }\r\n  },\r\n  error: function (...args) {\r\n    // Errors always logged regardless of DEBUG_ACTIVE\r\n    console.error(...args);\r\n  },\r\n};\r\n\r\n// RFC-0091: Expose shared utilities globally for child widgets (TELEMETRY, etc.)\r\n// RFC-0091: Shared constants across all widgets\r\nconst DATA_API_HOST = 'https://api.data.apps.myio-bas.com';\r\n\r\nwindow.MyIOUtils = window.MyIOUtils || {};\r\nObject.assign(window.MyIOUtils, {\r\n  LogHelper,\r\n  DATA_API_HOST,\r\n  isDebugActive: () => DEBUG_ACTIVE,\r\n  setDebug: (active) => {\r\n    DEBUG_ACTIVE = !!active;\r\n    console.log(`[MyIOUtils] Debug mode ${DEBUG_ACTIVE ? 'enabled' : 'disabled'}`);\r\n  },\r\n  // Temperature domain: global min/max temperature limits (populated by onDataUpdated)\r\n  temperatureLimits: {\r\n    minTemperature: null,\r\n    maxTemperature: null,\r\n  },\r\n  // RFC-XXXX: SuperAdmin flag - user with @myio.com.br email (except alarme/alarmes)\r\n  // Populated by detectSuperAdmin() in onInit\r\n  SuperAdmin: false,\r\n  /**\r\n   * Handle 401 Unauthorized errors globally\r\n   * Shows toast message and reloads the page\r\n   * @param {string} context - Context description for logging (e.g., 'TemperatureSettingsModal')\r\n   */\r\n  handleUnauthorizedError: (context = 'API') => {\r\n    LogHelper.error(`[MyIOUtils] 401 Unauthorized in ${context} - session expired`);\r\n\r\n    // Get MyIOToast from library\r\n    const MyIOToast = window.MyIOLibrary?.MyIOToast;\r\n    if (MyIOToast) {\r\n      MyIOToast.error('Sess√£o expirada. Recarregando p√°gina...', 3000);\r\n    } else {\r\n      console.error('[MyIOUtils] Sess√£o expirada. Recarregando p√°gina...');\r\n    }\r\n\r\n    // Reload page after toast displays\r\n    setTimeout(() => {\r\n      window.location.reload();\r\n    }, 2500);\r\n  },\r\n});\r\n// Expose customerTB_ID via getter (reads from MyIOOrchestrator when available)\r\n// Check if property already exists to avoid \"Cannot redefine property\" error\r\nif (!Object.prototype.hasOwnProperty.call(window.MyIOUtils, 'customerTB_ID')) {\r\n  Object.defineProperty(window.MyIOUtils, 'customerTB_ID', {\r\n    get: () => window.MyIOOrchestrator?.customerTB_ID || null,\r\n    enumerable: true,\r\n    configurable: true, // Allow redefinition if needed\r\n  });\r\n}\r\n\r\n// RFC-0051.1: Global widget settings (will be populated in onInit)\r\n// IMPORTANT: customerTB_ID must NEVER be 'default' - it must always be a valid ThingsBoard ID\r\nlet widgetSettings = {\r\n  customerTB_ID: null, // MUST be set in onInit\r\n  debugMode: false,\r\n  domainsEnabled: { energy: true, water: true, temperature: true },\r\n};\r\n\r\n// Config object (populated in onInit from widgetSettings)\r\nlet config = null;\r\n\r\n(function () {\r\n  // Utilit√°rios DOM\r\n  const $ = (sel, root = document) => root.querySelector(sel);\r\n  const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));\r\n  const on = (el, ev, fn) => el && el.addEventListener(ev, fn);\r\n\r\n  let rootEl;\r\n\r\n  // Atualiza a altura √∫til do conte√∫do e garante que os elementos est√£o bem posicionados\r\n  function applySizing() {\r\n    try {\r\n      // For√ßa rec√°lculo do layout se necess√°rio\r\n      if (rootEl) {\r\n        rootEl.style.display = 'grid';\r\n\r\n        // Garante que os tb-child elementos do MENU nÔøΩo tenham overflow issues\r\n        const menu = $('.myio-menu', rootEl);\r\n        if (menu) {\r\n          const menuChildren = $$('.tb-child', menu);\r\n          menuChildren.forEach((child) => {\r\n            child.style.overflow = 'hidden';\r\n            child.style.width = '100%';\r\n            child.style.height = '100%';\r\n          });\r\n        }\r\n\r\n        // Especial tratamento para o conteÔøΩdo principal - permite scroll nos widgets\r\n        const content = $('.myio-content', rootEl);\r\n        if (content) {\r\n          // Primeiro: container direto do content deve ter overflow auto para controlar scroll\r\n          const contentChild = $('.tb-child', content);\r\n          if (contentChild) {\r\n            contentChild.style.overflow = 'auto'; // Mudado de 'visible' para 'auto'\r\n            contentChild.style.height = '100%';\r\n            contentChild.style.width = '100%';\r\n          }\r\n\r\n          // Segundo: dentro dos states, os widgets individuais tambÔøΩm precisam de scroll\r\n          const stateContainers = $$('[data-content-state]', content);\r\n          LogHelper.log(`[MAIN_VIEW] Found ${stateContainers.length} state containers`);\r\n          stateContainers.forEach((stateContainer, idx) => {\r\n            const widgetsInState = $$('.tb-child', stateContainer);\r\n            LogHelper.log(`[MAIN_VIEW] State ${idx}: ${widgetsInState.length} widgets found`, {\r\n              state: stateContainer.getAttribute('data-content-state'),\r\n              display: stateContainer.style.display,\r\n            });\r\n            widgetsInState.forEach((widget, widgetIdx) => {\r\n              const before = widget.style.overflow;\r\n              widget.style.overflow = 'auto';\r\n              widget.style.width = '100%';\r\n              widget.style.height = '100%';\r\n              LogHelper.log(`[MAIN_VIEW]   Widget ${widgetIdx}: overflow ${before} ? auto`);\r\n            });\r\n          });\r\n\r\n          // Diagn√≥stico: logar dimens√µes do container vis√≠vel\r\n          const visible = Array.from(content.querySelectorAll('[data-content-state]')).find(\r\n            (div) => div.style.display !== 'none'\r\n          );\r\n          if (visible) {\r\n            const r1 = content.getBoundingClientRect();\r\n            const r2 = visible.getBoundingClientRect();\r\n            const r3 = contentChild ? contentChild.getBoundingClientRect() : null;\r\n            LogHelper.log('[MAIN_VIEW] sizing content dims', {\r\n              content: { w: r1.width, h: r1.height },\r\n              visible: { w: r2.width, h: r2.height },\r\n              child: r3 ? { w: r3.width, h: r3.height } : null,\r\n            });\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {\r\n      LogHelper.warn('[myio-container] sizing warn:', e);\r\n    }\r\n  }\r\n\r\n  // Alterna o modo \"menu compacto\" acrescentando/removendo classe no root\r\n  function setMenuCompact(compact) {\r\n    if (!rootEl) return;\r\n    rootEl.classList.toggle('menu-compact', !!compact);\r\n\r\n    // For√ßa rec√°lculo ap√≥s mudan√ßa de modo\r\n    setTimeout(() => {\r\n      applySizing();\r\n    }, 50);\r\n  }\r\n\r\n  // Exponha dois eventos globais simples (opcionais):\r\n  // window.dispatchEvent(new CustomEvent('myio:menu-compact', { detail: { compact: true } }))\r\n  // window.dispatchEvent(new CustomEvent('myio:menu-expand'))\r\n  function registerGlobalEvents() {\r\n    on(window, 'myio:menu-compact', (ev) => {\r\n      setMenuCompact(ev?.detail?.compact ?? true);\r\n    });\r\n    on(window, 'myio:menu-expand', () => {\r\n      setMenuCompact(false);\r\n    });\r\n\r\n    // Adiciona suporte para toggle via evento\r\n    on(window, 'myio:menu-toggle', () => {\r\n      const isCompact = rootEl?.classList.contains('menu-compact');\r\n      setMenuCompact(!isCompact);\r\n    });\r\n  }\r\n\r\n  // Detecta mudan√ßas de viewport para aplicar sizing\r\n  function setupResizeObserver() {\r\n    if (typeof ResizeObserver !== 'undefined' && rootEl) {\r\n      const resizeObserver = new ResizeObserver(() => {\r\n        applySizing();\r\n      });\r\n      resizeObserver.observe(rootEl);\r\n    }\r\n  }\r\n\r\n  // RFC-XXXX: SuperAdmin detection\r\n  // SuperAdmin = user with @myio.com.br email EXCEPT alarme@myio.com.br or alarmes@myio.com.br\r\n  async function detectSuperAdmin() {\r\n    const jwt = localStorage.getItem('jwt_token');\r\n    if (!jwt) {\r\n      window.MyIOUtils.SuperAdmin = false;\r\n      LogHelper.log('[MAIN_VIEW] SuperAdmin: false (no JWT token)');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch('/api/auth/user', {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'X-Authorization': `Bearer ${jwt}`,\r\n        },\r\n        credentials: 'include',\r\n      });\r\n\r\n      if (!response.ok) {\r\n        window.MyIOUtils.SuperAdmin = false;\r\n        LogHelper.warn('[MAIN_VIEW] SuperAdmin: false (API error:', response.status, ')');\r\n        return;\r\n      }\r\n\r\n      const user = await response.json();\r\n      const email = (user.email || '').toLowerCase().trim();\r\n\r\n      // Check: email ends with @myio.com.br AND is NOT alarme@ or alarmes@\r\n      const isSuperAdmin =\r\n        email.endsWith('@myio.com.br') &&\r\n        !email.startsWith('alarme@') &&\r\n        !email.startsWith('alarmes@');\r\n\r\n      window.MyIOUtils.SuperAdmin = isSuperAdmin;\r\n      LogHelper.log(`[MAIN_VIEW] SuperAdmin detection: ${email} -> ${isSuperAdmin}`);\r\n    } catch (err) {\r\n      LogHelper.error('[MAIN_VIEW] SuperAdmin detection failed:', err);\r\n      window.MyIOUtils.SuperAdmin = false;\r\n    }\r\n  }\r\n\r\n  // ThingsBoard lifecycle\r\n  self.onInit = async function () {\r\n    rootEl = $('#myio-root');\r\n\r\n    // Populate global widget settings early to avoid undefined errors\r\n    // These settings are available globally to all functions\r\n\r\n    // CRITICAL: customerTB_ID MUST be set - abort if missing\r\n    const customerTB_ID = self.ctx.settings?.customerTB_ID;\r\n    if (!customerTB_ID) {\r\n      LogHelper.error('[Orchestrator] ‚ùå CRITICAL: customerTB_ID is missing from widget settings!');\r\n      LogHelper.error(\r\n        '[Orchestrator] Widget cannot function without customerTB_ID. Please configure it in widget settings.'\r\n      );\r\n      throw new Error('customerTB_ID is required but not found in widget settings');\r\n    }\r\n\r\n    widgetSettings.customerTB_ID = customerTB_ID;\r\n\r\n    // RFC-0085: Expose customerTB_ID globally for MENU and other widgets\r\n    if (window.MyIOOrchestrator) {\r\n      window.MyIOOrchestrator.customerTB_ID = customerTB_ID;\r\n    }\r\n\r\n    widgetSettings.debugMode = self.ctx.settings?.debugMode ?? false;\r\n    widgetSettings.domainsEnabled = self.ctx.settings?.domainsEnabled ?? {\r\n      energy: true,\r\n      water: true,\r\n      temperature: true,\r\n    };\r\n\r\n    LogHelper.log('[Orchestrator] üìã Widget settings captured:', {\r\n      customerTB_ID: widgetSettings.customerTB_ID,\r\n      debugMode: widgetSettings.debugMode,\r\n    });\r\n\r\n    // Initialize config from widgetSettings\r\n    config = {\r\n      debugMode: widgetSettings.debugMode,\r\n      domainsEnabled: widgetSettings.domainsEnabled,\r\n    };\r\n\r\n    LogHelper.log('[Orchestrator] üîß Config initialized from settings:', config);\r\n\r\n    // RFC-0051.2: Expose orchestrator stub IMMEDIATELY\r\n    // This prevents race conditions with TELEMETRY widgets that check for orchestrator\r\n    // We expose a stub with isReady flag that will be set to true when fully initialized\r\n    if (!window.MyIOOrchestrator) {\r\n      window.MyIOOrchestrator = {\r\n        // Status flags\r\n        isReady: false,\r\n        credentialsSet: false,\r\n\r\n        // Customer ID from settings (for MENU and other widgets)\r\n        customerTB_ID: null,\r\n\r\n        // Data access methods (will be populated later)\r\n        getCurrentPeriod: () => null,\r\n        getCredentials: () => null,\r\n\r\n        // Credential management (will be populated later)\r\n        setCredentials: async (customerId, clientId, clientSecret) => {\r\n          LogHelper.warn('[Orchestrator] ‚ö†Ô∏è setCredentials called before orchestrator is ready');\r\n        },\r\n\r\n        // Token manager stub\r\n        tokenManager: {\r\n          setToken: (key, token) => {\r\n            LogHelper.warn('[Orchestrator] ‚ö†Ô∏è tokenManager.setToken called before orchestrator is ready');\r\n          },\r\n        },\r\n\r\n        // Internal state (will be populated later)\r\n        inFlight: {},\r\n      };\r\n\r\n      LogHelper.log('[Orchestrator] ‚ö° Exposed to window.MyIOOrchestrator EARLY (stub mode)');\r\n    }\r\n\r\n    registerGlobalEvents();\r\n    setupResizeObserver();\r\n\r\n    // RFC-XXXX: Detect SuperAdmin early (async, non-blocking)\r\n    detectSuperAdmin();\r\n\r\n    // Initialize MyIO Library and Authentication\r\n    const MyIO =\r\n      (typeof MyIOLibrary !== 'undefined' && MyIOLibrary) ||\r\n      (typeof window !== 'undefined' && window.MyIOLibrary) ||\r\n      null;\r\n\r\n    if (MyIO) {\r\n      try {\r\n        // RFC-0051.1: Use widgetSettings from closure\r\n        const customerTB_ID = widgetSettings.customerTB_ID !== 'default' ? widgetSettings.customerTB_ID : '';\r\n        const jwt = localStorage.getItem('jwt_token');\r\n\r\n        LogHelper.log('[MAIN_VIEW] üîç Credentials fetch starting...');\r\n        LogHelper.log(\r\n          '[MAIN_VIEW] customerTB_ID:',\r\n          customerTB_ID ? customerTB_ID : '‚ùå NOT FOUND IN SETTINGS'\r\n        );\r\n        LogHelper.log('[MAIN_VIEW] jwt token:', jwt ? '‚úÖ FOUND' : '‚ùå NOT FOUND IN localStorage');\r\n\r\n        let CLIENT_ID = '';\r\n        let CLIENT_SECRET = '';\r\n        let CUSTOMER_ING_ID = '';\r\n\r\n        if (customerTB_ID && jwt) {\r\n          try {\r\n            LogHelper.log('[MAIN_VIEW] üì° Fetching customer attributes from ThingsBoard...');\r\n            // Fetch customer attributes\r\n            const attrs = await MyIO.fetchThingsboardCustomerAttrsFromStorage(customerTB_ID, jwt);\r\n\r\n            LogHelper.log('[MAIN_VIEW] üì¶ Received attrs:', attrs);\r\n\r\n            CLIENT_ID = attrs?.client_id || '';\r\n            CLIENT_SECRET = attrs?.client_secret || '';\r\n            CUSTOMER_ING_ID = attrs?.ingestionId || '';\r\n\r\n            LogHelper.log('[MAIN_VIEW] üîë Parsed credentials:');\r\n            LogHelper.log('[MAIN_VIEW]   CLIENT_ID:', CLIENT_ID ? '‚úÖ ' + CLIENT_ID : '‚ùå EMPTY');\r\n            LogHelper.log(\r\n              '[MAIN_VIEW]   CLIENT_SECRET:',\r\n              CLIENT_SECRET ? '‚úÖ ' + CLIENT_SECRET.substring(0, 10) + '...' : '‚ùå EMPTY'\r\n            );\r\n            LogHelper.log(\r\n              '[MAIN_VIEW]   CUSTOMER_ING_ID:',\r\n              CUSTOMER_ING_ID ? '‚úÖ ' + CUSTOMER_ING_ID : '‚ùå EMPTY'\r\n            );\r\n          } catch (err) {\r\n            LogHelper.error('[MAIN_VIEW] ‚ùå Failed to fetch customer attributes:', err);\r\n            LogHelper.error('[MAIN_VIEW] Error details:', {\r\n              message: err.message,\r\n              stack: err.stack,\r\n              name: err.name,\r\n            });\r\n          }\r\n        } else {\r\n          LogHelper.warn('[MAIN_VIEW] ‚ö†Ô∏è Cannot fetch credentials - missing required data:');\r\n          if (!customerTB_ID) LogHelper.warn('[MAIN_VIEW]   - customerTB_ID is missing from settings');\r\n          if (!jwt) LogHelper.warn('[MAIN_VIEW]   - JWT token is missing from localStorage');\r\n        }\r\n\r\n        // Check if credentials are present\r\n        if (!CLIENT_ID || !CLIENT_SECRET || !CUSTOMER_ING_ID) {\r\n          LogHelper.warn(\r\n            '[MAIN_VIEW] Missing credentials - CLIENT_ID, CLIENT_SECRET, or CUSTOMER_ING_ID not found'\r\n          );\r\n          LogHelper.warn(\r\n            \"[MAIN_VIEW] Orchestrator will be available but won't be able to fetch data without credentials\"\r\n          );\r\n\r\n          // RFC-0054 FIX: Dispatch initial tab event even without credentials (with delay)\r\n          // This enables HEADER controls, even though data fetch will fail\r\n          LogHelper.log(\r\n            '[MAIN_VIEW] Will dispatch initial tab event for default state: energy after 100ms delay...'\r\n          );\r\n          setTimeout(() => {\r\n            LogHelper.log(\r\n              '[MAIN_VIEW] Dispatching initial tab event for default state: energy (no credentials)'\r\n            );\r\n            window.dispatchEvent(\r\n              new CustomEvent('myio:dashboard-state', {\r\n                detail: { tab: 'energy' },\r\n              })\r\n            );\r\n          }, 100);\r\n        } else {\r\n          // Set credentials in orchestrator (only if present)\r\n          LogHelper.log('[MAIN_VIEW] üîê Calling MyIOOrchestrator.setCredentials...');\r\n          LogHelper.log('[MAIN_VIEW] üîê Arguments:', {\r\n            customerId: CUSTOMER_ING_ID,\r\n            clientId: CLIENT_ID,\r\n            clientSecret: CLIENT_SECRET.substring(0, 10) + '...',\r\n          });\r\n\r\n          MyIOOrchestrator.setCredentials(CUSTOMER_ING_ID, CLIENT_ID, CLIENT_SECRET);\r\n\r\n          LogHelper.log('[MAIN_VIEW] üîê setCredentials completed, verifying...');\r\n          // Verify credentials were set\r\n          const currentCreds = MyIOOrchestrator.getCredentials?.();\r\n          if (currentCreds) {\r\n            LogHelper.log('[MAIN_VIEW] ‚úÖ Credentials verified in orchestrator:', currentCreds);\r\n          } else {\r\n            LogHelper.warn('[MAIN_VIEW] ‚ö†Ô∏è Orchestrator does not have getCredentials method');\r\n          }\r\n\r\n          // Build auth and get token\r\n          const myIOAuth = MyIO.buildMyioIngestionAuth({\r\n            dataApiHost: 'https://api.data.apps.myio-bas.com',\r\n            clientId: CLIENT_ID,\r\n            clientSecret: CLIENT_SECRET,\r\n          });\r\n\r\n          // Get token and set it in token manager\r\n          const ingestionToken = await myIOAuth.getToken();\r\n          MyIOOrchestrator.tokenManager.setToken('ingestionToken', ingestionToken);\r\n\r\n          LogHelper.log('[MAIN_VIEW] Auth initialized successfully with CLIENT_ID:', CLIENT_ID);\r\n\r\n          // Dispatch initial tab event AFTER credentials AND with delay\r\n          // Delay ensures HEADER has time to register its listener\r\n          LogHelper.log(\r\n            '[MAIN_VIEW] Will dispatch initial tab event for default state: energy after 100ms delay...'\r\n          );\r\n          setTimeout(() => {\r\n            LogHelper.log(\r\n              '[MAIN_VIEW] Dispatching initial tab event for default state: energy (after credentials + delay)'\r\n            );\r\n            window.dispatchEvent(\r\n              new CustomEvent('myio:dashboard-state', {\r\n                detail: { tab: 'energy' },\r\n              })\r\n            );\r\n          }, 100);\r\n        }\r\n      } catch (err) {\r\n        LogHelper.error('[MAIN_VIEW] Auth initialization failed:', err);\r\n\r\n        // RFC-0054 FIX: Dispatch initial tab event even on error (with delay)\r\n        // This enables HEADER controls, even though data fetch will fail\r\n        LogHelper.log(\r\n          '[MAIN_VIEW] Will dispatch initial tab event for default state: energy after 100ms delay...'\r\n        );\r\n        setTimeout(() => {\r\n          LogHelper.log('[MAIN_VIEW] Dispatching initial tab event for default state: energy (after error)');\r\n          window.dispatchEvent(\r\n            new CustomEvent('myio:dashboard-state', {\r\n              detail: { tab: 'energy' },\r\n            })\r\n          );\r\n        }, 100);\r\n      }\r\n    } else {\r\n      LogHelper.warn('[MAIN_VIEW] MyIOLibrary not available');\r\n\r\n      // RFC-0054 FIX: Dispatch initial tab event even without MyIOLibrary (with delay)\r\n      // This enables HEADER controls, even though data fetch will fail\r\n      LogHelper.log(\r\n        '[MAIN_VIEW] Will dispatch initial tab event for default state: energy after 100ms delay...'\r\n      );\r\n      setTimeout(() => {\r\n        LogHelper.log('[MAIN_VIEW] Dispatching initial tab event for default state: energy (no MyIOLibrary)');\r\n        window.dispatchEvent(\r\n          new CustomEvent('myio:dashboard-state', {\r\n            detail: { tab: 'energy' },\r\n          })\r\n        );\r\n      }, 100);\r\n    }\r\n\r\n    // // Log √∫til para conferir se os states existem\r\n    // try {\r\n    //   const states = self.ctx?.dashboard?.configuration?.states || {};\r\n    //   // LogHelper.log('[myio-container] states dispon√≠veis:', Object.keys(states));\r\n    //   // Esperados: \"menu\", \"telemetry_content\", \"water_content\", \"temperature_content\", \"alarm_content\", \"footer\"\r\n    // } catch (e) {\r\n    //   LogHelper.warn('[myio-container] n√£o foi poss√≠vel listar states:', e);\r\n    // }\r\n  };\r\n\r\n  self.onResize = function () {\r\n    applySizing();\r\n  };\r\n\r\n  self.onDataUpdated = function () {\r\n    // Normalmente n√£o √© necess√°rio aqui, pois cada state cuida do pr√≥prio dado.\r\n    // Mas podemos garantir que o layout est√° correto\r\n    setTimeout(() => {\r\n      applySizing();\r\n    }, 50);\r\n\r\n    // Extract and expose global minTemperature/maxTemperature for temperature domain\r\n    // These values are read by TELEMETRY widget via window.MyIOUtils.temperatureLimits\r\n    const ctxDataRows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\r\n    ctxDataRows.forEach((data) => {\r\n      const keyName = data?.dataKey?.name;\r\n      if (keyName === 'maxTemperature') {\r\n        const val = Number(data.data?.[0]?.[1]) || null;\r\n        window.MyIOUtils.temperatureLimits.maxTemperature = val;\r\n        LogHelper.log(`[MAIN_VIEW] Exposed global maxTemperature: ${val}`);\r\n      }\r\n      if (keyName === 'minTemperature') {\r\n        const val = Number(data.data?.[0]?.[1]) || null;\r\n        window.MyIOUtils.temperatureLimits.minTemperature = val;\r\n        LogHelper.log(`[MAIN_VIEW] Exposed global minTemperature: ${val}`);\r\n      }\r\n    });\r\n  };\r\n\r\n  self.onDestroy = function () {\r\n    // Limpa event listeners se necess√°rio\r\n    if (typeof window !== 'undefined') {\r\n      // Remove custom event listeners se foram adicionados\r\n    }\r\n\r\n    // Destroy orchestrator\r\n    if (window.MyIOOrchestrator) {\r\n      window.MyIOOrchestrator.destroy();\r\n    }\r\n  };\r\n})();\r\n\r\n// ========== ORCHESTRATOR IMPLEMENTATION ==========\r\n\r\n/**\r\n * Global shared state for widget coordination\r\n * Prevents race conditions and ensures first widget priority\r\n */\r\nif (!window.MyIOOrchestratorState) {\r\n  window.MyIOOrchestratorState = {\r\n    // Widget registration and priority\r\n    widgetPriority: [],\r\n    widgetRegistry: new Map(), // widgetId -> {domain, registeredAt}\r\n\r\n    // Loading state per domain\r\n    loading: {},\r\n\r\n    // Pending listeners for late-joining widgets\r\n    pendingListeners: {},\r\n\r\n    // Last emission timestamp per domain (deduplication)\r\n    lastEmission: {},\r\n\r\n    // Lock to prevent concurrent requests\r\n    locks: {},\r\n  };\r\n\r\n  LogHelper.log('[Orchestrator] üåç Global state initialized:', window.MyIOOrchestratorState);\r\n}\r\n\r\nconst OrchestratorState = window.MyIOOrchestratorState;\r\n\r\n/**\r\n * @typedef {'hour'|'day'|'month'} Granularity\r\n * @typedef {'energy'|'water'|'temperature'} Domain\r\n */\r\n\r\n/**\r\n * @typedef {Object} Period\r\n * @property {string} startISO - ISO 8601 with timezone\r\n * @property {string} endISO - ISO 8601 with timezone\r\n * @property {Granularity} granularity - Data aggregation level\r\n * @property {string} tz - IANA timezone\r\n */\r\n\r\n/**\r\n * @typedef {Object} EnrichedItem\r\n * @property {string} id - ThingsBoard entityId (single source of truth)\r\n * @property {string} tbId - ThingsBoard deviceId\r\n * @property {string} ingestionId - Data Ingestion API UUID\r\n * @property {string} identifier - Human-readable ID\r\n * @property {string} label - Display name\r\n * @property {number} value - Consumption total\r\n * @property {number} perc - Percentage of group total\r\n * @property {string|null} slaveId - Modbus slave ID\r\n * @property {string|null} centralId - Central unit ID\r\n * @property {string} deviceType - Device type\r\n */\r\n\r\n// ========== UTILITIES ==========\r\n\r\n/**\r\n * Generates a unique key from domain and period for request deduplication.\r\n */\r\nfunction periodKey(domain, period) {\r\n  const customerTbId = widgetSettings.customerTB_ID;\r\n  return `${customerTbId}:${domain}:${period.startISO}:${period.endISO}:${period.granularity}`;\r\n}\r\n\r\n// ========== ORCHESTRATOR SINGLETON ==========\r\n\r\nconst MyIOOrchestrator = (() => {\r\n  // ========== PHASE 1: BUSY OVERLAY MANAGEMENT (RFC-0044/RFC-0054) ==========\r\n  const BUSY_OVERLAY_ID = 'myio-orchestrator-busy-overlay';\r\n  let globalBusyState = {\r\n    isVisible: false,\r\n    timeoutId: null,\r\n    startTime: null,\r\n    currentDomain: null,\r\n    requestCount: 0,\r\n  };\r\n\r\n  // RFC-0054: contador por domÔøΩnio e cooldown pÔøΩs-provide\r\n  const activeRequests = new Map(); // domain -> count\r\n  const lastProvide = new Map(); // domain -> { periodKey, at }\r\n\r\n  function getActiveTotal() {\r\n    let total = 0;\r\n    activeRequests.forEach((v) => {\r\n      total += v || 0;\r\n    });\r\n    return total;\r\n  }\r\n\r\n  function ensureOrchestratorBusyDOM() {\r\n    let el = document.getElementById(BUSY_OVERLAY_ID);\r\n    if (el) return el;\r\n\r\n    el = document.createElement('div');\r\n    el.id = BUSY_OVERLAY_ID;\r\n    el.style.cssText = `\r\n    position: fixed;\r\n    inset: 0;\r\n    background: rgba(45, 20, 88, 0.6);\r\n    backdrop-filter: blur(3px);\r\n    display: none;\r\n    align-items: center;\r\n    justify-content: center;\r\n    z-index: 99999;\r\n    font-family: Inter, system-ui, sans-serif;\r\n  `;\r\n\r\n    const container = document.createElement('div');\r\n    container.style.cssText = `\r\n    background: #2d1458;\r\n    color: #fff;\r\n    border-radius: 18px;\r\n    padding: 24px 32px;\r\n    box-shadow: 0 12px 40px rgba(0,0,0,0.35);\r\n    border: 1px solid rgba(255,255,255,0.1);\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 16px;\r\n    min-width: 320px;\r\n  `;\r\n\r\n    const spinner = document.createElement('div');\r\n    spinner.style.cssText = `\r\n    width: 24px;\r\n    height: 24px;\r\n    border: 3px solid rgba(255,255,255,0.25);\r\n    border-top-color: #ffffff;\r\n    border-radius: 50%;\r\n    animation: spin 0.9s linear infinite;\r\n  `;\r\n\r\n    const message = document.createElement('div');\r\n    message.id = `${BUSY_OVERLAY_ID}-message`;\r\n    message.style.cssText = `\r\n    font-weight: 600;\r\n    font-size: 14px;\r\n    letter-spacing: 0.2px;\r\n  `;\r\n    message.textContent = 'Carregando dados...';\r\n\r\n    container.appendChild(spinner);\r\n    container.appendChild(message);\r\n    el.appendChild(container);\r\n    document.body.appendChild(el);\r\n\r\n    // Add CSS animation\r\n    if (!document.querySelector('#myio-busy-styles')) {\r\n      const styleEl = document.createElement('style');\r\n      styleEl.id = 'myio-busy-styles';\r\n      styleEl.textContent = `\r\n      @keyframes spin {\r\n        from { transform: rotate(0deg); }\r\n        to { transform: rotate(360deg); }\r\n      }\r\n    `;\r\n      document.head.appendChild(styleEl);\r\n    }\r\n\r\n    return el;\r\n  }\r\n\r\n  // PHASE 1: Centralized busy management with extended timeout\r\n  function showGlobalBusy(domain = 'unknown', message = 'Carregando dados...', timeoutMs = 25000) {\r\n    // RFC-0054: cooldown - nÔøΩo reabrir modal se acabou de prover dados\r\n    const lp = lastProvide.get(domain);\r\n    if (lp && Date.now() - lp.at < 30000) {\r\n      LogHelper.log(`[Orchestrator] ?? Cooldown active for ${domain}, skipping showGlobalBusy()`);\r\n      return;\r\n    }\r\n    const totalBefore = getActiveTotal();\r\n    const prev = activeRequests.get(domain) || 0;\r\n    activeRequests.set(domain, prev + 1);\r\n    LogHelper.log(\r\n      `[Orchestrator] ?? Active requests for ${domain}: ${prev + 1} (totalBefore=${totalBefore})`\r\n    );\r\n\r\n    const el = ensureOrchestratorBusyDOM();\r\n    const messageEl = el.querySelector(`#${BUSY_OVERLAY_ID}-message`);\r\n\r\n    if (messageEl) {\r\n      // Mensagem genÔøΩrica para evitar rÔøΩtulo incorreto ao alternar abas\r\n      messageEl.textContent = 'Carregando dados...';\r\n    }\r\n\r\n    // Clear existing timeout\r\n    if (globalBusyState.timeoutId) {\r\n      clearTimeout(globalBusyState.timeoutId);\r\n      globalBusyState.timeoutId = null;\r\n    }\r\n\r\n    // Mostrar overlay apenas quando saiu de 0 ? 1\r\n    if (totalBefore === 0) {\r\n      globalBusyState.isVisible = true;\r\n      globalBusyState.currentDomain = domain;\r\n      globalBusyState.startTime = Date.now();\r\n      globalBusyState.requestCount++;\r\n      el.style.display = 'flex';\r\n    }\r\n\r\n    // RFC-0048: Start widget monitoring (will be stopped by hideGlobalBusy)\r\n    // This is defined later in the orchestrator initialization\r\n    if (window.MyIOOrchestrator?.widgetBusyMonitor) {\r\n      window.MyIOOrchestrator.widgetBusyMonitor.startMonitoring(domain);\r\n    }\r\n\r\n    // PHASE 1: Extended timeout (25s instead of 10s)\r\n    globalBusyState.timeoutId = setTimeout(() => {\r\n      LogHelper.warn(`[Orchestrator] ?? BUSY TIMEOUT (25s) for domain ${domain} - implementing recovery`);\r\n\r\n      // Check if still actually busy\r\n      if (globalBusyState.isVisible && el.style.display !== 'none') {\r\n        // PHASE 3: Circuit breaker pattern - try graceful recovery\r\n        try {\r\n          // Emit recovery event\r\n          window.dispatchEvent(\r\n            new CustomEvent('myio:busy-timeout-recovery', {\r\n              detail: { domain, duration: Date.now() - globalBusyState.startTime },\r\n            })\r\n          );\r\n\r\n          // Hide busy and show user-friendly message\r\n          hideGlobalBusy(domain);\r\n\r\n          // Non-intrusive notification\r\n          showRecoveryNotification();\r\n        } catch (err) {\r\n          LogHelper.error(`[Orchestrator] ‚ùå Error in timeout recovery:`, err);\r\n          hideGlobalBusy(domain);\r\n        }\r\n      }\r\n\r\n      globalBusyState.timeoutId = null;\r\n    }, timeoutMs); // 25 seconds (Phase 1 requirement)\r\n\r\n    if (totalBefore === 0) {\r\n      LogHelper.log(`[Orchestrator] ? Global busy shown (domain=${domain})`);\r\n    } else {\r\n      LogHelper.log(`[Orchestrator] ?? Busy already visible (domain=${domain})`);\r\n    }\r\n  }\r\n\r\n  function hideGlobalBusy(domain = null) {\r\n    // RFC-0054: decremento por domÔøΩnio; se domain for nulo, forÔøΩa limpeza\r\n    if (domain) {\r\n      const prev = activeRequests.get(domain) || 0;\r\n      const next = Math.max(0, prev - 1);\r\n      activeRequests.set(domain, next);\r\n      LogHelper.log(\r\n        `[Orchestrator] ? hideGlobalBusy(${domain}) -> ${prev}?${next}, total=${getActiveTotal()}`\r\n      );\r\n      if (getActiveTotal() > 0) return; // mantÔøΩm overlay enquanto houver ativas\r\n    } else {\r\n      activeRequests.clear();\r\n    }\r\n\r\n    // RFC-0048: Stop widget monitoring for current domain\r\n    if (window.MyIOOrchestrator?.widgetBusyMonitor) {\r\n      window.MyIOOrchestrator.widgetBusyMonitor.stopAll();\r\n    }\r\n\r\n    const el = document.getElementById(BUSY_OVERLAY_ID);\r\n    if (el) {\r\n      el.style.display = 'none';\r\n    }\r\n\r\n    // Clear timeout\r\n    if (globalBusyState.timeoutId) {\r\n      clearTimeout(globalBusyState.timeoutId);\r\n      globalBusyState.timeoutId = null;\r\n    }\r\n\r\n    // Update state\r\n    globalBusyState.isVisible = false;\r\n    globalBusyState.currentDomain = null;\r\n    globalBusyState.startTime = null;\r\n\r\n    LogHelper.log(`[Orchestrator] ? Global busy hidden`);\r\n  }\r\n\r\n  // PHASE 4: Non-intrusive recovery notification\r\n  function showRecoveryNotification() {\r\n    const notification = document.createElement('div');\r\n    notification.style.cssText = `\r\n    position: fixed;\r\n    top: 20px;\r\n    right: 20px;\r\n    background: #f97316;\r\n    color: white;\r\n    padding: 12px 16px;\r\n    border-radius: 8px;\r\n    font-size: 14px;\r\n    font-weight: 500;\r\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\r\n    z-index: 999999;\r\n    font-family: Inter, system-ui, sans-serif;\r\n  `;\r\n    notification.textContent = 'Dados recarregados automaticamente';\r\n    document.body.appendChild(notification);\r\n\r\n    setTimeout(() => {\r\n      if (notification.parentNode) {\r\n        notification.parentNode.removeChild(notification);\r\n      }\r\n    }, 4000);\r\n  }\r\n\r\n  // Premium alert for missing credentials\r\n  function showCredentialsAlert() {\r\n    const overlay = document.createElement('div');\r\n    overlay.id = 'myio-credentials-alert';\r\n    overlay.style.cssText = `\r\n    position: fixed;\r\n    inset: 0;\r\n    background: rgba(45, 20, 88, 0.75);\r\n    backdrop-filter: blur(8px);\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    z-index: 999999;\r\n    font-family: Inter, system-ui, sans-serif;\r\n  `;\r\n\r\n    const alertBox = document.createElement('div');\r\n    alertBox.style.cssText = `\r\n    background: linear-gradient(135deg, #2d1458 0%, #1a0b33 100%);\r\n    color: #fff;\r\n    border-radius: 20px;\r\n    padding: 40px 48px;\r\n    box-shadow: 0 20px 60px rgba(0,0,0,0.5);\r\n    border: 2px solid rgba(255,255,255,0.1);\r\n    max-width: 500px;\r\n    text-align: center;\r\n    animation: slideIn 0.3s ease-out;\r\n  `;\r\n\r\n    alertBox.innerHTML = `\r\n    <div style=\"font-size: 48px; margin-bottom: 16px;\">‚ö†Ô∏è</div>\r\n    <h2 style=\"\r\n      font-size: 24px;\r\n      font-weight: 700;\r\n      margin: 0 0 16px 0;\r\n      background: linear-gradient(135deg, #fbbf24, #f59e0b);\r\n      -webkit-background-clip: text;\r\n      -webkit-text-fill-color: transparent;\r\n      background-clip: text;\r\n    \">Credenciais N√£o Encontradas</h2>\r\n    <p style=\"\r\n      font-size: 16px;\r\n      line-height: 1.6;\r\n      margin: 0 0 24px 0;\r\n      color: rgba(255,255,255,0.85);\r\n    \">\r\n      As credenciais de autentica√ß√£o n√£o foram configuradas no sistema.\r\n      <br><br>\r\n      <strong>Credenciais necess√°rias:</strong>\r\n      <br>‚Ä¢ CLIENT_ID\r\n      <br>‚Ä¢ CLIENT_SECRET\r\n      <br>‚Ä¢ CUSTOMER_ING_ID\r\n      <br><br>\r\n      Entre em contato com o administrador para configurar as credenciais necess√°rias.\r\n    </p>\r\n    <button id=\"credentials-alert-close\" style=\"\r\n      background: linear-gradient(135deg, #f59e0b, #d97706);\r\n      color: white;\r\n      border: none;\r\n      padding: 14px 32px;\r\n      border-radius: 10px;\r\n      font-size: 15px;\r\n      font-weight: 600;\r\n      cursor: pointer;\r\n      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);\r\n      transition: all 0.2s ease;\r\n    \">Fechar</button>\r\n  `;\r\n\r\n    overlay.appendChild(alertBox);\r\n    document.body.appendChild(overlay);\r\n\r\n    // Add CSS animation\r\n    if (!document.querySelector('#myio-credentials-alert-styles')) {\r\n      const styleEl = document.createElement('style');\r\n      styleEl.id = 'myio-credentials-alert-styles';\r\n      styleEl.textContent = `\r\n      @keyframes slideIn {\r\n        from {\r\n          opacity: 0;\r\n          transform: translateY(-20px) scale(0.95);\r\n        }\r\n        to {\r\n          opacity: 1;\r\n          transform: translateY(0) scale(1);\r\n        }\r\n      }\r\n\r\n      #credentials-alert-close:hover {\r\n        transform: translateY(-2px);\r\n        box-shadow: 0 6px 16px rgba(245, 158, 11, 0.5);\r\n      }\r\n\r\n      #credentials-alert-close:active {\r\n        transform: translateY(0);\r\n      }\r\n    `;\r\n      document.head.appendChild(styleEl);\r\n    }\r\n\r\n    // Close button handler\r\n    const closeBtn = document.getElementById('credentials-alert-close');\r\n    if (closeBtn) {\r\n      closeBtn.addEventListener('click', () => {\r\n        if (overlay.parentNode) {\r\n          overlay.parentNode.removeChild(overlay);\r\n        }\r\n      });\r\n    }\r\n\r\n    LogHelper.error('[MAIN_VIEW] Credentials alert displayed - system halted');\r\n  }\r\n\r\n  // PHASE 2: Shared state management for widgets coordination\r\n  let sharedWidgetState = {\r\n    activePeriod: null,\r\n    lastProcessedPeriodKey: null,\r\n    busyWidgets: new Set(),\r\n    mutexMap: new Map(), // RFC-0054 FIX: Mutex por domÔøΩnio (nÔøΩo global)\r\n  };\r\n\r\n  // State\r\n  const inFlight = new Map();\r\n  const abortControllers = new Map();\r\n\r\n  // Config will be initialized in onInit() after widgetSettings are populated\r\n  let config = null;\r\n\r\n  let visibleTab = 'energy';\r\n  let currentPeriod = null;\r\n  let CUSTOMER_ING_ID = '';\r\n  let CLIENT_ID = '';\r\n  let CLIENT_SECRET = '';\r\n\r\n  // Credentials promise resolver for async wait\r\n  let credentialsResolver = null;\r\n  let credentialsPromise = new Promise((resolve) => {\r\n    credentialsResolver = resolve;\r\n  });\r\n\r\n  // Metrics\r\n  const metrics = {\r\n    hydrationTimes: [],\r\n    totalRequests: 0,\r\n    errorCounts: {},\r\n\r\n    recordHydration(domain, duration) {\r\n      this.hydrationTimes.push({ domain, duration, timestamp: Date.now() });\r\n      this.totalRequests++;\r\n\r\n      if (config?.debugMode) {\r\n        LogHelper.log(`[Orchestrator] ${domain} hydration: ${duration}ms`);\r\n      }\r\n    },\r\n\r\n    recordError(domain, error) {\r\n      this.errorCounts[domain] = (this.errorCounts[domain] || 0) + 1;\r\n      LogHelper.error(`[Orchestrator] ${domain} error:`, error);\r\n    },\r\n\r\n    generateTelemetrySummary() {\r\n      const sum = this.hydrationTimes.reduce((acc, h) => acc + h.duration, 0);\r\n      const avg = this.hydrationTimes.length > 0 ? Math.round(sum / this.hydrationTimes.length) : 0;\r\n\r\n      return {\r\n        orchestrator_total_requests: this.totalRequests,\r\n        orchestrator_avg_hydration_ms: avg,\r\n        orchestrator_errors_total: Object.values(this.errorCounts).reduce((a, b) => a + b, 0),\r\n      };\r\n    },\r\n  };\r\n\r\n  // Request management\r\n  function abortInflight(key) {\r\n    const ac = abortControllers.get(key);\r\n    if (ac) {\r\n      ac.abort();\r\n      abortControllers.delete(key);\r\n    }\r\n  }\r\n\r\n  function abortAllInflight() {\r\n    for (const [key, ac] of abortControllers.entries()) {\r\n      ac.abort();\r\n    }\r\n    abortControllers.clear();\r\n    inFlight.clear();\r\n  }\r\n\r\n  async function fetchAndEnrich(domain, period) {\r\n    try {\r\n      LogHelper.log(`[Orchestrator] üîç fetchAndEnrich called for ${domain}`);\r\n\r\n      // Skip API fetch for temperature domain - uses only ctx.data telemetry from ThingsBoard\r\n      if (domain === 'temperature') {\r\n        LogHelper.log(`[Orchestrator] Skipping API fetch for temperature domain - using ctx.data only`);\r\n        return []; // Return empty array - TELEMETRY widget will use ctx.data directly\r\n      }\r\n\r\n      // Wait for credentials promise and refresh from global state\r\n      // Don't trust local scope variables - they may be stale\r\n      LogHelper.log(`[Orchestrator] Credentials check: flag=${window.MyIOOrchestrator?.credentialsSet}`);\r\n\r\n      // If credentials flag is not set, wait for them with timeout\r\n      if (!window.MyIOOrchestrator?.credentialsSet) {\r\n        const timeoutPromise = new Promise((_, reject) =>\r\n          setTimeout(() => reject(new Error('Credentials timeout after 10s')), 10000)\r\n        );\r\n\r\n        try {\r\n          LogHelper.log(`[Orchestrator] ‚è≥ Waiting for credentials to be set...`);\r\n          await Promise.race([credentialsPromise, timeoutPromise]);\r\n          LogHelper.log(`[Orchestrator] ‚úÖ Credentials promise resolved`);\r\n        } catch (err) {\r\n          LogHelper.error(`[Orchestrator] ‚ö†Ô∏è Credentials timeout - ${err.message}`);\r\n          throw new Error('Credentials not available - initialization timeout');\r\n        }\r\n      } else {\r\n        LogHelper.log(`[Orchestrator] ‚úÖ Credentials flag already set`);\r\n      }\r\n\r\n      // RFC-0082 FIX: Always refresh credentials from global state after waiting\r\n      // This ensures we have the latest values, not stale closure variables\r\n      const latestCreds = window.MyIOOrchestrator?.getCredentials?.();\r\n\r\n      if (!latestCreds || !latestCreds.CLIENT_ID || !latestCreds.CLIENT_SECRET) {\r\n        LogHelper.error(`[Orchestrator] ‚ùå Credentials validation failed after wait:`, {\r\n          hasGetCredentials: !!window.MyIOOrchestrator?.getCredentials,\r\n          credentialsReturned: !!latestCreds,\r\n          CLIENT_ID: latestCreds?.CLIENT_ID || 'MISSING',\r\n          CLIENT_SECRET_exists: !!latestCreds?.CLIENT_SECRET,\r\n          CUSTOMER_ING_ID: latestCreds?.CUSTOMER_ING_ID || 'MISSING',\r\n        });\r\n        throw new Error('Missing CLIENT_ID or CLIENT_SECRET - credentials not properly set');\r\n      }\r\n\r\n      const clientId = latestCreds.CLIENT_ID;\r\n      const clientSecret = latestCreds.CLIENT_SECRET;\r\n\r\n      LogHelper.log(`[Orchestrator] üîç Using credentials:`, {\r\n        CLIENT_ID: clientId?.substring(0, 10) + '...',\r\n        CLIENT_SECRET_length: clientSecret?.length || 0,\r\n        CUSTOMER_ING_ID: latestCreds.CUSTOMER_ING_ID,\r\n      });\r\n\r\n      // Create fresh MyIOAuth instance every time (like TELEMETRY widget)\r\n      const MyIO =\r\n        (typeof MyIOLibrary !== 'undefined' && MyIOLibrary) ||\r\n        (typeof window !== 'undefined' && window.MyIOLibrary) ||\r\n        null;\r\n\r\n      if (!MyIO) {\r\n        throw new Error('MyIOLibrary not available');\r\n      }\r\n\r\n      const myIOAuth = MyIO.buildMyioIngestionAuth({\r\n        dataApiHost: DATA_API_HOST,\r\n        clientId: clientId,\r\n        clientSecret: clientSecret,\r\n      });\r\n\r\n      // Get fresh token\r\n      const token = await myIOAuth.getToken();\r\n      if (!token) {\r\n        throw new Error('Failed to get ingestion token');\r\n      }\r\n\r\n      // Validate customer ID exists\r\n      if (!latestCreds.CUSTOMER_ING_ID) {\r\n        throw new Error('Missing CUSTOMER_ING_ID - customer not configured');\r\n      }\r\n\r\n      const customerId = latestCreds.CUSTOMER_ING_ID;\r\n\r\n      // Build API URL based on domain\r\n      const url = new URL(\r\n        `${DATA_API_HOST}/api/v1/telemetry/customers/${customerId}/${domain}/devices/totals`\r\n      );\r\n      url.searchParams.set('startTime', period.startISO);\r\n      url.searchParams.set('endTime', period.endISO);\r\n      url.searchParams.set('deep', '1');\r\n\r\n      LogHelper.log(`[Orchestrator] Fetching from: ${url.toString()}`);\r\n\r\n      const res = await fetch(url.toString(), {\r\n        headers: { Authorization: `Bearer ${token}` },\r\n      });\r\n\r\n      if (!res.ok) {\r\n        if (res.status === 401 || res.status === 403) {\r\n          emitTokenExpired();\r\n        }\r\n        throw new Error(`API error: ${res.status}`);\r\n      }\r\n\r\n      const json = await res.json();\r\n      const rows = Array.isArray(json) ? json : json?.data ?? [];\r\n\r\n      // Debug first row to see available fields\r\n      if (rows.length > 0) {\r\n        //LogHelper.log(`[Orchestrator] Sample API row (full):`, JSON.stringify(rows[0], null, 2));\r\n        //LogHelper.log(`[Orchestrator] Sample API row groupType field:`, rows[0].groupType);\r\n      }\r\n\r\n      // Convert API response to enriched items format\r\n      const items = rows.map((row) => ({\r\n        id: row.id,\r\n        tbId: row.id,\r\n        ingestionId: row.id,\r\n        identifier: row.identifier || row.id,\r\n        label: row.name || row.label || row.identifier || row.id, // ‚Üê API usa \"name\", n√£o \"label\"\r\n        value: Number(row.total_value || 0),\r\n        perc: 0,\r\n        deviceType: row.deviceType || 'energy',\r\n        slaveId: row.slaveId || null,\r\n        centralId: row.centralId || null,\r\n      }));\r\n\r\n      // DEBUG: Log sample item with value\r\n      if (items.length > 0 && items[0].value > 0) {\r\n        LogHelper.log(`[Orchestrator] üîç Sample API row ‚Üí item:`, {\r\n          api_row: { id: rows[0].id, total_value: rows[0].total_value, name: rows[0].name },\r\n          mapped_item: {\r\n            id: items[0].id,\r\n            ingestionId: items[0].ingestionId,\r\n            value: items[0].value,\r\n            label: items[0].label,\r\n          },\r\n        });\r\n      }\r\n\r\n      LogHelper.log(`[Orchestrator] fetchAndEnrich: fetched ${items.length} items for domain ${domain}`);\r\n      return items;\r\n    } catch (error) {\r\n      LogHelper.error(`[Orchestrator] fetchAndEnrich error for domain ${domain}:`, error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extracts period from key, ignoring customerTB_ID prefix.\r\n   * @param {string} key - Ex: 'null:energy:2025-10-01...:day' ou '20b93da0:energy:2025-10-01...:day'\r\n   * @returns {string} Ex: 'energy:2025-10-01...:day'\r\n   */\r\n  function extractPeriod(key) {\r\n    if (!key) return '';\r\n    const parts = key.split(':');\r\n    return parts.slice(1).join(':'); // Remove primeiro segmento (customerTB_ID)\r\n  }\r\n\r\n  // Fetch data for a domain and period\r\n  async function hydrateDomain(domain, period) {\r\n    const key = periodKey(domain, period);\r\n    const startTime = Date.now();\r\n\r\n    LogHelper.log(`[Orchestrator] hydrateDomain called for ${domain}:`, { key, inFlight: inFlight.has(key) });\r\n\r\n    // Coalesce duplicate requests\r\n    if (inFlight.has(key)) {\r\n      LogHelper.log(`[Orchestrator] ‚è≠Ô∏è Coalescing duplicate request for ${key}`);\r\n      return inFlight.get(key);\r\n    }\r\n\r\n    // Show busy overlay\r\n    showGlobalBusy(domain, 'Carregando dados...');\r\n\r\n    // Set mutex for coordination\r\n    sharedWidgetState.mutexMap.set(domain, true);\r\n    sharedWidgetState.activePeriod = period;\r\n\r\n    const fetchPromise = (async () => {\r\n      try {\r\n        const items = await fetchAndEnrich(domain, period);\r\n\r\n        emitHydrated(domain, key, items.length);\r\n\r\n        // Emit data to widgets\r\n        emitProvide(domain, key, items);\r\n        LogHelper.log(`[Orchestrator] üì° Emitted provide-data for ${domain} with ${items.length} items`);\r\n\r\n        const duration = Date.now() - startTime;\r\n        metrics.recordHydration(domain, duration);\r\n\r\n        LogHelper.log(`[Orchestrator] ‚úÖ Data fetched for ${domain} in ${duration}ms`);\r\n        return items;\r\n      } catch (error) {\r\n        LogHelper.error(`[Orchestrator] ‚ùå Error fetching ${domain}:`, error);\r\n        metrics.recordError(domain, error);\r\n        emitError(domain, error);\r\n        throw error;\r\n      } finally {\r\n        // Hide busy overlay\r\n        LogHelper.log(`[Orchestrator] üîÑ Finally block - hiding busy for ${domain}`);\r\n        hideGlobalBusy(domain);\r\n\r\n        // Release mutex\r\n        sharedWidgetState.mutexMap.set(domain, false);\r\n        LogHelper.log(`[Orchestrator] üîì Mutex released for ${domain}`);\r\n      }\r\n    })().finally(() => {\r\n      inFlight.delete(key);\r\n      LogHelper.log(`[Orchestrator] üßπ Cleaned up inFlight for ${key}`);\r\n    });\r\n\r\n    inFlight.set(key, fetchPromise);\r\n    return fetchPromise;\r\n  }\r\n\r\n  // Emit data to widgets\r\n  function emitProvide(domain, pKey, items) {\r\n    const now = Date.now();\r\n    const key = `${domain}_${pKey}`;\r\n\r\n    // Don't emit empty arrays\r\n    if (!items || items.length === 0) {\r\n      LogHelper.warn(`[Orchestrator] ‚ö†Ô∏è Skipping emitProvide for ${domain} - no items to emit`);\r\n      return;\r\n    }\r\n\r\n    // Prevent duplicate emissions (< 100ms)\r\n    if (OrchestratorState.lastEmission[key]) {\r\n      const timeSinceLastEmit = now - OrchestratorState.lastEmission[key];\r\n      if (timeSinceLastEmit < 100) {\r\n        LogHelper.log(\r\n          `[Orchestrator] ‚è≠Ô∏è Skipping duplicate emission for ${domain} (${timeSinceLastEmit}ms ago)`\r\n        );\r\n        return;\r\n      }\r\n    }\r\n\r\n    OrchestratorState.lastEmission[key] = now;\r\n\r\n    // Emit event to all widgets\r\n    const eventDetail = { domain, periodKey: pKey, items };\r\n    window.dispatchEvent(new CustomEvent('myio:telemetry:provide-data', { detail: eventDetail }));\r\n\r\n    try {\r\n      lastProvide.set(domain, { periodKey: pKey, at: Date.now() });\r\n      hideGlobalBusy(domain);\r\n    } catch (e) {\r\n      // Silently ignore\r\n    }\r\n\r\n    // Mark as not loading\r\n    OrchestratorState.loading[domain] = false;\r\n\r\n    // Process pending listeners (widgets that arrived late)\r\n    if (OrchestratorState.pendingListeners[domain]) {\r\n      LogHelper.log(\r\n        `[Orchestrator] üîî Processing ${OrchestratorState.pendingListeners[domain].length} pending listeners for ${domain}`\r\n      );\r\n\r\n      OrchestratorState.pendingListeners[domain].forEach((callback) => {\r\n        try {\r\n          callback({ detail: eventDetail });\r\n        } catch (err) {\r\n          LogHelper.error(`[Orchestrator] Error calling pending listener:`, err);\r\n        }\r\n      });\r\n\r\n      delete OrchestratorState.pendingListeners[domain];\r\n    }\r\n\r\n    LogHelper.log(`[Orchestrator] üì° Emitted provide-data for ${domain} with ${items.length} items`);\r\n  }\r\n\r\n  function emitHydrated(domain, periodKey, count) {\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:orchestrator:data-hydrated', {\r\n        detail: { domain, periodKey, count },\r\n      })\r\n    );\r\n  }\r\n\r\n  function emitError(domain, error) {\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:orchestrator:error', {\r\n        detail: {\r\n          domain,\r\n          error: error.message || String(error),\r\n          code: error.status || 500,\r\n        },\r\n      })\r\n    );\r\n  }\r\n\r\n  let tokenExpiredDebounce = 0;\r\n  function emitTokenExpired() {\r\n    const now = Date.now();\r\n    if (now - tokenExpiredDebounce < 60_000) return;\r\n\r\n    tokenExpiredDebounce = now;\r\n    window.dispatchEvent(new CustomEvent('myio:token-expired', { detail: {} }));\r\n  }\r\n\r\n  // Token manager\r\n  const tokenManager = {\r\n    tokens: {},\r\n\r\n    updateTokens(newTokens) {\r\n      this.tokens = { ...this.tokens, ...newTokens };\r\n\r\n      // Abort in-flight requests when tokens are rotated\r\n      abortAllInflight();\r\n\r\n      window.dispatchEvent(new CustomEvent('myio:token-rotated', { detail: {} }));\r\n\r\n      if (config?.debugMode) LogHelper.log('[Orchestrator] Tokens rotated');\r\n    },\r\n\r\n    getToken(type) {\r\n      return this.tokens[type] || null;\r\n    },\r\n\r\n    setToken(type, value) {\r\n      this.tokens[type] = value;\r\n    },\r\n  };\r\n\r\n  // Widget registration system for priority management\r\n  /**\r\n   * Registra widget com prioridade baseada na ordem de inicializa√ß√£o\r\n   */\r\n  function registerWidget(widgetId, domain) {\r\n    if (!OrchestratorState.widgetPriority.includes(widgetId)) {\r\n      OrchestratorState.widgetPriority.push(widgetId);\r\n\r\n      const priority = OrchestratorState.widgetPriority.indexOf(widgetId) + 1;\r\n\r\n      // Store in registry with metadata\r\n      OrchestratorState.widgetRegistry.set(widgetId, {\r\n        domain,\r\n        registeredAt: Date.now(),\r\n        priority,\r\n      });\r\n\r\n      LogHelper.log(\r\n        `[Orchestrator] üìù Widget registered: ${widgetId} (domain: ${domain}, priority: ${priority})`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listener para widgets se registrarem\r\n   */\r\n  window.addEventListener('myio:widget:register', (ev) => {\r\n    const { widgetId, domain } = ev.detail;\r\n    registerWidget(widgetId, domain);\r\n  });\r\n\r\n  // Event listeners\r\n  window.addEventListener('myio:update-date', (ev) => {\r\n    LogHelper.log('[Orchestrator] üìÖ Received myio:update-date event', ev.detail);\r\n    currentPeriod = ev.detail.period;\r\n\r\n    // Cross-context emission removed - HEADER already handles this\r\n    // No need to re-emit here as it creates infinite loop\r\n\r\n    if (visibleTab && currentPeriod) {\r\n      LogHelper.log(`[Orchestrator] üìÖ myio:update-date ‚Üí hydrateDomain(${visibleTab})`);\r\n      hydrateDomain(visibleTab, currentPeriod);\r\n    }\r\n  });\r\n\r\n  window.addEventListener('myio:dashboard-state', (ev) => {\r\n    const tab = ev.detail.tab;\r\n    try {\r\n      hideGlobalBusy(tab);\r\n    } catch (e) {\r\n      // Silently ignore - busy indicator may not exist yet\r\n    }\r\n    visibleTab = tab;\r\n    if (visibleTab && currentPeriod) {\r\n      LogHelper.log(`[Orchestrator] ?? myio:dashboard-state ? hydrateDomain(${visibleTab})`);\r\n      hydrateDomain(visibleTab, currentPeriod);\r\n    } else {\r\n      LogHelper.log(\r\n        `[Orchestrator] ?? myio:dashboard-state skipped (visibleTab=${visibleTab}, currentPeriod=${!!currentPeriod})`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Request-data listener with pending listeners support\r\n  window.addEventListener('myio:telemetry:request-data', async (ev) => {\r\n    const { domain, period, widgetId, priority } = ev.detail;\r\n\r\n    LogHelper.log(\r\n      `[Orchestrator] üì® Received data request from widget ${widgetId} (domain: ${domain}, priority: ${priority})`\r\n    );\r\n\r\n    // Check if already loading\r\n    if (OrchestratorState.loading[domain]) {\r\n      LogHelper.log(`[Orchestrator] ‚è≥ Already loading ${domain}, adding to pending listeners`);\r\n\r\n      // Add pending listener\r\n      if (!OrchestratorState.pendingListeners[domain]) {\r\n        OrchestratorState.pendingListeners[domain] = [];\r\n      }\r\n\r\n      OrchestratorState.pendingListeners[domain].push((data) => {\r\n        window.dispatchEvent(new CustomEvent('myio:telemetry:provide-data', { detail: data.detail }));\r\n        try {\r\n          lastProvide.set(domain, { periodKey: data.detail.periodKey, at: Date.now() });\r\n          hideGlobalBusy(domain);\r\n        } catch (e) {\r\n          // Silently ignore\r\n        }\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    // Fetch fresh data\r\n    OrchestratorState.loading[domain] = true;\r\n\r\n    try {\r\n      const p = period || currentPeriod;\r\n      if (p) {\r\n        LogHelper.log(`[Orchestrator] üì° myio:telemetry:request-data ‚Üí hydrateDomain(${domain})`);\r\n        await hydrateDomain(domain, p);\r\n      } else {\r\n        LogHelper.log(`[Orchestrator] üì° myio:telemetry:request-data skipped (no period)`);\r\n        OrchestratorState.loading[domain] = false;\r\n      }\r\n    } catch (error) {\r\n      LogHelper.error(`[Orchestrator] Error hydrating ${domain}:`, error);\r\n      OrchestratorState.loading[domain] = false;\r\n    }\r\n  });\r\n\r\n  // Telemetry reporting\r\n  if (!config?.debugMode && typeof window.tbClient !== 'undefined') {\r\n    setInterval(() => {\r\n      try {\r\n        window.tbClient.sendTelemetry(metrics.generateTelemetrySummary());\r\n      } catch (e) {\r\n        LogHelper.warn('[Orchestrator] Failed to send telemetry:', e);\r\n      }\r\n    }, 5 * 60 * 1000);\r\n  }\r\n\r\n  // RFC-0048: Widget Busy Monitor - Detects stuck widgets showing busy for too long\r\n  const widgetBusyMonitor = {\r\n    timers: new Map(), // domain -> timeoutId\r\n    TIMEOUT_MS: 30000, // 30 seconds\r\n\r\n    startMonitoring(domain) {\r\n      // Clear existing timer if any\r\n      this.stopMonitoring(domain);\r\n\r\n      const timerId = setTimeout(() => {\r\n        LogHelper.error(\r\n          `[WidgetMonitor] ‚ö†Ô∏è Widget ${domain} has been showing busy for more than ${\r\n            this.TIMEOUT_MS / 1000\r\n          }s!`\r\n        );\r\n        LogHelper.error(`[WidgetMonitor] Possible issues:`);\r\n        LogHelper.error(`[WidgetMonitor] 1. Widget n√£o recebeu dados do orchestrator`);\r\n        LogHelper.error(`[WidgetMonitor] 2. Widget recebeu dados vazios mas n√£o chamou hideBusy()`);\r\n        LogHelper.error(`[WidgetMonitor] 3. Erro silencioso impedindo processamento`);\r\n\r\n        // Log current busy state\r\n        const busyState = globalBusyState;\r\n        LogHelper.error(`[WidgetMonitor] Current busy state:`, busyState);\r\n\r\n        // Attempt auto-recovery: force hide busy for stuck widget\r\n        LogHelper.warn(`[WidgetMonitor] üîß Attempting auto-recovery: forcing hideBusy for ${domain}`);\r\n        hideGlobalBusy(domain);\r\n      }, this.TIMEOUT_MS);\r\n\r\n      this.timers.set(domain, timerId);\r\n      LogHelper.log(`[WidgetMonitor] ‚úÖ Started monitoring ${domain} (timeout: ${this.TIMEOUT_MS / 1000}s)`);\r\n    },\r\n\r\n    stopMonitoring(domain) {\r\n      const timerId = this.timers.get(domain);\r\n      if (timerId) {\r\n        clearTimeout(timerId);\r\n        this.timers.delete(domain);\r\n        LogHelper.log(`[WidgetMonitor] ‚úÖ Stopped monitoring ${domain}`);\r\n      }\r\n    },\r\n\r\n    stopAll() {\r\n      for (const [domain, timerId] of this.timers.entries()) {\r\n        clearTimeout(timerId);\r\n        LogHelper.log(`[WidgetMonitor] ‚úÖ Stopped monitoring ${domain}`);\r\n      }\r\n      this.timers.clear();\r\n    },\r\n  };\r\n\r\n  // Public API\r\n  return {\r\n    hydrateDomain,\r\n    setVisibleTab: (tab) => {\r\n      visibleTab = tab;\r\n    },\r\n    getVisibleTab: () => visibleTab,\r\n    getCurrentPeriod: () => currentPeriod,\r\n    getStats: () => ({\r\n      totalRequests: metrics.totalRequests,\r\n      inFlightCount: inFlight.size,\r\n    }),\r\n    tokenManager,\r\n    metrics,\r\n    config,\r\n\r\n    // Expose centralized busy management\r\n    showGlobalBusy,\r\n    hideGlobalBusy,\r\n\r\n    // Expose shared state\r\n    getSharedWidgetState: () => sharedWidgetState,\r\n    setSharedPeriod: (period) => {\r\n      sharedWidgetState.activePeriod = period;\r\n    },\r\n\r\n    // Expose busy state for debugging\r\n    getBusyState: () => ({ ...globalBusyState }),\r\n\r\n    // Expose widget busy monitor\r\n    widgetBusyMonitor,\r\n\r\n    setCredentials: (customerId, clientId, clientSecret) => {\r\n      LogHelper.log(`[Orchestrator] üîê setCredentials called with:`, {\r\n        customerId,\r\n        clientId,\r\n        clientSecretLength: clientSecret?.length || 0,\r\n      });\r\n\r\n      CUSTOMER_ING_ID = customerId;\r\n      CLIENT_ID = clientId;\r\n      CLIENT_SECRET = clientSecret;\r\n\r\n      LogHelper.log(`[Orchestrator] ‚úÖ Credentials set successfully:`, {\r\n        CUSTOMER_ING_ID,\r\n        CLIENT_ID,\r\n        CLIENT_SECRET_length: CLIENT_SECRET?.length || 0,\r\n      });\r\n\r\n      // RFC-0051.2: Mark credentials as set\r\n      if (window.MyIOOrchestrator) {\r\n        window.MyIOOrchestrator.credentialsSet = true;\r\n      }\r\n\r\n      // Resolve the promise to unblock waiting fetchAndEnrich calls\r\n      if (credentialsResolver) {\r\n        credentialsResolver();\r\n        LogHelper.log(`[Orchestrator] ‚úÖ Credentials promise resolved - unblocking pending requests`);\r\n      }\r\n    },\r\n\r\n    getCredentials: () => {\r\n      return {\r\n        CUSTOMER_ING_ID,\r\n        CLIENT_ID,\r\n        CLIENT_SECRET,\r\n      };\r\n    },\r\n\r\n    destroy: () => {\r\n      // Abort all in-flight requests\r\n      abortAllInflight();\r\n\r\n      // Stop all widget monitors\r\n      widgetBusyMonitor.stopAll();\r\n\r\n      // Clean up busy overlay\r\n      hideGlobalBusy();\r\n      const busyEl = document.getElementById(BUSY_OVERLAY_ID);\r\n      if (busyEl && busyEl.parentNode) {\r\n        busyEl.parentNode.removeChild(busyEl);\r\n      }\r\n    },\r\n  };\r\n})();\r\n\r\n// RFC-0051.2: Update stub with real implementation and mark as ready\r\nif (window.MyIOOrchestrator && !window.MyIOOrchestrator.isReady) {\r\n  // Merge real implementation with stub\r\n  Object.assign(window.MyIOOrchestrator, MyIOOrchestrator);\r\n\r\n  // Mark as ready\r\n  window.MyIOOrchestrator.isReady = true;\r\n  window.MyIOOrchestrator.credentialsSet = false; // Will be set by setCredentials()\r\n\r\n  LogHelper.log('[Orchestrator] ‚úÖ Orchestrator fully initialized and ready');\r\n\r\n  // Emit ready event for widgets that are waiting\r\n  window.dispatchEvent(\r\n    new CustomEvent('myio:orchestrator:ready', {\r\n      detail: { timestamp: Date.now() },\r\n    })\r\n  );\r\n\r\n  LogHelper.log('[Orchestrator] üì¢ Emitted myio:orchestrator:ready event');\r\n} else {\r\n  // Fallback: no stub exists (shouldn't happen but be safe)\r\n  window.MyIOOrchestrator = MyIOOrchestrator;\r\n  window.MyIOOrchestrator.isReady = true;\r\n  window.MyIOOrchestrator.credentialsSet = false;\r\n\r\n  LogHelper.log('[MyIOOrchestrator] Initialized (no stub found)');\r\n}\r\n",
      "settingsSchema": "{\r\n  \"schema\": {\r\n    \"type\": \"object\",\r\n    \"title\": \"MAIN_VIEW Orchestrator Settings\",\r\n    \"properties\": {\r\n      \"customerTB_ID\": {\r\n        \"title\": \"Customer ThingsBoard ID\",\r\n        \"type\": \"string\",\r\n        \"description\": \"ID do customer no ThingsBoard para buscar atributos de autentica√ß√£o (client_id, client_secret, ingestionId)\"\r\n      },\r\n      \"enableCache\": {\r\n        \"title\": \"Enable Cache System\",\r\n        \"type\": \"boolean\",\r\n        \"default\": true,\r\n        \"description\": \"RFC-0052: Enable/disable cache system globally. Set to FALSE to always fetch fresh data from API (use for troubleshooting or real-time dashboards). WARNING: Disabling cache increases API load.\"\r\n      },\r\n      \"cacheTtlMinutes\": {\r\n        \"title\": \"Cache TTL (minutes)\",\r\n        \"type\": \"number\",\r\n        \"default\": 30,\r\n        \"description\": \"Time-to-live for cached data entries (RFC-0047: changed from 5 to 30 minutes)\"\r\n      },\r\n      \"enableStaleWhileRevalidate\": {\r\n        \"title\": \"Enable Stale-While-Revalidate\",\r\n        \"type\": \"boolean\",\r\n        \"default\": true,\r\n        \"description\": \"Serve stale data immediately while refreshing in background\"\r\n      },\r\n      \"maxCacheSize\": {\r\n        \"title\": \"Max Cache Size\",\r\n        \"type\": \"number\",\r\n        \"default\": 50,\r\n        \"description\": \"Maximum number of cache entries (LRU eviction)\"\r\n      },\r\n      \"debugMode\": {\r\n        \"title\": \"Debug Mode\",\r\n        \"type\": \"boolean\",\r\n        \"default\": false,\r\n        \"description\": \"Enable console logging and debug overlay (Ctrl+Shift+D)\"\r\n      },\r\n      \"domainsEnabled\": {\r\n        \"title\": \"Enabled Domains\",\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"energy\": {\r\n            \"title\": \"Energy Domain\",\r\n            \"type\": \"boolean\",\r\n            \"default\": true\r\n          },\r\n          \"water\": {\r\n            \"title\": \"Water Domain\",\r\n            \"type\": \"boolean\",\r\n            \"default\": true\r\n          },\r\n          \"temperature\": {\r\n            \"title\": \"Temperature Domain\",\r\n            \"type\": \"boolean\",\r\n            \"default\": true\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n  \"form\": [\r\n    \"customerTB_ID\",\r\n    \"enableCache\",\r\n    \"cacheTtlMinutes\",\r\n    \"enableStaleWhileRevalidate\",\r\n    \"maxCacheSize\",\r\n    \"debugMode\",\r\n    \"domainsEnabled.energy\",\r\n    \"domainsEnabled.water\",\r\n    \"domainsEnabled.temperature\"\r\n  ]\r\n}\r\n",
      "dataKeySettingsSchema": "{}\n",
      "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Attributes card\",\"decimals\":null}"
    },
    "externalId": null,
    "resources": null,
    "id": {
      "entityType": "WIDGET_TYPE",
      "id": "1faf5e00-a3b5-11f0-afe1-175479a33d89"
    },
    "scada": false,
    "tags": null
  },
  "relations": [],
  "attributes": {
    "SERVER_SCOPE": []
  }
}