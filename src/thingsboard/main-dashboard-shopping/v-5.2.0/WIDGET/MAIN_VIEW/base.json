{
  "entityType": "WIDGET_TYPE",
  "entity": {
    "fqn": "widget_shopping_dashboard_main_view_v_5_2_0",
    "name": "Widget - Shopping Dashboard - MAIN VIEW - v.5.2.0",
    "deprecated": false,
    "image": null,
    "description": null,
    "descriptor": {
      "type": "latest",
      "sizeX": 7.5,
      "sizeY": 3,
      "resources": [
        {
          "url": "https://unpkg.com/myio-js-library@latest/dist/myio-js-library.umd.min.js"
        }
      ],
      "templateHtml": "<section id=\"myio-root\" class=\"myio-grid\">\r\n  <aside class=\"myio-sidebar\">\r\n    <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"menu\"></tb-dashboard-state>\r\n  </aside>\r\n\r\n  <header class=\"myio-header\">\r\n    <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"header\"></tb-dashboard-state>\r\n  </header>\r\n\r\n  <main class=\"myio-content\">\r\n    <!-- RFC-0053: All states pre-loaded with show/hide logic (no iframes!) -->\r\n    <div data-content-state=\"telemetry_content\" style=\"display: block; height: 100%; min-height: 400px\">\r\n      <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"telemetry_content\"></tb-dashboard-state>\r\n    </div>\r\n    <div data-content-state=\"water_content\" style=\"display: none; height: 100%; min-height: 400px\">\r\n      <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"water_content\"></tb-dashboard-state>\r\n    </div>\r\n    <div data-content-state=\"temperature_content\" style=\"display: none; height: 100%; min-height: 400px\">\r\n      <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"temperature_content\"></tb-dashboard-state>\r\n    </div>\r\n    <div data-content-state=\"alarm_content\" style=\"display: none; height: 100%; min-height: 400px\">\r\n      <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"alarm_content\"></tb-dashboard-state>\r\n    </div>\r\n  </main>\r\n\r\n  <footer class=\"myio-footer\">\r\n    <tb-dashboard-state class=\"tb-child\" [ctx]=\"ctx\" stateId=\"footer\"></tb-dashboard-state>\r\n  </footer>\r\n</section>\r\n",
      "templateCss": "#myio-root {\r\n  --myio-radius: 16px;\r\n\r\n  --sidebar-w: 260px;\r\n  --sidebar-w-compact: 72px;\r\n}\r\n\r\n/* root + filhos ocupam 100% */\r\n#myio-root.myio-grid,\r\n#myio-root .tb-child {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\n/* GRID PRINCIPAL */\r\n#myio-root.myio-grid {\r\n  display: grid;\r\n  grid-template-columns: var(--sidebar-w) 1fr;\r\n  grid-template-rows: auto 1fr 46px;\r\n  grid-template-areas:\r\n    'sidebar header'\r\n    'sidebar content'\r\n    'footer footer';\r\n  width: 100%;\r\n  height: 100%;\r\n  background: var(--myio-bg);\r\n  overflow: hidden;\r\n  gap: 0 !important;\r\n}\r\n\r\n/* Ãreas */\r\n#myio-root .myio-sidebar {\r\n  grid-area: sidebar;\r\n  background: var(--myio-panel);\r\n  border-right: 1px solid var(--myio-border);\r\n  box-shadow: none; /* remove sombra lateral */\r\n  padding: 0;\r\n  margin: 0;\r\n}\r\n\r\n#myio-root .myio-content {\r\n  grid-area: content;\r\n  background: transparent;\r\n  overflow: auto;\r\n  height: 100%;\r\n  min-height: 0; /* allow grid child to shrink and enable inner scroll */\r\n  box-sizing: border-box;\r\n  margin: 0 !important;\r\n  padding: 0 0 0 0 !important; /* Sem padding-bottom, o grid jÃ¡ reserva espaÃ§o */\r\n  position: relative;\r\n}\r\n\r\n/* Garantir que os containers de conteÃºdo preencham a Ã¡rea disponÃ­vel */\r\n#myio-root .myio-content [data-content-state] {\r\n  display: block;\r\n  width: 100%;\r\n  height: 100%;\r\n  min-height: 400px;\r\n  box-sizing: border-box;\r\n}\r\n\r\n#myio-root .myio-header {\r\n  grid-area: header;\r\n  background: var(--myio-panel);\r\n  border-bottom: 1px solid var(--myio-border);\r\n  padding: 0;\r\n  margin: 0;\r\n  min-height: 75px;\r\n}\r\n\r\n#myio-root .myio-footer {\r\n  grid-area: footer;\r\n  height: 46px;\r\n  min-height: 46px;\r\n  max-height: 46px;\r\n  overflow: visible;\r\n  z-index: 1000;\r\n}\r\n\r\n/* AparÃªncia comum */\r\n#myio-root .myio-sidebar {\r\n  border-radius: 0;\r\n}\r\n\r\n/* Neutralizador de states internos */\r\n#myio-root .myio-sidebar .tb-child,\r\n#myio-root .myio-header .tb-child {\r\n  width: 100%;\r\n  height: 100%;\r\n  margin: 0 !important;\r\n  padding: 0 !important;\r\n  display: flex;\r\n  align-items: stretch;\r\n  justify-content: stretch;\r\n  overflow: visible;\r\n}\r\n\r\n/* Widgets de content precisam de scroll - NÃƒO forÃ§ar overflow: visible */\r\n#myio-root .myio-content .tb-child {\r\n  width: 100%;\r\n  height: 100%;\r\n  margin: 0 !important;\r\n  padding: 0 !important;\r\n  display: flex;\r\n  align-items: stretch;\r\n  justify-content: stretch;\r\n  overflow: auto; /* âœ… MUDADO: permite scroll nos widgets */\r\n}\r\n\r\n/* ThingsBoard wrapper para widgets dinamicamente carregados */\r\n#myio-root .myio-content .tb-child tb-dynamic-component,\r\n#myio-root .myio-content .tb-child tb-dynamic-component > * {\r\n  display: block;\r\n  width: 100%;\r\n  height: 100%;\r\n  min-height: 400px;\r\n}\r\n#myio-root .myio-footer .tb-child {\r\n  /* Remove o padding padrÃ£o do Gridster */\r\n  padding: 0 !important;\r\n\r\n  /* Aplica todo o estilo visual que estava no #myio-root .myio-footer */\r\n  background: linear-gradient(90deg, #121a2b, #1c2743);\r\n  border-top: 2px solid #00e09e;\r\n  box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n/* wrapper interno (nÃ­vel 1 e 2) */\r\n#myio-root .myio-content .tb-child > :first-child,\r\n#myio-root .myio-content .tb-child > :first-child > :first-child {\r\n  margin-left: 0 !important;\r\n  padding-left: 0 !important;\r\n}\r\n\r\n/* elementos internos comuns */\r\n#myio-root .myio-content .tb-child > * {\r\n  flex: 1 1 auto;\r\n  width: 100%;\r\n  max-width: none;\r\n  height: 100%;\r\n  box-sizing: border-box;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\n/* containers internos */\r\n#myio-root .myio-content .tb-child .container,\r\n#myio-root .myio-content .tb-child .content,\r\n#myio-root .myio-content .tb-child .mat-card,\r\n#myio-root .myio-content .tb-child .mat-mdc-card {\r\n  width: 100%;\r\n  max-width: none;\r\n  margin: 0;\r\n  box-sizing: border-box;\r\n  background: transparent !important;\r\n  box-shadow: none !important;\r\n  padding: 0 !important;\r\n  border-radius: 0 !important;\r\n}\r\n\r\n/* grids internos */\r\n#myio-root .myio-content .tb-child .layout-row,\r\n#myio-root .myio-content .tb-child .layout-column {\r\n  width: 100%;\r\n  max-width: none;\r\n}\r\n\r\n/* Scrollbar suave apenas no content */\r\n#myio-root .myio-content::-webkit-scrollbar {\r\n  width: 10px;\r\n  height: 10px;\r\n}\r\n#myio-root .myio-content::-webkit-scrollbar-track {\r\n  background: transparent;\r\n}\r\n\r\n/* Menu compacto */\r\n#myio-root.myio-grid.menu-compact {\r\n  grid-template-columns: var(--sidebar-w-compact) 1fr;\r\n}\r\n#myio-root.myio-grid.menu-compact .myio-sidebar {\r\n  width: var(--sidebar-w-compact);\r\n}\r\n\r\n/* Responsivo */\r\n@media (max-width: 1200px) {\r\n  #myio-root {\r\n    --sidebar-w: 260px;\r\n  }\r\n}\r\n@media (max-width: 920px) {\r\n  #myio-root.myio-grid {\r\n    grid-template-columns: 1fr;\r\n    grid-template-rows: auto 1fr; /* sidebar, content */\r\n    grid-template-areas:\r\n      'sidebar'\r\n      'content';\r\n  }\r\n  #myio-root .myio-sidebar {\r\n    border-right: none;\r\n    border-bottom: 1px solid var(--myio-border);\r\n  }\r\n}\r\n\r\n/* ajustes extras */\r\n.shops-menu-root {\r\n  padding: 12px 0; /* sÃ³ vertical */\r\n}\r\n#myio-root .myio-content > * {\r\n  margin: 0;\r\n}\r\n",
      "controllerScript": "/* global self, window, document, localStorage, MyIOLibrary, ResizeObserver */\r\n\r\n/*********************************************************\r\n * MYIO â€“ Container 2 states (menu/content)\r\n * - Ajusta alturas automaticamente\r\n * - Suporta \"menu compacto\" via evento global\r\n * - MantÃ©m simples: os tb-dashboard-state renderizam os\r\n * dashboards configurados no prÃ³prio ThingsBoard.\r\n *********************************************************/\r\n\r\n// Debug configuration - can be toggled at runtime via window.MyIOUtils.setDebug(true/false)\r\nlet DEBUG_ACTIVE = true;\r\n\r\n// LogHelper utility - shared across all widgets in this context\r\nconst LogHelper = {\r\n  log: function (...args) {\r\n    if (DEBUG_ACTIVE) {\r\n      console.log(...args);\r\n    }\r\n  },\r\n  warn: function (...args) {\r\n    if (DEBUG_ACTIVE) {\r\n      console.warn(...args);\r\n    }\r\n  },\r\n  error: function (...args) {\r\n    // Errors always logged regardless of DEBUG_ACTIVE\r\n    console.error(...args);\r\n  },\r\n};\r\n\r\n// RFC-0091: Expose shared utilities globally for child widgets (TELEMETRY, etc.)\r\n// RFC-0091: Shared constants across all widgets\r\nconst DATA_API_HOST = 'https://api.data.apps.myio-bas.com';\r\n\r\nwindow.MyIOUtils = window.MyIOUtils || {};\r\nObject.assign(window.MyIOUtils, {\r\n  LogHelper,\r\n  DATA_API_HOST,\r\n  isDebugActive: () => DEBUG_ACTIVE,\r\n  setDebug: (active) => {\r\n    DEBUG_ACTIVE = !!active;\r\n    console.log(`[MyIOUtils] Debug mode ${DEBUG_ACTIVE ? 'enabled' : 'disabled'}`);\r\n  },\r\n  // Temperature domain: global min/max temperature limits (populated by onDataUpdated)\r\n  temperatureLimits: {\r\n    minTemperature: null,\r\n    maxTemperature: null,\r\n  },\r\n  // RFC-0106: Global mapInstantaneousPower from customer's parent entity\r\n  // Used for deviceStatus calculation with power ranges\r\n  mapInstantaneousPower: null,\r\n  // RFC-XXXX: SuperAdmin flag - user with @myio.com.br email (except alarme/alarmes)\r\n  // Populated by detectSuperAdmin() in onInit\r\n  SuperAdmin: false,\r\n\r\n  // RFC-0108: Measurement display settings (units, decimal places)\r\n  // Default values - can be overridden by user via MeasurementSetupModal\r\n  measurementSettings: {\r\n    water: { unit: 'm3', decimalPlaces: 3, autoScale: true },\r\n    energy: { unit: 'auto', decimalPlaces: 3, forceUnit: false },\r\n    temperature: { unit: 'celsius', decimalPlaces: 1 },\r\n  },\r\n\r\n  /**\r\n   * RFC-0108: Format a number with Brazilian locale (1.234,56)\r\n   * @param {number} value - The number to format\r\n   * @param {number} decimals - Number of decimal places\r\n   * @returns {string} Formatted number string\r\n   */\r\n  formatNumberBR: (value, decimals = 2) => {\r\n    const parts = value.toFixed(decimals).split('.');\r\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, '.');\r\n    return decimals > 0 ? parts.join(',') : parts[0];\r\n  },\r\n\r\n  /**\r\n   * RFC-0108: Format energy value based on measurement settings\r\n   * @param {number} valueKwh - Energy value in kWh\r\n   * @returns {string} Formatted value with unit (e.g., \"1.234,567 kWh\" or \"1,234 MWh\")\r\n   */\r\n  formatEnergyWithSettings: (valueKwh) => {\r\n    const settings = window.MyIOUtils?.measurementSettings?.energy || {\r\n      unit: 'auto',\r\n      decimalPlaces: 3,\r\n      forceUnit: false,\r\n    };\r\n    const formatNum = window.MyIOUtils?.formatNumberBR || ((v, d) => v.toFixed(d));\r\n\r\n    let displayValue = valueKwh;\r\n    let unit = 'kWh';\r\n\r\n    if (settings.unit === 'mwh') {\r\n      displayValue = valueKwh / 1000;\r\n      unit = 'MWh';\r\n    } else if (settings.unit === 'auto' && !settings.forceUnit && valueKwh >= 1000) {\r\n      displayValue = valueKwh / 1000;\r\n      unit = 'MWh';\r\n    }\r\n\r\n    return `${formatNum(displayValue, settings.decimalPlaces)} ${unit}`;\r\n  },\r\n\r\n  /**\r\n   * RFC-0108: Format water value based on measurement settings\r\n   * @param {number} valueM3 - Water volume in cubic meters\r\n   * @returns {string} Formatted value with unit (e.g., \"1.234,567 mÂ³\" or \"1.234.567,000 L\")\r\n   */\r\n  formatWaterWithSettings: (valueM3) => {\r\n    const settings = window.MyIOUtils?.measurementSettings?.water || {\r\n      unit: 'm3',\r\n      decimalPlaces: 3,\r\n      autoScale: true,\r\n    };\r\n    const formatNum = window.MyIOUtils?.formatNumberBR || ((v, d) => v.toFixed(d));\r\n\r\n    let displayValue = valueM3;\r\n    let unit = 'mÂ³';\r\n\r\n    if (settings.unit === 'liters') {\r\n      displayValue = valueM3 * 1000;\r\n      unit = 'L';\r\n    }\r\n\r\n    return `${formatNum(displayValue, settings.decimalPlaces)} ${unit}`;\r\n  },\r\n\r\n  /**\r\n   * RFC-0108: Format temperature value based on measurement settings\r\n   * @param {number} valueCelsius - Temperature in Celsius\r\n   * @returns {string} Formatted value with unit (e.g., \"23,5 Â°C\" or \"74,3 Â°F\")\r\n   */\r\n  formatTemperatureWithSettings: (valueCelsius) => {\r\n    const settings = window.MyIOUtils?.measurementSettings?.temperature || {\r\n      unit: 'celsius',\r\n      decimalPlaces: 1,\r\n    };\r\n    const formatNum = window.MyIOUtils?.formatNumberBR || ((v, d) => v.toFixed(d));\r\n\r\n    let displayValue = valueCelsius;\r\n    let unit = 'Â°C';\r\n\r\n    if (settings.unit === 'fahrenheit') {\r\n      displayValue = (valueCelsius * 9) / 5 + 32;\r\n      unit = 'Â°F';\r\n    }\r\n\r\n    return `${formatNum(displayValue, settings.decimalPlaces)} ${unit}`;\r\n  },\r\n\r\n  /**\r\n   * RFC-0108: Update measurement settings (called by MENU after modal save)\r\n   * @param {object} newSettings - New measurement settings object\r\n   */\r\n  updateMeasurementSettings: (newSettings) => {\r\n    if (newSettings) {\r\n      if (newSettings.water) window.MyIOUtils.measurementSettings.water = newSettings.water;\r\n      if (newSettings.energy) window.MyIOUtils.measurementSettings.energy = newSettings.energy;\r\n      if (newSettings.temperature) window.MyIOUtils.measurementSettings.temperature = newSettings.temperature;\r\n      LogHelper.log('[MyIOUtils] RFC-0108: Measurement settings updated:', window.MyIOUtils.measurementSettings);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Handle 401 Unauthorized errors globally\r\n   * Shows toast message and reloads the page\r\n   * @param {string} context - Context description for logging (e.g., 'TemperatureSettingsModal')\r\n   */\r\n  handleUnauthorizedError: (context = 'API') => {\r\n    LogHelper.error(`[MyIOUtils] 401 Unauthorized in ${context} - session expired`);\r\n\r\n    // Get MyIOToast from library\r\n    const MyIOToast = window.MyIOLibrary?.MyIOToast;\r\n    if (MyIOToast) {\r\n      MyIOToast.error('SessÃ£o expirada. Recarregando pÃ¡gina...', 3000);\r\n    } else {\r\n      console.error('[MyIOUtils] SessÃ£o expirada. Recarregando pÃ¡gina...');\r\n    }\r\n\r\n    // Reload page after toast displays\r\n    setTimeout(() => {\r\n      window.location.reload();\r\n    }, 2500);\r\n  },\r\n\r\n  /**\r\n   * RFC-0106: Handle data loading errors (ctx.data timeout, no datasources, etc.)\r\n   * Shows toast message and reloads the page to try again\r\n   * ONLY reloads if there's no existing data displayed (prevents unnecessary reloads when cache is available)\r\n   * Now includes RETRY logic: tries to refetch data before reloading the page\r\n   * @param {string} domain - Domain that failed to load (e.g., 'energy', 'water')\r\n   * @param {string} reason - Reason for the failure\r\n   */\r\n  handleDataLoadError: (domain = 'unknown', reason = 'timeout') => {\r\n    LogHelper.error(`[MyIOUtils] Data load error for ${domain}: ${reason}`);\r\n\r\n    // Check if we already have data in window.STATE for this domain\r\n    // If we have cached/existing data, don't reload - just log the error\r\n    const existingData = window.STATE?.[domain];\r\n    const hasExistingData =\r\n      existingData &&\r\n      (existingData.summary?.total > 0 ||\r\n        existingData.entrada?.total > 0 ||\r\n        existingData.lojas?.total > 0 ||\r\n        existingData._raw?.length > 0);\r\n\r\n    if (hasExistingData) {\r\n      LogHelper.warn(`[MyIOUtils] Data load failed but existing data found for ${domain} - skipping reload`);\r\n      // Silent skip - don't show toast when we have cached data to display\r\n      // User doesn't need to know about background refresh failures\r\n      return; // Don't reload - we have data to show\r\n    }\r\n\r\n    // Track retry attempts per domain\r\n    window._dataLoadRetryAttempts = window._dataLoadRetryAttempts || {};\r\n    const retryCount = window._dataLoadRetryAttempts[domain] || 0;\r\n    const MAX_RETRIES = 5;\r\n\r\n    if (retryCount < MAX_RETRIES) {\r\n      // Increment retry counter\r\n      window._dataLoadRetryAttempts[domain] = retryCount + 1;\r\n\r\n      const MyIOToast = window.MyIOLibrary?.MyIOToast;\r\n      const retryMessage = `Tentativa ${retryCount + 1}/${MAX_RETRIES}: Recarregando dados (${domain})...`;\r\n\r\n      LogHelper.warn(`[MyIOUtils] Retry ${retryCount + 1}/${MAX_RETRIES} for ${domain}`);\r\n\r\n      if (MyIOToast) {\r\n        MyIOToast.warning(retryMessage, 3000);\r\n      }\r\n\r\n      // Try to trigger a refetch by clicking the \"Carregar\" button after a short delay\r\n      setTimeout(() => {\r\n        LogHelper.log(`[MyIOUtils] Triggering retry fetch for ${domain}...`);\r\n\r\n        // Clear any cached period key to force a fresh fetch\r\n        if (window.MyIOOrchestrator?.clearCache) {\r\n          window.MyIOOrchestrator.clearCache(domain);\r\n        }\r\n\r\n        // Try to click the \"Carregar\" button from HEADER widget\r\n        // This is more reliable because it uses the exact same flow as user interaction\r\n        const btnLoad = document.querySelector('#tbx-btn-load');\r\n        if (btnLoad && !btnLoad.disabled) {\r\n          LogHelper.log(`[MyIOUtils] ðŸ”„ Clicking \"Carregar\" button for retry...`);\r\n          btnLoad.click();\r\n        } else {\r\n          // Fallback: emit request event directly if button not available\r\n          LogHelper.log(`[MyIOUtils] âš ï¸ Carregar button not found, emitting request event directly...`);\r\n          window.dispatchEvent(\r\n            new CustomEvent('myio:telemetry:request-data', {\r\n              detail: {\r\n                domain: domain,\r\n                isRetry: true,\r\n                retryAttempt: retryCount + 1,\r\n              },\r\n            })\r\n          );\r\n        }\r\n      }, 2000);\r\n\r\n      return; // Don't reload yet - wait for retry\r\n    }\r\n\r\n    // Max retries exceeded - must reload\r\n    LogHelper.error(`[MyIOUtils] Max retries (${MAX_RETRIES}) exceeded for ${domain} - reloading page`);\r\n\r\n    // Reset retry counter before reload\r\n    window._dataLoadRetryAttempts[domain] = 0;\r\n\r\n    const MyIOToast = window.MyIOLibrary?.MyIOToast;\r\n    const message = `Erro ao carregar dados (${domain}). Recarregando pÃ¡gina...`;\r\n\r\n    if (MyIOToast) {\r\n      MyIOToast.error(message, 4000);\r\n    } else {\r\n      console.error(`[MyIOUtils] ${message}`);\r\n      // Fallback: show alert if toast not available\r\n      window.alert(message);\r\n    }\r\n\r\n    // Reload page after toast displays\r\n    setTimeout(() => {\r\n      window.location.reload();\r\n    }, 3500);\r\n  },\r\n});\r\n// Expose customerTB_ID via getter (reads from MyIOOrchestrator when available)\r\n// Check if property already exists to avoid \"Cannot redefine property\" error\r\nif (!Object.prototype.hasOwnProperty.call(window.MyIOUtils, 'customerTB_ID')) {\r\n  Object.defineProperty(window.MyIOUtils, 'customerTB_ID', {\r\n    get: () => window.MyIOOrchestrator?.customerTB_ID || null,\r\n    enumerable: true,\r\n    configurable: true, // Allow redefinition if needed\r\n  });\r\n}\r\n\r\n// RFC-0051.1: Global widget settings (will be populated in onInit)\r\n// IMPORTANT: customerTB_ID must NEVER be 'default' - it must always be a valid ThingsBoard ID\r\nlet widgetSettings = {\r\n  customerTB_ID: null, // MUST be set in onInit\r\n  debugMode: false,\r\n  domainsEnabled: { energy: true, water: true, temperature: true },\r\n  excludeDevicesAtCountSubtotalCAG: [], // Entity IDs to exclude from CAG subtotal calculation\r\n};\r\n\r\n// Config object (populated in onInit from widgetSettings)\r\nlet config = null;\r\n\r\n// ============================================================================\r\n// RFC-0106: Device Classification (moved from TELEMETRY)\r\n// Centralized classification logic for device categorization\r\n// ============================================================================\r\n\r\n/**\r\n * RFC-0097/RFC-0106: Centralized device classification configuration\r\n * All deviceType â†’ category mapping rules are defined here\r\n */\r\nconst DEVICE_CLASSIFICATION_CONFIG = {\r\n  // DeviceTypes que pertencem Ã  categoria ClimatizaÃ§Ã£o\r\n  // Baseado em src/MYIO-SIM/v5.2.0/mapPower.json\r\n  climatizacao: {\r\n    // DeviceTypes que sÃ£o SEMPRE climatizaÃ§Ã£o (independente do identifier)\r\n    deviceTypes: ['CHILLER', 'AR_CONDICIONADO', 'HVAC', 'FANCOIL'],\r\n    // DeviceTypes genÃ©ricos que sÃ³ sÃ£o climatizaÃ§Ã£o SE tiverem identifier de climatizaÃ§Ã£o\r\n    conditionalDeviceTypes: ['BOMBA', 'MOTOR'],\r\n    // Identifiers que indicam climatizaÃ§Ã£o (usado para deviceTypes condicionais)\r\n    identifiers: ['CAG', 'FANCOIL'],\r\n    identifierPrefixes: ['CAG-', 'FANCOIL-'],\r\n  },\r\n  // DeviceTypes que pertencem Ã  categoria Elevadores\r\n  elevadores: {\r\n    deviceTypes: ['ELEVADOR'],\r\n    identifiers: ['ELV', 'ELEVADOR', 'ELEVADORES'],\r\n    identifierPrefixes: ['ELV-', 'ELEVADOR-'],\r\n  },\r\n  // DeviceTypes que pertencem Ã  categoria Escadas Rolantes\r\n  escadas_rolantes: {\r\n    deviceTypes: ['ESCADA_ROLANTE'],\r\n    identifiers: ['ESC', 'ESCADA', 'ESCADASROLANTES'],\r\n    identifierPrefixes: ['ESC-', 'ESCADA-', 'ESCADA_'],\r\n  },\r\n};\r\n\r\n// Sets prÃ©-computados para lookup rÃ¡pido\r\nconst CLIMATIZACAO_DEVICE_TYPES_SET = new Set(DEVICE_CLASSIFICATION_CONFIG.climatizacao.deviceTypes);\r\nconst CLIMATIZACAO_CONDITIONAL_TYPES_SET = new Set(\r\n  DEVICE_CLASSIFICATION_CONFIG.climatizacao.conditionalDeviceTypes || []\r\n);\r\nconst ELEVADORES_DEVICE_TYPES_SET = new Set(DEVICE_CLASSIFICATION_CONFIG.elevadores.deviceTypes);\r\nconst ESCADAS_DEVICE_TYPES_SET = new Set(DEVICE_CLASSIFICATION_CONFIG.escadas_rolantes.deviceTypes);\r\n\r\nconst CLIMATIZACAO_IDENTIFIERS_SET = new Set(DEVICE_CLASSIFICATION_CONFIG.climatizacao.identifiers);\r\nconst ELEVADORES_IDENTIFIERS_SET = new Set(DEVICE_CLASSIFICATION_CONFIG.elevadores.identifiers);\r\nconst ESCADAS_IDENTIFIERS_SET = new Set(DEVICE_CLASSIFICATION_CONFIG.escadas_rolantes.identifiers);\r\n\r\n// RFC-0097: Regex para excluir equipamentos ao detectar widget \"lojas\"\r\n// ConstruÃ­do dinamicamente a partir do config\r\nconst EQUIPMENT_EXCLUSION_PATTERN = new RegExp(\r\n  [\r\n    ...DEVICE_CLASSIFICATION_CONFIG.climatizacao.deviceTypes,\r\n    ...DEVICE_CLASSIFICATION_CONFIG.elevadores.deviceTypes,\r\n    ...DEVICE_CLASSIFICATION_CONFIG.escadas_rolantes.deviceTypes,\r\n    'bomba',\r\n    'subesta',\r\n    'entrada',\r\n  ]\r\n    .map((t) => t.toLowerCase())\r\n    .join('|'),\r\n  'i'\r\n);\r\n\r\n/**\r\n * RFC-0106: Check if device is a store (loja)\r\n * Centralized logic: deviceProfile === '3F_MEDIDOR'\r\n *\r\n * @param {Object|string} itemOrDeviceProfile - Device item with deviceProfile property, or deviceProfile string directly\r\n * @returns {boolean} True if device is a store\r\n */\r\nfunction isStoreDevice(itemOrDeviceProfile) {\r\n  let deviceProfile;\r\n\r\n  if (typeof itemOrDeviceProfile === 'string') {\r\n    deviceProfile = itemOrDeviceProfile;\r\n  } else if (itemOrDeviceProfile && typeof itemOrDeviceProfile === 'object') {\r\n    deviceProfile = itemOrDeviceProfile.deviceProfile;\r\n  } else {\r\n    return false;\r\n  }\r\n\r\n  return String(deviceProfile || '').toUpperCase() === '3F_MEDIDOR';\r\n}\r\n\r\n/**\r\n * RFC-0106: Classify device by deviceProfile attribute\r\n * Single datasource approach - classification based on deviceProfile\r\n *\r\n * Rules:\r\n * - Lojas: deviceProfile === '3F_MEDIDOR' (uses isStoreDevice)\r\n * - Others: classify by deviceProfile using DEVICE_CLASSIFICATION_CONFIG\r\n *\r\n * @param {Object} item - Device item with deviceType, deviceProfile and identifier properties\r\n * @returns {'lojas'|'climatizacao'|'elevadores'|'escadas_rolantes'|'outros'}\r\n */\r\nfunction classifyDeviceByDeviceType(item) {\r\n  if (!item) return 'outros';\r\n\r\n  const deviceProfile = String(item.deviceProfile || '').toUpperCase();\r\n\r\n  // RFC-0106: Lojas - use centralized isStoreDevice\r\n  if (isStoreDevice(item)) {\r\n    return 'lojas';\r\n  }\r\n\r\n  // RFC-0106: For all other classifications, use deviceProfile directly\r\n  if (!deviceProfile || deviceProfile === 'N/D') {\r\n    return 'outros';\r\n  }\r\n\r\n  // DeviceProfiles que sÃ£o SEMPRE climatizaÃ§Ã£o (CHILLER, FANCOIL, etc.)\r\n  if (CLIMATIZACAO_DEVICE_TYPES_SET.has(deviceProfile)) {\r\n    return 'climatizacao';\r\n  }\r\n\r\n  // DeviceProfiles condicionais (BOMBA, MOTOR) - sÃ³ climatizaÃ§Ã£o se identifier for CAG, etc.\r\n  if (CLIMATIZACAO_CONDITIONAL_TYPES_SET.has(deviceProfile)) {\r\n    const identifier = String(item.identifier || '')\r\n      .toUpperCase()\r\n      .trim();\r\n\r\n    // Verificar se o identifier indica climatizaÃ§Ã£o\r\n    if (CLIMATIZACAO_IDENTIFIERS_SET.has(identifier)) {\r\n      return 'climatizacao';\r\n    }\r\n    // Verificar prefixos (CAG-, FANCOIL-, etc.)\r\n    for (const prefix of DEVICE_CLASSIFICATION_CONFIG.climatizacao.identifierPrefixes) {\r\n      if (identifier.startsWith(prefix.toUpperCase())) {\r\n        return 'climatizacao';\r\n      }\r\n    }\r\n    // BOMBA/MOTOR sem identifier de climatizaÃ§Ã£o â†’ outros\r\n    return 'outros';\r\n  }\r\n\r\n  if (ELEVADORES_DEVICE_TYPES_SET.has(deviceProfile)) {\r\n    return 'elevadores';\r\n  }\r\n\r\n  if (ESCADAS_DEVICE_TYPES_SET.has(deviceProfile)) {\r\n    return 'escadas_rolantes';\r\n  }\r\n\r\n  // Default: outros\r\n  return 'outros';\r\n}\r\n\r\n/**\r\n * RFC-0097: Classify device by identifier attribute\r\n * Uses centralized DEVICE_CLASSIFICATION_CONFIG\r\n * @param {string} identifier - Device identifier (e.g., \"CAG\", \"Fancoil\", \"ELV\", etc.)\r\n * @returns {'climatizacao'|'elevadores'|'escadas_rolantes'|'outros'|null}\r\n */\r\nfunction classifyDeviceByIdentifier(identifier = '') {\r\n  // Safe guard against null/undefined/empty\r\n  if (!identifier || identifier === 'N/A' || identifier === 'null' || identifier === 'undefined') {\r\n    return null;\r\n  }\r\n\r\n  const id = String(identifier).trim().toUpperCase();\r\n\r\n  // Ignore \"Sem Identificador identificado\" marker\r\n  if (id.includes('SEM IDENTIFICADOR')) {\r\n    return null;\r\n  }\r\n\r\n  // Check each category using centralized config\r\n  // ClimatizaÃ§Ã£o\r\n  if (CLIMATIZACAO_IDENTIFIERS_SET.has(id)) {\r\n    return 'climatizacao';\r\n  }\r\n  for (const prefix of DEVICE_CLASSIFICATION_CONFIG.climatizacao.identifierPrefixes) {\r\n    if (id.startsWith(prefix.toUpperCase())) return 'climatizacao';\r\n  }\r\n\r\n  // Elevadores\r\n  if (ELEVADORES_IDENTIFIERS_SET.has(id)) {\r\n    return 'elevadores';\r\n  }\r\n  for (const prefix of DEVICE_CLASSIFICATION_CONFIG.elevadores.identifierPrefixes) {\r\n    if (id.startsWith(prefix.toUpperCase())) return 'elevadores';\r\n  }\r\n\r\n  // Escadas Rolantes\r\n  if (ESCADAS_IDENTIFIERS_SET.has(id)) {\r\n    return 'escadas_rolantes';\r\n  }\r\n  for (const prefix of DEVICE_CLASSIFICATION_CONFIG.escadas_rolantes.identifierPrefixes) {\r\n    if (id.startsWith(prefix.toUpperCase())) return 'escadas_rolantes';\r\n  }\r\n\r\n  // Outros: qualquer outro identifier nÃ£o reconhecido\r\n  return 'outros';\r\n}\r\n\r\n/**\r\n * RFC-0097/RFC-0106: Classify device using deviceType as primary method\r\n * @param {Object} item - Device item with deviceType, deviceProfile, identifier, and label\r\n * @returns {'climatizacao'|'elevadores'|'escadas_rolantes'|'outros'}\r\n */\r\nfunction classifyDevice(item) {\r\n  // Safe guard - ensure item exists\r\n  if (!item) {\r\n    LogHelper.warn('[RFC-0106] classifyDevice called with null/undefined item');\r\n    return 'outros';\r\n  }\r\n\r\n  // RFC-0097: Primary classification by deviceType (or deviceProfile when deviceType = 3F_MEDIDOR)\r\n  const category = classifyDeviceByDeviceType(item);\r\n\r\n  // Return if we got a specific category (not 'outros')\r\n  if (category !== 'outros') {\r\n    return category;\r\n  }\r\n\r\n  // Fallback: try identifier-based classification for special cases (e.g., ESCADASROLANTES)\r\n  if (item.identifier) {\r\n    const categoryByIdentifier = classifyDeviceByIdentifier(item.identifier);\r\n    if (categoryByIdentifier && categoryByIdentifier !== 'outros') {\r\n      return categoryByIdentifier;\r\n    }\r\n  }\r\n\r\n  // Default: outros\r\n  return 'outros';\r\n}\r\n\r\n/**\r\n * RFC-0106: Map equipment category to labelWidget for widget filtering\r\n * @param {string} category - Device category ('lojas', 'climatizacao', 'elevadores', 'escadas_rolantes', 'outros')\r\n * @returns {string} labelWidget value for filtering\r\n */\r\nfunction categoryToLabelWidget(category) {\r\n  const mapping = {\r\n    lojas: 'Lojas',\r\n    climatizacao: 'ClimatizaÃ§Ã£o',\r\n    elevadores: 'Elevadores',\r\n    escadas_rolantes: 'Escadas Rolantes',\r\n    outros: '',\r\n  };\r\n  return mapping[category] || '';\r\n}\r\n\r\n/**\r\n * RFC-0106: Infer labelWidget from deviceType AND deviceProfile\r\n * Classification based on BOTH deviceType and deviceProfile from ThingsBoard datasource\r\n *\r\n * Rules (priority order):\r\n * 1. LOJAS: deviceProfile = '3F_MEDIDOR' (uses isStoreDevice)\r\n * 2. ENTRADA: deviceType OR deviceProfile contains ENTRADA/TRAFO/SUBESTACAO\r\n * 3. For other categories, check deviceProfile first, then deviceType:\r\n *    - CHILLER, FANCOIL, HVAC, AR_CONDICIONADO â†’ 'ClimatizaÃ§Ã£o'\r\n *    - ELEVADOR â†’ 'Elevadores'\r\n *    - ESCADA_ROLANTE â†’ 'Escadas Rolantes'\r\n *    - BOMBA, MOTOR, etc â†’ 'Ãrea Comum'\r\n * 4. Default: 'Ãrea Comum' (if no classification matches)\r\n *\r\n * @param {Object} row - Item with deviceType, deviceProfile, identifier, name\r\n * @returns {string} labelWidget for widget filtering\r\n */\r\nfunction inferLabelWidget(row) {\r\n  // First try groupType from API (takes precedence)\r\n  const groupType = row.groupType || row.group_type || '';\r\n  if (groupType) {\r\n    return groupType;\r\n  }\r\n\r\n  // Get deviceType and deviceProfile from ThingsBoard datasource\r\n  const deviceType = String(row.deviceType || '').toUpperCase();\r\n  const deviceProfile = String(row.deviceProfile || '').toUpperCase();\r\n\r\n  // ==========================================================================\r\n  // RULE 1: LOJAS - use centralized isStoreDevice\r\n  // ==========================================================================\r\n  if (isStoreDevice(row)) {\r\n    return 'Lojas';\r\n  }\r\n\r\n  // ==========================================================================\r\n  // RULE 2: ENTRADA - deviceType OR deviceProfile contains ENTRADA/TRAFO/SUBESTACAO\r\n  // ==========================================================================\r\n  const ENTRADA_PATTERNS = ['ENTRADA', 'TRAFO', 'SUBESTACAO'];\r\n  const isEntradaByType = ENTRADA_PATTERNS.some((p) => deviceType.includes(p));\r\n  const isEntradaByProfile = ENTRADA_PATTERNS.some((p) => deviceProfile.includes(p));\r\n  if (isEntradaByType || isEntradaByProfile) {\r\n    return 'Entrada';\r\n  }\r\n\r\n  // ==========================================================================\r\n  // RULE 3: Check deviceProfile FIRST for other categories, then deviceType\r\n  // ==========================================================================\r\n\r\n  // ClimatizaÃ§Ã£o: CHILLER, FANCOIL, HVAC, AR_CONDICIONADO, COMPRESSOR, VENTILADOR\r\n  const CLIMATIZACAO_PATTERNS = [\r\n    'CHILLER',\r\n    'FANCOIL',\r\n    'HVAC',\r\n    'AR_CONDICIONADO',\r\n    'COMPRESSOR',\r\n    'VENTILADOR',\r\n    'CLIMATIZA',\r\n  ];\r\n  if (\r\n    CLIMATIZACAO_PATTERNS.some((p) => deviceProfile.includes(p)) ||\r\n    CLIMATIZACAO_PATTERNS.some((p) => deviceType.includes(p))\r\n  ) {\r\n    return 'ClimatizaÃ§Ã£o';\r\n  }\r\n\r\n  // Elevadores: ELEVADOR, ELV\r\n  const ELEVADOR_PATTERNS = ['ELEVADOR', 'ELV'];\r\n  if (\r\n    ELEVADOR_PATTERNS.some((p) => deviceProfile.includes(p)) ||\r\n    ELEVADOR_PATTERNS.some((p) => deviceType.includes(p))\r\n  ) {\r\n    return 'Elevadores';\r\n  }\r\n\r\n  // Escadas Rolantes: ESCADA_ROLANTE, ESCADA\r\n  const ESCADA_PATTERNS = ['ESCADA_ROLANTE', 'ESCADA'];\r\n  if (\r\n    ESCADA_PATTERNS.some((p) => deviceProfile.includes(p)) ||\r\n    ESCADA_PATTERNS.some((p) => deviceType.includes(p))\r\n  ) {\r\n    return 'Escadas Rolantes';\r\n  }\r\n\r\n  // ==========================================================================\r\n  // RFC-0108 FIX: Water domain - HIDROMETRO_SHOPPING and HIDROMETRO_AREA_COMUM\r\n  // Must be checked BEFORE generic HIDROMETRO pattern in AREA_COMUM_PATTERNS\r\n  // ==========================================================================\r\n  if (deviceType.includes('HIDROMETRO_SHOPPING') || deviceProfile.includes('HIDROMETRO_SHOPPING')) {\r\n    return 'Entrada';\r\n  }\r\n  if (deviceType.includes('HIDROMETRO_AREA_COMUM') || deviceProfile.includes('HIDROMETRO_AREA_COMUM')) {\r\n    return 'Ãrea Comum';\r\n  }\r\n  // Generic HIDROMETRO (without specific profile) â†’ Lojas (for water domain)\r\n  if (deviceType === 'HIDROMETRO' && (deviceProfile === 'HIDROMETRO' || !deviceProfile)) {\r\n    return 'Lojas';\r\n  }\r\n\r\n  // Ãrea Comum: BOMBA, MOTOR, RELOGIO, etc (but NOT generic HIDROMETRO)\r\n  const AREA_COMUM_PATTERNS = [\r\n    'BOMBA',\r\n    'MOTOR',\r\n    'RELOGIO',\r\n    // 'HIDROMETRO', - REMOVED: Now handled specifically above\r\n    'CAIXA_DAGUA',\r\n    'TANK',\r\n    'ILUMINACAO',\r\n    'LUZ',\r\n  ];\r\n  if (\r\n    AREA_COMUM_PATTERNS.some((p) => deviceProfile.includes(p)) ||\r\n    AREA_COMUM_PATTERNS.some((p) => deviceType.includes(p))\r\n  ) {\r\n    return 'Ãrea Comum';\r\n  }\r\n\r\n  // Temperature types\r\n  if (deviceProfile.includes('TERMOSTATO') || deviceType.includes('TERMOSTATO')) {\r\n    return 'Temperatura';\r\n  }\r\n\r\n  // ==========================================================================\r\n  // RULE 4: Default - if nothing matched, default to Ãrea Comum\r\n  // (deviceType = 3F_MEDIDOR but deviceProfile != 3F_MEDIDOR means it's equipment)\r\n  // ==========================================================================\r\n  return 'Ãrea Comum';\r\n}\r\n\r\n// Expose classification utilities globally for TELEMETRY and other widgets\r\nwindow.MyIOUtils = window.MyIOUtils || {};\r\nObject.assign(window.MyIOUtils, {\r\n  DEVICE_CLASSIFICATION_CONFIG,\r\n  classifyDevice,\r\n  classifyDeviceByDeviceType,\r\n  classifyDeviceByIdentifier,\r\n  categoryToLabelWidget,\r\n  inferLabelWidget,\r\n  isStoreDevice,\r\n  EQUIPMENT_EXCLUSION_PATTERN,\r\n});\r\n\r\n// ============================================================================\r\n// End RFC-0106: Device Classification\r\n// ============================================================================\r\n\r\n(function () {\r\n  // UtilitÃ¡rios DOM\r\n  const $ = (sel, root = document) => root.querySelector(sel);\r\n  const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));\r\n  const on = (el, ev, fn) => el && el.addEventListener(ev, fn);\r\n\r\n  let rootEl;\r\n\r\n  // Atualiza a altura Ãºtil do conteÃºdo e garante que os elementos estÃ£o bem posicionados\r\n  function applySizing() {\r\n    try {\r\n      // ForÃ§a recÃ¡lculo do layout se necessÃ¡rio\r\n      if (rootEl) {\r\n        rootEl.style.display = 'grid';\r\n\r\n        // Garante que os tb-child elementos do MENU nï¿½o tenham overflow issues\r\n        const menu = $('.myio-menu', rootEl);\r\n        if (menu) {\r\n          const menuChildren = $$('.tb-child', menu);\r\n          menuChildren.forEach((child) => {\r\n            child.style.overflow = 'hidden';\r\n            child.style.width = '100%';\r\n            child.style.height = '100%';\r\n          });\r\n        }\r\n\r\n        // Especial tratamento para o conteï¿½do principal - permite scroll nos widgets\r\n        const content = $('.myio-content', rootEl);\r\n        if (content) {\r\n          // Primeiro: container direto do content deve ter overflow auto para controlar scroll\r\n          const contentChild = $('.tb-child', content);\r\n          if (contentChild) {\r\n            contentChild.style.overflow = 'auto'; // Mudado de 'visible' para 'auto'\r\n            contentChild.style.height = '100%';\r\n            contentChild.style.width = '100%';\r\n          }\r\n\r\n          // Segundo: dentro dos states, os widgets individuais tambï¿½m precisam de scroll\r\n          const stateContainers = $$('[data-content-state]', content);\r\n          LogHelper.log(`[MAIN_VIEW] Found ${stateContainers.length} state containers`);\r\n          stateContainers.forEach((stateContainer, idx) => {\r\n            const widgetsInState = $$('.tb-child', stateContainer);\r\n            LogHelper.log(`[MAIN_VIEW] State ${idx}: ${widgetsInState.length} widgets found`, {\r\n              state: stateContainer.getAttribute('data-content-state'),\r\n              display: stateContainer.style.display,\r\n            });\r\n            widgetsInState.forEach((widget, widgetIdx) => {\r\n              const before = widget.style.overflow;\r\n              widget.style.overflow = 'auto';\r\n              widget.style.width = '100%';\r\n              widget.style.height = '100%';\r\n              LogHelper.log(`[MAIN_VIEW]   Widget ${widgetIdx}: overflow ${before} ? auto`);\r\n            });\r\n          });\r\n\r\n          // DiagnÃ³stico: logar dimensÃµes do container visÃ­vel\r\n          const visible = Array.from(content.querySelectorAll('[data-content-state]')).find(\r\n            (div) => div.style.display !== 'none'\r\n          );\r\n          if (visible) {\r\n            const r1 = content.getBoundingClientRect();\r\n            const r2 = visible.getBoundingClientRect();\r\n            const r3 = contentChild ? contentChild.getBoundingClientRect() : null;\r\n            LogHelper.log('[MAIN_VIEW] sizing content dims', {\r\n              content: { w: r1.width, h: r1.height },\r\n              visible: { w: r2.width, h: r2.height },\r\n              child: r3 ? { w: r3.width, h: r3.height } : null,\r\n            });\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {\r\n      LogHelper.warn('[myio-container] sizing warn:', e);\r\n    }\r\n  }\r\n\r\n  // Alterna o modo \"menu compacto\" acrescentando/removendo classe no root\r\n  function setMenuCompact(compact) {\r\n    if (!rootEl) return;\r\n    rootEl.classList.toggle('menu-compact', !!compact);\r\n\r\n    // ForÃ§a recÃ¡lculo apÃ³s mudanÃ§a de modo\r\n    setTimeout(() => {\r\n      applySizing();\r\n    }, 50);\r\n  }\r\n\r\n  // Exponha dois eventos globais simples (opcionais):\r\n  // window.dispatchEvent(new CustomEvent('myio:menu-compact', { detail: { compact: true } }))\r\n  // window.dispatchEvent(new CustomEvent('myio:menu-expand'))\r\n  function registerGlobalEvents() {\r\n    on(window, 'myio:menu-compact', (ev) => {\r\n      setMenuCompact(ev?.detail?.compact ?? true);\r\n    });\r\n    on(window, 'myio:menu-expand', () => {\r\n      setMenuCompact(false);\r\n    });\r\n\r\n    // Adiciona suporte para toggle via evento\r\n    on(window, 'myio:menu-toggle', () => {\r\n      const isCompact = rootEl?.classList.contains('menu-compact');\r\n      setMenuCompact(!isCompact);\r\n    });\r\n\r\n    // RFC-0108: Listen for measurement settings updates from MENU\r\n    on(window, 'myio:measurement-settings-updated', (ev) => {\r\n      const settings = ev?.detail;\r\n      if (settings) {\r\n        // Update MyIOUtils shared settings\r\n        if (window.MyIOUtils?.updateMeasurementSettings) {\r\n          window.MyIOUtils.updateMeasurementSettings(settings);\r\n        }\r\n        // Also store in orchestrator for persistence\r\n        if (window.MyIOOrchestrator) {\r\n          window.MyIOOrchestrator.measurementDisplaySettings = settings;\r\n        }\r\n        LogHelper.log('[MAIN_VIEW] RFC-0108: Measurement settings updated:', settings);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Detecta mudanÃ§as de viewport para aplicar sizing\r\n  function setupResizeObserver() {\r\n    if (typeof ResizeObserver !== 'undefined' && rootEl) {\r\n      const resizeObserver = new ResizeObserver(() => {\r\n        applySizing();\r\n      });\r\n      resizeObserver.observe(rootEl);\r\n    }\r\n  }\r\n\r\n  // RFC-XXXX: SuperAdmin detection\r\n  // SuperAdmin = user with @myio.com.br email EXCEPT alarme@myio.com.br or alarmes@myio.com.br\r\n  async function detectSuperAdmin() {\r\n    const jwt = localStorage.getItem('jwt_token');\r\n    if (!jwt) {\r\n      window.MyIOUtils.SuperAdmin = false;\r\n      LogHelper.log('[MAIN_VIEW] SuperAdmin: false (no JWT token)');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch('/api/auth/user', {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'X-Authorization': `Bearer ${jwt}`,\r\n        },\r\n        credentials: 'include',\r\n      });\r\n\r\n      if (!response.ok) {\r\n        window.MyIOUtils.SuperAdmin = false;\r\n        LogHelper.warn('[MAIN_VIEW] SuperAdmin: false (API error:', response.status, ')');\r\n        return;\r\n      }\r\n\r\n      const user = await response.json();\r\n      const email = (user.email || '').toLowerCase().trim();\r\n\r\n      // Check: email ends with @myio.com.br AND is NOT alarme@ or alarmes@\r\n      const isSuperAdmin =\r\n        email.endsWith('@myio.com.br') && !email.startsWith('alarme@') && !email.startsWith('alarmes@');\r\n\r\n      window.MyIOUtils.SuperAdmin = isSuperAdmin;\r\n      LogHelper.log(`[MAIN_VIEW] SuperAdmin detection: ${email} -> ${isSuperAdmin}`);\r\n    } catch (err) {\r\n      LogHelper.error('[MAIN_VIEW] SuperAdmin detection failed:', err);\r\n      window.MyIOUtils.SuperAdmin = false;\r\n    }\r\n  }\r\n\r\n  // ThingsBoard lifecycle\r\n  self.onInit = async function () {\r\n    rootEl = $('#myio-root');\r\n\r\n    // Populate global widget settings early to avoid undefined errors\r\n    // These settings are available globally to all functions\r\n\r\n    // CRITICAL: customerTB_ID MUST be set - abort if missing\r\n    const customerTB_ID = self.ctx.settings?.customerTB_ID;\r\n    if (!customerTB_ID) {\r\n      LogHelper.error('[Orchestrator] âŒ CRITICAL: customerTB_ID is missing from widget settings!');\r\n      LogHelper.error(\r\n        '[Orchestrator] Widget cannot function without customerTB_ID. Please configure it in widget settings.'\r\n      );\r\n      throw new Error('customerTB_ID is required but not found in widget settings');\r\n    }\r\n\r\n    widgetSettings.customerTB_ID = customerTB_ID;\r\n\r\n    // Triple-check: Validate that cached data belongs to current shopping\r\n    // If shopping changed, clear all cached data to prevent stale data display\r\n    const shoppingChanged = window.STATE?.validateCustomer?.(customerTB_ID);\r\n    if (shoppingChanged) {\r\n      LogHelper.warn('[Orchestrator] ðŸ”„ Shopping changed - cache cleared, will reload all data');\r\n    }\r\n\r\n    // RFC-0085: Expose customerTB_ID globally for MENU and other widgets\r\n    if (window.MyIOOrchestrator) {\r\n      window.MyIOOrchestrator.customerTB_ID = customerTB_ID;\r\n    }\r\n\r\n    widgetSettings.debugMode = self.ctx.settings?.debugMode ?? false;\r\n    widgetSettings.domainsEnabled = self.ctx.settings?.domainsEnabled ?? {\r\n      energy: true,\r\n      water: true,\r\n      temperature: true,\r\n    };\r\n    widgetSettings.excludeDevicesAtCountSubtotalCAG =\r\n      self.ctx.settings?.excludeDevicesAtCountSubtotalCAG ?? [];\r\n\r\n    LogHelper.log('[Orchestrator] ðŸ“‹ Widget settings captured:', {\r\n      customerTB_ID: widgetSettings.customerTB_ID,\r\n      debugMode: widgetSettings.debugMode,\r\n      excludeDevicesAtCountSubtotalCAG: widgetSettings.excludeDevicesAtCountSubtotalCAG,\r\n    });\r\n\r\n    // Initialize config from widgetSettings\r\n    config = {\r\n      debugMode: widgetSettings.debugMode,\r\n      domainsEnabled: widgetSettings.domainsEnabled,\r\n    };\r\n\r\n    LogHelper.log('[Orchestrator] ðŸ”§ Config initialized from settings:', config);\r\n\r\n    // RFC-0107: Initialize contract loading now that customerTB_ID is available\r\n    // This fetches device counts from SERVER_SCOPE and shows the contract loading modal\r\n    initializeContractLoading();\r\n\r\n    // RFC-0051.2: Expose orchestrator stub IMMEDIATELY\r\n    // This prevents race conditions with TELEMETRY widgets that check for orchestrator\r\n    // We expose a stub with isReady flag that will be set to true when fully initialized\r\n    if (!window.MyIOOrchestrator) {\r\n      window.MyIOOrchestrator = {\r\n        // Status flags\r\n        isReady: false,\r\n        credentialsSet: false,\r\n\r\n        // Customer ID from settings (for MENU and other widgets)\r\n        customerTB_ID: null,\r\n\r\n        // RFC-0108: Measurement display settings (units, decimal places)\r\n        // Populated by MENU when user opens MeasurementSetupModal\r\n        measurementDisplaySettings: null,\r\n\r\n        // Data access methods (will be populated later)\r\n        getCurrentPeriod: () => null,\r\n        getCredentials: () => null,\r\n\r\n        // Credential management (will be populated later)\r\n        setCredentials: async (_customerId, _clientId, _clientSecret) => {\r\n          LogHelper.warn('[Orchestrator] âš ï¸ setCredentials called before orchestrator is ready');\r\n        },\r\n\r\n        // Token manager stub\r\n        tokenManager: {\r\n          setToken: (_key, _token) => {\r\n            LogHelper.warn('[Orchestrator] âš ï¸ tokenManager.setToken called before orchestrator is ready');\r\n          },\r\n        },\r\n\r\n        // Internal state (will be populated later)\r\n        inFlight: {},\r\n      };\r\n\r\n      LogHelper.log('[Orchestrator] âš¡ Exposed to window.MyIOOrchestrator EARLY (stub mode)');\r\n    }\r\n\r\n    registerGlobalEvents();\r\n    setupResizeObserver();\r\n\r\n    // RFC-XXXX: Detect SuperAdmin early (async, non-blocking)\r\n    detectSuperAdmin();\r\n\r\n    // Initialize MyIO Library and Authentication\r\n    const MyIO =\r\n      (typeof MyIOLibrary !== 'undefined' && MyIOLibrary) ||\r\n      (typeof window !== 'undefined' && window.MyIOLibrary) ||\r\n      null;\r\n\r\n    if (MyIO) {\r\n      try {\r\n        // RFC-0051.1: Use widgetSettings from closure\r\n        const customerTB_ID = widgetSettings.customerTB_ID !== 'default' ? widgetSettings.customerTB_ID : '';\r\n        const jwt = localStorage.getItem('jwt_token');\r\n\r\n        LogHelper.log('[MAIN_VIEW] ðŸ” Credentials fetch starting...');\r\n        LogHelper.log(\r\n          '[MAIN_VIEW] customerTB_ID:',\r\n          customerTB_ID ? customerTB_ID : 'âŒ NOT FOUND IN SETTINGS'\r\n        );\r\n        LogHelper.log('[MAIN_VIEW] jwt token:', jwt ? 'âœ… FOUND' : 'âŒ NOT FOUND IN localStorage');\r\n\r\n        let CLIENT_ID = '';\r\n        let CLIENT_SECRET = '';\r\n        let CUSTOMER_ING_ID = '';\r\n\r\n        if (customerTB_ID && jwt) {\r\n          try {\r\n            LogHelper.log('[MAIN_VIEW] ðŸ“¡ Fetching customer attributes from ThingsBoard...');\r\n            // Fetch customer attributes\r\n            const attrs = await MyIO.fetchThingsboardCustomerAttrsFromStorage(customerTB_ID, jwt);\r\n\r\n            LogHelper.log('[MAIN_VIEW] ðŸ“¦ Received attrs:', attrs);\r\n\r\n            CLIENT_ID = attrs?.client_id || '';\r\n            CLIENT_SECRET = attrs?.client_secret || '';\r\n            CUSTOMER_ING_ID = attrs?.ingestionId || '';\r\n\r\n            LogHelper.log('[MAIN_VIEW] ðŸ”‘ Parsed credentials:');\r\n            LogHelper.log('[MAIN_VIEW]   CLIENT_ID:', CLIENT_ID ? 'âœ… ' + CLIENT_ID : 'âŒ EMPTY');\r\n            LogHelper.log(\r\n              '[MAIN_VIEW]   CLIENT_SECRET:',\r\n              CLIENT_SECRET ? 'âœ… ' + CLIENT_SECRET.substring(0, 10) + '...' : 'âŒ EMPTY'\r\n            );\r\n            LogHelper.log(\r\n              '[MAIN_VIEW]   CUSTOMER_ING_ID:',\r\n              CUSTOMER_ING_ID ? 'âœ… ' + CUSTOMER_ING_ID : 'âŒ EMPTY'\r\n            );\r\n          } catch (err) {\r\n            LogHelper.error('[MAIN_VIEW] âŒ Failed to fetch customer attributes:', err);\r\n            LogHelper.error('[MAIN_VIEW] Error details:', {\r\n              message: err.message,\r\n              stack: err.stack,\r\n              name: err.name,\r\n            });\r\n          }\r\n        } else {\r\n          LogHelper.warn('[MAIN_VIEW] âš ï¸ Cannot fetch credentials - missing required data:');\r\n          if (!customerTB_ID) LogHelper.warn('[MAIN_VIEW]   - customerTB_ID is missing from settings');\r\n          if (!jwt) LogHelper.warn('[MAIN_VIEW]   - JWT token is missing from localStorage');\r\n        }\r\n\r\n        // Check if credentials are present\r\n        if (!CLIENT_ID || !CLIENT_SECRET || !CUSTOMER_ING_ID) {\r\n          LogHelper.warn(\r\n            '[MAIN_VIEW] Missing credentials - CLIENT_ID, CLIENT_SECRET, or CUSTOMER_ING_ID not found'\r\n          );\r\n          LogHelper.warn(\r\n            \"[MAIN_VIEW] Orchestrator will be available but won't be able to fetch data without credentials\"\r\n          );\r\n\r\n          // RFC-0054 FIX: Dispatch initial tab event even without credentials (with delay)\r\n          // This enables HEADER controls, even though data fetch will fail\r\n          LogHelper.log(\r\n            '[MAIN_VIEW] Will dispatch initial tab event for default state: energy after 100ms delay...'\r\n          );\r\n          setTimeout(() => {\r\n            LogHelper.log(\r\n              '[MAIN_VIEW] Dispatching initial tab event for default state: energy (no credentials)'\r\n            );\r\n            window.dispatchEvent(\r\n              new CustomEvent('myio:dashboard-state', {\r\n                detail: { tab: 'energy' },\r\n              })\r\n            );\r\n          }, 100);\r\n        } else {\r\n          // Set credentials in orchestrator (only if present)\r\n          LogHelper.log('[MAIN_VIEW] ðŸ” Calling MyIOOrchestrator.setCredentials...');\r\n          LogHelper.log('[MAIN_VIEW] ðŸ” Arguments:', {\r\n            customerId: CUSTOMER_ING_ID,\r\n            clientId: CLIENT_ID,\r\n            clientSecret: CLIENT_SECRET.substring(0, 10) + '...',\r\n          });\r\n\r\n          MyIOOrchestrator.setCredentials(CUSTOMER_ING_ID, CLIENT_ID, CLIENT_SECRET);\r\n\r\n          LogHelper.log('[MAIN_VIEW] ðŸ” setCredentials completed, verifying...');\r\n          // Verify credentials were set\r\n          const currentCreds = MyIOOrchestrator.getCredentials?.();\r\n          if (currentCreds) {\r\n            LogHelper.log('[MAIN_VIEW] âœ… Credentials verified in orchestrator:', currentCreds);\r\n          } else {\r\n            LogHelper.warn('[MAIN_VIEW] âš ï¸ Orchestrator does not have getCredentials method');\r\n          }\r\n\r\n          // Build auth and get token\r\n          const myIOAuth = MyIO.buildMyioIngestionAuth({\r\n            dataApiHost: 'https://api.data.apps.myio-bas.com',\r\n            clientId: CLIENT_ID,\r\n            clientSecret: CLIENT_SECRET,\r\n          });\r\n\r\n          // Get token and set it in token manager\r\n          const ingestionToken = await myIOAuth.getToken();\r\n          MyIOOrchestrator.tokenManager.setToken('ingestionToken', ingestionToken);\r\n\r\n          LogHelper.log('[MAIN_VIEW] Auth initialized successfully with CLIENT_ID:', CLIENT_ID);\r\n\r\n          // Dispatch initial tab event AFTER credentials AND with delay\r\n          // Delay ensures HEADER has time to register its listener\r\n          LogHelper.log(\r\n            '[MAIN_VIEW] Will dispatch initial tab event for default state: energy after 100ms delay...'\r\n          );\r\n          setTimeout(() => {\r\n            LogHelper.log(\r\n              '[MAIN_VIEW] Dispatching initial tab event for default state: energy (after credentials + delay)'\r\n            );\r\n            window.dispatchEvent(\r\n              new CustomEvent('myio:dashboard-state', {\r\n                detail: { tab: 'energy' },\r\n              })\r\n            );\r\n          }, 100);\r\n        }\r\n      } catch (err) {\r\n        LogHelper.error('[MAIN_VIEW] Auth initialization failed:', err);\r\n\r\n        // RFC-0054 FIX: Dispatch initial tab event even on error (with delay)\r\n        // This enables HEADER controls, even though data fetch will fail\r\n        LogHelper.log(\r\n          '[MAIN_VIEW] Will dispatch initial tab event for default state: energy after 100ms delay...'\r\n        );\r\n        setTimeout(() => {\r\n          LogHelper.log('[MAIN_VIEW] Dispatching initial tab event for default state: energy (after error)');\r\n          window.dispatchEvent(\r\n            new CustomEvent('myio:dashboard-state', {\r\n              detail: { tab: 'energy' },\r\n            })\r\n          );\r\n        }, 100);\r\n      }\r\n    } else {\r\n      LogHelper.warn('[MAIN_VIEW] MyIOLibrary not available');\r\n\r\n      // RFC-0054 FIX: Dispatch initial tab event even without MyIOLibrary (with delay)\r\n      // This enables HEADER controls, even though data fetch will fail\r\n      LogHelper.log(\r\n        '[MAIN_VIEW] Will dispatch initial tab event for default state: energy after 100ms delay...'\r\n      );\r\n      setTimeout(() => {\r\n        LogHelper.log('[MAIN_VIEW] Dispatching initial tab event for default state: energy (no MyIOLibrary)');\r\n        window.dispatchEvent(\r\n          new CustomEvent('myio:dashboard-state', {\r\n            detail: { tab: 'energy' },\r\n          })\r\n        );\r\n      }, 100);\r\n    }\r\n\r\n    // NOTE: Temperature limits (minTemperature, maxTemperature) are extracted in onDataUpdated\r\n    // because onInit runs before the customer datasource data is available\r\n  };\r\n\r\n  self.onResize = function () {\r\n    applySizing();\r\n  };\r\n\r\n  // RFC-0106: Extract temperature limits when data arrives from customer datasource\r\n  // This must be in onDataUpdated because onInit runs before data is available\r\n  self.onDataUpdated = function () {\r\n    const ctxDataRows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\r\n    for (const row of ctxDataRows) {\r\n      // Look for customer datasource (aliasName = 'customer')\r\n      const aliasName = (row?.datasource?.aliasName || row?.datasource?.name || '').toLowerCase();\r\n      if (aliasName !== 'customer') {\r\n        continue;\r\n      }\r\n\r\n      const keyName = (row?.dataKey?.name || '').toLowerCase();\r\n      const rawValue = row?.data?.[0]?.[1];\r\n\r\n      if (keyName === 'mintemperature' && rawValue !== undefined && rawValue !== null) {\r\n        const val = Number(rawValue);\r\n        if (!isNaN(val) && window.MyIOUtils.temperatureLimits.minTemperature !== val) {\r\n          window.MyIOUtils.temperatureLimits.minTemperature = val;\r\n          LogHelper.log(`[MAIN_VIEW] Exposed global minTemperature from customer: ${val}`);\r\n        }\r\n      }\r\n\r\n      if (keyName === 'maxtemperature' && rawValue !== undefined && rawValue !== null) {\r\n        const val = Number(rawValue);\r\n        if (!isNaN(val) && window.MyIOUtils.temperatureLimits.maxTemperature !== val) {\r\n          window.MyIOUtils.temperatureLimits.maxTemperature = val;\r\n          LogHelper.log(`[MAIN_VIEW] Exposed global maxTemperature from customer: ${val}`);\r\n        }\r\n      }\r\n\r\n      // RFC-0106: Extract mapInstantaneousPower from customer datasource\r\n      // This is used for deviceStatus calculation with power ranges\r\n      if (keyName === 'mapinstantaneouspower' && rawValue !== undefined && rawValue !== null) {\r\n        try {\r\n          const parsed = typeof rawValue === 'string' ? JSON.parse(rawValue) : rawValue;\r\n          if (parsed && window.MyIOUtils.mapInstantaneousPower !== parsed) {\r\n            window.MyIOUtils.mapInstantaneousPower = parsed;\r\n            LogHelper.log(`[MAIN_VIEW] Exposed global mapInstantaneousPower from customer`);\r\n          }\r\n        } catch (err) {\r\n          LogHelper.warn(`[MAIN_VIEW] Failed to parse mapInstantaneousPower: ${err.message}`);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  self.onDestroy = function () {\r\n    // Limpa event listeners se necessÃ¡rio\r\n    if (typeof window !== 'undefined') {\r\n      // Remove custom event listeners se foram adicionados\r\n    }\r\n\r\n    // Destroy orchestrator\r\n    if (window.MyIOOrchestrator) {\r\n      window.MyIOOrchestrator.destroy();\r\n    }\r\n  };\r\n})();\r\n\r\n// ========== ORCHESTRATOR IMPLEMENTATION ==========\r\n\r\n/**\r\n * Global shared state for widget coordination\r\n * Prevents race conditions and ensures first widget priority\r\n */\r\nif (!window.MyIOOrchestratorState) {\r\n  window.MyIOOrchestratorState = {\r\n    // Widget registration and priority\r\n    widgetPriority: [],\r\n    widgetRegistry: new Map(), // widgetId -> {domain, registeredAt}\r\n\r\n    // Loading state per domain\r\n    loading: {},\r\n\r\n    // Pending listeners for late-joining widgets\r\n    pendingListeners: {},\r\n\r\n    // Last emission timestamp per domain (deduplication)\r\n    lastEmission: {},\r\n\r\n    // Lock to prevent concurrent requests\r\n    locks: {},\r\n  };\r\n\r\n  LogHelper.log('[Orchestrator] ðŸŒ Global state initialized:', window.MyIOOrchestratorState);\r\n}\r\n\r\nconst OrchestratorState = window.MyIOOrchestratorState;\r\n\r\n// ============================================================================\r\n// RFC-0106: Global STATE for pre-computed data by domain and group\r\n// ============================================================================\r\n/**\r\n * window.STATE structure:\r\n * {\r\n *   energy: {\r\n *     lojas: { items: [], total: 0, count: 0 },\r\n *     entrada: { items: [], total: 0, count: 0 },\r\n *     areacomum: { items: [], total: 0, count: 0 },\r\n *     summary: { total: 0, byGroup: {...}, percentages: {...}, periodKey: '' }\r\n *   },\r\n *   water: { ... },\r\n *   temperature: { ... }\r\n * }\r\n */\r\nif (!window.STATE) {\r\n  window.STATE = {\r\n    energy: null,\r\n    water: null,\r\n    temperature: null,\r\n    _lastUpdate: {},\r\n    _customerTB_ID: null, // Track current shopping to detect navigation\r\n\r\n    // Helper: Get items for a specific domain and group\r\n    // Usage: window.STATE.get('energy', 'lojas') => { items: [...], total: 0, count: 0 }\r\n    get(domain, group) {\r\n      const domainData = this[domain];\r\n      if (!domainData) return null;\r\n      if (group === 'summary') return domainData.summary;\r\n      return domainData[group] || null;\r\n    },\r\n\r\n    // Helper: Get items array directly\r\n    // Usage: window.STATE.getItems('energy', 'lojas') => [...]\r\n    getItems(domain, group) {\r\n      const data = this.get(domain, group);\r\n      return data?.items || [];\r\n    },\r\n\r\n    // Helper: Get summary for a domain\r\n    // Usage: window.STATE.getSummary('energy') => { total, byGroup, percentages, formatted }\r\n    getSummary(domain) {\r\n      return this[domain]?.summary || null;\r\n    },\r\n\r\n    // Helper: Check if data is ready for a domain\r\n    // Usage: window.STATE.isReady('energy') => true/false\r\n    isReady(domain) {\r\n      return this[domain] !== null && this._lastUpdate[domain] !== undefined;\r\n    },\r\n\r\n    /**\r\n     * Triple-check: Validate that data belongs to current shopping\r\n     * If customerTB_ID changed, clear all cached data\r\n     * @param {string} customerTB_ID - Current shopping ID\r\n     * @returns {boolean} true if data was cleared due to shopping change\r\n     */\r\n    validateCustomer(customerTB_ID) {\r\n      if (!customerTB_ID) return false;\r\n\r\n      if (this._customerTB_ID && this._customerTB_ID !== customerTB_ID) {\r\n        // Shopping changed! Clear all cached data\r\n        console.warn(`[STATE] ðŸ”„ Shopping changed from ${this._customerTB_ID} to ${customerTB_ID} - clearing cache`);\r\n        this.energy = null;\r\n        this.water = null;\r\n        this.temperature = null;\r\n        this._lastUpdate = {};\r\n        this._customerTB_ID = customerTB_ID;\r\n        return true; // Data was cleared\r\n      }\r\n\r\n      // First time or same shopping\r\n      this._customerTB_ID = customerTB_ID;\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Force clear all data (for manual refresh)\r\n     */\r\n    clearAll() {\r\n      console.log('[STATE] ðŸ§¹ Clearing all cached data');\r\n      this.energy = null;\r\n      this.water = null;\r\n      this.temperature = null;\r\n      this._lastUpdate = {};\r\n      // Keep _customerTB_ID to avoid unnecessary reloads\r\n    },\r\n  };\r\n  LogHelper.log('[Orchestrator] ðŸ—„ï¸ window.STATE initialized with helpers');\r\n}\r\n\r\n/**\r\n * RFC-0107: Global contract state\r\n * Stores device counts from SERVER_SCOPE attributes for HEADER widget access\r\n *\r\n * This state is populated during dashboard initialization when contract\r\n * attributes are fetched from the ThingsBoard SERVER_SCOPE API.\r\n *\r\n * The HEADER widget listens for 'myio:contract:loaded' event to display\r\n * the contract status icon with tooltip.\r\n */\r\nif (!window.CONTRACT_STATE) {\r\n  window.CONTRACT_STATE = {\r\n    isLoaded: false,\r\n    isValid: false,\r\n    timestamp: null,\r\n    energy: {\r\n      total: 0,\r\n      entries: 0, // qtDevices3f-Entries\r\n      commonArea: 0, // qtDevices3f-CommonArea\r\n      stores: 0, // qtDevices3f-Stores\r\n    },\r\n    water: {\r\n      total: 0,\r\n      entries: 0, // qtDevicesHidr-Entries\r\n      commonArea: 0, // qtDevicesHidr-CommonArea\r\n      stores: 0, // qtDevicesHidr-Stores\r\n    },\r\n    temperature: {\r\n      total: 0,\r\n      internal: 0, // qtDevicesTemp-Internal (climate-controlled)\r\n      stores: 0, // qtDevicesTemp-Stores (non-climate-controlled)\r\n    },\r\n  };\r\n  LogHelper.log('[RFC-0107] ðŸ“‹ window.CONTRACT_STATE initialized');\r\n}\r\n\r\n/**\r\n * RFC-0107: Device count attribute keys from SERVER_SCOPE\r\n * These attributes are set by the backend during customer provisioning\r\n */\r\nconst DEVICE_COUNT_KEYS = {\r\n  energy: {\r\n    total: 'qtDevices3f',\r\n    entries: 'qtDevices3f-Entries',\r\n    commonArea: 'qtDevices3f-CommonArea',\r\n    stores: 'qtDevices3f-Stores',\r\n  },\r\n  water: {\r\n    total: 'qtDevicesHidr',\r\n    entries: 'qtDevicesHidr-Entries',\r\n    commonArea: 'qtDevicesHidr-CommonArea',\r\n    stores: 'qtDevicesHidr-Stores',\r\n  },\r\n  temperature: {\r\n    total: 'qtDevicesTemp',\r\n    internal: 'qtDevicesTemp-Internal',\r\n    stores: 'qtDevicesTemp-Stores',\r\n  },\r\n};\r\n\r\n/**\r\n * RFC-0107: Parses SERVER_SCOPE attributes into device count structure\r\n * @param {Array} attributes - Raw attributes from ThingsBoard API\r\n * @returns {Object} Parsed device counts by domain and group\r\n */\r\nfunction parseDeviceCountAttributes(attributes) {\r\n  const getAttrValue = (key) => {\r\n    const attr = attributes.find((a) => a.key === key);\r\n    if (!attr) return 0;\r\n    const value = typeof attr.value === 'string' ? parseInt(attr.value, 10) : attr.value;\r\n    return isNaN(value) ? 0 : value;\r\n  };\r\n\r\n  return {\r\n    energy: {\r\n      total: getAttrValue(DEVICE_COUNT_KEYS.energy.total),\r\n      entries: getAttrValue(DEVICE_COUNT_KEYS.energy.entries),\r\n      commonArea: getAttrValue(DEVICE_COUNT_KEYS.energy.commonArea),\r\n      stores: getAttrValue(DEVICE_COUNT_KEYS.energy.stores),\r\n    },\r\n    water: {\r\n      total: getAttrValue(DEVICE_COUNT_KEYS.water.total),\r\n      entries: getAttrValue(DEVICE_COUNT_KEYS.water.entries),\r\n      commonArea: getAttrValue(DEVICE_COUNT_KEYS.water.commonArea),\r\n      stores: getAttrValue(DEVICE_COUNT_KEYS.water.stores),\r\n    },\r\n    temperature: {\r\n      total: getAttrValue(DEVICE_COUNT_KEYS.temperature.total),\r\n      internal: getAttrValue(DEVICE_COUNT_KEYS.temperature.internal),\r\n      stores: getAttrValue(DEVICE_COUNT_KEYS.temperature.stores),\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * RFC-0107: Fetches device count attributes from SERVER_SCOPE\r\n * Reference pattern: MYIO-SIM/v5.2.0/MAIN/controller.js - fetchInstantaneousPowerLimits()\r\n *\r\n * @param {string} entityId - The customer entity ID (customerTB_ID)\r\n * @param {string} entityType - Entity type (default: 'CUSTOMER')\r\n * @returns {Promise<Object|null>} Device counts object or null on error\r\n */\r\nasync function fetchDeviceCountAttributes(entityId, entityType = 'CUSTOMER') {\r\n  const token = localStorage.getItem('jwt_token');\r\n  if (!token) {\r\n    LogHelper.warn('[RFC-0107] JWT token not found');\r\n    return null;\r\n  }\r\n\r\n  const url = `/api/plugins/telemetry/${entityType}/${entityId}/values/attributes/SERVER_SCOPE`;\r\n\r\n  try {\r\n    LogHelper.log(`[RFC-0107] Fetching device counts from SERVER_SCOPE: ${url}`);\r\n\r\n    const response = await fetch(url, {\r\n      headers: {\r\n        'X-Authorization': `Bearer ${token}`,\r\n        'Content-Type': 'application/json',\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      if (response.status === 404) {\r\n        LogHelper.log(`[RFC-0107] No attributes found for ${entityType} ${entityId}`);\r\n        return null;\r\n      }\r\n      LogHelper.warn(`[RFC-0107] Failed to fetch ${entityType} attributes: ${response.status}`);\r\n      return null;\r\n    }\r\n\r\n    const attributes = await response.json();\r\n    LogHelper.log('[RFC-0107] SERVER_SCOPE attributes received:', attributes.length, 'items');\r\n\r\n    return parseDeviceCountAttributes(attributes);\r\n  } catch (error) {\r\n    LogHelper.error('[RFC-0107] Error fetching device counts:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0107: Validates SERVER_SCOPE device counts against window.STATE\r\n * Called after all domains have loaded to verify contract integrity\r\n *\r\n * @param {Object} serverCounts - Counts from SERVER_SCOPE attributes\r\n * @returns {Object} Validation result with status and discrepancies\r\n */\r\nfunction validateDeviceCounts(serverCounts) {\r\n  const state = window.STATE;\r\n  const discrepancies = [];\r\n\r\n  // Validate Energy\r\n  if (state?.energy) {\r\n    const stateEnergyTotal =\r\n      (state.energy.lojas?.count || 0) +\r\n      (state.energy.entrada?.count || 0) +\r\n      (state.energy.areacomum?.count || 0);\r\n\r\n    if (serverCounts.energy.total > 0 && stateEnergyTotal !== serverCounts.energy.total) {\r\n      discrepancies.push({\r\n        domain: 'energy',\r\n        expected: serverCounts.energy.total,\r\n        actual: stateEnergyTotal,\r\n      });\r\n    }\r\n  }\r\n\r\n  // Validate Water\r\n  if (state?.water) {\r\n    const stateWaterTotal =\r\n      (state.water.lojas?.count || 0) +\r\n      (state.water.entrada?.count || 0) +\r\n      (state.water.areacomum?.count || 0);\r\n\r\n    if (serverCounts.water.total > 0 && stateWaterTotal !== serverCounts.water.total) {\r\n      discrepancies.push({\r\n        domain: 'water',\r\n        expected: serverCounts.water.total,\r\n        actual: stateWaterTotal,\r\n      });\r\n    }\r\n  }\r\n\r\n  // Validate Temperature\r\n  if (state?.temperature) {\r\n    const stateTempTotal =\r\n      (state.temperature.lojas?.count || 0) +\r\n      (state.temperature.entrada?.count || 0) +\r\n      (state.temperature.areacomum?.count || 0);\r\n\r\n    if (serverCounts.temperature.total > 0 && stateTempTotal !== serverCounts.temperature.total) {\r\n      discrepancies.push({\r\n        domain: 'temperature',\r\n        expected: serverCounts.temperature.total,\r\n        actual: stateTempTotal,\r\n      });\r\n    }\r\n  }\r\n\r\n  const isValid = discrepancies.length === 0;\r\n  if (!isValid) {\r\n    LogHelper.warn('[RFC-0107] Device count validation failed:', discrepancies);\r\n  } else {\r\n    LogHelper.log('[RFC-0107] Device count validation passed');\r\n  }\r\n\r\n  return { isValid, discrepancies };\r\n}\r\n\r\n/**\r\n * RFC-0107: Stores contract state in window.CONTRACT_STATE and dispatches event\r\n * This function is called after device counts are fetched and validated\r\n *\r\n * @param {Object} deviceCounts - Device counts from SERVER_SCOPE\r\n * @param {Object} validationResult - Validation result (optional, defaults to valid)\r\n */\r\nfunction storeContractState(deviceCounts, validationResult = { isValid: true, discrepancies: [] }) {\r\n  window.CONTRACT_STATE = {\r\n    isLoaded: true,\r\n    isValid: validationResult.isValid,\r\n    discrepancies: validationResult.discrepancies || [],\r\n    timestamp: new Date().toISOString(),\r\n    energy: {\r\n      total: deviceCounts.energy.total,\r\n      entries: deviceCounts.energy.entries,\r\n      commonArea: deviceCounts.energy.commonArea,\r\n      stores: deviceCounts.energy.stores,\r\n    },\r\n    water: {\r\n      total: deviceCounts.water.total,\r\n      entries: deviceCounts.water.entries,\r\n      commonArea: deviceCounts.water.commonArea,\r\n      stores: deviceCounts.water.stores,\r\n    },\r\n    temperature: {\r\n      total: deviceCounts.temperature.total,\r\n      internal: deviceCounts.temperature.internal,\r\n      stores: deviceCounts.temperature.stores,\r\n    },\r\n  };\r\n\r\n  // Dispatch event for HEADER widget to listen\r\n  window.dispatchEvent(\r\n    new CustomEvent('myio:contract:loaded', {\r\n      detail: window.CONTRACT_STATE,\r\n    })\r\n  );\r\n\r\n  LogHelper.log('[RFC-0107] ðŸ“‹ CONTRACT_STATE stored and event dispatched:', window.CONTRACT_STATE);\r\n}\r\n\r\n/**\r\n * Categorize items into 3 groups: lojas, entrada, areacomum\r\n * Rules:\r\n * - LOJAS: deviceProfile = '3F_MEDIDOR' (uses isStoreDevice)\r\n * - ENTRADA: (deviceType = '3F_MEDIDOR' AND deviceProfile in [TRAFO, ENTRADA, RELOGIO, SUBESTACAO])\r\n *            OR deviceType in [TRAFO, ENTRADA, RELOGIO, SUBESTACAO]\r\n * - AREACOMUM: everything else\r\n */\r\nfunction categorizeItemsByGroup(items) {\r\n  const ENTRADA_PROFILES = new Set(['TRAFO', 'ENTRADA', 'RELOGIO', 'SUBESTACAO']);\r\n  const ENTRADA_TYPES = new Set(['TRAFO', 'ENTRADA', 'RELOGIO', 'SUBESTACAO']);\r\n\r\n  const lojas = [];\r\n  const entrada = [];\r\n  const areacomum = [];\r\n\r\n  // Helper to safely convert to uppercase string (handles objects, arrays, numbers, etc.)\r\n  const toStr = (val) => String(val || '').toUpperCase();\r\n\r\n  for (const item of items) {\r\n    const deviceType = toStr(item.deviceType);\r\n    const deviceProfile = toStr(item.deviceProfile);\r\n\r\n    // Rule 1: LOJAS - use centralized isStoreDevice\r\n    if (isStoreDevice(item)) {\r\n      lojas.push(item);\r\n      continue;\r\n    }\r\n\r\n    // Rule 2: ENTRADA - deviceType = 3F_MEDIDOR with entrada profile, OR deviceType is entrada type\r\n    const isEntradaByProfile = deviceType === '3F_MEDIDOR' && ENTRADA_PROFILES.has(deviceProfile);\r\n    const isEntradaByType = ENTRADA_TYPES.has(deviceType);\r\n    if (isEntradaByProfile || isEntradaByType) {\r\n      entrada.push(item);\r\n      continue;\r\n    }\r\n\r\n    // Rule 3: AREACOMUM - everything else\r\n    areacomum.push(item);\r\n  }\r\n\r\n  return { lojas, entrada, areacomum };\r\n}\r\n\r\n/**\r\n * RFC-0106: Categorize water items into 4 groups: entrada, lojas, banheiros, areacomum\r\n *\r\n * RULE ORDER:\r\n * 1. ENTRADA: deviceType = HIDROMETRO_SHOPPING OR (deviceType = HIDROMETRO AND deviceProfile = HIDROMETRO_SHOPPING)\r\n * 2. AREACOMUM: deviceType = HIDROMETRO_AREA_COMUM OR (deviceType = HIDROMETRO AND deviceProfile = HIDROMETRO_AREA_COMUM)\r\n *    NOTE: Banheiros with HIDROMETRO_AREA_COMUM go here - they are extracted by TELEMETRY widget for TELEMETRY_INFO\r\n * 3. BANHEIROS: identifier/label contains BANHEIRO, WC, SANITARIO, TOALETE, LAVABO (for standalone bathroom meters)\r\n * 4. LOJAS: deviceType = HIDROMETRO AND (deviceProfile = HIDROMETRO OR empty)\r\n *\r\n * Fallback rules (for items not matching primary rules):\r\n * - ENTRADA: label/identifier contains ENTRADA, PRINCIPAL, RELOGIO\r\n * - AREACOMUM: everything else\r\n */\r\nfunction categorizeItemsByGroupWater(items) {\r\n  const BANHEIRO_PATTERNS = ['BANHEIRO', 'WC', 'SANITARIO', 'TOALETE', 'LAVABO'];\r\n  const ENTRADA_PATTERNS = ['ENTRADA', 'PRINCIPAL', 'RELOGIO', 'NASCENTE'];\r\n\r\n  const entrada = [];\r\n  const lojas = [];\r\n  const banheiros = [];\r\n  const areacomum = [];\r\n  const caixadagua = []; // RFC-0107: Category for tanks\r\n\r\n  // Helper to safely convert to uppercase string (handles objects, arrays, numbers, etc.)\r\n  const toStr = (val) => String(val || '').toUpperCase();\r\n\r\n  for (const item of items) {\r\n    const dt = toStr(item.deviceType);\r\n    const dp = toStr(item.deviceProfile);\r\n    const identifier = toStr(item.identifier);\r\n    const label = toStr(item.label);\r\n    const lw = toStr(item.labelWidget);\r\n    const combined = `${identifier} ${label} ${lw}`;\r\n\r\n    // ========== PRIMARY RULES: Based on deviceType AND deviceProfile ==========\r\n\r\n    // Rule 1: ENTRADA - deviceType = HIDROMETRO_SHOPPING OR (deviceType = HIDROMETRO AND deviceProfile = HIDROMETRO_SHOPPING)\r\n    // RFC-0107: Also check for _isHidrometerDevice flag (from ctx.data hidrometro items)\r\n    if (dt === 'HIDROMETRO_SHOPPING' || (dt === 'HIDROMETRO' && dp === 'HIDROMETRO_SHOPPING') || item._isHidrometerDevice) {\r\n      entrada.push(item);\r\n      continue;\r\n    }\r\n\r\n    // Rule 2: AREACOMUM - deviceType = HIDROMETRO_AREA_COMUM OR (deviceType = HIDROMETRO AND deviceProfile = HIDROMETRO_AREA_COMUM)\r\n    // NOTE: Banheiros with deviceType HIDROMETRO_AREA_COMUM go here too - they are extracted later by TELEMETRY widget\r\n    if (dt === 'HIDROMETRO_AREA_COMUM' || (dt === 'HIDROMETRO' && dp === 'HIDROMETRO_AREA_COMUM')) {\r\n      areacomum.push(item);\r\n      continue;\r\n    }\r\n\r\n    // Rule 3: BANHEIROS - check identifier for bathroom patterns (only for HIDROMETRO devices not in areacomum)\r\n    // These are standalone bathroom meters with deviceType = HIDROMETRO\r\n    if (BANHEIRO_PATTERNS.some((p) => identifier.includes(p) || label.includes(p))) {\r\n      banheiros.push(item);\r\n      continue;\r\n    }\r\n\r\n    // Rule 4: LOJAS - deviceType = HIDROMETRO AND (deviceProfile = HIDROMETRO OR deviceProfile is empty/missing)\r\n    if (dt === 'HIDROMETRO' && (dp === 'HIDROMETRO' || dp === '')) {\r\n      lojas.push(item);\r\n      continue;\r\n    }\r\n\r\n    // Rule 5: CAIXA D'ÃGUA - tanks (deviceType = TANK or CAIXA_DAGUA, or labelWidget = \"Caixa D'Ãgua\")\r\n    if (dt === 'TANK' || dt === 'CAIXA_DAGUA' || lw === \"CAIXA D'ÃGUA\" || item._isTankDevice) {\r\n      caixadagua.push(item);\r\n      continue;\r\n    }\r\n\r\n    // ========== FALLBACK RULES: Pattern matching for other deviceTypes ==========\r\n\r\n    // Fallback 1: ENTRADA - main water entry points\r\n    if (ENTRADA_PATTERNS.some((p) => combined.includes(p))) {\r\n      entrada.push(item);\r\n      continue;\r\n    }\r\n\r\n    // Fallback 2: AREACOMUM - everything else\r\n    areacomum.push(item);\r\n  }\r\n\r\n  return { entrada, lojas, banheiros, areacomum, caixadagua };\r\n}\r\n\r\n/**\r\n * Build group data with items, total, and count\r\n */\r\nfunction buildGroupData(items) {\r\n  const total = items.reduce((sum, item) => sum + (Number(item.value) || 0), 0);\r\n  return {\r\n    items: items,\r\n    total: total,\r\n    count: items.length,\r\n  };\r\n}\r\n\r\n/**\r\n * Build summary for TELEMETRY_INFO (pie chart, cards, tooltips)\r\n * RFC-0106: Pre-compute ALL tooltip data so TELEMETRY_INFO just reads it\r\n */\r\nfunction buildSummary(lojas, entrada, areacomum, periodKey) {\r\n  // ============ TOTALS ============\r\n  const lojasTotal = lojas.reduce((sum, item) => sum + (Number(item.value) || 0), 0);\r\n  const entradaTotal = entrada.reduce((sum, item) => sum + (Number(item.value) || 0), 0);\r\n  const areacomumTotal = areacomum.reduce((sum, item) => sum + (Number(item.value) || 0), 0);\r\n  const grandTotal = lojasTotal + entradaTotal + areacomumTotal;\r\n\r\n  // ============ PERCENTAGE HELPER ============\r\n  const calcPerc = (value) => (grandTotal > 0 ? (value / grandTotal) * 100 : 0);\r\n  const calcPercStr = (value) => calcPerc(value).toFixed(1);\r\n\r\n  // ============ SUBCATEGORIZE AREACOMUM ============\r\n  const CLIMATIZACAO_PATTERNS = [\r\n    'CHILLER',\r\n    'FANCOIL',\r\n    'HVAC',\r\n    'AR_CONDICIONADO',\r\n    'COMPRESSOR',\r\n    'VENTILADOR',\r\n    'CLIMATIZA',\r\n    'BOMBA_HIDRAULICA',\r\n    'BOMBASHIDRAULICAS',\r\n  ];\r\n  const ELEVADOR_PATTERNS = ['ELEVADOR'];\r\n  const ESCADA_PATTERNS = ['ESCADA', 'ROLANTE'];\r\n\r\n  // Outros equipment patterns\r\n  const ILUMINACAO_PATTERNS = ['ILUMINA', 'LUZ', 'LAMPADA', 'LED'];\r\n  const BOMBA_INCENDIO_PATTERNS = ['INCENDIO', 'INCÃŠNDIO', 'BOMBA_INCENDIO'];\r\n  const GERADOR_PATTERNS = ['GERADOR', 'NOBREAK', 'UPS'];\r\n\r\n  const climatizacaoItems = [];\r\n  const elevadoresItems = [];\r\n  const escadasRolantesItems = [];\r\n  const outrosItems = [];\r\n\r\n  // Subcategories within climatizacao\r\n  const chillerItems = [];\r\n  const fancoilItems = [];\r\n  const bombaHidraulicaItems = [];\r\n  const cagItems = [];\r\n  const hvacOutrosItems = [];\r\n\r\n  // Subcategories within outros\r\n  const iluminacaoItems = [];\r\n  const bombaIncendioItems = [];\r\n  const geradorItems = [];\r\n  const outrosGeralItems = [];\r\n\r\n  // Helper to safely convert to uppercase string (handles objects, arrays, numbers, etc.)\r\n  const toStr = (val) => String(val || '').toUpperCase();\r\n\r\n  for (const item of areacomum) {\r\n    const lw = toStr(item.labelWidget);\r\n    const dt = toStr(item.deviceType);\r\n    const dp = toStr(item.deviceProfile);\r\n    const label = toStr(item.label);\r\n    const combined = `${lw} ${dt} ${dp} ${label}`;\r\n\r\n    if (ELEVADOR_PATTERNS.some((p) => combined.includes(p))) {\r\n      elevadoresItems.push(item);\r\n    } else if (ESCADA_PATTERNS.some((p) => combined.includes(p))) {\r\n      escadasRolantesItems.push(item);\r\n    } else if (CLIMATIZACAO_PATTERNS.some((p) => combined.includes(p))) {\r\n      climatizacaoItems.push(item);\r\n      // Sub-classify within climatizacao\r\n      if (combined.includes('CHILLER')) chillerItems.push(item);\r\n      else if (combined.includes('FANCOIL')) fancoilItems.push(item);\r\n      else if (\r\n        combined.includes('BOMBA_HIDRAULICA') ||\r\n        combined.includes('BOMBASHIDRAULICAS') ||\r\n        (combined.includes('BOMBA') && !BOMBA_INCENDIO_PATTERNS.some((p) => combined.includes(p)))\r\n      ) {\r\n        bombaHidraulicaItems.push(item);\r\n      } else if (combined.includes('CAG') || combined.includes('CENTRAL')) cagItems.push(item);\r\n      else hvacOutrosItems.push(item);\r\n    } else {\r\n      outrosItems.push(item);\r\n      // Sub-classify within outros\r\n      if (ILUMINACAO_PATTERNS.some((p) => combined.includes(p))) {\r\n        iluminacaoItems.push(item);\r\n      } else if (BOMBA_INCENDIO_PATTERNS.some((p) => combined.includes(p))) {\r\n        bombaIncendioItems.push(item);\r\n      } else if (GERADOR_PATTERNS.some((p) => combined.includes(p))) {\r\n        geradorItems.push(item);\r\n      } else {\r\n        outrosGeralItems.push(item);\r\n      }\r\n    }\r\n  }\r\n\r\n  // ============ FILTER EXCLUDED DEVICES FROM CAG ============\r\n  // RFC: excludeDevicesAtCountSubtotalCAG - remove specified entity IDs from CAG calculation\r\n  const excludeIds = widgetSettings.excludeDevicesAtCountSubtotalCAG || [];\r\n  const excludeIdsSet = new Set(excludeIds.map((id) => String(id).trim().toLowerCase()));\r\n\r\n  let cagItemsFiltered = cagItems;\r\n  let excludedFromCAG = [];\r\n\r\n  if (excludeIdsSet.size > 0) {\r\n    cagItemsFiltered = cagItems.filter((item) => {\r\n      const itemId = String(item.id || '').toLowerCase();\r\n      const isExcluded = excludeIdsSet.has(itemId);\r\n      if (isExcluded) {\r\n        excludedFromCAG.push(item);\r\n      }\r\n      return !isExcluded;\r\n    });\r\n\r\n    if (excludedFromCAG.length > 0) {\r\n      const excludedTotal = excludedFromCAG.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n      LogHelper.log(\r\n        `[buildSummary] ðŸš« Excluded ${\r\n          excludedFromCAG.length\r\n        } devices from CAG subtotal (${excludedTotal.toFixed(2)} kWh):`,\r\n        excludedFromCAG.map((i) => ({ id: i.id, label: i.label, value: i.value }))\r\n      );\r\n    }\r\n  }\r\n\r\n  // ============ CALCULATE SUB-TOTALS ============\r\n  const climatizacaoTotal = climatizacaoItems.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n  const elevadoresTotal = elevadoresItems.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n  const escadasRolantesTotal = escadasRolantesItems.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n  const outrosTotal = outrosItems.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n\r\n  // Climatizacao subcategories totals (CAG uses filtered list)\r\n  const chillerTotal = chillerItems.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n  const fancoilTotal = fancoilItems.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n  const bombaHidraulicaTotal = bombaHidraulicaItems.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n  const cagTotal = cagItemsFiltered.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n  const hvacOutrosTotal = hvacOutrosItems.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n\r\n  // Outros subcategories totals\r\n  const iluminacaoTotal = iluminacaoItems.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n  const bombaIncendioTotal = bombaIncendioItems.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n  const geradorTotal = geradorItems.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n  const outrosGeralTotal = outrosGeralItems.reduce((sum, i) => sum + (Number(i.value) || 0), 0);\r\n\r\n  // ============ DEVICE STATUS AGGREGATION ============\r\n  const allItems = [...lojas, ...entrada, ...areacomum];\r\n  const statusAggregation = aggregateDeviceStatus(allItems);\r\n\r\n  // ============ BUILD TOOLTIP-READY STRUCTURE ============\r\n  const buildCategorySummary = (items, total, name) => ({\r\n    summary: {\r\n      total: total,\r\n      count: items.length,\r\n      perc: calcPerc(total),\r\n      percStr: calcPercStr(total) + '%',\r\n      formatted: total.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }),\r\n    },\r\n    details: {\r\n      devices: items.map((i) => ({\r\n        id: i.id,\r\n        label: i.label || i.name,\r\n        value: i.value,\r\n        deviceStatus: i.deviceStatus,\r\n      })),\r\n      name: name,\r\n    },\r\n  });\r\n\r\n  return {\r\n    total: grandTotal,\r\n    periodKey: periodKey,\r\n\r\n    // Legacy structure (backwards compatibility)\r\n    byGroup: {\r\n      lojas: { total: lojasTotal, count: lojas.length },\r\n      entrada: { total: entradaTotal, count: entrada.length },\r\n      areacomum: { total: areacomumTotal, count: areacomum.length },\r\n    },\r\n    percentages: {\r\n      lojas: calcPercStr(lojasTotal),\r\n      entrada: calcPercStr(entradaTotal),\r\n      areacomum: calcPercStr(areacomumTotal),\r\n    },\r\n    formatted: {\r\n      lojas: lojasTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }),\r\n      entrada: entradaTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }),\r\n      areacomum: areacomumTotal.toLocaleString('pt-BR', {\r\n        minimumFractionDigits: 2,\r\n        maximumFractionDigits: 2,\r\n      }),\r\n      total: grandTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }),\r\n    },\r\n\r\n    // ============ TOOLTIP-READY DATA ============\r\n    // Each category has .summary (totals) and .details (device list)\r\n    entrada: buildCategorySummary(entrada, entradaTotal, 'Entrada'),\r\n    lojas: buildCategorySummary(lojas, lojasTotal, 'Lojas'),\r\n    climatizacao: {\r\n      ...buildCategorySummary(climatizacaoItems, climatizacaoTotal, 'ClimatizaÃ§Ã£o'),\r\n      subcategories: {\r\n        chillers: buildCategorySummary(chillerItems, chillerTotal, 'Chillers'),\r\n        fancoils: buildCategorySummary(fancoilItems, fancoilTotal, 'Fancoils'),\r\n        bombasHidraulicas: buildCategorySummary(\r\n          bombaHidraulicaItems,\r\n          bombaHidraulicaTotal,\r\n          'Bombas HidrÃ¡ulicas'\r\n        ),\r\n        cag: buildCategorySummary(cagItemsFiltered, cagTotal, 'CAG'),\r\n        hvacOutros: buildCategorySummary(hvacOutrosItems, hvacOutrosTotal, 'Outros HVAC'),\r\n      },\r\n    },\r\n    elevadores: buildCategorySummary(elevadoresItems, elevadoresTotal, 'Elevadores'),\r\n    escadasRolantes: buildCategorySummary(escadasRolantesItems, escadasRolantesTotal, 'Escadas Rolantes'),\r\n    outros: {\r\n      ...buildCategorySummary(outrosItems, outrosTotal, 'Outros'),\r\n      subcategories: {\r\n        iluminacao: buildCategorySummary(iluminacaoItems, iluminacaoTotal, 'IluminaÃ§Ã£o'),\r\n        bombasIncendio: buildCategorySummary(bombaIncendioItems, bombaIncendioTotal, 'Bombas de IncÃªndio'),\r\n        geradores: buildCategorySummary(geradorItems, geradorTotal, 'Geradores/Nobreaks'),\r\n        geral: buildCategorySummary(outrosGeralItems, outrosGeralTotal, 'Outros Equipamentos'),\r\n      },\r\n    },\r\n    areaComum: buildCategorySummary(areacomum, areacomumTotal, 'Ãrea Comum'),\r\n\r\n    // ============ RESUMO GERAL (GRAND TOTAL + STATUS) ============\r\n    resumo: {\r\n      summary: {\r\n        total: grandTotal,\r\n        count: allItems.length,\r\n        perc: 100,\r\n        percStr: '100%',\r\n        formatted: grandTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }),\r\n      },\r\n      details: {\r\n        byCategory: {\r\n          entrada: { count: entrada.length, total: entradaTotal },\r\n          lojas: { count: lojas.length, total: lojasTotal },\r\n          climatizacao: { count: climatizacaoItems.length, total: climatizacaoTotal },\r\n          elevadores: { count: elevadoresItems.length, total: elevadoresTotal },\r\n          escadasRolantes: { count: escadasRolantesItems.length, total: escadasRolantesTotal },\r\n          outros: { count: outrosItems.length, total: outrosTotal },\r\n        },\r\n        byStatus: statusAggregation,\r\n      },\r\n    },\r\n\r\n    // ============ DEVICE STATUS AGGREGATION (for tooltip) ============\r\n    deviceStatusAggregation: statusAggregation,\r\n\r\n    // ============ EXCLUDED DEVICES FROM CAG SUBTOTAL ============\r\n    // RFC: excludeDevicesAtCountSubtotalCAG - list of devices excluded from CAG calculation\r\n    excludedFromCAG: excludedFromCAG.map((item) => ({\r\n      id: item.id,\r\n      label: item.label || item.name || item.deviceIdentifier || item.id,\r\n      value: item.value || 0,\r\n    })),\r\n  };\r\n}\r\n\r\n/**\r\n * Aggregate device status from items\r\n * Returns counts and device lists for each status\r\n */\r\nfunction aggregateDeviceStatus(items) {\r\n  const NO_CONSUMPTION_THRESHOLD = 0.01;\r\n\r\n  const result = {\r\n    hasData: items.length > 0,\r\n    normal: 0,\r\n    alert: 0,\r\n    failure: 0,\r\n    standby: 0,\r\n    offline: 0,\r\n    noConsumption: 0,\r\n    normalDevices: [],\r\n    alertDevices: [],\r\n    failureDevices: [],\r\n    standbyDevices: [],\r\n    offlineDevices: [],\r\n    noConsumptionDevices: [],\r\n  };\r\n\r\n  const statusMapping = {\r\n    power_on: 'normal',\r\n    warning: 'alert',\r\n    failure: 'failure',\r\n    standby: 'standby',\r\n    power_off: 'offline',\r\n    maintenance: 'offline',\r\n    no_info: 'offline',\r\n    not_installed: 'offline',\r\n    offline: 'offline',\r\n  };\r\n\r\n  for (const item of items) {\r\n    const deviceInfo = {\r\n      id: item.id,\r\n      label: item.label || item.name || item.identifier || '',\r\n      name: item.name || '',\r\n    };\r\n\r\n    const deviceStatus = item.deviceStatus || 'no_info';\r\n    const value = Number(item.value || 0);\r\n\r\n    // Check for \"no consumption\" (online but zero value)\r\n    const isOnline = !['no_info', 'offline', 'not_installed', 'maintenance', 'power_off'].includes(\r\n      deviceStatus\r\n    );\r\n    if (isOnline && Math.abs(value) < NO_CONSUMPTION_THRESHOLD) {\r\n      result.noConsumption++;\r\n      result.noConsumptionDevices.push(deviceInfo);\r\n      continue;\r\n    }\r\n\r\n    // Map to status category\r\n    const mappedStatus = statusMapping[deviceStatus] || 'offline';\r\n    result[mappedStatus]++;\r\n    result[`${mappedStatus}Devices`].push(deviceInfo);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * RFC-0106: Build summary for water domain (TELEMETRY_INFO water)\r\n * Similar to buildSummary but with water-specific categories\r\n */\r\nfunction buildSummaryWater(entrada, lojas, banheiros, areacomum, periodKey) {\r\n  // ============ TOTALS ============\r\n  const entradaTotal = entrada.reduce((sum, item) => sum + (Number(item.value) || 0), 0);\r\n  const lojasTotal = lojas.reduce((sum, item) => sum + (Number(item.value) || 0), 0);\r\n  const banheirosTotal = banheiros.reduce((sum, item) => sum + (Number(item.value) || 0), 0);\r\n  const areacomumTotal = areacomum.reduce((sum, item) => sum + (Number(item.value) || 0), 0);\r\n  const consumidoresTotal = lojasTotal + banheirosTotal + areacomumTotal;\r\n  const grandTotal = entradaTotal; // Entrada is the reference\r\n\r\n  // ============ PERCENTAGE HELPER ============\r\n  const calcPerc = (value) => (grandTotal > 0 ? (value / grandTotal) * 100 : 0);\r\n  const calcPercStr = (value) => calcPerc(value).toFixed(1);\r\n\r\n  // ============ PONTOS NÃƒO MAPEADOS ============\r\n  // Calculated as difference between entrada and sum of consumers\r\n  const pontosNaoMapeadosTotal = Math.max(0, entradaTotal - consumidoresTotal);\r\n  const hasInconsistency = consumidoresTotal > entradaTotal * 1.05; // 5% tolerance\r\n\r\n  // ============ DEVICE STATUS AGGREGATION ============\r\n  const allItems = [...entrada, ...lojas, ...banheiros, ...areacomum];\r\n  const statusAggregation = aggregateDeviceStatus(allItems);\r\n\r\n  // ============ BUILD TOOLTIP-READY STRUCTURE ============\r\n  const buildCategorySummary = (items, total, name) => ({\r\n    summary: {\r\n      total: total,\r\n      count: items.length,\r\n      perc: calcPerc(total),\r\n      percStr: calcPercStr(total) + '%',\r\n      formatted:\r\n        total.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' mÂ³',\r\n    },\r\n    details: {\r\n      devices: items.map((i) => ({\r\n        id: i.id,\r\n        label: i.label || i.name,\r\n        value: i.value,\r\n        deviceStatus: i.deviceStatus,\r\n      })),\r\n      name: name,\r\n    },\r\n  });\r\n\r\n  return {\r\n    total: grandTotal,\r\n    periodKey: periodKey,\r\n    unit: 'mÂ³',\r\n\r\n    // Legacy structure (backwards compatibility)\r\n    byGroup: {\r\n      entrada: { total: entradaTotal, count: entrada.length },\r\n      lojas: { total: lojasTotal, count: lojas.length },\r\n      banheiros: { total: banheirosTotal, count: banheiros.length },\r\n      areacomum: { total: areacomumTotal, count: areacomum.length },\r\n      pontosNaoMapeados: { total: pontosNaoMapeadosTotal, count: 0, isCalculated: true },\r\n    },\r\n    percentages: {\r\n      entrada: '100.0',\r\n      lojas: calcPercStr(lojasTotal),\r\n      banheiros: calcPercStr(banheirosTotal),\r\n      areacomum: calcPercStr(areacomumTotal),\r\n      pontosNaoMapeados: calcPercStr(pontosNaoMapeadosTotal),\r\n    },\r\n    formatted: {\r\n      entrada:\r\n        entradaTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' mÂ³',\r\n      lojas:\r\n        lojasTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' mÂ³',\r\n      banheiros:\r\n        banheirosTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) +\r\n        ' mÂ³',\r\n      areacomum:\r\n        areacomumTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) +\r\n        ' mÂ³',\r\n      total:\r\n        grandTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' mÂ³',\r\n    },\r\n\r\n    // ============ TOOLTIP-READY DATA ============\r\n    entrada: buildCategorySummary(entrada, entradaTotal, 'Entrada'),\r\n    lojas: buildCategorySummary(lojas, lojasTotal, 'Lojas'),\r\n    banheiros: buildCategorySummary(banheiros, banheirosTotal, 'Banheiros'),\r\n    areaComum: buildCategorySummary(areacomum, areacomumTotal, 'Ãrea Comum'),\r\n    pontosNaoMapeados: {\r\n      summary: {\r\n        total: pontosNaoMapeadosTotal,\r\n        count: 0,\r\n        perc: calcPerc(pontosNaoMapeadosTotal),\r\n        percStr: calcPercStr(pontosNaoMapeadosTotal) + '%',\r\n        formatted:\r\n          pontosNaoMapeadosTotal.toLocaleString('pt-BR', {\r\n            minimumFractionDigits: 2,\r\n            maximumFractionDigits: 2,\r\n          }) + ' mÂ³',\r\n        isCalculated: true,\r\n        hasInconsistency: hasInconsistency,\r\n      },\r\n      details: {\r\n        devices: [],\r\n        name: 'Pontos NÃ£o Mapeados',\r\n        description: 'DiferenÃ§a entre entrada e soma dos consumidores',\r\n      },\r\n    },\r\n\r\n    // ============ RESUMO GERAL (GRAND TOTAL + STATUS) ============\r\n    resumo: {\r\n      summary: {\r\n        total: grandTotal,\r\n        count: allItems.length,\r\n        perc: 100,\r\n        percStr: '100%',\r\n        formatted:\r\n          grandTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' mÂ³',\r\n      },\r\n      details: {\r\n        byCategory: {\r\n          entrada: { count: entrada.length, total: entradaTotal },\r\n          lojas: { count: lojas.length, total: lojasTotal },\r\n          banheiros: { count: banheiros.length, total: banheirosTotal },\r\n          areacomum: { count: areacomum.length, total: areacomumTotal },\r\n          pontosNaoMapeados: { count: 0, total: pontosNaoMapeadosTotal, isCalculated: true },\r\n        },\r\n        byStatus: statusAggregation,\r\n        hasInconsistency: hasInconsistency,\r\n      },\r\n    },\r\n\r\n    // ============ DEVICE STATUS AGGREGATION (for tooltip) ============\r\n    deviceStatusAggregation: statusAggregation,\r\n  };\r\n}\r\n\r\n/**\r\n * Populate window.STATE for a domain with categorized data\r\n * RFC-0106: Now supports both energy and water domains with specific categorization\r\n */\r\nfunction populateState(domain, items, periodKey) {\r\n  if (domain === 'water') {\r\n    // Water domain: entrada, lojas, banheiros, areacomum, caixadagua\r\n    const { entrada, lojas, banheiros, areacomum, caixadagua } = categorizeItemsByGroupWater(items);\r\n\r\n    window.STATE[domain] = {\r\n      entrada: buildGroupData(entrada),\r\n      lojas: buildGroupData(lojas),\r\n      banheiros: buildGroupData(banheiros),\r\n      areacomum: buildGroupData(areacomum),\r\n      caixadagua: buildGroupData(caixadagua), // RFC-0107: Tanks\r\n      summary: buildSummaryWater(entrada, lojas, banheiros, areacomum, periodKey),\r\n      _raw: items,\r\n    };\r\n\r\n    window.STATE._lastUpdate[domain] = Date.now();\r\n\r\n    LogHelper.log(`[Orchestrator] ðŸ—„ï¸ window.STATE.${domain} populated:`, {\r\n      entrada: entrada.length,\r\n      lojas: lojas.length,\r\n      banheiros: banheiros.length,\r\n      areacomum: areacomum.length,\r\n      caixadagua: caixadagua.length,\r\n      total: items.length,\r\n    });\r\n  } else {\r\n    // Energy domain (default): lojas, entrada, areacomum\r\n    const { lojas, entrada, areacomum } = categorizeItemsByGroup(items);\r\n\r\n    window.STATE[domain] = {\r\n      lojas: buildGroupData(lojas),\r\n      entrada: buildGroupData(entrada),\r\n      areacomum: buildGroupData(areacomum),\r\n      summary: buildSummary(lojas, entrada, areacomum, periodKey),\r\n      _raw: items,\r\n    };\r\n\r\n    window.STATE._lastUpdate[domain] = Date.now();\r\n\r\n    LogHelper.log(`[Orchestrator] ðŸ—„ï¸ window.STATE.${domain} populated:`, {\r\n      lojas: lojas.length,\r\n      entrada: entrada.length,\r\n      areacomum: areacomum.length,\r\n      total: items.length,\r\n    });\r\n  }\r\n\r\n  // Emit state-ready event for widgets that prefer to read from STATE\r\n  window.dispatchEvent(\r\n    new CustomEvent('myio:state:ready', {\r\n      detail: { domain, periodKey },\r\n    })\r\n  );\r\n}\r\n\r\n/**\r\n * RFC-0106: Populate window.STATE.temperature with sensor data\r\n * Temperature domain is simpler - no categorization, just a flat list of sensors\r\n * @param {Array} items - Temperature sensor items from ctx.data\r\n */\r\nfunction populateStateTemperature(items) {\r\n  // Get temperature limits from MyIOUtils (set by customer attributes)\r\n  const minTemp = window.MyIOUtils?.temperatureLimits?.minTemperature ?? 18;\r\n  const maxTemp = window.MyIOUtils?.temperatureLimits?.maxTemperature ?? 27;\r\n\r\n  // Categorize sensors by status\r\n  const normal = [];\r\n  const warning = [];\r\n  const critical = [];\r\n  const offline = [];\r\n\r\n  for (const item of items) {\r\n    const temp = Number(item.temperature || item.value || 0);\r\n    const status = item.deviceStatus || item.connectionStatus || 'unknown';\r\n\r\n    // Check if device is offline first\r\n    if (status === 'offline' || status === 'no_info') {\r\n      offline.push(item);\r\n      continue;\r\n    }\r\n\r\n    // Categorize by temperature value\r\n    if (temp < minTemp || temp > maxTemp) {\r\n      critical.push(item);\r\n    } else if (temp <= minTemp + 2 || temp >= maxTemp - 2) {\r\n      // Within 2 degrees of limits = warning\r\n      warning.push(item);\r\n    } else {\r\n      normal.push(item);\r\n    }\r\n  }\r\n\r\n  // Calculate aggregates\r\n  const allTemps = items.filter((i) => i.deviceStatus !== 'offline').map((i) => Number(i.temperature || 0));\r\n  const avgTemp = allTemps.length > 0 ? allTemps.reduce((a, b) => a + b, 0) / allTemps.length : 0;\r\n  const minValue = allTemps.length > 0 ? Math.min(...allTemps) : 0;\r\n  const maxValue = allTemps.length > 0 ? Math.max(...allTemps) : 0;\r\n\r\n  window.STATE.temperature = {\r\n    items: items,\r\n    normal: normal,\r\n    warning: warning,\r\n    critical: critical,\r\n    offline: offline,\r\n    summary: {\r\n      total: items.length,\r\n      normalCount: normal.length,\r\n      warningCount: warning.length,\r\n      criticalCount: critical.length,\r\n      offlineCount: offline.length,\r\n      avgTemperature: avgTemp,\r\n      minTemperature: minValue,\r\n      maxTemperature: maxValue,\r\n      limits: { min: minTemp, max: maxTemp },\r\n    },\r\n    _raw: items,\r\n  };\r\n\r\n  window.STATE._lastUpdate.temperature = Date.now();\r\n\r\n  LogHelper.log(`[Orchestrator] ðŸŒ¡ï¸ window.STATE.temperature populated:`, {\r\n    total: items.length,\r\n    normal: normal.length,\r\n    warning: warning.length,\r\n    critical: critical.length,\r\n    offline: offline.length,\r\n    avgTemp: avgTemp.toFixed(1),\r\n  });\r\n\r\n  // Emit state-ready event\r\n  window.dispatchEvent(\r\n    new CustomEvent('myio:state:ready', {\r\n      detail: { domain: 'temperature', periodKey: 'realtime' },\r\n    })\r\n  );\r\n}\r\n\r\n/**\r\n * @typedef {'hour'|'day'|'month'} Granularity\r\n * @typedef {'energy'|'water'|'temperature'} Domain\r\n */\r\n\r\n/**\r\n * @typedef {Object} Period\r\n * @property {string} startISO - ISO 8601 with timezone\r\n * @property {string} endISO - ISO 8601 with timezone\r\n * @property {Granularity} granularity - Data aggregation level\r\n * @property {string} tz - IANA timezone\r\n */\r\n\r\n/**\r\n * @typedef {Object} EnrichedItem\r\n * @property {string} id - ThingsBoard entityId (single source of truth)\r\n * @property {string} tbId - ThingsBoard deviceId\r\n * @property {string} ingestionId - Data Ingestion API UUID\r\n * @property {string} identifier - Human-readable ID\r\n * @property {string} label - Display name\r\n * @property {number} value - Consumption total\r\n * @property {number} perc - Percentage of group total\r\n * @property {string|null} slaveId - Modbus slave ID\r\n * @property {string|null} centralId - Central unit ID\r\n * @property {string} deviceType - Device type\r\n */\r\n\r\n// ========== UTILITIES ==========\r\n\r\n/**\r\n * Generates a unique key from domain and period for request deduplication.\r\n */\r\nfunction periodKey(domain, period) {\r\n  const customerTbId = widgetSettings.customerTB_ID;\r\n  return `${customerTbId}:${domain}:${period.startISO}:${period.endISO}:${period.granularity}`;\r\n}\r\n\r\n// ========== ORCHESTRATOR SINGLETON ==========\r\n\r\nconst MyIOOrchestrator = (() => {\r\n  // ========== PHASE 1: BUSY OVERLAY MANAGEMENT (RFC-0044/RFC-0054) ==========\r\n  const BUSY_OVERLAY_ID = 'myio-orchestrator-busy-overlay';\r\n  let globalBusyState = {\r\n    isVisible: false,\r\n    timeoutId: null,\r\n    startTime: null,\r\n    currentDomain: null,\r\n    requestCount: 0,\r\n  };\r\n\r\n  // RFC-0054: contador por domï¿½nio e cooldown pï¿½s-provide\r\n  const activeRequests = new Map(); // domain -> count\r\n  const lastProvide = new Map(); // domain -> { periodKey, at }\r\n\r\n  function getActiveTotal() {\r\n    let total = 0;\r\n    activeRequests.forEach((v) => {\r\n      total += v || 0;\r\n    });\r\n    return total;\r\n  }\r\n\r\n  /**\r\n   * RFC-0107: Creates the contract loading modal DOM with domain breakdown\r\n   * Shows loading progress for Energy, Water, and Temperature domains\r\n   * with expandable details for each group (entries, common area, stores)\r\n   */\r\n  function ensureOrchestratorBusyDOM() {\r\n    let el = document.getElementById(BUSY_OVERLAY_ID);\r\n    if (el) return el;\r\n\r\n    el = document.createElement('div');\r\n    el.id = BUSY_OVERLAY_ID;\r\n    el.style.cssText = `\r\n    position: fixed;\r\n    inset: 0;\r\n    background: rgba(150, 132, 181, 0.45);\r\n    backdrop-filter: blur(5px);\r\n    display: none;\r\n    align-items: center;\r\n    justify-content: center;\r\n    z-index: 99999;\r\n    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;\r\n  `;\r\n\r\n    const container = document.createElement('div');\r\n    container.id = `${BUSY_OVERLAY_ID}-container`;\r\n    container.style.cssText = `\r\n    background: #2d1458;\r\n    color: #fff;\r\n    border-radius: 18px;\r\n    padding: 28px 32px;\r\n    box-shadow: 0 12px 40px rgba(0,0,0,0.35);\r\n    border: 1px solid rgba(255,255,255,0.1);\r\n    min-width: 400px;\r\n    max-width: 500px;\r\n  `;\r\n\r\n    // RFC-0107: Contract loading modal with domain details\r\n    container.innerHTML = `\r\n      <!-- Header with spinner -->\r\n      <div style=\"display:flex; align-items:center; gap:12px; margin-bottom:20px;\">\r\n        <div class=\"contract-spinner\" style=\"\r\n            width:22px;height:22px;border-radius:50%;\r\n            border:3px solid rgba(255,255,255,.25);\r\n            border-top-color:#ffffff; animation:spin .9s linear infinite;\"></div>\r\n        <div id=\"${BUSY_OVERLAY_ID}-message\" style=\"font-weight:600; font-size:16px; letter-spacing:.2px;\">\r\n          Carregando contrato...\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Domain sections -->\r\n      <div id=\"${BUSY_OVERLAY_ID}-domains\" style=\"display:flex; flex-direction:column; gap:10px;\">\r\n\r\n        <!-- Energy Domain -->\r\n        <div class=\"domain-section\" data-domain=\"energy\" style=\"\r\n            background:rgba(255,255,255,0.08); border-radius:12px; overflow:hidden;\">\r\n          <div class=\"domain-header\" style=\"\r\n              display:flex; align-items:center; justify-content:space-between;\r\n              padding:12px 14px; cursor:pointer;\">\r\n            <div style=\"display:flex; align-items:center; gap:10px;\">\r\n              <span style=\"font-size:20px;\">âš¡</span>\r\n              <span style=\"font-weight:500;\">Energia</span>\r\n            </div>\r\n            <div style=\"display:flex; align-items:center; gap:10px;\">\r\n              <span class=\"domain-status\" style=\"\r\n                  width:18px; height:18px; border-radius:50%;\r\n                  border:2px solid rgba(255,255,255,0.3);\r\n                  display:flex; align-items:center; justify-content:center;\r\n                  font-size:10px;\"></span>\r\n              <span class=\"domain-count\" style=\"font-size:13px; opacity:0.7;\">--</span>\r\n              <span class=\"expand-arrow\" style=\"font-size:12px; transition:transform 0.2s;\">â–¼</span>\r\n            </div>\r\n          </div>\r\n          <div class=\"domain-details\">\r\n            <div class=\"detail-row\" style=\"display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid rgba(255,255,255,0.08);\">\r\n              <span style=\"font-size:12px; opacity:0.8;\">Entradas</span>\r\n              <span class=\"detail-entries\" style=\"font-size:12px; font-weight:500;\">--</span>\r\n            </div>\r\n            <div class=\"detail-row\" style=\"display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid rgba(255,255,255,0.08);\">\r\n              <span style=\"font-size:12px; opacity:0.8;\">Ãrea Comum</span>\r\n              <span class=\"detail-commonArea\" style=\"font-size:12px; font-weight:500;\">--</span>\r\n            </div>\r\n            <div class=\"detail-row\" style=\"display:flex; justify-content:space-between; padding:8px 0;\">\r\n              <span style=\"font-size:12px; opacity:0.8;\">Lojas</span>\r\n              <span class=\"detail-stores\" style=\"font-size:12px; font-weight:500;\">--</span>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <!-- Water Domain -->\r\n        <div class=\"domain-section\" data-domain=\"water\" style=\"\r\n            background:rgba(255,255,255,0.08); border-radius:12px; overflow:hidden;\">\r\n          <div class=\"domain-header\" style=\"\r\n              display:flex; align-items:center; justify-content:space-between;\r\n              padding:12px 14px; cursor:pointer;\">\r\n            <div style=\"display:flex; align-items:center; gap:10px;\">\r\n              <span style=\"font-size:20px;\">ðŸ’§</span>\r\n              <span style=\"font-weight:500;\">Ãgua</span>\r\n            </div>\r\n            <div style=\"display:flex; align-items:center; gap:10px;\">\r\n              <span class=\"domain-status\" style=\"\r\n                  width:18px; height:18px; border-radius:50%;\r\n                  border:2px solid rgba(255,255,255,0.3);\r\n                  display:flex; align-items:center; justify-content:center;\r\n                  font-size:10px;\"></span>\r\n              <span class=\"domain-count\" style=\"font-size:13px; opacity:0.7;\">--</span>\r\n              <span class=\"expand-arrow\" style=\"font-size:12px; transition:transform 0.2s;\">â–¼</span>\r\n            </div>\r\n          </div>\r\n          <div class=\"domain-details\">\r\n            <div class=\"detail-row\" style=\"display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid rgba(255,255,255,0.08);\">\r\n              <span style=\"font-size:12px; opacity:0.8;\">Entradas</span>\r\n              <span class=\"detail-entries\" style=\"font-size:12px; font-weight:500;\">--</span>\r\n            </div>\r\n            <div class=\"detail-row\" style=\"display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid rgba(255,255,255,0.08);\">\r\n              <span style=\"font-size:12px; opacity:0.8;\">Ãrea Comum</span>\r\n              <span class=\"detail-commonArea\" style=\"font-size:12px; font-weight:500;\">--</span>\r\n            </div>\r\n            <div class=\"detail-row\" style=\"display:flex; justify-content:space-between; padding:8px 0;\">\r\n              <span style=\"font-size:12px; opacity:0.8;\">Lojas</span>\r\n              <span class=\"detail-stores\" style=\"font-size:12px; font-weight:500;\">--</span>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <!-- Temperature Domain -->\r\n        <div class=\"domain-section\" data-domain=\"temperature\" style=\"\r\n            background:rgba(255,255,255,0.08); border-radius:12px; overflow:hidden;\">\r\n          <div class=\"domain-header\" style=\"\r\n              display:flex; align-items:center; justify-content:space-between;\r\n              padding:12px 14px; cursor:pointer;\">\r\n            <div style=\"display:flex; align-items:center; gap:10px;\">\r\n              <span style=\"font-size:20px;\">ðŸŒ¡ï¸</span>\r\n              <span style=\"font-weight:500;\">Temperatura</span>\r\n            </div>\r\n            <div style=\"display:flex; align-items:center; gap:10px;\">\r\n              <span class=\"domain-status\" style=\"\r\n                  width:18px; height:18px; border-radius:50%;\r\n                  border:2px solid rgba(255,255,255,0.3);\r\n                  display:flex; align-items:center; justify-content:center;\r\n                  font-size:10px;\"></span>\r\n              <span class=\"domain-count\" style=\"font-size:13px; opacity:0.7;\">--</span>\r\n              <span class=\"expand-arrow\" style=\"font-size:12px; transition:transform 0.2s;\">â–¼</span>\r\n            </div>\r\n          </div>\r\n          <div class=\"domain-details\">\r\n            <div class=\"detail-row\" style=\"display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid rgba(255,255,255,0.08);\">\r\n              <span style=\"font-size:12px; opacity:0.8;\">Climatizados</span>\r\n              <span class=\"detail-internal\" style=\"font-size:12px; font-weight:500;\">--</span>\r\n            </div>\r\n            <div class=\"detail-row\" style=\"display:flex; justify-content:space-between; padding:8px 0;\">\r\n              <span style=\"font-size:12px; opacity:0.8;\">Lojas</span>\r\n              <span class=\"detail-stores\" style=\"font-size:12px; font-weight:500;\">--</span>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n      </div>\r\n\r\n      <!-- Validation status (hidden by default) -->\r\n      <div id=\"${BUSY_OVERLAY_ID}-status\" style=\"\r\n          margin-top:16px; padding:12px 14px; border-radius:10px;\r\n          background:rgba(255,255,255,0.05); display:none;\">\r\n      </div>\r\n\r\n      <!-- Action buttons -->\r\n      <div id=\"${BUSY_OVERLAY_ID}-actions\" style=\"\r\n          display:flex; gap:10px; margin-top:16px; justify-content:flex-end;\">\r\n        <button class=\"contract-pause-btn\" style=\"\r\n            padding:8px 16px; border-radius:8px; border:1px solid rgba(255,255,255,0.2);\r\n            background:rgba(255,255,255,0.1); color:#fff; font-size:13px;\r\n            cursor:pointer; display:flex; align-items:center; gap:6px;\r\n            transition:all 0.2s ease;\">\r\n          <span class=\"pause-icon\">â¸</span>\r\n          <span class=\"pause-text\">Pausar</span>\r\n        </button>\r\n        <button class=\"contract-close-btn\" style=\"\r\n            padding:8px 16px; border-radius:8px; border:none;\r\n            background:#81c784; color:#1a1a2e; font-size:13px; font-weight:500;\r\n            cursor:not-allowed; opacity:0.5; display:flex; align-items:center; gap:6px;\r\n            transition:all 0.2s ease;\" disabled>\r\n          <span>âœ“</span>\r\n          <span>Fechar</span>\r\n        </button>\r\n      </div>\r\n    `;\r\n\r\n    el.appendChild(container);\r\n    document.body.appendChild(el);\r\n\r\n    // Add CSS animation and expand styles\r\n    if (!document.querySelector('#myio-busy-styles')) {\r\n      const styleEl = document.createElement('style');\r\n      styleEl.id = 'myio-busy-styles';\r\n      styleEl.textContent = `\r\n      @keyframes spin {\r\n        from { transform: rotate(0deg); }\r\n        to { transform: rotate(360deg); }\r\n      }\r\n      #${BUSY_OVERLAY_ID} .domain-section .domain-details {\r\n        max-height: 0;\r\n        overflow: hidden;\r\n        transition: max-height 0.3s ease-out, padding 0.3s ease-out;\r\n        padding: 0 14px;\r\n        background: rgba(0,0,0,0.15);\r\n      }\r\n      #${BUSY_OVERLAY_ID} .domain-section.expanded .domain-details {\r\n        max-height: 200px;\r\n        padding: 8px 14px 12px 14px;\r\n      }\r\n      #${BUSY_OVERLAY_ID} .domain-section.expanded .expand-arrow {\r\n        transform: rotate(180deg);\r\n      }\r\n      #${BUSY_OVERLAY_ID} .domain-section .domain-header {\r\n        user-select: none;\r\n      }\r\n      #${BUSY_OVERLAY_ID} .domain-section.loaded .domain-status {\r\n        background: rgba(76,175,80,0.3);\r\n        border-color: #81c784;\r\n        color: #81c784;\r\n      }\r\n      #${BUSY_OVERLAY_ID} .domain-section.loaded .domain-count {\r\n        opacity: 1;\r\n        color: #81c784;\r\n      }\r\n      #${BUSY_OVERLAY_ID} .domain-section.error .domain-status {\r\n        background: rgba(244,67,54,0.3);\r\n        border-color: #ef5350;\r\n        color: #ef5350;\r\n      }\r\n      #${BUSY_OVERLAY_ID} .domain-section.error .domain-count {\r\n        opacity: 1;\r\n        color: #ef5350;\r\n      }\r\n      #${BUSY_OVERLAY_ID} .contract-pause-btn:hover {\r\n        background: rgba(255,255,255,0.2);\r\n        border-color: rgba(255,255,255,0.4);\r\n      }\r\n      #${BUSY_OVERLAY_ID} .contract-pause-btn.paused {\r\n        background: rgba(239,83,80,0.2);\r\n        border-color: #ef5350;\r\n      }\r\n      #${BUSY_OVERLAY_ID} .contract-close-btn:not(:disabled):hover {\r\n        background: #66bb6a;\r\n      }\r\n    `;\r\n      document.head.appendChild(styleEl);\r\n    }\r\n\r\n    // RFC-0107: Set up button event listeners\r\n    setupContractModalButtons(el);\r\n\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * RFC-0107: Sets up event listeners for pause, close buttons and domain expand\r\n   */\r\n  function setupContractModalButtons(modalEl) {\r\n    const pauseBtn = modalEl.querySelector('.contract-pause-btn');\r\n    const closeBtn = modalEl.querySelector('.contract-close-btn');\r\n\r\n    // Initialize pause state\r\n    window._contractModalPaused = false;\r\n\r\n    // Domain header expand/collapse handlers\r\n    const domainHeaders = modalEl.querySelectorAll('.domain-header');\r\n    domainHeaders.forEach((header) => {\r\n      header.addEventListener('click', () => {\r\n        const section = header.parentElement;\r\n        section.classList.toggle('expanded');\r\n        LogHelper.log(\r\n          `[RFC-0107] Domain ${section.dataset.domain} ${\r\n            section.classList.contains('expanded') ? 'expanded' : 'collapsed'\r\n          }`\r\n        );\r\n      });\r\n    });\r\n\r\n    // Pause button handler\r\n    if (pauseBtn) {\r\n      pauseBtn.addEventListener('click', () => {\r\n        window._contractModalPaused = !window._contractModalPaused;\r\n        const icon = pauseBtn.querySelector('.pause-icon');\r\n        const text = pauseBtn.querySelector('.pause-text');\r\n\r\n        if (window._contractModalPaused) {\r\n          // Paused state\r\n          icon.textContent = 'â–¶';\r\n          text.textContent = 'Retomar';\r\n          pauseBtn.classList.add('paused');\r\n          LogHelper.log('[RFC-0107] Contract modal auto-close paused');\r\n\r\n          // Clear auto-close timeout\r\n          if (window._contractModalAutoCloseId) {\r\n            clearTimeout(window._contractModalAutoCloseId);\r\n            window._contractModalAutoCloseId = null;\r\n          }\r\n        } else {\r\n          // Resumed state\r\n          icon.textContent = 'â¸';\r\n          text.textContent = 'Pausar';\r\n          pauseBtn.classList.remove('paused');\r\n          LogHelper.log('[RFC-0107] Contract modal auto-close resumed');\r\n\r\n          // Restart auto-close timer (15 seconds)\r\n          window._contractModalAutoCloseId = setTimeout(() => {\r\n            if (!window._contractModalPaused && window.MyIOOrchestrator?.hideGlobalBusy) {\r\n              LogHelper.log('[RFC-0107] Auto-closing contract modal');\r\n              window.MyIOOrchestrator.hideGlobalBusy();\r\n            }\r\n          }, 15000);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Close button handler\r\n    if (closeBtn) {\r\n      closeBtn.addEventListener('click', () => {\r\n        if (!closeBtn.disabled) {\r\n          LogHelper.log('[RFC-0107] Contract modal closed by user');\r\n          if (window._contractModalAutoCloseId) {\r\n            clearTimeout(window._contractModalAutoCloseId);\r\n            window._contractModalAutoCloseId = null;\r\n          }\r\n          if (window.MyIOOrchestrator?.hideGlobalBusy) {\r\n            window.MyIOOrchestrator.hideGlobalBusy();\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * RFC-0107: Updates a domain section in the contract loading modal\r\n   * @param {string} domain - Domain name (energy, water, temperature)\r\n   * @param {Object} counts - Device counts object\r\n   * @param {boolean} isLoaded - Whether domain data is loaded\r\n   * @param {boolean} hasError - Whether there's a validation error\r\n   */\r\n  function updateContractModalDomain(domain, counts, isLoaded = false, hasError = false) {\r\n    const el = document.getElementById(BUSY_OVERLAY_ID);\r\n    if (!el) return;\r\n\r\n    const section = el.querySelector(`.domain-section[data-domain=\"${domain}\"]`);\r\n    if (!section) return;\r\n\r\n    // Update total count\r\n    const totalCount = counts?.total || 0;\r\n    const countEl = section.querySelector('.domain-count');\r\n    if (countEl) {\r\n      countEl.textContent = `${totalCount} dispositivos`;\r\n    }\r\n\r\n    // Update status icon\r\n    const statusEl = section.querySelector('.domain-status');\r\n    if (statusEl && isLoaded) {\r\n      statusEl.textContent = hasError ? '!' : 'âœ“';\r\n    }\r\n\r\n    // Update detail rows based on domain\r\n    if (domain === 'energy' || domain === 'water') {\r\n      const entriesEl = section.querySelector('.detail-entries');\r\n      const commonAreaEl = section.querySelector('.detail-commonArea');\r\n      const storesEl = section.querySelector('.detail-stores');\r\n      if (entriesEl) entriesEl.textContent = counts?.entries || 0;\r\n      if (commonAreaEl) commonAreaEl.textContent = counts?.commonArea || 0;\r\n      if (storesEl) storesEl.textContent = counts?.stores || 0;\r\n    } else if (domain === 'temperature') {\r\n      const internalEl = section.querySelector('.detail-internal');\r\n      const storesEl = section.querySelector('.detail-stores');\r\n      if (internalEl) internalEl.textContent = counts?.internal || 0;\r\n      if (storesEl) storesEl.textContent = counts?.stores || 0;\r\n    }\r\n\r\n    // Add loaded/error class\r\n    section.classList.remove('loaded', 'error');\r\n    if (isLoaded) {\r\n      section.classList.add(hasError ? 'error' : 'loaded');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * RFC-0107: Updates the validation status in the contract loading modal\r\n   * @param {boolean} isValid - Validation result\r\n   * @param {string} message - Status message\r\n   */\r\n  function updateContractModalStatus(isValid, message) {\r\n    const el = document.getElementById(BUSY_OVERLAY_ID);\r\n    if (!el) return;\r\n\r\n    const statusEl = el.querySelector(`#${BUSY_OVERLAY_ID}-status`);\r\n    if (!statusEl) return;\r\n\r\n    statusEl.style.display = 'block';\r\n\r\n    if (isValid) {\r\n      statusEl.style.background = 'rgba(76,175,80,0.2)';\r\n      statusEl.innerHTML = `<span style=\"color:#81c784; font-size:13px;\">âœ“ ${\r\n        message || 'Contrato validado com sucesso'\r\n      }</span>`;\r\n    } else {\r\n      statusEl.style.background = 'rgba(244,67,54,0.2)';\r\n      statusEl.innerHTML = `<span style=\"color:#ef5350; font-size:13px;\">âš  ${\r\n        message || 'Problemas detectados na validaÃ§Ã£o'\r\n      }</span>`;\r\n    }\r\n  }\r\n\r\n  // PHASE 1: Centralized busy management with extended timeout\r\n  function showGlobalBusy(domain = 'unknown', message = 'Carregando dados...', timeoutMs = 25000) {\r\n    // RFC-0054: cooldown - nï¿½o reabrir modal se acabou de prover dados\r\n    const lp = lastProvide.get(domain);\r\n    if (lp && Date.now() - lp.at < 30000) {\r\n      LogHelper.log(`[Orchestrator] ?? Cooldown active for ${domain}, skipping showGlobalBusy()`);\r\n      return;\r\n    }\r\n    const totalBefore = getActiveTotal();\r\n    const prev = activeRequests.get(domain) || 0;\r\n    activeRequests.set(domain, prev + 1);\r\n    LogHelper.log(\r\n      `[Orchestrator] ?? Active requests for ${domain}: ${prev + 1} (totalBefore=${totalBefore})`\r\n    );\r\n\r\n    const el = ensureOrchestratorBusyDOM();\r\n    const messageEl = el.querySelector(`#${BUSY_OVERLAY_ID}-message`);\r\n\r\n    if (messageEl) {\r\n      // Mensagem genï¿½rica para evitar rï¿½tulo incorreto ao alternar abas\r\n      messageEl.textContent = 'Carregando dados...';\r\n    }\r\n\r\n    // Clear existing timeout\r\n    if (globalBusyState.timeoutId) {\r\n      clearTimeout(globalBusyState.timeoutId);\r\n      globalBusyState.timeoutId = null;\r\n    }\r\n\r\n    // Mostrar overlay apenas quando saiu de 0 ? 1\r\n    if (totalBefore === 0) {\r\n      globalBusyState.isVisible = true;\r\n      globalBusyState.currentDomain = domain;\r\n      globalBusyState.startTime = Date.now();\r\n      globalBusyState.requestCount++;\r\n      el.style.display = 'flex';\r\n    }\r\n\r\n    // RFC-0048: Start widget monitoring (will be stopped by hideGlobalBusy)\r\n    // This is defined later in the orchestrator initialization\r\n    if (window.MyIOOrchestrator?.widgetBusyMonitor) {\r\n      window.MyIOOrchestrator.widgetBusyMonitor.startMonitoring(domain);\r\n    }\r\n\r\n    // PHASE 1: Extended timeout (25s instead of 10s)\r\n    globalBusyState.timeoutId = setTimeout(() => {\r\n      LogHelper.warn(`[Orchestrator] ?? BUSY TIMEOUT (25s) for domain ${domain} - implementing recovery`);\r\n\r\n      // Check if still actually busy\r\n      if (globalBusyState.isVisible && el.style.display !== 'none') {\r\n        // PHASE 3: Circuit breaker pattern - try graceful recovery\r\n        try {\r\n          // Emit recovery event\r\n          window.dispatchEvent(\r\n            new CustomEvent('myio:busy-timeout-recovery', {\r\n              detail: { domain, duration: Date.now() - globalBusyState.startTime },\r\n            })\r\n          );\r\n\r\n          // Hide busy and show user-friendly message\r\n          hideGlobalBusy(domain);\r\n\r\n          // Non-intrusive notification\r\n          showRecoveryNotification();\r\n        } catch (err) {\r\n          LogHelper.error(`[Orchestrator] âŒ Error in timeout recovery:`, err);\r\n          hideGlobalBusy(domain);\r\n        }\r\n      }\r\n\r\n      globalBusyState.timeoutId = null;\r\n    }, timeoutMs); // 25 seconds (Phase 1 requirement)\r\n\r\n    if (totalBefore === 0) {\r\n      LogHelper.log(`[Orchestrator] ? Global busy shown (domain=${domain})`);\r\n    } else {\r\n      LogHelper.log(`[Orchestrator] ?? Busy already visible (domain=${domain})`);\r\n    }\r\n  }\r\n\r\n  function hideGlobalBusy(domain = null) {\r\n    // RFC-0054: decremento por domï¿½nio; se domain for nulo, forï¿½a limpeza\r\n    if (domain) {\r\n      const prev = activeRequests.get(domain) || 0;\r\n      const next = Math.max(0, prev - 1);\r\n      activeRequests.set(domain, next);\r\n      LogHelper.log(\r\n        `[Orchestrator] ? hideGlobalBusy(${domain}) -> ${prev}?${next}, total=${getActiveTotal()}`\r\n      );\r\n      if (getActiveTotal() > 0) return; // mantï¿½m overlay enquanto houver ativas\r\n    } else {\r\n      activeRequests.clear();\r\n    }\r\n\r\n    // RFC-0048: Stop widget monitoring for current domain\r\n    if (window.MyIOOrchestrator?.widgetBusyMonitor) {\r\n      window.MyIOOrchestrator.widgetBusyMonitor.stopAll();\r\n    }\r\n\r\n    const el = document.getElementById(BUSY_OVERLAY_ID);\r\n    if (el) {\r\n      el.style.display = 'none';\r\n    }\r\n\r\n    // Clear timeout\r\n    if (globalBusyState.timeoutId) {\r\n      clearTimeout(globalBusyState.timeoutId);\r\n      globalBusyState.timeoutId = null;\r\n    }\r\n\r\n    // Update state\r\n    globalBusyState.isVisible = false;\r\n    globalBusyState.currentDomain = null;\r\n    globalBusyState.startTime = null;\r\n\r\n    LogHelper.log(`[Orchestrator] ? Global busy hidden`);\r\n  }\r\n\r\n  // PHASE 4: Non-intrusive recovery notification\r\n  function showRecoveryNotification() {\r\n    const notification = document.createElement('div');\r\n    notification.style.cssText = `\r\n    position: fixed;\r\n    top: 20px;\r\n    right: 20px;\r\n    background: #f97316;\r\n    color: white;\r\n    padding: 12px 16px;\r\n    border-radius: 8px;\r\n    font-size: 14px;\r\n    font-weight: 500;\r\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\r\n    z-index: 999999;\r\n    font-family: Inter, system-ui, sans-serif;\r\n  `;\r\n    notification.textContent = 'Dados recarregados automaticamente';\r\n    document.body.appendChild(notification);\r\n\r\n    setTimeout(() => {\r\n      if (notification.parentNode) {\r\n        notification.parentNode.removeChild(notification);\r\n      }\r\n    }, 4000);\r\n  }\r\n\r\n  // PHASE 2: Shared state management for widgets coordination\r\n  let sharedWidgetState = {\r\n    activePeriod: null,\r\n    lastProcessedPeriodKey: null,\r\n    busyWidgets: new Set(),\r\n    mutexMap: new Map(), // RFC-0054 FIX: Mutex por domï¿½nio (nï¿½o global)\r\n  };\r\n\r\n  // State\r\n  const inFlight = new Map();\r\n  const abortControllers = new Map();\r\n\r\n  // Config will be initialized in onInit() after widgetSettings are populated\r\n  let config = null;\r\n\r\n  let visibleTab = 'energy';\r\n  let currentPeriod = null;\r\n  let CUSTOMER_ING_ID = '';\r\n  let CLIENT_ID = '';\r\n  let CLIENT_SECRET = '';\r\n\r\n  // Credentials promise resolver for async wait\r\n  let credentialsResolver = null;\r\n  let credentialsPromise = new Promise((resolve) => {\r\n    credentialsResolver = resolve;\r\n  });\r\n\r\n  // Metrics\r\n  const metrics = {\r\n    hydrationTimes: [],\r\n    totalRequests: 0,\r\n    errorCounts: {},\r\n\r\n    recordHydration(domain, duration) {\r\n      this.hydrationTimes.push({ domain, duration, timestamp: Date.now() });\r\n      this.totalRequests++;\r\n\r\n      if (config?.debugMode) {\r\n        LogHelper.log(`[Orchestrator] ${domain} hydration: ${duration}ms`);\r\n      }\r\n    },\r\n\r\n    recordError(domain, error) {\r\n      this.errorCounts[domain] = (this.errorCounts[domain] || 0) + 1;\r\n      LogHelper.error(`[Orchestrator] ${domain} error:`, error);\r\n    },\r\n\r\n    generateTelemetrySummary() {\r\n      const sum = this.hydrationTimes.reduce((acc, h) => acc + h.duration, 0);\r\n      const avg = this.hydrationTimes.length > 0 ? Math.round(sum / this.hydrationTimes.length) : 0;\r\n\r\n      return {\r\n        orchestrator_total_requests: this.totalRequests,\r\n        orchestrator_avg_hydration_ms: avg,\r\n        orchestrator_errors_total: Object.values(this.errorCounts).reduce((a, b) => a + b, 0),\r\n      };\r\n    },\r\n  };\r\n\r\n  // Request management\r\n  function abortAllInflight() {\r\n    for (const [key, ac] of abortControllers.entries()) {\r\n      ac.abort();\r\n    }\r\n    abortControllers.clear();\r\n    inFlight.clear();\r\n  }\r\n\r\n  /**\r\n   * RFC-0106: Convert ThingsBoard connectionStatus to deviceStatus\r\n   * ThingsBoard connectionStatus can be: 'true'/'false', 'ONLINE'/'OFFLINE', true/false, 'CONNECTED'/'DISCONNECTED'\r\n   *\r\n   * Logic follows TELEMETRY buildAuthoritativeItems:\r\n   * - offline â†’ 'no_info' (device disconnected, no consumption data available)\r\n   * - online â†’ 'power_on' (simplified; energy devices may use calculateDeviceStatusWithRanges in TELEMETRY)\r\n   *\r\n   * @param {string|boolean|null} connectionStatus - Raw status from ThingsBoard\r\n   * @returns {string} deviceStatus: 'power_on' or 'no_info'\r\n   */\r\n  function convertConnectionStatusToDeviceStatus(connectionStatus) {\r\n    if (connectionStatus === null || connectionStatus === undefined || connectionStatus === '') {\r\n      return 'no_info';\r\n    }\r\n\r\n    const statusStr = String(connectionStatus).toLowerCase().trim();\r\n\r\n    // Online/connected states â†’ power_on\r\n    // \"waiting\" means device is registered and awaiting data, treat as potentially online\r\n    const ONLINE_VALUES = ['true', 'online', 'connected', '1', 'active', 'yes', 'waiting'];\r\n    if (ONLINE_VALUES.includes(statusStr)) {\r\n      return 'power_on';\r\n    }\r\n\r\n    // Offline/disconnected/unknown states â†’ no_info\r\n    // RFC-0106: Offline devices have no consumption data, so status is 'no_info' (not 'offline')\r\n    // This aligns with TELEMETRY logic: tbConnectionStatus === 'offline' â†’ deviceStatus = 'no_info'\r\n    return 'no_info';\r\n  }\r\n\r\n  /**\r\n   * RFC-0106: Datasource alias whitelist by domain\r\n   * Each domain has a specific datasource that contains device metadata\r\n   */\r\n  const ALLOWED_ALIASES_BY_DOMAIN = {\r\n    energy: 'all3fs', // Energy domain: All3Fs datasource\r\n    water: 'allhidrosdevices', // Water domain: AllHidrosDevices datasource\r\n    temperature: 'alltempdevices', // Temperature domain: AllTempDevices datasource\r\n  };\r\n\r\n  /**\r\n   * RFC-0106: Build metadata map from self.ctx.data\r\n   * Reads ThingsBoard datasource data and groups by entityId\r\n   * Returns map: ingestionId â†’ { deviceType, deviceProfile, identifier, label, ... }\r\n   * @param {string} domain - Domain to filter datasources ('energy' or 'water')\r\n   */\r\n  function buildMetadataMapFromCtxData(domain = 'energy') {\r\n    const metadataByIngestion = new Map();\r\n    const metadataByEntityId = new Map();\r\n\r\n    const rows = Array.isArray(self?.ctx?.data) ? self.ctx.data : [];\r\n\r\n    // DEBUG: Log datasources configured in widget\r\n    const datasources = Array.isArray(self?.ctx?.datasources) ? self.ctx.datasources : [];\r\n    LogHelper.log(`[Orchestrator] ðŸ“‹ Widget datasources configured: ${datasources.length}`);\r\n    if (datasources.length > 0) {\r\n      const dsInfo = datasources.map((ds) => ({\r\n        aliasName: ds.aliasName || ds.name || 'unknown',\r\n        entityCount: ds.dataKeys?.length || 0,\r\n        type: ds.type || 'unknown',\r\n      }));\r\n      LogHelper.log(`[Orchestrator] ðŸ“‹ Datasource details:`, JSON.stringify(dsInfo));\r\n    }\r\n\r\n    if (rows.length === 0) {\r\n      LogHelper.warn(\r\n        `[Orchestrator] âš ï¸ self.ctx.data is empty - no metadata available (${datasources.length} datasources configured)`\r\n      );\r\n      return { byIngestion: metadataByIngestion, byEntityId: metadataByEntityId };\r\n    }\r\n\r\n    // RFC-0106: Use whitelist approach - only include the specific datasource for this domain\r\n    const allowedAlias = ALLOWED_ALIASES_BY_DOMAIN[domain] || ALLOWED_ALIASES_BY_DOMAIN.energy;\r\n    LogHelper.log(`[Orchestrator] ðŸ“‹ Using whitelist for domain '${domain}': only alias '${allowedAlias}'`);\r\n\r\n    // DEBUG: Log all unique aliasNames found in ctx.data\r\n    const allAliases = new Set();\r\n    for (const row of rows) {\r\n      const alias = row?.datasource?.aliasName || row?.datasource?.name || 'unknown';\r\n      allAliases.add(alias);\r\n    }\r\n    LogHelper.log(`[Orchestrator] ðŸ“‹ Datasource aliases found: ${Array.from(allAliases).join(', ')}`);\r\n\r\n    // DEBUG: Log sample items from the allowed alias datasource\r\n    const aliasRows = rows.filter((r) => {\r\n      const alias = (r?.datasource?.aliasName || r?.datasource?.name || '').toLowerCase();\r\n      return alias === allowedAlias;\r\n    });\r\n    if (aliasRows.length > 0) {\r\n      // Get unique entityIds from this alias\r\n      const entityIds = [\r\n        ...new Set(aliasRows.map((r) => r?.datasource?.entityId?.id || r?.datasource?.entityId)),\r\n      ].filter(Boolean);\r\n      LogHelper.log(\r\n        `[Orchestrator] ðŸ” DEBUG: Found ${entityIds.length} unique entities in '${allowedAlias}' datasource`\r\n      );\r\n\r\n      // Sample: first + 2 random\r\n      const sampleIds = [entityIds[0]];\r\n      if (entityIds.length > 1) sampleIds.push(entityIds[Math.floor(entityIds.length / 3)]);\r\n      if (entityIds.length > 2) sampleIds.push(entityIds[Math.floor((entityIds.length * 2) / 3)]);\r\n\r\n      for (const sampleId of sampleIds) {\r\n        const sampleRows = aliasRows.filter(\r\n          (r) => (r?.datasource?.entityId?.id || r?.datasource?.entityId) === sampleId\r\n        );\r\n        const sampleData = {};\r\n        for (const sr of sampleRows) {\r\n          const key = sr?.dataKey?.name || 'unknown';\r\n          sampleData[key] = sr?.data?.[0]?.[1] ?? null;\r\n        }\r\n        sampleData._entityId = sampleId;\r\n        sampleData._entityName = sampleRows[0]?.datasource?.entityName || 'N/A';\r\n        LogHelper.log(\r\n          `[Orchestrator] ðŸ” DEBUG Sample from '${allowedAlias}':`,\r\n          JSON.stringify(sampleData, null, 2)\r\n        );\r\n      }\r\n    }\r\n\r\n    // Group by entityId first - only process rows from allowed alias\r\n    for (const row of rows) {\r\n      // Check aliasName - only include allowed datasource (whitelist approach)\r\n      const aliasName = (row?.datasource?.aliasName || row?.datasource?.name || '').toLowerCase();\r\n      if (aliasName !== allowedAlias) {\r\n        continue;\r\n      }\r\n\r\n      const entityId = row?.datasource?.entityId?.id || row?.datasource?.entityId || null;\r\n      const keyName = String(row?.dataKey?.name || '').toLowerCase();\r\n      const val = row?.data?.[0]?.[1] ?? null;\r\n\r\n      if (!entityId) continue;\r\n\r\n      // Get or create metadata entry\r\n      if (!metadataByEntityId.has(entityId)) {\r\n        metadataByEntityId.set(entityId, {\r\n          tbId: entityId,\r\n          entityName: row?.datasource?.entityName || row?.datasource?.name || '',\r\n          label: row?.datasource?.entityLabel || row?.datasource?.entityName || '',\r\n        });\r\n      }\r\n\r\n      const meta = metadataByEntityId.get(entityId);\r\n\r\n      // Map dataKey values - common fields\r\n      if (keyName === 'devicetype') meta.deviceType = val;\r\n      else if (keyName === 'deviceprofile') meta.deviceProfile = val;\r\n      else if (keyName === 'identifier') meta.identifier = val;\r\n      else if (keyName === 'ingestionid') meta.ingestionId = val;\r\n      else if (keyName === 'slaveid') meta.slaveId = val;\r\n      else if (keyName === 'centralid') meta.centralId = val;\r\n      else if (keyName === 'centralname') meta.centralName = val;\r\n      else if (keyName === 'connectionstatus') meta.connectionStatus = val;\r\n      else if (keyName === 'lastactivitytime') meta.lastActivityTime = val;\r\n      else if (keyName === 'lastconnecttime') meta.lastConnectTime = val;\r\n      else if (keyName === 'lastdisconnecttime') meta.lastDisconnectTime = val;\r\n      else if (keyName === 'log_annotations') meta.log_annotations = val;\r\n      // Only override label if dataKey has a non-empty value\r\n      // Otherwise keep the entityLabel/entityName fallback from initialization\r\n      else if (keyName === 'label' && val && String(val).trim() !== '') meta.label = val;\r\n      // Energy-specific fields\r\n      else if (keyName === 'devicemapinstaneouspower') meta.deviceMapInstaneousPower = val;\r\n      else if (keyName === 'consumption') meta.consumption = val; // instantaneous power in Watts\r\n      // Water-specific fields\r\n      else if (keyName === 'pulses') meta.pulses = val;\r\n      else if (keyName === 'litersperpulse') meta.litersPerPulse = val;\r\n      else if (keyName === 'volume') meta.volume = val;\r\n      // Tank-specific fields (TANK/CAIXA_DAGUA)\r\n      else if (keyName === 'water_level') meta.waterLevel = val;\r\n      else if (keyName === 'water_percentage') meta.waterPercentage = val;\r\n      // Temperature-specific fields\r\n      else if (keyName === 'temperature') meta.temperature = val;\r\n    }\r\n\r\n    // Build map by ingestionId\r\n    for (const [entityId, meta] of metadataByEntityId.entries()) {\r\n      const ingestionId = meta.ingestionId;\r\n      if (ingestionId) {\r\n        metadataByIngestion.set(ingestionId, meta);\r\n      }\r\n    }\r\n\r\n    LogHelper.log(\r\n      `[Orchestrator] ðŸ“‹ Built metadata map: ${metadataByEntityId.size} entities, ${metadataByIngestion.size} with ingestionId`\r\n    );\r\n\r\n    // RFC-0108 DEBUG: Log ALL ingestionIds for water domain to diagnose matching issues\r\n    if (domain === 'water' && metadataByEntityId.size > 0) {\r\n      const allIngestionIds = [];\r\n      for (const [entityId, meta] of metadataByEntityId.entries()) {\r\n        allIngestionIds.push({\r\n          label: meta.label || meta.entityName || entityId.substring(0, 8),\r\n          ingestionId: meta.ingestionId || 'MISSING',\r\n          tbId: entityId.substring(0, 8),\r\n        });\r\n      }\r\n      // Log devices with VACINA in name or entityName\r\n      const vacinaDevices = [];\r\n      for (const [entityId, meta] of metadataByEntityId.entries()) {\r\n        const labelUpper = (meta.label || '').toUpperCase();\r\n        const entityNameUpper = (meta.entityName || '').toUpperCase();\r\n        if (labelUpper.includes('VACINA') || labelUpper.includes('VACINAÃ‡ÃƒO') ||\r\n            entityNameUpper.includes('VACINA') || entityNameUpper.includes('VACINAÃ‡ÃƒO')) {\r\n          vacinaDevices.push({\r\n            label: meta.label,\r\n            entityName: meta.entityName,\r\n            ingestionId: meta.ingestionId || 'MISSING',\r\n            deviceType: meta.deviceType || 'MISSING',\r\n            deviceProfile: meta.deviceProfile || 'MISSING',\r\n            tbId: entityId,\r\n          });\r\n        }\r\n      }\r\n      if (vacinaDevices.length > 0) {\r\n        LogHelper.log(`[RFC-0108 DEBUG] VACINA devices in metadata:`, JSON.stringify(vacinaDevices, null, 2));\r\n      }\r\n      // Log first 10 ingestionIds for reference\r\n      LogHelper.log(`[RFC-0108 DEBUG] First 10 ingestionIds:`, allIngestionIds.slice(0, 10));\r\n    }\r\n\r\n    // DEBUG RFC-0107: Log deviceTypes of all entities in metadataByEntityId\r\n    if (metadataByEntityId.size > 0) {\r\n      const deviceTypes = [];\r\n      for (const [entityId, meta] of metadataByEntityId.entries()) {\r\n        deviceTypes.push(`${meta.label || entityId.substring(0, 8)}:${meta.deviceType || 'N/A'}`);\r\n      }\r\n      LogHelper.log(`[Orchestrator] ðŸ“‹ RFC-0107 Device types in metadata: ${deviceTypes.join(', ')}`);\r\n    }\r\n\r\n    // DEBUG: Log all dataKeys found in ctx.data\r\n    const allDataKeys = new Set();\r\n    for (const row of rows) {\r\n      const keyName = row?.dataKey?.name;\r\n      if (keyName) allDataKeys.add(keyName);\r\n    }\r\n    LogHelper.log(`[Orchestrator] ðŸ“‹ DataKeys found in ctx.data:`, Array.from(allDataKeys).join(', '));\r\n\r\n    // DEBUG: Log sample metadata with ALL fields\r\n    if (metadataByIngestion.size > 0) {\r\n      const firstEntry = metadataByIngestion.values().next().value;\r\n      LogHelper.log(`[Orchestrator] ðŸ” Sample metadata (ALL fields):`, JSON.stringify(firstEntry, null, 2));\r\n    }\r\n\r\n    return { byIngestion: metadataByIngestion, byEntityId: metadataByEntityId };\r\n  }\r\n\r\n  /**\r\n   * RFC-0106: Wait for ctx.data to be populated with datasources\r\n   * This prevents the timing issue where API is called before ThingsBoard loads datasources\r\n   */\r\n  async function waitForCtxData(maxWaitMs = 20000, checkIntervalMs = 200, domain = null) {\r\n    const startTime = Date.now();\r\n\r\n    while (Date.now() - startTime < maxWaitMs) {\r\n      const datasources = Array.isArray(self?.ctx?.datasources) ? self.ctx.datasources : [];\r\n      const rows = Array.isArray(self?.ctx?.data) ? self.ctx.data : [];\r\n\r\n      // Check if we have datasources configured AND data rows\r\n      if (datasources.length > 0 && rows.length > 0) {\r\n        LogHelper.log(\r\n          `[Orchestrator] âœ… ctx.data ready: ${datasources.length} datasources, ${rows.length} rows`\r\n        );\r\n        return true;\r\n      }\r\n\r\n      // RFC-0106 FIX: Check if another call already fetched data for this domain\r\n      // This prevents duplicate waiting when data is already available\r\n      if (domain) {\r\n        const cachedData = window.MyIOOrchestratorData?.[domain];\r\n        if (cachedData && cachedData.items && cachedData.items.length > 0) {\r\n          const cacheAge = Date.now() - (cachedData.timestamp || 0);\r\n          if (cacheAge < 30000) {\r\n            LogHelper.log(\r\n              `[Orchestrator] âœ… Data already available in cache for ${domain} (${cachedData.items.length} items, age: ${cacheAge}ms) - exiting wait`\r\n            );\r\n            return 'cached'; // Special return to indicate cached data is available\r\n          }\r\n        }\r\n      }\r\n\r\n      // Log progress every second\r\n      const elapsed = Date.now() - startTime;\r\n      if (elapsed % 1000 < checkIntervalMs) {\r\n        LogHelper.log(\r\n          `[Orchestrator] â³ Waiting for ctx.data... ${Math.round(elapsed / 1000)}s (${\r\n            datasources.length\r\n          } datasources, ${rows.length} rows)`\r\n        );\r\n      }\r\n\r\n      // Wait before next check\r\n      await new Promise((resolve) => setTimeout(resolve, checkIntervalMs));\r\n    }\r\n\r\n    // Timeout - check one more time if cache is available before failing\r\n    if (domain) {\r\n      const cachedData = window.MyIOOrchestratorData?.[domain];\r\n      if (cachedData && cachedData.items && cachedData.items.length > 0) {\r\n        LogHelper.log(\r\n          `[Orchestrator] âœ… Timeout but cache available for ${domain} (${cachedData.items.length} items)`\r\n        );\r\n        return 'cached';\r\n      }\r\n    }\r\n\r\n    // Timeout - proceed anyway but log warning\r\n    const datasources = Array.isArray(self?.ctx?.datasources) ? self.ctx.datasources : [];\r\n    const rows = Array.isArray(self?.ctx?.data) ? self.ctx.data : [];\r\n    LogHelper.warn(\r\n      `[Orchestrator] âš ï¸ ctx.data wait timeout after ${maxWaitMs}ms: ${datasources.length} datasources, ${rows.length} rows`\r\n    );\r\n    return false;\r\n  }\r\n\r\n  // RFC-0106: Track if we need to re-fetch when ctx.data becomes available\r\n  let ctxDataWasEmpty = false;\r\n  let lastFetchDomain = null;\r\n  let lastFetchPeriod = null;\r\n\r\n  /**\r\n   * RFC-0106: Check if ctx.data has new data and trigger re-fetch if needed\r\n   */\r\n  function checkAndRefetchIfNeeded() {\r\n    if (!ctxDataWasEmpty || !lastFetchDomain || !lastFetchPeriod) return;\r\n\r\n    const rows = Array.isArray(self?.ctx?.data) ? self.ctx.data : [];\r\n    if (rows.length > 0) {\r\n      LogHelper.log(\r\n        `[Orchestrator] ðŸ”„ ctx.data now available (${rows.length} rows) - triggering re-fetch for ${lastFetchDomain}`\r\n      );\r\n      ctxDataWasEmpty = false;\r\n\r\n      // Clear cache and re-fetch\r\n      inFlight.clear();\r\n      hydrateDomain(lastFetchDomain, lastFetchPeriod);\r\n    }\r\n  }\r\n\r\n  // Check periodically if ctx.data becomes available\r\n  setInterval(checkAndRefetchIfNeeded, 2000);\r\n\r\n  async function fetchAndEnrich(domain, period) {\r\n    try {\r\n      LogHelper.log(`[Orchestrator] ðŸ” fetchAndEnrich called for ${domain}`);\r\n\r\n      // RFC-0106 FIX: Check if fresh data is already available in MyIOOrchestratorData\r\n      // This prevents duplicate hydrateDomain calls (with different keys) from waiting for ctx.data\r\n      // when data was already successfully fetched by another call\r\n      const cachedData = window.MyIOOrchestratorData?.[domain];\r\n      if (cachedData && cachedData.items && cachedData.items.length > 0) {\r\n        const cacheAge = Date.now() - (cachedData.timestamp || 0);\r\n        // Use cache if less than 30 seconds old\r\n        if (cacheAge < 30000) {\r\n          LogHelper.log(\r\n            `[Orchestrator] âœ… Using cached data for ${domain}: ${cachedData.items.length} items (age: ${cacheAge}ms)`\r\n          );\r\n\r\n          // RFC-0108 DEBUG: Analyze cached data for ingestionId issues (water domain)\r\n          if (domain === 'water') {\r\n            const items = cachedData.items;\r\n            const withIngestionId = items.filter(i => i.ingestionId).length;\r\n            const withApiData = items.filter(i => i._hasApiData).length;\r\n            const withZeroValue = items.filter(i => i.value === 0 || i.value === null || i.value === undefined).length;\r\n            const entradaDevices = items.filter(i => i.labelWidget === 'Entrada');\r\n\r\n            LogHelper.log(`[RFC-0108 CACHE DEBUG] Water cache analysis:`, {\r\n              total: items.length,\r\n              withIngestionId,\r\n              withoutIngestionId: items.length - withIngestionId,\r\n              withApiData,\r\n              withZeroValue,\r\n              entradaCount: entradaDevices.length,\r\n            });\r\n\r\n            // Log devices with labelWidget='Entrada' to diagnose VACINACAO issue\r\n            if (entradaDevices.length > 0) {\r\n              LogHelper.log(`[RFC-0108 CACHE DEBUG] Entrada devices:`, entradaDevices.map(d => ({\r\n                label: d.label,\r\n                value: d.value,\r\n                ingestionId: d.ingestionId || 'MISSING',\r\n                hasApiData: d._hasApiData,\r\n                tbId: d.tbId?.substring(0, 8),\r\n              })));\r\n            }\r\n\r\n            // Log devices with value=0 but might have API data\r\n            const suspiciousDevices = items.filter(i => i.value === 0 && !i._hasApiData);\r\n            if (suspiciousDevices.length > 0) {\r\n              LogHelper.log(`[RFC-0108 CACHE DEBUG] Devices with value=0 and no API match (first 5):`,\r\n                suspiciousDevices.slice(0, 5).map(d => ({\r\n                  label: d.label,\r\n                  ingestionId: d.ingestionId || 'MISSING',\r\n                  deviceType: d.deviceType,\r\n                  labelWidget: d.labelWidget,\r\n                })));\r\n            }\r\n          }\r\n\r\n          return cachedData.items;\r\n        }\r\n      }\r\n\r\n      // Temperature domain: uses ctx.data directly (no API call) - realtime data from ThingsBoard\r\n      if (domain === 'temperature') {\r\n        LogHelper.log(`[Orchestrator] ðŸŒ¡ï¸ Temperature domain - using ctx.data directly (no API)`);\r\n\r\n        // Wait for ctx.data to be populated (pass domain to check cache during wait)\r\n        const ctxDataReady = await waitForCtxData(20000, 200, domain);\r\n\r\n        // If cached data is available, return it directly\r\n        if (ctxDataReady === 'cached') {\r\n          const cachedData = window.MyIOOrchestratorData?.[domain];\r\n          LogHelper.log(\r\n            `[Orchestrator] âœ… Using cached temperature data: ${cachedData?.items?.length || 0} items`\r\n          );\r\n          return cachedData?.items || [];\r\n        }\r\n\r\n        if (!ctxDataReady) {\r\n          LogHelper.warn(`[Orchestrator] âš ï¸ ctx.data not ready for temperature`);\r\n          window.MyIOUtils?.handleDataLoadError(domain, 'ctx.data timeout - datasources not loaded');\r\n          return [];\r\n        }\r\n\r\n        // Build metadata map from AllTempDevices datasource\r\n        const { byIngestion: metadataMap, byEntityId: metadataByEntityId } =\r\n          buildMetadataMapFromCtxData(domain);\r\n\r\n        if (metadataByEntityId.size === 0) {\r\n          LogHelper.warn(`[Orchestrator] âš ï¸ No temperature devices found in ctx.data`);\r\n          return [];\r\n        }\r\n\r\n        LogHelper.log(`[Orchestrator] ðŸŒ¡ï¸ Found ${metadataByEntityId.size} temperature devices`);\r\n\r\n        // Build items directly from metadata (value = temperature reading)\r\n        const items = [];\r\n        for (const [entityId, meta] of metadataByEntityId.entries()) {\r\n          const temperatureValue = Number(meta.temperature || 0);\r\n          const deviceStatus = convertConnectionStatusToDeviceStatus(meta.connectionStatus);\r\n\r\n          items.push({\r\n            id: entityId,\r\n            tbId: entityId,\r\n            ingestionId: meta.ingestionId || null,\r\n            identifier: meta.identifier || '',\r\n            label: meta.label || meta.identifier || 'Sensor',\r\n            entityLabel: meta.label || meta.identifier || 'Sensor',\r\n            name: meta.label || meta.identifier || 'Sensor',\r\n            value: temperatureValue,\r\n            temperature: temperatureValue,\r\n            deviceType: meta.deviceType || 'TERMOSTATO',\r\n            deviceProfile: meta.deviceProfile || '',\r\n            deviceStatus: deviceStatus,\r\n            connectionStatus: meta.connectionStatus || 'unknown',\r\n            centralId: meta.centralId || null,\r\n            centralName: meta.centralName || '',\r\n            slaveId: meta.slaveId || null,\r\n            lastActivityTime: meta.lastActivityTime || null,\r\n            lastConnectTime: meta.lastConnectTime || null,\r\n            lastDisconnectTime: meta.lastDisconnectTime || null,\r\n            log_annotations: meta.log_annotations || null,\r\n          });\r\n        }\r\n\r\n        // Populate window.STATE.temperature\r\n        populateStateTemperature(items);\r\n\r\n        LogHelper.log(`[Orchestrator] ðŸŒ¡ï¸ Temperature items built: ${items.length}`);\r\n        return items;\r\n      }\r\n\r\n      // RFC-0106: MUST wait for ctx.data to be populated BEFORE calling API\r\n      // The flow is: ctx.data (metadata) â†’ API (consumption) â†’ match by ingestionId\r\n      // Track domain/period for potential re-fetch if ctx.data loads later\r\n      lastFetchDomain = domain;\r\n      lastFetchPeriod = period;\r\n\r\n      const ctxDataReady = await waitForCtxData(20000, 200, domain);\r\n\r\n      // If cached data is available, return it directly (another call already fetched)\r\n      if (ctxDataReady === 'cached') {\r\n        const cachedData = window.MyIOOrchestratorData?.[domain];\r\n        LogHelper.log(\r\n          `[Orchestrator] âœ… Using cached ${domain} data: ${cachedData?.items?.length || 0} items`\r\n        );\r\n        return cachedData?.items || [];\r\n      }\r\n\r\n      if (!ctxDataReady) {\r\n        // Mark that ctx.data was empty - will trigger re-fetch when data arrives\r\n        ctxDataWasEmpty = true;\r\n        LogHelper.warn(\r\n          `[Orchestrator] âš ï¸ ctx.data not ready - skipping API call, will auto-refetch when available`\r\n        );\r\n\r\n        // RFC-0106: Show toast and reload page when ctx.data fails to load\r\n        window.MyIOUtils?.handleDataLoadError(domain, 'ctx.data timeout - datasources not loaded');\r\n\r\n        return []; // DO NOT call API without metadata\r\n      }\r\n\r\n      // RFC-0106: Build metadata map FIRST from ctx.data (filtered by domain's datasource)\r\n      const { byIngestion: metadataMap, byEntityId: metadataByEntityId } =\r\n        buildMetadataMapFromCtxData(domain);\r\n\r\n      // RFC-0107: For water domain, check for tank and hidrometro devices from ctx.data\r\n      // TANK/CAIXA_DAGUA get data directly from ThingsBoard (water_level, water_percentage)\r\n      // HIDROMETRO devices also need to be included from ctx.data (they have pulses)\r\n      let tankItems = [];\r\n      let hidrometroItems = [];\r\n      if (domain === 'water' && metadataByEntityId.size > 0) {\r\n        // DEBUG: Log all water device types\r\n        const waterDeviceTypes = [];\r\n        for (const [, meta] of metadataByEntityId.entries()) {\r\n          waterDeviceTypes.push(meta.deviceType || 'N/A');\r\n        }\r\n        LogHelper.log(`[Orchestrator] ðŸ” DEBUG Water device types: ${waterDeviceTypes.join(', ')}`);\r\n\r\n        for (const [entityId, meta] of metadataByEntityId.entries()) {\r\n          const deviceType = String(meta.deviceType || '').toUpperCase();\r\n          const deviceProfile = String(meta.deviceProfile || '').toUpperCase();\r\n          // RFC-0107: Detect tank devices by:\r\n          // 1. deviceType = TANK or CAIXA_DAGUA\r\n          // 2. OR has water_level/water_percentage data (even without deviceType)\r\n          // BUT EXCLUDE hidrometers (devices with pulses data or HIDROMETRO deviceType)\r\n          const hasWaterLevelData = meta.waterLevel !== undefined || meta.waterPercentage !== undefined;\r\n          const isTankByType = deviceType === 'TANK' || deviceType === 'CAIXA_DAGUA';\r\n          // Check for hidrometers: deviceType contains HIDROMETRO\r\n          const isHidrometer = deviceType.includes('HIDROMETRO');\r\n          const deviceStatus = convertConnectionStatusToDeviceStatus(meta.connectionStatus);\r\n\r\n          // RFC-0107: Build HIDROMETRO items from ctx.data\r\n          // Categorization based on deviceType AND deviceProfile:\r\n          // - HIDROMETRO_SHOPPING â†’ Entrada (main water meter)\r\n          // - HIDROMETRO_AREA_COMUM â†’ Ãrea Comum (common area meters)\r\n          // - HIDROMETRO with profile = HIDROMETRO or empty â†’ Lojas (store meters)\r\n          if (isHidrometer) {\r\n            const pulses = Number(meta.pulses || 0);\r\n            const dp = (deviceProfile || '').toUpperCase();\r\n            const dt = deviceType.toUpperCase();\r\n\r\n            // Determine labelWidget based on deviceType and deviceProfile\r\n            let labelWidget = 'Lojas'; // Default: store meters\r\n            let isEntradaDevice = false;\r\n\r\n            if (dt === 'HIDROMETRO_SHOPPING' || dp === 'HIDROMETRO_SHOPPING') {\r\n              labelWidget = 'Entrada';\r\n              isEntradaDevice = true;\r\n            } else if (dt === 'HIDROMETRO_AREA_COMUM' || dp === 'HIDROMETRO_AREA_COMUM') {\r\n              labelWidget = 'Ãrea Comum';\r\n            }\r\n            // else: HIDROMETRO with profile = HIDROMETRO or empty â†’ Lojas\r\n\r\n            hidrometroItems.push({\r\n              id: entityId,\r\n              tbId: entityId,\r\n              ingestionId: meta.ingestionId || null,\r\n              identifier: meta.identifier || '',\r\n              label: meta.label || meta.identifier || 'HidrÃ´metro',\r\n              entityLabel: meta.label || meta.identifier || 'HidrÃ´metro',\r\n              name: meta.label || meta.identifier || 'HidrÃ´metro',\r\n              value: 0, // RFC-0108 FIX: Use 0 as placeholder - real value comes from API enrichment via ingestionId\r\n              pulses: pulses, // Keep pulses for reference only, not for display\r\n              deviceType: deviceType,\r\n              deviceProfile: deviceProfile || deviceType,\r\n              effectiveDeviceType: deviceProfile || deviceType,\r\n              deviceStatus: deviceStatus,\r\n              connectionStatus: meta.connectionStatus || 'unknown',\r\n              centralId: meta.centralId || null,\r\n              centralName: meta.centralName || '',\r\n              slaveId: meta.slaveId || null,\r\n              lastActivityTime: meta.lastActivityTime || null,\r\n              lastConnectTime: meta.lastConnectTime || null,\r\n              lastDisconnectTime: meta.lastDisconnectTime || null,\r\n              log_annotations: meta.log_annotations || null,\r\n              labelWidget: labelWidget,\r\n              groupLabel: labelWidget,\r\n              _hasMetadata: true,\r\n              _isHidrometerDevice: isEntradaDevice, // Only true for ENTRADA devices\r\n            });\r\n            continue;\r\n          }\r\n\r\n          if (isTankByType || hasWaterLevelData) {\r\n            const waterLevel = Number(meta.waterLevel || 0);\r\n            const waterPercentage = Number(meta.waterPercentage || 0);\r\n\r\n            tankItems.push({\r\n              id: entityId,\r\n              tbId: entityId,\r\n              ingestionId: meta.ingestionId || null,\r\n              identifier: meta.identifier || '',\r\n              label: meta.label || meta.identifier || \"Caixa d'Ã¡gua\",\r\n              entityLabel: meta.label || meta.identifier || \"Caixa d'Ã¡gua\",\r\n              name: meta.label || meta.identifier || \"Caixa d'Ã¡gua\",\r\n              value: waterLevel, // water_level in liters\r\n              waterLevel: waterLevel,\r\n              waterPercentage: waterPercentage, // 0-1 range\r\n              // Default to TANK if detected by water data but no deviceType\r\n              deviceType: deviceType || 'TANK',\r\n              deviceProfile: meta.deviceProfile || deviceType || 'TANK',\r\n              effectiveDeviceType: meta.deviceProfile || deviceType || 'TANK',\r\n              deviceStatus: deviceStatus,\r\n              connectionStatus: meta.connectionStatus || 'unknown',\r\n              centralId: meta.centralId || null,\r\n              centralName: meta.centralName || '',\r\n              slaveId: meta.slaveId || null,\r\n              lastActivityTime: meta.lastActivityTime || null,\r\n              lastConnectTime: meta.lastConnectTime || null,\r\n              lastDisconnectTime: meta.lastDisconnectTime || null,\r\n              log_annotations: meta.log_annotations || null,\r\n              labelWidget: \"Caixa D'Ãgua\", // Tanks go to Caixa D'Ãgua widget\r\n              groupLabel: \"Caixa D'Ãgua\",\r\n              _hasMetadata: true,\r\n              _isTankDevice: true,\r\n            });\r\n          }\r\n        }\r\n\r\n        if (tankItems.length > 0) {\r\n          LogHelper.log(\r\n            `[Orchestrator] ðŸš° Found ${tankItems.length} tank devices (TANK/CAIXA_DAGUA) in water domain`\r\n          );\r\n        }\r\n        if (hidrometroItems.length > 0) {\r\n          LogHelper.log(\r\n            `[Orchestrator] ðŸš¿ Found ${hidrometroItems.length} hidrometro devices in water domain`\r\n          );\r\n        }\r\n      }\r\n\r\n      // RFC-0107: Combine water devices from ctx.data (tanks + hidrometros)\r\n      const waterDevicesFromCtx = [...tankItems, ...hidrometroItems];\r\n\r\n      if (metadataMap.size === 0 && waterDevicesFromCtx.length === 0) {\r\n        LogHelper.warn(`[Orchestrator] âš ï¸ Metadata map is empty - no devices found in ctx.data`);\r\n        ctxDataWasEmpty = true;\r\n\r\n        // RFC-0106: Show toast and reload page when metadata map is empty\r\n        window.MyIOUtils?.handleDataLoadError(domain, 'no devices found in datasource');\r\n\r\n        return []; // No metadata = no point calling API\r\n      }\r\n\r\n      // If we only have water devices from ctx.data and no devices with ingestionId, return them directly\r\n      if (metadataMap.size === 0 && waterDevicesFromCtx.length > 0) {\r\n        LogHelper.log(\r\n          `[Orchestrator] ðŸš° Only water devices from ctx.data found - skipping API call, returning ${waterDevicesFromCtx.length} items (${tankItems.length} tanks, ${hidrometroItems.length} hidrometros)`\r\n        );\r\n        const waterPeriodKey = `water:${domain}:${period.startISO}:${period.endISO}:${period.granularity}`;\r\n        populateState(domain, waterDevicesFromCtx, waterPeriodKey);\r\n        return waterDevicesFromCtx;\r\n      }\r\n\r\n      LogHelper.log(`[Orchestrator] âœ… Metadata map built: ${metadataMap.size} devices with ingestionId`);\r\n\r\n      // Wait for credentials promise and refresh from global state\r\n      // Don't trust local scope variables - they may be stale\r\n      LogHelper.log(`[Orchestrator] Credentials check: flag=${window.MyIOOrchestrator?.credentialsSet}`);\r\n\r\n      // If credentials flag is not set, wait for them with timeout\r\n      if (!window.MyIOOrchestrator?.credentialsSet) {\r\n        const timeoutPromise = new Promise((_, reject) =>\r\n          setTimeout(() => reject(new Error('Credentials timeout after 10s')), 10000)\r\n        );\r\n\r\n        try {\r\n          LogHelper.log(`[Orchestrator] â³ Waiting for credentials to be set...`);\r\n          await Promise.race([credentialsPromise, timeoutPromise]);\r\n          LogHelper.log(`[Orchestrator] âœ… Credentials promise resolved`);\r\n        } catch (err) {\r\n          LogHelper.error(`[Orchestrator] âš ï¸ Credentials timeout - ${err.message}`);\r\n          throw new Error('Credentials not available - initialization timeout');\r\n        }\r\n      } else {\r\n        LogHelper.log(`[Orchestrator] âœ… Credentials flag already set`);\r\n      }\r\n\r\n      // RFC-0082 FIX: Always refresh credentials from global state after waiting\r\n      // This ensures we have the latest values, not stale closure variables\r\n      const latestCreds = window.MyIOOrchestrator?.getCredentials?.();\r\n\r\n      if (!latestCreds || !latestCreds.CLIENT_ID || !latestCreds.CLIENT_SECRET) {\r\n        LogHelper.error(`[Orchestrator] âŒ Credentials validation failed after wait:`, {\r\n          hasGetCredentials: !!window.MyIOOrchestrator?.getCredentials,\r\n          credentialsReturned: !!latestCreds,\r\n          CLIENT_ID: latestCreds?.CLIENT_ID || 'MISSING',\r\n          CLIENT_SECRET_exists: !!latestCreds?.CLIENT_SECRET,\r\n          CUSTOMER_ING_ID: latestCreds?.CUSTOMER_ING_ID || 'MISSING',\r\n        });\r\n        throw new Error('Missing CLIENT_ID or CLIENT_SECRET - credentials not properly set');\r\n      }\r\n\r\n      const clientId = latestCreds.CLIENT_ID;\r\n      const clientSecret = latestCreds.CLIENT_SECRET;\r\n\r\n      LogHelper.log(`[Orchestrator] ðŸ” Using credentials:`, {\r\n        CLIENT_ID: clientId?.substring(0, 10) + '...',\r\n        CLIENT_SECRET_length: clientSecret?.length || 0,\r\n        CUSTOMER_ING_ID: latestCreds.CUSTOMER_ING_ID,\r\n      });\r\n\r\n      // Create fresh MyIOAuth instance every time (like TELEMETRY widget)\r\n      const MyIO =\r\n        (typeof MyIOLibrary !== 'undefined' && MyIOLibrary) ||\r\n        (typeof window !== 'undefined' && window.MyIOLibrary) ||\r\n        null;\r\n\r\n      if (!MyIO) {\r\n        throw new Error('MyIOLibrary not available');\r\n      }\r\n\r\n      const myIOAuth = MyIO.buildMyioIngestionAuth({\r\n        dataApiHost: DATA_API_HOST,\r\n        clientId: clientId,\r\n        clientSecret: clientSecret,\r\n      });\r\n\r\n      // Get fresh token\r\n      const token = await myIOAuth.getToken();\r\n      if (!token) {\r\n        throw new Error('Failed to get ingestion token');\r\n      }\r\n\r\n      // Validate customer ID exists\r\n      if (!latestCreds.CUSTOMER_ING_ID) {\r\n        throw new Error('Missing CUSTOMER_ING_ID - customer not configured');\r\n      }\r\n\r\n      const customerId = latestCreds.CUSTOMER_ING_ID;\r\n\r\n      // Build API URL based on domain\r\n      const url = new URL(\r\n        `${DATA_API_HOST}/api/v1/telemetry/customers/${customerId}/${domain}/devices/totals`\r\n      );\r\n      url.searchParams.set('startTime', period.startISO);\r\n      url.searchParams.set('endTime', period.endISO);\r\n      url.searchParams.set('deep', '1');\r\n\r\n      LogHelper.log(`[Orchestrator] Fetching from: ${url.toString()}`);\r\n\r\n      const res = await fetch(url.toString(), {\r\n        headers: { Authorization: `Bearer ${token}` },\r\n      });\r\n\r\n      if (!res.ok) {\r\n        if (res.status === 401 || res.status === 403) {\r\n          emitTokenExpired();\r\n        }\r\n        throw new Error(`API error: ${res.status}`);\r\n      }\r\n\r\n      const json = await res.json();\r\n\r\n      // RFC-0108 DEBUG: Log raw JSON structure for water\r\n      if (domain === 'water') {\r\n        LogHelper.log(`[RFC-0108 DEBUG] Water API JSON structure:`, {\r\n          isArray: Array.isArray(json),\r\n          hasData: !!json?.data,\r\n          hasSummary: !!json?.summary,\r\n          topLevelKeys: Object.keys(json || {}),\r\n          summaryTotal: json?.summary?.totalValue,\r\n        });\r\n      }\r\n\r\n      const rows = Array.isArray(json) ? json : json?.data ?? [];\r\n\r\n      // RFC-0108 DEBUG: Log raw API response for water domain\r\n      if (domain === 'water' && rows.length > 0) {\r\n        LogHelper.log(`[RFC-0108 DEBUG] Water API first row with total_value:`, {\r\n          id: rows[0].id,\r\n          name: rows[0].name,\r\n          total_value: rows[0].total_value,\r\n          typeof_total_value: typeof rows[0].total_value,\r\n        });\r\n        LogHelper.log(`[RFC-0108 DEBUG] Water API total rows: ${rows.length}`);\r\n      }\r\n\r\n      // RFC-0108: Use METADATA as base, enrich with API data\r\n      // If no API match found, keep item with value=0 (don't discard)\r\n      // This ensures all devices from ThingsBoard datasource are displayed\r\n\r\n      // RFC-0106: Value field differs by domain:\r\n      // - energy: total_value (kWh)\r\n      // - water: total_value (mÂ³) - API returns total_value for both domains\r\n      const getValueFromRow = (row) => {\r\n        if (!row) return 0;\r\n        // Both energy and water use total_value from API\r\n        // Water API may also return total_volume or total_pulses as alternatives\r\n        if (domain === 'water') {\r\n          const val = Number(row.total_value ?? row.total_volume ?? row.total_pulses ?? 0);\r\n          // RFC-0108 DEBUG: Log first few water API rows to diagnose value extraction\r\n          if (!getValueFromRow._loggedWater) {\r\n            getValueFromRow._loggedWater = 0;\r\n          }\r\n          if (getValueFromRow._loggedWater < 3) {\r\n            LogHelper.log(`[RFC-0108 DEBUG] Water API row FULL:`, JSON.stringify(row, null, 2));\r\n            LogHelper.log(`[RFC-0108 DEBUG] Water API keys: ${Object.keys(row).join(', ')}`);\r\n            LogHelper.log(`[RFC-0108 DEBUG] Extracted value: ${val}`);\r\n            getValueFromRow._loggedWater++;\r\n          }\r\n          return val;\r\n        }\r\n        // Energy: total_value\r\n        return Number(row.total_value || 0);\r\n      };\r\n\r\n      // RFC-0108: Build API data map by ingestionId for quick lookup\r\n      const apiDataMap = new Map();\r\n      // RFC-0108 FIX: Also build name-based map as fallback for devices without ingestionId\r\n      const apiDataByName = new Map();\r\n      for (const row of rows) {\r\n        if (row.id) {\r\n          apiDataMap.set(row.id, row);\r\n        }\r\n        // Build normalized name map (lowercase, trimmed) for fallback matching\r\n        if (row.name) {\r\n          const normalizedName = String(row.name).toLowerCase().trim();\r\n          if (!apiDataByName.has(normalizedName)) {\r\n            apiDataByName.set(normalizedName, row);\r\n          }\r\n        }\r\n      }\r\n      LogHelper.log(`[Orchestrator] ðŸ“Š API data map: ${apiDataMap.size} items by ID, ${apiDataByName.size} by name`);\r\n\r\n      // RFC-0108 DEBUG: Compare metadata ingestionIds with API ids\r\n      if (domain === 'water') {\r\n        const metaIngestionIds = new Set();\r\n        for (const [, meta] of metadataByEntityId.entries()) {\r\n          if (meta.ingestionId) metaIngestionIds.add(meta.ingestionId);\r\n        }\r\n        const apiIds = new Set(apiDataMap.keys());\r\n\r\n        // Find IDs in API but not in metadata\r\n        const apiOnly = [...apiIds].filter(id => !metaIngestionIds.has(id));\r\n        // Find IDs in metadata but not in API\r\n        const metaOnly = [...metaIngestionIds].filter(id => !apiIds.has(id));\r\n\r\n        LogHelper.log(`[RFC-0108 DEBUG] Water ID comparison:`, {\r\n          metadataCount: metaIngestionIds.size,\r\n          apiCount: apiIds.size,\r\n          apiOnlyCount: apiOnly.length,\r\n          metaOnlyCount: metaOnly.length,\r\n        });\r\n        if (apiOnly.length > 0) {\r\n          LogHelper.log(`[RFC-0108 DEBUG] API IDs NOT in metadata (first 5):`, apiOnly.slice(0, 5));\r\n        }\r\n        if (metaOnly.length > 0) {\r\n          LogHelper.log(`[RFC-0108 DEBUG] Metadata IDs NOT in API (first 5):`, metaOnly.slice(0, 5));\r\n        }\r\n      }\r\n\r\n      // RFC-0108: Create items from METADATA (ctx.data) as base\r\n      // Enrich with API data if available, otherwise value=0\r\n      const domainLower = domain.toLowerCase();\r\n      const items = [];\r\n      let matchedCount = 0;\r\n      let unmatchedCount = 0;\r\n\r\n      let nameMatchedCount = 0;\r\n\r\n      for (const [entityId, meta] of metadataByEntityId.entries()) {\r\n        // Skip if no ingestionId in metadata\r\n        const ingestionId = meta.ingestionId;\r\n\r\n        // Try to find API data by ingestionId first\r\n        let apiRow = ingestionId ? apiDataMap.get(ingestionId) : null;\r\n        let matchedBy = apiRow ? 'ingestionId' : null;\r\n\r\n        // RFC-0108 FIX: Fallback to name-based matching if ingestionId doesn't match\r\n        if (!apiRow && domain === 'water') {\r\n          const metaLabel = (meta.label || meta.entityName || '').toLowerCase().trim();\r\n          if (metaLabel && apiDataByName.has(metaLabel)) {\r\n            apiRow = apiDataByName.get(metaLabel);\r\n            matchedBy = 'name';\r\n            nameMatchedCount++;\r\n            LogHelper.log(`[RFC-0108 DEBUG] Name-based match for \"${meta.label}\": found API data with value ${getValueFromRow(apiRow)}`);\r\n          }\r\n        }\r\n\r\n        const hasApiData = !!apiRow;\r\n\r\n        if (hasApiData) {\r\n          matchedCount++;\r\n        } else {\r\n          unmatchedCount++;\r\n        }\r\n\r\n        // Use metadata from ThingsBoard datasource (ctx.data) - NO FALLBACKS for deviceType\r\n        const rawDeviceType = meta.deviceType || null;\r\n        const deviceProfile = meta.deviceProfile || null;\r\n\r\n        // MASTER RULE for deviceType:\r\n        // - If deviceType = deviceProfile = '3F_MEDIDOR' â†’ keep as '3F_MEDIDOR' (it's a loja)\r\n        // - If deviceType = '3F_MEDIDOR' AND deviceProfile != '3F_MEDIDOR' â†’ force deviceType = deviceProfile\r\n        let deviceType = rawDeviceType;\r\n        if (rawDeviceType === '3F_MEDIDOR' && deviceProfile && deviceProfile !== '3F_MEDIDOR') {\r\n          deviceType = deviceProfile;\r\n        }\r\n\r\n        // Skip items with deviceType = domain (placeholder)\r\n        const dt = (deviceType || '').toLowerCase();\r\n        if (dt === domainLower) {\r\n          continue;\r\n        }\r\n\r\n        const identifier = meta.identifier || 'N/A';\r\n        // RFC-0108: Use label from datasource, fallback to entityName without customer suffix\r\n        // entityName format: \"Device Name (Customer Name)\" â†’ extract just \"Device Name\"\r\n        // Also clean meta.label if it has the suffix (when entityLabel was not set)\r\n        let entityNameClean = meta.entityName || '';\r\n        if (entityNameClean.includes(' (') && entityNameClean.endsWith(')')) {\r\n          entityNameClean = entityNameClean.substring(0, entityNameClean.lastIndexOf(' ('));\r\n        }\r\n        let labelClean = meta.label || '';\r\n        if (labelClean.includes(' (') && labelClean.endsWith(')')) {\r\n          labelClean = labelClean.substring(0, labelClean.lastIndexOf(' ('));\r\n        }\r\n        const label = labelClean || entityNameClean || 'SEM ETIQUETA';\r\n        const name = apiRow?.name || entityNameClean || '';\r\n\r\n        // Infer labelWidget from deviceType/deviceProfile\r\n        const labelWidget = inferLabelWidget({\r\n          deviceType: deviceType,\r\n          deviceProfile: deviceProfile,\r\n          identifier: identifier,\r\n          name: name,\r\n        });\r\n\r\n        items.push({\r\n          id: ingestionId || entityId,\r\n          tbId: entityId,\r\n          ingestionId: ingestionId || null,\r\n          identifier: identifier,\r\n          deviceIdentifier: identifier,\r\n          label: label,\r\n          entityLabel: label,\r\n          name: name,\r\n          value: getValueFromRow(apiRow), // 0 if no API match\r\n          perc: 0,\r\n          deviceType: deviceType,\r\n          deviceProfile: deviceProfile,\r\n          effectiveDeviceType: deviceProfile || deviceType || null,\r\n          deviceStatus: convertConnectionStatusToDeviceStatus(meta.connectionStatus),\r\n          connectionStatus: meta.connectionStatus || 'unknown',\r\n          slaveId: meta.slaveId || apiRow?.slaveId || null,\r\n          centralId: meta.centralId || apiRow?.centralId || null,\r\n          centralName: meta.centralName || null,\r\n          gatewayId: apiRow?.gatewayId || null,\r\n          customerId: apiRow?.customerId || null,\r\n          assetId: apiRow?.assetId || null,\r\n          assetName: apiRow?.assetName || null,\r\n          lastActivityTime: meta.lastActivityTime || null,\r\n          lastConnectTime: meta.lastConnectTime || null,\r\n          lastDisconnectTime: meta.lastDisconnectTime || null,\r\n          log_annotations: meta.log_annotations || null,\r\n          // Power limits and instantaneous power (for deviceStatus calculation)\r\n          deviceMapInstaneousPower: meta.deviceMapInstaneousPower || null,\r\n          consumptionPower: meta.consumption || null,\r\n          labelWidget: labelWidget,\r\n          groupLabel: labelWidget,\r\n          _hasMetadata: true, // All items come from metadata\r\n          _hasApiData: hasApiData, // Flag to indicate if API data was found\r\n          _matchedBy: matchedBy, // 'ingestionId', 'name', or null\r\n        });\r\n      }\r\n\r\n      LogHelper.log(\r\n        `[Orchestrator] ðŸ“Š RFC-0108: Created ${items.length} items from metadata. API match: ${matchedCount} matched (${nameMatchedCount} by name), ${unmatchedCount} with value=0`\r\n      );\r\n\r\n      // DEBUG: Log sample items\r\n      if (items.length > 0) {\r\n        const sampleWithApi = items.find(i => i._hasApiData);\r\n        const sampleWithoutApi = items.find(i => !i._hasApiData);\r\n        if (sampleWithApi) {\r\n          LogHelper.log(`[Orchestrator] ðŸ” Sample item WITH API data:`, {\r\n            id: sampleWithApi.id,\r\n            label: sampleWithApi.label,\r\n            value: sampleWithApi.value,\r\n            deviceType: sampleWithApi.deviceType,\r\n            labelWidget: sampleWithApi.labelWidget,\r\n            matchedBy: sampleWithApi._matchedBy,\r\n          });\r\n        }\r\n        if (sampleWithoutApi) {\r\n          LogHelper.log(`[Orchestrator] ðŸ” Sample item WITHOUT API data (value=0):`, {\r\n            id: sampleWithoutApi.id,\r\n            label: sampleWithoutApi.label,\r\n            value: sampleWithoutApi.value,\r\n            deviceType: sampleWithoutApi.deviceType,\r\n            labelWidget: sampleWithoutApi.labelWidget,\r\n            ingestionId: sampleWithoutApi.ingestionId || 'MISSING',\r\n          });\r\n        }\r\n\r\n        // RFC-0108 DEBUG: Log VACINA device specifically after enrichment (regardless of classification)\r\n        if (domain === 'water') {\r\n          const vacinaItems = items.filter(i => {\r\n            const label = (i.label || '').toUpperCase();\r\n            const name = (i.name || '').toUpperCase();\r\n            return label.includes('VACINA') || name.includes('VACINA');\r\n          });\r\n          if (vacinaItems.length > 0) {\r\n            LogHelper.log(`[RFC-0108 DEBUG] VACINA device AFTER ENRICHMENT:`, JSON.stringify(vacinaItems.map(d => ({\r\n              label: d.label,\r\n              value: d.value,\r\n              ingestionId: d.ingestionId,\r\n              hasApiData: d._hasApiData,\r\n              matchedBy: d._matchedBy,\r\n              labelWidget: d.labelWidget,\r\n              deviceType: d.deviceType,\r\n              deviceProfile: d.deviceProfile,\r\n            })), null, 2));\r\n          }\r\n\r\n          const entradaDevices = items.filter(i => i.labelWidget === 'Entrada');\r\n          if (entradaDevices.length > 0) {\r\n            LogHelper.log(`[RFC-0108 DEBUG] Entrada devices after enrichment:`, entradaDevices.map(d => ({\r\n              label: d.label,\r\n              value: d.value,\r\n              hasApiData: d._hasApiData,\r\n              matchedBy: d._matchedBy,\r\n              ingestionId: d.ingestionId || 'MISSING',\r\n            })));\r\n          }\r\n\r\n          // Log all devices that have no match and value=0\r\n          const unmatchedDevices = items.filter(i => !i._hasApiData && i.value === 0);\r\n          if (unmatchedDevices.length > 0 && unmatchedDevices.length <= 20) {\r\n            LogHelper.log(`[RFC-0108 DEBUG] ALL unmatched devices (value=0):`, unmatchedDevices.map(d => ({\r\n              label: d.label,\r\n              ingestionId: d.ingestionId || 'MISSING',\r\n              labelWidget: d.labelWidget,\r\n            })));\r\n          } else if (unmatchedDevices.length > 20) {\r\n            LogHelper.log(`[RFC-0108 DEBUG] Too many unmatched devices: ${unmatchedDevices.length} - showing first 10:`, unmatchedDevices.slice(0, 10).map(d => ({\r\n              label: d.label,\r\n              ingestionId: d.ingestionId || 'MISSING',\r\n              labelWidget: d.labelWidget,\r\n            })));\r\n          }\r\n        }\r\n      }\r\n\r\n      // RFC-0107: Combine with water devices from ctx.data (tanks + hidrometros)\r\n      // RFC-0108 FIX: Merge API values from enriched items into hidrometroItems before combining\r\n      let finalItems = items;\r\n      if (tankItems.length > 0 || hidrometroItems.length > 0) {\r\n        // Create map from tbId to enriched item data (API values)\r\n        const enrichedItemsMap = new Map();\r\n        for (const item of items) {\r\n          if (item.tbId) {\r\n            enrichedItemsMap.set(item.tbId, item);\r\n          }\r\n        }\r\n\r\n        // Merge API values into hidrometroItems (preserving pulses but using API total_value)\r\n        let mergedCount = 0;\r\n        for (const hidro of hidrometroItems) {\r\n          const enrichedItem = enrichedItemsMap.get(hidro.tbId);\r\n          if (enrichedItem && enrichedItem._hasApiData) {\r\n            hidro.value = enrichedItem.value; // Use API total_value\r\n            hidro._hasApiData = true;\r\n            hidro._matchedBy = enrichedItem._matchedBy;\r\n            mergedCount++;\r\n          }\r\n        }\r\n\r\n        if (mergedCount > 0) {\r\n          LogHelper.log(`[Orchestrator] ðŸ”„ RFC-0108: Merged API values into ${mergedCount}/${hidrometroItems.length} hidrometros`);\r\n\r\n          // DEBUG: Log VACINA device after merge\r\n          const vacinaHidro = hidrometroItems.find(h => {\r\n            const label = (h.label || '').toUpperCase();\r\n            return label.includes('VACINA');\r\n          });\r\n          if (vacinaHidro) {\r\n            LogHelper.log(`[RFC-0108 DEBUG] VACINA hidrometro AFTER MERGE:`, JSON.stringify({\r\n              label: vacinaHidro.label,\r\n              value: vacinaHidro.value,\r\n              pulses: vacinaHidro.pulses,\r\n              hasApiData: vacinaHidro._hasApiData,\r\n              matchedBy: vacinaHidro._matchedBy,\r\n            }, null, 2));\r\n          }\r\n        }\r\n\r\n        // Create set of IDs already processed as tanks or hidrometros\r\n        const waterDeviceIds = new Set([\r\n          ...tankItems.map(i => i.tbId),\r\n          ...hidrometroItems.map(i => i.tbId)\r\n        ]);\r\n        // Filter items to exclude duplicates\r\n        const itemsWithoutWaterDevices = items.filter(i => !waterDeviceIds.has(i.tbId));\r\n        finalItems = [...itemsWithoutWaterDevices, ...tankItems, ...hidrometroItems];\r\n        LogHelper.log(\r\n          `[Orchestrator] ðŸš° Combined ${itemsWithoutWaterDevices.length} metadata items + ${tankItems.length} tanks + ${hidrometroItems.length} hidrometros = ${finalItems.length} total (filtered ${items.length - itemsWithoutWaterDevices.length} duplicates)`\r\n        );\r\n      }\r\n\r\n      LogHelper.log(\r\n        `[Orchestrator] fetchAndEnrich: fetched ${finalItems.length} items for domain ${domain}`\r\n      );\r\n      return finalItems;\r\n    } catch (error) {\r\n      LogHelper.error(`[Orchestrator] fetchAndEnrich error for domain ${domain}:`, error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Fetch data for a domain and period\r\n  async function hydrateDomain(domain, period) {\r\n    const key = periodKey(domain, period);\r\n    const startTime = Date.now();\r\n\r\n    LogHelper.log(`[Orchestrator] hydrateDomain called for ${domain}:`, { key, inFlight: inFlight.has(key) });\r\n\r\n    // Coalesce duplicate requests\r\n    if (inFlight.has(key)) {\r\n      LogHelper.log(`[Orchestrator] â­ï¸ Coalescing duplicate request for ${key}`);\r\n      return inFlight.get(key);\r\n    }\r\n\r\n    // Show busy overlay\r\n    showGlobalBusy(domain, 'Carregando dados...');\r\n\r\n    // Set mutex for coordination\r\n    sharedWidgetState.mutexMap.set(domain, true);\r\n    sharedWidgetState.activePeriod = period;\r\n\r\n    const fetchPromise = (async () => {\r\n      try {\r\n        const items = await fetchAndEnrich(domain, period);\r\n\r\n        emitHydrated(domain, key, items.length);\r\n\r\n        // Emit data to widgets\r\n        emitProvide(domain, key, items);\r\n        LogHelper.log(`[Orchestrator] ðŸ“¡ Emitted provide-data for ${domain} with ${items.length} items`);\r\n\r\n        const duration = Date.now() - startTime;\r\n        metrics.recordHydration(domain, duration);\r\n\r\n        LogHelper.log(`[Orchestrator] âœ… Data fetched for ${domain} in ${duration}ms`);\r\n        return items;\r\n      } catch (error) {\r\n        LogHelper.error(`[Orchestrator] âŒ Error fetching ${domain}:`, error);\r\n        metrics.recordError(domain, error);\r\n        emitError(domain, error);\r\n\r\n        // RFC-0106: Show toast and reload page on fetch errors\r\n        window.MyIOUtils?.handleDataLoadError(domain, error.message || 'fetch error');\r\n\r\n        throw error;\r\n      } finally {\r\n        // Hide busy overlay\r\n        LogHelper.log(`[Orchestrator] ðŸ”„ Finally block - hiding busy for ${domain}`);\r\n        hideGlobalBusy(domain);\r\n\r\n        // Release mutex\r\n        sharedWidgetState.mutexMap.set(domain, false);\r\n        LogHelper.log(`[Orchestrator] ðŸ”“ Mutex released for ${domain}`);\r\n\r\n        // RFC-0107: Dispatch event to signal fetch completion (for contract modal timer)\r\n        window.dispatchEvent(\r\n          new CustomEvent('myio:domain:fetch-complete', {\r\n            detail: { domain },\r\n          })\r\n        );\r\n        LogHelper.log(`[Orchestrator] ðŸ“¡ Dispatched myio:domain:fetch-complete for ${domain}`);\r\n      }\r\n    })().finally(() => {\r\n      inFlight.delete(key);\r\n      LogHelper.log(`[Orchestrator] ðŸ§¹ Cleaned up inFlight for ${key}`);\r\n    });\r\n\r\n    inFlight.set(key, fetchPromise);\r\n    return fetchPromise;\r\n  }\r\n\r\n  // Emit data to widgets\r\n  function emitProvide(domain, pKey, items) {\r\n    const now = Date.now();\r\n    const key = `${domain}_${pKey}`;\r\n\r\n    // Don't emit empty arrays\r\n    if (!items || items.length === 0) {\r\n      LogHelper.warn(`[Orchestrator] âš ï¸ Skipping emitProvide for ${domain} - no items to emit`);\r\n      return;\r\n    }\r\n\r\n    // Prevent duplicate emissions (< 100ms)\r\n    if (OrchestratorState.lastEmission[key]) {\r\n      const timeSinceLastEmit = now - OrchestratorState.lastEmission[key];\r\n      if (timeSinceLastEmit < 100) {\r\n        LogHelper.log(\r\n          `[Orchestrator] â­ï¸ Skipping duplicate emission for ${domain} (${timeSinceLastEmit}ms ago)`\r\n        );\r\n        return;\r\n      }\r\n    }\r\n\r\n    OrchestratorState.lastEmission[key] = now;\r\n\r\n    // RFC-0106: Populate window.STATE with categorized data BEFORE emitting\r\n    // This allows widgets to read directly from window.STATE instead of events\r\n    populateState(domain, items, pKey);\r\n\r\n    // RFC-0106 FIX: Store in MyIOOrchestratorData for late-initializing widgets\r\n    // This ensures widgets that miss the event can still find the data\r\n    if (!window.MyIOOrchestratorData) {\r\n      window.MyIOOrchestratorData = {};\r\n    }\r\n    window.MyIOOrchestratorData[domain] = {\r\n      periodKey: pKey,\r\n      items: items,\r\n      timestamp: now,\r\n      version: (window.MyIOOrchestratorData[domain]?.version || 0) + 1,\r\n    };\r\n    LogHelper.log(\r\n      `[Orchestrator] ðŸ“¦ MyIOOrchestratorData updated for ${domain}: ${items.length} items (v${window.MyIOOrchestratorData[domain].version})`\r\n    );\r\n\r\n    // Emit event to all widgets (kept for backwards compatibility)\r\n    const eventDetail = { domain, periodKey: pKey, items };\r\n    window.dispatchEvent(new CustomEvent('myio:telemetry:provide-data', { detail: eventDetail }));\r\n\r\n    try {\r\n      lastProvide.set(domain, { periodKey: pKey, at: Date.now() });\r\n      hideGlobalBusy(domain);\r\n    } catch (_e) {\r\n      // Silently ignore\r\n    }\r\n\r\n    // Mark as not loading\r\n    OrchestratorState.loading[domain] = false;\r\n\r\n    // Process pending listeners (widgets that arrived late)\r\n    if (OrchestratorState.pendingListeners[domain]) {\r\n      LogHelper.log(\r\n        `[Orchestrator] ðŸ”” Processing ${OrchestratorState.pendingListeners[domain].length} pending listeners for ${domain}`\r\n      );\r\n\r\n      OrchestratorState.pendingListeners[domain].forEach((callback) => {\r\n        try {\r\n          callback({ detail: eventDetail });\r\n        } catch (err) {\r\n          LogHelper.error(`[Orchestrator] Error calling pending listener:`, err);\r\n        }\r\n      });\r\n\r\n      delete OrchestratorState.pendingListeners[domain];\r\n    }\r\n\r\n    LogHelper.log(`[Orchestrator] ðŸ“¡ Emitted provide-data for ${domain} with ${items.length} items`);\r\n  }\r\n\r\n  function emitHydrated(domain, periodKey, count) {\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:orchestrator:data-hydrated', {\r\n        detail: { domain, periodKey, count },\r\n      })\r\n    );\r\n  }\r\n\r\n  function emitError(domain, error) {\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:orchestrator:error', {\r\n        detail: {\r\n          domain,\r\n          error: error.message || String(error),\r\n          code: error.status || 500,\r\n        },\r\n      })\r\n    );\r\n  }\r\n\r\n  let tokenExpiredDebounce = 0;\r\n  function emitTokenExpired() {\r\n    const now = Date.now();\r\n    if (now - tokenExpiredDebounce < 60_000) return;\r\n\r\n    tokenExpiredDebounce = now;\r\n    window.dispatchEvent(new CustomEvent('myio:token-expired', { detail: {} }));\r\n  }\r\n\r\n  // Token manager\r\n  const tokenManager = {\r\n    tokens: {},\r\n\r\n    updateTokens(newTokens) {\r\n      this.tokens = { ...this.tokens, ...newTokens };\r\n\r\n      // Abort in-flight requests when tokens are rotated\r\n      abortAllInflight();\r\n\r\n      window.dispatchEvent(new CustomEvent('myio:token-rotated', { detail: {} }));\r\n\r\n      if (config?.debugMode) LogHelper.log('[Orchestrator] Tokens rotated');\r\n    },\r\n\r\n    getToken(type) {\r\n      return this.tokens[type] || null;\r\n    },\r\n\r\n    setToken(type, value) {\r\n      this.tokens[type] = value;\r\n    },\r\n  };\r\n\r\n  // Widget registration system for priority management\r\n  /**\r\n   * Registra widget com prioridade baseada na ordem de inicializaÃ§Ã£o\r\n   */\r\n  function registerWidget(widgetId, domain) {\r\n    if (!OrchestratorState.widgetPriority.includes(widgetId)) {\r\n      OrchestratorState.widgetPriority.push(widgetId);\r\n\r\n      const priority = OrchestratorState.widgetPriority.indexOf(widgetId) + 1;\r\n\r\n      // Store in registry with metadata\r\n      OrchestratorState.widgetRegistry.set(widgetId, {\r\n        domain,\r\n        registeredAt: Date.now(),\r\n        priority,\r\n      });\r\n\r\n      LogHelper.log(\r\n        `[Orchestrator] ðŸ“ Widget registered: ${widgetId} (domain: ${domain}, priority: ${priority})`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listener para widgets se registrarem\r\n   */\r\n  window.addEventListener('myio:widget:register', (ev) => {\r\n    const { widgetId, domain } = ev.detail;\r\n    registerWidget(widgetId, domain);\r\n  });\r\n\r\n  // Event listeners\r\n  window.addEventListener('myio:update-date', (ev) => {\r\n    LogHelper.log('[Orchestrator] ðŸ“… Received myio:update-date event', ev.detail);\r\n    currentPeriod = ev.detail.period;\r\n\r\n    // Cross-context emission removed - HEADER already handles this\r\n    // No need to re-emit here as it creates infinite loop\r\n\r\n    if (visibleTab && currentPeriod) {\r\n      LogHelper.log(`[Orchestrator] ðŸ“… myio:update-date â†’ hydrateDomain(${visibleTab})`);\r\n      hydrateDomain(visibleTab, currentPeriod);\r\n    }\r\n  });\r\n\r\n  window.addEventListener('myio:dashboard-state', (ev) => {\r\n    const tab = ev.detail.tab;\r\n    try {\r\n      hideGlobalBusy(tab);\r\n    } catch (_e) {\r\n      // Silently ignore - busy indicator may not exist yet\r\n    }\r\n    visibleTab = tab;\r\n    if (visibleTab && currentPeriod) {\r\n      LogHelper.log(`[Orchestrator] ?? myio:dashboard-state ? hydrateDomain(${visibleTab})`);\r\n      hydrateDomain(visibleTab, currentPeriod);\r\n    } else {\r\n      LogHelper.log(\r\n        `[Orchestrator] ?? myio:dashboard-state skipped (visibleTab=${visibleTab}, currentPeriod=${!!currentPeriod})`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Request-data listener with pending listeners support\r\n  window.addEventListener('myio:telemetry:request-data', async (ev) => {\r\n    const { domain, period, widgetId, priority } = ev.detail;\r\n\r\n    LogHelper.log(\r\n      `[Orchestrator] ðŸ“¨ Received data request from widget ${widgetId} (domain: ${domain}, priority: ${priority})`\r\n    );\r\n\r\n    // Check if already loading\r\n    if (OrchestratorState.loading[domain]) {\r\n      LogHelper.log(`[Orchestrator] â³ Already loading ${domain}, adding to pending listeners`);\r\n\r\n      // Add pending listener\r\n      if (!OrchestratorState.pendingListeners[domain]) {\r\n        OrchestratorState.pendingListeners[domain] = [];\r\n      }\r\n\r\n      OrchestratorState.pendingListeners[domain].push((data) => {\r\n        window.dispatchEvent(new CustomEvent('myio:telemetry:provide-data', { detail: data.detail }));\r\n        try {\r\n          lastProvide.set(domain, { periodKey: data.detail.periodKey, at: Date.now() });\r\n          hideGlobalBusy(domain);\r\n        } catch (_e) {\r\n          // Silently ignore\r\n        }\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    // Fetch fresh data\r\n    OrchestratorState.loading[domain] = true;\r\n\r\n    try {\r\n      const p = period || currentPeriod;\r\n      if (p) {\r\n        LogHelper.log(`[Orchestrator] ðŸ“¡ myio:telemetry:request-data â†’ hydrateDomain(${domain})`);\r\n        await hydrateDomain(domain, p);\r\n      } else {\r\n        LogHelper.log(`[Orchestrator] ðŸ“¡ myio:telemetry:request-data skipped (no period)`);\r\n        OrchestratorState.loading[domain] = false;\r\n      }\r\n    } catch (error) {\r\n      LogHelper.error(`[Orchestrator] Error hydrating ${domain}:`, error);\r\n      OrchestratorState.loading[domain] = false;\r\n    }\r\n  });\r\n\r\n  // Telemetry reporting\r\n  if (!config?.debugMode && typeof window.tbClient !== 'undefined') {\r\n    setInterval(() => {\r\n      try {\r\n        window.tbClient.sendTelemetry(metrics.generateTelemetrySummary());\r\n      } catch (e) {\r\n        LogHelper.warn('[Orchestrator] Failed to send telemetry:', e);\r\n      }\r\n    }, 5 * 60 * 1000);\r\n  }\r\n\r\n  // RFC-0048: Widget Busy Monitor - Detects stuck widgets showing busy for too long\r\n  const widgetBusyMonitor = {\r\n    timers: new Map(), // domain -> timeoutId\r\n    TIMEOUT_MS: 30000, // 30 seconds\r\n\r\n    startMonitoring(domain) {\r\n      // Clear existing timer if any\r\n      this.stopMonitoring(domain);\r\n\r\n      const timerId = setTimeout(() => {\r\n        LogHelper.error(\r\n          `[WidgetMonitor] âš ï¸ Widget ${domain} has been showing busy for more than ${\r\n            this.TIMEOUT_MS / 1000\r\n          }s!`\r\n        );\r\n        LogHelper.error(`[WidgetMonitor] Possible issues:`);\r\n        LogHelper.error(`[WidgetMonitor] 1. Widget nÃ£o recebeu dados do orchestrator`);\r\n        LogHelper.error(`[WidgetMonitor] 2. Widget recebeu dados vazios mas nÃ£o chamou hideBusy()`);\r\n        LogHelper.error(`[WidgetMonitor] 3. Erro silencioso impedindo processamento`);\r\n\r\n        // Log current busy state\r\n        const busyState = globalBusyState;\r\n        LogHelper.error(`[WidgetMonitor] Current busy state:`, busyState);\r\n\r\n        // Attempt auto-recovery: force hide busy for stuck widget\r\n        LogHelper.warn(`[WidgetMonitor] ðŸ”§ Attempting auto-recovery: forcing hideBusy for ${domain}`);\r\n        hideGlobalBusy(domain);\r\n\r\n        // RFC-0106: Show toast and reload page when widget is stuck\r\n        window.MyIOUtils?.handleDataLoadError(domain, 'widget stuck in busy state for 30s');\r\n      }, this.TIMEOUT_MS);\r\n\r\n      this.timers.set(domain, timerId);\r\n      LogHelper.log(`[WidgetMonitor] âœ… Started monitoring ${domain} (timeout: ${this.TIMEOUT_MS / 1000}s)`);\r\n    },\r\n\r\n    stopMonitoring(domain) {\r\n      const timerId = this.timers.get(domain);\r\n      if (timerId) {\r\n        clearTimeout(timerId);\r\n        this.timers.delete(domain);\r\n        LogHelper.log(`[WidgetMonitor] âœ… Stopped monitoring ${domain}`);\r\n      }\r\n    },\r\n\r\n    stopAll() {\r\n      for (const [domain, timerId] of this.timers.entries()) {\r\n        clearTimeout(timerId);\r\n        LogHelper.log(`[WidgetMonitor] âœ… Stopped monitoring ${domain}`);\r\n      }\r\n      this.timers.clear();\r\n    },\r\n  };\r\n\r\n  // Public API\r\n  return {\r\n    hydrateDomain,\r\n    setVisibleTab: (tab) => {\r\n      visibleTab = tab;\r\n    },\r\n    getVisibleTab: () => visibleTab,\r\n    getCurrentPeriod: () => currentPeriod,\r\n    getStats: () => ({\r\n      totalRequests: metrics.totalRequests,\r\n      inFlightCount: inFlight.size,\r\n    }),\r\n    tokenManager,\r\n    metrics,\r\n    config,\r\n\r\n    // Expose centralized busy management\r\n    showGlobalBusy,\r\n    hideGlobalBusy,\r\n\r\n    // RFC-0107: Contract loading modal functions\r\n    updateContractModalDomain,\r\n    updateContractModalStatus,\r\n\r\n    // Expose shared state\r\n    getSharedWidgetState: () => sharedWidgetState,\r\n    setSharedPeriod: (period) => {\r\n      sharedWidgetState.activePeriod = period;\r\n    },\r\n\r\n    // Expose busy state for debugging\r\n    getBusyState: () => ({ ...globalBusyState }),\r\n\r\n    // Expose widget busy monitor\r\n    widgetBusyMonitor,\r\n\r\n    setCredentials: (customerId, clientId, clientSecret) => {\r\n      LogHelper.log(`[Orchestrator] ðŸ” setCredentials called with:`, {\r\n        customerId,\r\n        clientId,\r\n        clientSecretLength: clientSecret?.length || 0,\r\n      });\r\n\r\n      CUSTOMER_ING_ID = customerId;\r\n      CLIENT_ID = clientId;\r\n      CLIENT_SECRET = clientSecret;\r\n\r\n      LogHelper.log(`[Orchestrator] âœ… Credentials set successfully:`, {\r\n        CUSTOMER_ING_ID,\r\n        CLIENT_ID,\r\n        CLIENT_SECRET_length: CLIENT_SECRET?.length || 0,\r\n      });\r\n\r\n      // RFC-0051.2: Mark credentials as set\r\n      if (window.MyIOOrchestrator) {\r\n        window.MyIOOrchestrator.credentialsSet = true;\r\n      }\r\n\r\n      // Resolve the promise to unblock waiting fetchAndEnrich calls\r\n      if (credentialsResolver) {\r\n        credentialsResolver();\r\n        LogHelper.log(`[Orchestrator] âœ… Credentials promise resolved - unblocking pending requests`);\r\n      }\r\n    },\r\n\r\n    getCredentials: () => {\r\n      return {\r\n        CUSTOMER_ING_ID,\r\n        CLIENT_ID,\r\n        CLIENT_SECRET,\r\n      };\r\n    },\r\n\r\n    destroy: () => {\r\n      // Abort all in-flight requests\r\n      abortAllInflight();\r\n\r\n      // Stop all widget monitors\r\n      widgetBusyMonitor.stopAll();\r\n\r\n      // Clean up busy overlay\r\n      hideGlobalBusy();\r\n      const busyEl = document.getElementById(BUSY_OVERLAY_ID);\r\n      if (busyEl && busyEl.parentNode) {\r\n        busyEl.parentNode.removeChild(busyEl);\r\n      }\r\n    },\r\n  };\r\n})();\r\n\r\n// RFC-0051.2: Update stub with real implementation and mark as ready\r\nif (window.MyIOOrchestrator && !window.MyIOOrchestrator.isReady) {\r\n  // Merge real implementation with stub\r\n  Object.assign(window.MyIOOrchestrator, MyIOOrchestrator);\r\n\r\n  // Mark as ready\r\n  window.MyIOOrchestrator.isReady = true;\r\n  window.MyIOOrchestrator.credentialsSet = false; // Will be set by setCredentials()\r\n\r\n  LogHelper.log('[Orchestrator] âœ… Orchestrator fully initialized and ready');\r\n\r\n  // Emit ready event for widgets that are waiting\r\n  window.dispatchEvent(\r\n    new CustomEvent('myio:orchestrator:ready', {\r\n      detail: { timestamp: Date.now() },\r\n    })\r\n  );\r\n\r\n  LogHelper.log('[Orchestrator] ðŸ“¢ Emitted myio:orchestrator:ready event');\r\n\r\n  // RFC-0107: Contract loading will be initialized from self.onInit after customerTB_ID is set\r\n} else {\r\n  // Fallback: no stub exists (shouldn't happen but be safe)\r\n  window.MyIOOrchestrator = MyIOOrchestrator;\r\n  window.MyIOOrchestrator.isReady = true;\r\n  window.MyIOOrchestrator.credentialsSet = false;\r\n\r\n  LogHelper.log('[MyIOOrchestrator] Initialized (no stub found)');\r\n\r\n  // RFC-0107: Contract loading will be initialized from self.onInit after customerTB_ID is set\r\n}\r\n\r\n/**\r\n * RFC-0107: Initializes the contract loading modal and fetches device counts\r\n * This function is called when the orchestrator becomes ready\r\n */\r\nasync function initializeContractLoading() {\r\n  const customerTB_ID = widgetSettings.customerTB_ID;\r\n  if (!customerTB_ID) {\r\n    LogHelper.warn('[RFC-0107] customerTB_ID not available, skipping contract initialization');\r\n    return;\r\n  }\r\n\r\n  LogHelper.log('[RFC-0107] ðŸ“‹ Initializing contract loading...');\r\n\r\n  // Show the contract loading modal immediately\r\n  if (window.MyIOOrchestrator?.showGlobalBusy) {\r\n    window.MyIOOrchestrator.showGlobalBusy('contract', 'Carregando contrato...', 60000);\r\n    LogHelper.log('[RFC-0107] Contract loading modal shown');\r\n  }\r\n\r\n  try {\r\n    // Fetch device counts from SERVER_SCOPE\r\n    const deviceCounts = await fetchDeviceCountAttributes(customerTB_ID);\r\n\r\n    if (deviceCounts) {\r\n      LogHelper.log('[RFC-0107] Device counts fetched:', deviceCounts);\r\n\r\n      // Update the loading modal with expected counts (modal DOM should exist now)\r\n      if (window.MyIOOrchestrator?.updateContractModalDomain) {\r\n        window.MyIOOrchestrator.updateContractModalDomain('energy', deviceCounts.energy, false);\r\n        window.MyIOOrchestrator.updateContractModalDomain('water', deviceCounts.water, false);\r\n        window.MyIOOrchestrator.updateContractModalDomain('temperature', deviceCounts.temperature, false);\r\n        LogHelper.log('[RFC-0107] Modal domains updated with expected counts');\r\n      }\r\n\r\n      // Store counts in CONTRACT_STATE (initial, not validated yet)\r\n      window.CONTRACT_STATE = {\r\n        ...window.CONTRACT_STATE,\r\n        energy: deviceCounts.energy,\r\n        water: deviceCounts.water,\r\n        temperature: deviceCounts.temperature,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n\r\n      // Listen for domain data loaded events to update modal and validate\r\n      setupContractValidationListeners(deviceCounts);\r\n    } else {\r\n      LogHelper.warn('[RFC-0107] No device counts available from SERVER_SCOPE');\r\n    }\r\n  } catch (error) {\r\n    LogHelper.error('[RFC-0107] Error initializing contract loading:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0107: Sets up listeners to track domain loading and validate contract\r\n * @param {Object} expectedCounts - Device counts from SERVER_SCOPE\r\n */\r\nfunction setupContractValidationListeners(expectedCounts) {\r\n  // FIX: Only track domains that are actually enabled in widgetSettings\r\n  const enabledDomains = widgetSettings.domainsEnabled || { energy: true, water: true, temperature: true };\r\n  const activeDomains = ['energy', 'water', 'temperature'].filter((d) => enabledDomains[d]);\r\n\r\n  LogHelper.log('[RFC-0107] Active domains for validation:', activeDomains);\r\n\r\n  const domainsLoaded = {};\r\n  const domainsFetchComplete = {};\r\n  activeDomains.forEach((d) => {\r\n    domainsLoaded[d] = false;\r\n    domainsFetchComplete[d] = false;\r\n  });\r\n\r\n  let validationFinalized = false;\r\n\r\n  // Listen for domain state-ready events (data is in STATE)\r\n  const handleStateReady = (event) => {\r\n    const { domain } = event.detail || {};\r\n    if (!domain || !activeDomains.includes(domain)) return;\r\n\r\n    LogHelper.log(`[RFC-0107] Domain ${domain} data ready`);\r\n    domainsLoaded[domain] = true;\r\n\r\n    // Check for validation discrepancies\r\n    const state = window.STATE;\r\n    let hasError = false;\r\n\r\n    if (domain === 'energy' && state?.energy) {\r\n      const actual =\r\n        (state.energy.lojas?.count || 0) +\r\n        (state.energy.entrada?.count || 0) +\r\n        (state.energy.areacomum?.count || 0);\r\n      hasError = expectedCounts.energy.total > 0 && actual !== expectedCounts.energy.total;\r\n    } else if (domain === 'water' && state?.water) {\r\n      const actual =\r\n        (state.water.lojas?.count || 0) +\r\n        (state.water.entrada?.count || 0) +\r\n        (state.water.areacomum?.count || 0);\r\n      hasError = expectedCounts.water.total > 0 && actual !== expectedCounts.water.total;\r\n    } else if (domain === 'temperature' && state?.temperature) {\r\n      const actual =\r\n        (state.temperature.lojas?.count || 0) +\r\n        (state.temperature.entrada?.count || 0) +\r\n        (state.temperature.areacomum?.count || 0);\r\n      hasError = expectedCounts.temperature.total > 0 && actual !== expectedCounts.temperature.total;\r\n    }\r\n\r\n    // Update modal domain status\r\n    if (window.MyIOOrchestrator?.updateContractModalDomain) {\r\n      window.MyIOOrchestrator.updateContractModalDomain(\r\n        domain,\r\n        expectedCounts[domain],\r\n        true, // isLoaded\r\n        hasError\r\n      );\r\n    }\r\n\r\n    // Check if all domains are loaded and fetch complete\r\n    checkAllComplete();\r\n  };\r\n\r\n  // RFC-0107 FIX: Listen for fetch-complete events (after Finally block)\r\n  const handleFetchComplete = (event) => {\r\n    const { domain } = event.detail || {};\r\n    if (!domain || !activeDomains.includes(domain)) return;\r\n\r\n    LogHelper.log(`[RFC-0107] Domain ${domain} fetch complete (finally block done)`);\r\n    domainsFetchComplete[domain] = true;\r\n\r\n    // Check if all domains are loaded and fetch complete\r\n    checkAllComplete();\r\n  };\r\n\r\n  // Check if all domains have both state-ready and fetch-complete\r\n  const checkAllComplete = () => {\r\n    if (validationFinalized) return;\r\n\r\n    const allStateReady = Object.values(domainsLoaded).every((loaded) => loaded);\r\n    const allFetchComplete = Object.values(domainsFetchComplete).every((complete) => complete);\r\n\r\n    LogHelper.log(\r\n      `[RFC-0107] checkAllComplete: stateReady=${allStateReady}, fetchComplete=${allFetchComplete}`\r\n    );\r\n\r\n    if (allStateReady && allFetchComplete) {\r\n      validationFinalized = true;\r\n      LogHelper.log('[RFC-0107] All domains loaded AND fetch complete - finalizing validation');\r\n      finalizeContractValidation(expectedCounts);\r\n      window.removeEventListener('myio:state:ready', handleStateReady);\r\n      window.removeEventListener('myio:domain:fetch-complete', handleFetchComplete);\r\n    }\r\n  };\r\n\r\n  window.addEventListener('myio:state:ready', handleStateReady);\r\n  window.addEventListener('myio:domain:fetch-complete', handleFetchComplete);\r\n\r\n  // Also check for already-loaded domains (in case events were missed)\r\n  setTimeout(() => {\r\n    activeDomains.forEach((domain) => {\r\n      if (!domainsLoaded[domain] && window.STATE?.isReady?.(domain)) {\r\n        handleStateReady({ detail: { domain } });\r\n      }\r\n    });\r\n  }, 100);\r\n}\r\n\r\n/**\r\n * RFC-0107: Finalizes contract validation and stores state\r\n * @param {Object} expectedCounts - Device counts from SERVER_SCOPE\r\n */\r\nfunction finalizeContractValidation(expectedCounts) {\r\n  LogHelper.log('[RFC-0107] All domains loaded, finalizing contract validation...');\r\n\r\n  // Validate all domains\r\n  const validationResult = validateDeviceCounts(expectedCounts);\r\n\r\n  // Store final CONTRACT_STATE\r\n  storeContractState(expectedCounts, validationResult);\r\n\r\n  // Update modal status\r\n  if (window.MyIOOrchestrator?.updateContractModalStatus) {\r\n    const totalExpected =\r\n      expectedCounts.energy.total + expectedCounts.water.total + expectedCounts.temperature.total;\r\n\r\n    if (validationResult.isValid) {\r\n      window.MyIOOrchestrator.updateContractModalStatus(\r\n        true,\r\n        `${totalExpected} dispositivos carregados com sucesso`\r\n      );\r\n    } else {\r\n      const discrepancyDomains = validationResult.discrepancies.map((d) => d.domain).join(', ');\r\n      window.MyIOOrchestrator.updateContractModalStatus(\r\n        false,\r\n        `DivergÃªncias detectadas em: ${discrepancyDomains}`\r\n      );\r\n    }\r\n  }\r\n\r\n  LogHelper.log('[RFC-0107] âœ… Contract validation complete:', validationResult);\r\n\r\n  // RFC-0107: Auto-close the contract loading modal after 15 seconds (if not paused)\r\n  window._contractModalAutoCloseId = setTimeout(() => {\r\n    if (window._contractModalPaused) {\r\n      LogHelper.log('[RFC-0107] Auto-close skipped - modal is paused');\r\n      return;\r\n    }\r\n    if (window.MyIOOrchestrator?.hideGlobalBusy) {\r\n      LogHelper.log('[RFC-0107] Auto-closing contract loading modal after 15 seconds');\r\n      window.MyIOOrchestrator.hideGlobalBusy();\r\n    }\r\n  }, 15000);\r\n\r\n  // Enable close button now that loading is complete\r\n  const closeBtn = document.querySelector('#myio-orchestrator-busy-overlay .contract-close-btn');\r\n  if (closeBtn) {\r\n    closeBtn.disabled = false;\r\n    closeBtn.style.opacity = '1';\r\n    closeBtn.style.cursor = 'pointer';\r\n  }\r\n}\r\n",
      "settingsSchema": "{\r\n  \"schema\": {\r\n    \"type\": \"object\",\r\n    \"title\": \"MAIN_VIEW Orchestrator Settings\",\r\n    \"properties\": {\r\n      \"customerTB_ID\": {\r\n        \"title\": \"Customer ThingsBoard ID\",\r\n        \"type\": \"string\",\r\n        \"description\": \"ID do customer no ThingsBoard para buscar atributos de autenticaÃ§Ã£o (client_id, client_secret, ingestionId)\"\r\n      },\r\n      \"enableCache\": {\r\n        \"title\": \"Enable Cache System\",\r\n        \"type\": \"boolean\",\r\n        \"default\": true,\r\n        \"description\": \"RFC-0052: Enable/disable cache system globally. Set to FALSE to always fetch fresh data from API (use for troubleshooting or real-time dashboards). WARNING: Disabling cache increases API load.\"\r\n      },\r\n      \"cacheTtlMinutes\": {\r\n        \"title\": \"Cache TTL (minutes)\",\r\n        \"type\": \"number\",\r\n        \"default\": 30,\r\n        \"description\": \"Time-to-live for cached data entries (RFC-0047: changed from 5 to 30 minutes)\"\r\n      },\r\n      \"enableStaleWhileRevalidate\": {\r\n        \"title\": \"Enable Stale-While-Revalidate\",\r\n        \"type\": \"boolean\",\r\n        \"default\": true,\r\n        \"description\": \"Serve stale data immediately while refreshing in background\"\r\n      },\r\n      \"maxCacheSize\": {\r\n        \"title\": \"Max Cache Size\",\r\n        \"type\": \"number\",\r\n        \"default\": 50,\r\n        \"description\": \"Maximum number of cache entries (LRU eviction)\"\r\n      },\r\n      \"debugMode\": {\r\n        \"title\": \"Debug Mode\",\r\n        \"type\": \"boolean\",\r\n        \"default\": false,\r\n        \"description\": \"Enable console logging and debug overlay (Ctrl+Shift+D)\"\r\n      },\r\n      \"domainsEnabled\": {\r\n        \"title\": \"Enabled Domains\",\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"energy\": {\r\n            \"title\": \"Energy Domain\",\r\n            \"type\": \"boolean\",\r\n            \"default\": true\r\n          },\r\n          \"water\": {\r\n            \"title\": \"Water Domain\",\r\n            \"type\": \"boolean\",\r\n            \"default\": true\r\n          },\r\n          \"temperature\": {\r\n            \"title\": \"Temperature Domain\",\r\n            \"type\": \"boolean\",\r\n            \"default\": true\r\n          }\r\n        }\r\n      },\r\n      \"excludeDevicesAtCountSubtotalCAG\": {\r\n        \"title\": \"Excluir Devices do Subtotal CAG\",\r\n        \"type\": \"array\",\r\n        \"items\": {\r\n          \"type\": \"string\"\r\n        },\r\n        \"default\": [],\r\n        \"description\": \"Lista de Entity IDs do ThingsBoard que serÃ£o excluÃ­dos do cÃ¡lculo de consumo no summary CAG (ClimatizaÃ§Ã£o, Ãreas Comuns, etc). Ex: ['abc123-def456-...', 'xyz789-...']\"\r\n      }\r\n    }\r\n  },\r\n  \"form\": [\r\n    \"customerTB_ID\",\r\n    \"enableCache\",\r\n    \"cacheTtlMinutes\",\r\n    \"enableStaleWhileRevalidate\",\r\n    \"maxCacheSize\",\r\n    \"debugMode\",\r\n    \"domainsEnabled.energy\",\r\n    \"domainsEnabled.water\",\r\n    \"domainsEnabled.temperature\",\r\n    \"excludeDevicesAtCountSubtotalCAG\"\r\n  ]\r\n}\r\n",
      "dataKeySettingsSchema": "{}\n",
      "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Attributes card\",\"decimals\":null}"
    },
    "externalId": null,
    "resources": null,
    "id": {
      "entityType": "WIDGET_TYPE",
      "id": "1faf5e00-a3b5-11f0-afe1-175479a33d89"
    },
    "scada": false,
    "tags": null
  },
  "relations": [],
  "attributes": {
    "SERVER_SCOPE": []
  }
}