{
  "entityType": "WIDGET_TYPE",
  "entity": {
    "fqn": "widget_head_office_equipments_v_5_2_0",
    "name": "Widget Head Office - EQUIPMENTS - v.5.2.0",
    "deprecated": false,
    "image": null,
    "description": null,
    "descriptor": {
      "type": "latest",
      "sizeX": 7.5,
      "sizeY": 3,
      "resources": [
        {
          "url": "https://graphs.staging.apps.myio-bas.com/sdk/energy-chart-sdk.umd.js"
        },
        {
          "url": "https://unpkg.com/myio-js-library@0.1.180/dist/myio-js-library.umd.min.js"
        }
      ],
      "templateHtml": "<div class=\"equip-wrap\" id=\"equipWrap\">\r\n    <!-- RFC-0079: Sub-menu removed - now controlled by MENU widget -->\r\n\r\n    <div class=\"toolbar-zoom\" style=\"display: flex\">\r\n        <div class=\"shopping-filter-chips\"\r\n            id=\"shoppingFilterChips\"></div>\r\n        <!-- RFC-0093: Real-Time Mode Controls + RFC-0103: Power Limits -->\r\n        <div class=\"realtime-controls\" style=\"display: flex; padding: 7px; gap: 10px;\"\r\n          id=\"realtimeControls\">\r\n            <!-- RFC-0103: Power Limits Setup Button -->\r\n            <button id=\"powerLimitsBtn\"\r\n                class=\"power-limits-btn\"\r\n                title=\"Configurar Limites de Potência\">\r\n                <span class=\"btn-icon\">⚙️</span>\r\n                <span class=\"btn-label\">Limites</span>\r\n            </button>\r\n            <button id=\"realtimeToggleBtn\"\r\n                class=\"realtime-toggle\"\r\n                title=\"Ativar modo tempo real\">\r\n                <span class=\"toggle-icon\">⚡</span>\r\n                <span class=\"toggle-label\">Tempo Real</span>\r\n                <span class=\"toggle-status\">OFF</span>\r\n            </button>\r\n            <button id=\"realtimeSettingsBtn\"\r\n                class=\"realtime-settings-btn\"\r\n                title=\"Configurações\" style=\"display: none\">\r\n                <span>⚙️</span>\r\n            </button>\r\n            <div id=\"realtimeConnectionIndicator\"\r\n                class=\"realtime-connection-indicator\"\r\n                style=\"display: none\"></div>\r\n            <div id=\"realtimeProgressContainer\"\r\n                class=\"realtime-progress-container\"\r\n                style=\"display: none\">\r\n                <div class=\"realtime-progress-bar\">\r\n                    <div id=\"realtimeProgressFill\"\r\n                        class=\"realtime-progress-fill\">\r\n                    </div>\r\n                </div>\r\n                <span id=\"realtimeProgressText\"\r\n                    class=\"realtime-progress-text\">30s</span>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- RFC-0093: Header injected dynamically via buildHeaderDevicesGrid -->\r\n    <div id=\"equipHeaderContainer\"></div>\r\n\r\n    <!-- Loading overlay -->\r\n    <div id=\"equipments-loading-overlay\"\r\n        class=\"equipments-loading-overlay\"\r\n        style=\"display: none\">\r\n        <div class=\"loading-spinner\">\r\n            <svg style=\"width: 48px; height: 48px; animation: spin 1s linear infinite\"\r\n                viewBox=\"0 0 50 50\">\r\n                <circle cx=\"25\" cy=\"25\" r=\"20\" fill=\"none\"\r\n                    stroke=\"#6c2fbf\" stroke-width=\"5\"\r\n                    stroke-linecap=\"round\"\r\n                    stroke-dasharray=\"90,150\"\r\n                    stroke-dashoffset=\"0\"></circle>\r\n            </svg>\r\n            <p>Carregando dados de consumo...</p>\r\n        </div>\r\n    </div>\r\n\r\n    <section class=\"equip-grid\" id=\"equipGrid\">\r\n        <div id=\"cards-grid\" class=\"cards-grid\"></div>\r\n    </section>\r\n\r\n    <!-- RFC-0090: Filter Modal injected dynamically via createFilterModal -->\r\n</div>",
      "templateCss": "/* ====== TOKENS (escopo no wrap) ====== */\r\n.equip-wrap {\r\n  /* escala global de fontes (ajustada via JS) */\r\n  --fs: 0.94;\r\n\r\n  /* cores e layout */\r\n  --card-grad: linear-gradient(180deg, #ffffff 0%, #f7fbff 100%);\r\n  --card-bd: #dde7f1;\r\n  --ink-1: #1c2743;\r\n  --ink-2: #6b7a90;\r\n  --blue: #1f6fb5;\r\n  --accent: #9fc131;\r\n  --danger: #e54848;\r\n  --shadow: 0 8px 24px rgba(31, 116, 164, 0.08);\r\n  --shadow-hover: 0 14px 36px rgba(31, 116, 164, 0.16);\r\n  --radius: 20px;\r\n\r\n  /* tipografia derivada da escala */\r\n  --fs-2xs: calc(11px * var(--fs));\r\n  --fs-xs: calc(12px * var(--fs));\r\n  --fs-sm: calc(13px * var(--fs));\r\n  --fs-md: calc(14px * var(--fs));\r\n  --fs-lg: calc(16px * var(--fs));\r\n  --fs-xl: calc(20px * var(--fs));\r\n  --fs-xxl: calc(28px * var(--fs));\r\n\r\n  /* padding para não \"encostar\" no contorno do widget */\r\n  position: relative;\r\n  box-sizing: border-box;\r\n  padding: 12px;\r\n  width: 100%;\r\n  height: 100%;\r\n  overflow: auto;\r\n  background: transparent;\r\n}\r\n\r\n/* ====== RFC-0079: SUB-MENU NAVIGATION ====== */\r\n.equipments-submenu {\r\n  display: flex;\r\n  gap: 8px;\r\n  padding: 12px 16px;\r\n  background: linear-gradient(to bottom, #f8f9fa, #ffffff);\r\n  border-bottom: 2px solid #e0e0e0;\r\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\r\n  margin: -12px -12px 16px -12px; /* Negative margin to extend to widget edges */\r\n}\r\n\r\n.submenu-tab {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n  padding: 10px 20px;\r\n  background: #ffffff;\r\n  border: 1px solid #d0d0d0;\r\n  border-radius: 6px;\r\n  color: #424242;\r\n  font-size: 14px;\r\n  font-weight: 500;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n  outline: none;\r\n}\r\n\r\n.submenu-tab:hover {\r\n  background: #f5f5f5;\r\n  border-color: #7a2ff7;\r\n  color: #7a2ff7;\r\n}\r\n\r\n.submenu-tab.is-active {\r\n  background: linear-gradient(135deg, #7a2ff7, #5a1fd1);\r\n  color: #ffffff;\r\n  border-color: #7a2ff7;\r\n  box-shadow: 0 2px 8px rgba(122, 47, 247, 0.3);\r\n}\r\n\r\n.submenu-tab .ico {\r\n  font-size: 16px;\r\n  line-height: 1;\r\n}\r\n\r\n.submenu-tab:focus-visible {\r\n  outline: 2px solid #7a2ff7;\r\n  outline-offset: 2px;\r\n}\r\n\r\n/* RFC-0079: Sub-menu controls MAIN widget states */\r\n/* No view containers needed in EQUIPMENTS - all controlled via MAIN */\r\n\r\n/* Responsive: Stack tabs vertically on mobile */\r\n@media (max-width: 768px) {\r\n  .equipments-submenu {\r\n    flex-direction: column;\r\n    gap: 6px;\r\n    padding: 10px 12px;\r\n  }\r\n\r\n  .submenu-tab {\r\n    width: 100%;\r\n    justify-content: flex-start;\r\n    padding: 12px 16px;\r\n  }\r\n}\r\n\r\n/* RFC-0093: Header CSS now injected from MAIN via injectHeaderAndModalCSS() */\r\n\r\n/* ====== CONTROLES DE ZOOM ====== */\r\n.toolbar-zoom {\r\n  position: sticky;\r\n  top: 6px;\r\n  z-index: 2;\r\n  display: flex !important;\r\n  flex-direction: row !important;\r\n  flex-wrap: nowrap !important;\r\n  gap: 6px;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  margin-bottom: 8px;\r\n}\r\n\r\n.toolbar-zoom button {\r\n  border: 1px solid var(--card-bd);\r\n  background: #fff;\r\n  border-radius: 10px;\r\n  padding: 4px 10px;\r\n  font-size: var(--fs-lg);\r\n  color: var(--ink-1);\r\n  cursor: pointer;\r\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);\r\n}\r\n\r\n.toolbar-zoom button:hover {\r\n  background: #f3f8fc;\r\n}\r\n\r\n/* ====== SHOPPING FILTER CHIPS ====== */\r\n.shopping-filter-chips {\r\n  display: inline-flex !important;\r\n  gap: 6px;\r\n  flex-wrap: nowrap !important;\r\n  align-items: center;\r\n  flex: 1 1 auto;\r\n  min-width: 0;\r\n  max-width: calc(100% - 380px);\r\n  margin-right: 12px;\r\n  overflow-x: auto;\r\n  overflow-y: hidden;\r\n  scrollbar-width: thin;\r\n  scrollbar-color: #c0c0c0 transparent;\r\n}\r\n\r\n.shopping-filter-chips::-webkit-scrollbar {\r\n  height: 4px;\r\n}\r\n\r\n.shopping-filter-chips::-webkit-scrollbar-track {\r\n  background: transparent;\r\n}\r\n\r\n.shopping-filter-chips::-webkit-scrollbar-thumb {\r\n  background: #c0c0c0;\r\n  border-radius: 2px;\r\n}\r\n\r\n.shopping-filter-chips .filter-chip {\r\n  display: inline-flex;\r\n  align-items: center;\r\n  gap: 6px;\r\n  background: linear-gradient(135deg, #e0f2fe 0%, #dbeafe 100%);\r\n  border: 1px solid #bae6fd;\r\n  border-radius: 8px;\r\n  padding: 3px 8px;\r\n  font-size: var(--fs-xs);\r\n  color: #0c4a6e;\r\n  font-weight: 500;\r\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);\r\n  white-space: nowrap;\r\n  flex-shrink: 0;\r\n}\r\n\r\n.shopping-filter-chips .filter-chip-icon {\r\n  font-size: 10px;\r\n  opacity: 0.7;\r\n}\r\n\r\n.cards-grid {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\r\n  /* responsivo: 4 a 6 cards por linha */\r\n  gap: 16px;\r\n  /* espaço entre os cards */\r\n  margin-top: 24px;\r\n  /* RFC-0079: espaço adicional entre cabeçalho e grid */\r\n}\r\n\r\n.cards-grid > * {\r\n  min-width: 0;\r\n  width: auto;\r\n  box-sizing: border-box;\r\n}\r\n\r\n/* Responsividade da grid: 4 a 6 cards por linha */\r\n@media (min-width: 1920px) {\r\n  .cards-grid {\r\n    grid-template-columns: repeat(6, 1fr);\r\n    /* 6 cards em telas muito grandes (≥1920px) */\r\n    gap: 14px;\r\n  }\r\n}\r\n\r\n@media (min-width: 1600px) and (max-width: 1919px) {\r\n  .cards-grid {\r\n    grid-template-columns: repeat(5, 1fr);\r\n    /* 5 cards em telas grandes (1600-1919px) */\r\n    gap: 15px;\r\n  }\r\n}\r\n\r\n@media (min-width: 1280px) and (max-width: 1599px) {\r\n  .cards-grid {\r\n    grid-template-columns: repeat(5, 1fr);\r\n    /* 5 cards em telas médias (1280-1599px) */\r\n    gap: 14px;\r\n  }\r\n}\r\n\r\n@media (min-width: 1024px) and (max-width: 1279px) {\r\n  .cards-grid {\r\n    grid-template-columns: repeat(4, 1fr);\r\n    /* 4 cards em telas menores (1024-1279px) */\r\n    gap: 16px;\r\n  }\r\n}\r\n\r\n@media (max-width: 1023px) {\r\n  .cards-grid {\r\n    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\r\n    /* responsivo em telas pequenas (<1024px) */\r\n    gap: 12px;\r\n  }\r\n}\r\n\r\n/* ====== CARD ====== */\r\n.equip-card {\r\n  position: relative;\r\n  background-color: #fff;\r\n  /* fallback */\r\n  background-image: var(--card-grad) !important;\r\n  /* gradiente garantido */\r\n  border: 1px solid var(--card-bd);\r\n  border-radius: var(--radius);\r\n  box-shadow: var(--shadow);\r\n  color: var(--ink-1);\r\n  padding: 16px 18px 14px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 14px;\r\n  transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;\r\n  background-clip: padding-box;\r\n  /*overflow: hidden;*/\r\n  /* clip do anel animado */\r\n}\r\n\r\n.equip-card:hover {\r\n  transform: translateY(-2px);\r\n  box-shadow: var(--shadow-hover);\r\n  border-color: #cfdfee;\r\n}\r\n\r\n@keyframes ringBlink {\r\n  0%,\r\n  100% {\r\n    opacity: 0.25;\r\n  }\r\n\r\n  50% {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* ====== TIPOS E BLOCOS ====== */\r\n.equip-hd {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n}\r\n\r\n.equip-id {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 12px;\r\n}\r\n\r\n.equip-icon {\r\n  width: 36px;\r\n  height: 36px;\r\n  border-radius: 12px;\r\n  background: #dce7a8;\r\n  color: #55630a;\r\n  display: grid;\r\n  place-items: center;\r\n  font-weight: 700;\r\n  font-size: var(--fs-md);\r\n}\r\n\r\n.equip-title {\r\n  font-weight: 600;\r\n  line-height: 1.15;\r\n  font-size: var(--fs-lg);\r\n}\r\n\r\n.equip-code {\r\n  font-size: var(--fs-xs);\r\n  color: var(--ink-2);\r\n  margin-top: 2px;\r\n  letter-spacing: 0.2px;\r\n}\r\n\r\n.tb-dashboard-toolbar {\r\n  display: none !important;\r\n}\r\n\r\n.equip-menu {\r\n  border: 0;\r\n  background: transparent;\r\n  color: var(--ink-2);\r\n  font-size: var(--fs-xl);\r\n  cursor: pointer;\r\n  padding: 4px 6px;\r\n  border-radius: 8px;\r\n}\r\n\r\n.equip-menu:hover {\r\n  background: #eef5fb;\r\n  color: var(--ink-1);\r\n}\r\n\r\n.equip-status {\r\n  margin-top: 2px;\r\n}\r\n\r\n.chip {\r\n  display: inline-flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n  font-size: var(--fs-sm);\r\n  padding: 6px 10px;\r\n  border-radius: 999px;\r\n  font-weight: 600;\r\n  color: var(--blue);\r\n  background: #e8f0f6;\r\n}\r\n\r\n.chip .dot {\r\n  width: 8px;\r\n  height: 8px;\r\n  border-radius: 50%;\r\n  background: #6be39a;\r\n  box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.25) inset;\r\n}\r\n\r\n.chip.warn {\r\n  background: #d97706;\r\n}\r\n\r\n.chip.err {\r\n  background: #c2410c;\r\n}\r\n\r\n.chip.offline {\r\n  color: var(--ink-2);\r\n  /* Cor do texto cinza (usando sua variável) */\r\n  background: #f3f4f6;\r\n  /* Fundo cinza bem claro */\r\n  border-color: #e5e7eb;\r\n  /* Borda sutil para definir melhor */\r\n  border-color: #d1d5db;\r\n  /* Borda cinza, como solicitado */\r\n}\r\n\r\n.equip-power {\r\n  display: flex;\r\n  align-items: flex-end;\r\n  gap: 6px;\r\n  justify-content: flex-end;\r\n}\r\n\r\n.power {\r\n  font-size: var(--fs-xxl);\r\n  font-weight: 700;\r\n  letter-spacing: 0.2px;\r\n}\r\n\r\n.unit {\r\n  font-size: var(--fs-lg);\r\n  font-weight: 600;\r\n  color: var(--ink-1);\r\n}\r\n\r\n.sub {\r\n  width: 100%;\r\n  text-align: right;\r\n  color: var(--ink-2);\r\n  font-size: var(--fs-xs);\r\n  margin-top: -2px;\r\n}\r\n\r\n.equip-eff {\r\n  display: grid;\r\n  grid-template-columns: auto 1fr auto;\r\n  gap: 10px;\r\n  align-items: center;\r\n}\r\n\r\n.equip-eff .label {\r\n  color: var(--ink-2);\r\n  font-size: var(--fs-md);\r\n}\r\n\r\n.equip-eff .bar {\r\n  position: relative;\r\n  overflow: hidden;\r\n  height: 8px;\r\n  background: #11324f;\r\n  border-radius: 999px;\r\n}\r\n\r\n.equip-eff .fill {\r\n  position: absolute;\r\n  inset: 0 auto 0 0;\r\n  width: 0%;\r\n  background: linear-gradient(90deg, #1f6fb5 0%, #1f6fb5 70%, var(--accent) 70%, var(--accent) 100%);\r\n  border-radius: 999px;\r\n}\r\n\r\n.equip-eff .pct {\r\n  font-weight: 700;\r\n  font-size: var(--fs-md);\r\n}\r\n\r\n.equip-ft {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  gap: 18px;\r\n  border-top: 1px solid #e8f0f6;\r\n  padding-top: 10px;\r\n}\r\n\r\n.ft-item {\r\n  display: flex;\r\n  gap: 8px;\r\n  align-items: center;\r\n}\r\n\r\n.ft-item .ico {\r\n  font-size: var(--fs-md);\r\n  line-height: 1;\r\n  width: 22px;\r\n  text-align: center;\r\n}\r\n\r\n.ft-item .k {\r\n  color: var(--ink-2);\r\n  font-size: var(--fs-xs);\r\n}\r\n\r\n.ft-item .v {\r\n  font-weight: 600;\r\n  margin-top: 2px;\r\n  font-size: var(--fs-md);\r\n}\r\n\r\n/* === CARD COMPACTO: menor altura e consumo à direita === */\r\n.equip-card.compact {\r\n  padding: 12px 14px !important;\r\n  gap: 10px !important;\r\n  min-height: 150px;\r\n  display: grid !important;\r\n  grid-template-columns: 1fr auto;\r\n  grid-template-rows: auto auto auto auto;\r\n  grid-template-areas:\r\n    'hd     power'\r\n    'status power'\r\n    'eff    eff'\r\n    'ft     ft';\r\n}\r\n\r\n.equip-hd {\r\n  grid-area: hd;\r\n}\r\n\r\n.equip-status {\r\n  grid-area: status;\r\n}\r\n\r\n.equip-eff {\r\n  grid-area: eff;\r\n}\r\n\r\n.equip-ft {\r\n  grid-area: ft;\r\n  margin-top: 2px;\r\n}\r\n\r\n/* consumo (kW) no topo à direita ocupando duas linhas */\r\n.equip-power {\r\n  grid-area: power;\r\n  align-self: center;\r\n  text-align: right;\r\n  margin-left: 16px;\r\n}\r\n\r\n/* redução sutil de elementos para caber 5 cards */\r\n.equip-icon {\r\n  width: 30px !important;\r\n  height: 30px !important;\r\n  border-radius: 10px !important;\r\n}\r\n\r\n.equip-title {\r\n  font-size: var(--fs-md) !important;\r\n}\r\n\r\n.equip-code {\r\n  font-size: var(--fs-2xs) !important;\r\n}\r\n\r\n.equip-eff .bar {\r\n  height: 6px !important;\r\n}\r\n\r\n.equip-ft {\r\n  gap: 14px !important;\r\n  padding-top: 8px !important;\r\n}\r\n\r\n/* ---- Fix: consumo colado na direita no modo compacto ---- */\r\n.equip-card.compact {\r\n  /* 1ª coluna livre, 2ª com largura mínima e elástica */\r\n  grid-template-columns: 1fr minmax(160px, 1fr) !important;\r\n}\r\n\r\n.equip-card.compact .equip-power {\r\n  grid-area: power;\r\n  /* joga o grid item para a borda direita da coluna */\r\n  justify-self: end !important;\r\n  align-self: center !important;\r\n\r\n  /* e dentro dele, tudo alinhado à direita */\r\n  width: 100% !important;\r\n  display: flex !important;\r\n  justify-content: flex-end !important;\r\n  align-items: baseline !important;\r\n  /* número e “kW” na mesma linha base */\r\n  text-align: right !important;\r\n  gap: 6px;\r\n}\r\n\r\n.equip-card.compact .equip-power .power,\r\n.equip-card.compact .equip-power .unit,\r\n.equip-card.compact .equip-power .sub {\r\n  text-align: right !important;\r\n}\r\n\r\n@keyframes ringBlink {\r\n  0%,\r\n  100% {\r\n    opacity: 0.25;\r\n  }\r\n\r\n  50% {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* ====== LOADING OVERLAY ====== */\r\n.equipments-loading-overlay {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  background: rgba(255, 255, 255, 0.95);\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  z-index: 1000;\r\n  backdrop-filter: blur(4px);\r\n}\r\n\r\n.loading-spinner {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  gap: 16px;\r\n}\r\n\r\n.loading-spinner p {\r\n  font-size: var(--fs-md);\r\n  font-weight: 600;\r\n  color: var(--ink-1);\r\n  margin: 0;\r\n}\r\n\r\n@keyframes spin {\r\n  0% {\r\n    transform: rotate(0deg);\r\n  }\r\n  100% {\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n\r\n/* RFC-0093: Filter actions, search, modal, and button styles now injected from MAIN via injectHeaderAndModalCSS() */\r\n\r\n/* ====== RFC-0103: POWER LIMITS BUTTON ====== */\r\n.power-limits-btn {\r\n  display: inline-flex !important;\r\n  align-items: center;\r\n  gap: 6px;\r\n  padding: 6px 12px;\r\n  border: 1px solid #dde7f1;\r\n  border-radius: 8px;\r\n  background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);\r\n  color: var(--ink-1);\r\n  font-size: var(--fs-xs);\r\n  font-weight: 600;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);\r\n  flex-shrink: 0 !important;\r\n  white-space: nowrap;\r\n}\r\n\r\n.power-limits-btn:hover {\r\n  border-color: #4A148C;\r\n  background: linear-gradient(180deg, #f3e8ff 0%, #ede9fe 100%);\r\n  color: #4A148C;\r\n}\r\n\r\n.power-limits-btn:active {\r\n  transform: scale(0.98);\r\n}\r\n\r\n.power-limits-btn .btn-icon {\r\n  font-size: 14px;\r\n}\r\n\r\n.power-limits-btn .btn-label {\r\n  font-size: var(--fs-xs);\r\n}\r\n\r\n/* Responsive: Hide label on smaller screens */\r\n@media (max-width: 768px) {\r\n  .power-limits-btn .btn-label {\r\n    display: none;\r\n  }\r\n\r\n  .power-limits-btn {\r\n    padding: 6px 10px;\r\n  }\r\n}\r\n\r\n/* ====== RFC-0093: REAL-TIME MODE STYLES ====== */\r\n.realtime-controls {\r\n  display: inline-flex !important;\r\n  flex-direction: row !important;\r\n  flex-wrap: nowrap !important;\r\n  align-items: center !important;\r\n  gap: 8px;\r\n  flex-shrink: 0 !important;\r\n  flex-grow: 0 !important;\r\n  margin-left: auto;\r\n  white-space: nowrap;\r\n}\r\n\r\n/* Force all buttons inside realtime-controls to be inline */\r\n.realtime-controls > button,\r\n.realtime-controls > div {\r\n  display: inline-flex !important;\r\n  flex-shrink: 0 !important;\r\n}\r\n\r\n.realtime-toggle {\r\n  display: inline-flex !important;\r\n  align-items: center;\r\n  gap: 6px;\r\n  padding: 6px 12px;\r\n  border: 1px solid #dde7f1;\r\n  border-radius: 8px;\r\n  background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);\r\n  color: var(--ink-1);\r\n  font-size: var(--fs-xs);\r\n  font-weight: 600;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);\r\n  flex-shrink: 0;\r\n  white-space: nowrap;\r\n}\r\n\r\n.realtime-toggle:hover {\r\n  border-color: #f59e0b;\r\n  background: linear-gradient(180deg, #fffbeb 0%, #fef3c7 100%);\r\n}\r\n\r\n.realtime-toggle.active {\r\n  border-color: #f59e0b;\r\n  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);\r\n  color: #ffffff;\r\n  box-shadow: 0 2px 8px rgba(245, 158, 11, 0.35);\r\n  animation: realtimePulse 2s ease-in-out infinite;\r\n}\r\n\r\n.realtime-toggle .toggle-icon {\r\n  font-size: 14px;\r\n}\r\n\r\n.realtime-toggle .toggle-status {\r\n  padding: 2px 6px;\r\n  border-radius: 4px;\r\n  font-size: 10px;\r\n  font-weight: 700;\r\n  background: rgba(0, 0, 0, 0.08);\r\n}\r\n\r\n.realtime-toggle.active .toggle-status {\r\n  background: rgba(255, 255, 255, 0.25);\r\n}\r\n\r\n/* Settings button */\r\n.realtime-settings-btn {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  width: 32px;\r\n  height: 32px;\r\n  border: 1px solid #dde7f1;\r\n  border-radius: 6px;\r\n  background: #fff;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n  font-size: 14px;\r\n}\r\n\r\n.realtime-settings-btn:hover {\r\n  background: #f1f5f9;\r\n  border-color: #f59e0b;\r\n}\r\n\r\n/* Connection indicator */\r\n.realtime-connection-indicator {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 6px;\r\n  padding: 4px 10px;\r\n  border-radius: 6px;\r\n  font-size: 11px;\r\n  font-weight: 600;\r\n  background: #f1f5f9;\r\n  border: 1px solid #dde7f1;\r\n}\r\n\r\n.realtime-connection-indicator.ws-connected {\r\n  background: linear-gradient(180deg, #ecfdf5 0%, #d1fae5 100%);\r\n  border-color: #34d399;\r\n  color: #047857;\r\n}\r\n\r\n.realtime-connection-indicator.rest-mode {\r\n  background: linear-gradient(180deg, #fefce8 0%, #fef08a 100%);\r\n  border-color: #facc15;\r\n  color: #a16207;\r\n}\r\n\r\n.realtime-connection-indicator.disconnected {\r\n  background: linear-gradient(180deg, #fef2f2 0%, #fecaca 100%);\r\n  border-color: #f87171;\r\n  color: #b91c1c;\r\n}\r\n\r\n.realtime-connection-indicator .ws-dot,\r\n.realtime-connection-indicator .rest-dot,\r\n.realtime-connection-indicator .disconnected-dot {\r\n  width: 8px;\r\n  height: 8px;\r\n  border-radius: 50%;\r\n}\r\n\r\n.realtime-connection-indicator .ws-dot {\r\n  background: #10b981;\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.5);\r\n  animation: dotPulse 1.5s ease-in-out infinite;\r\n}\r\n\r\n.realtime-connection-indicator .rest-dot {\r\n  background: #f59e0b;\r\n}\r\n\r\n.realtime-connection-indicator .disconnected-dot {\r\n  background: #ef4444;\r\n  animation: dotPulse 0.8s ease-in-out infinite;\r\n}\r\n\r\n@keyframes dotPulse {\r\n  0%,\r\n  100% {\r\n    opacity: 1;\r\n    transform: scale(1);\r\n  }\r\n  50% {\r\n    opacity: 0.6;\r\n    transform: scale(0.9);\r\n  }\r\n}\r\n\r\n/* Progress bar container */\r\n.realtime-progress-container {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n  padding: 4px 10px;\r\n  background: linear-gradient(180deg, #fffbeb 0%, #fef3c7 100%);\r\n  border: 1px solid #fbbf24;\r\n  border-radius: 8px;\r\n  min-width: 100px;\r\n}\r\n\r\n.realtime-progress-bar {\r\n  flex: 1;\r\n  height: 6px;\r\n  background: rgba(251, 191, 36, 0.3);\r\n  border-radius: 3px;\r\n  overflow: hidden;\r\n  min-width: 50px;\r\n}\r\n\r\n.realtime-progress-fill {\r\n  height: 100%;\r\n  background: linear-gradient(90deg, #f59e0b 0%, #d97706 100%);\r\n  border-radius: 3px;\r\n  width: 100%;\r\n  transition: width 0.1s linear;\r\n}\r\n\r\n.realtime-progress-fill.fetching {\r\n  background: linear-gradient(90deg, #3b82f6 0%, #1d4ed8 100%);\r\n  animation: progressPulse 0.5s ease-in-out infinite;\r\n}\r\n\r\n.realtime-progress-text {\r\n  font-size: 11px;\r\n  font-weight: 700;\r\n  color: #92400e;\r\n  min-width: 24px;\r\n  text-align: right;\r\n}\r\n\r\n.realtime-progress-text.fetching {\r\n  color: #1d4ed8;\r\n}\r\n\r\n@keyframes progressPulse {\r\n  0%,\r\n  100% {\r\n    opacity: 1;\r\n  }\r\n  50% {\r\n    opacity: 0.6;\r\n  }\r\n}\r\n\r\n/* Settings Modal */\r\n.realtime-settings-modal {\r\n  position: fixed;\r\n  inset: 0;\r\n  background: rgba(0, 0, 0, 0.5);\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  z-index: 10000;\r\n  backdrop-filter: blur(4px);\r\n  animation: fadeIn 0.2s ease;\r\n}\r\n\r\n.realtime-settings-modal.hidden {\r\n  display: none;\r\n}\r\n\r\n.realtime-settings-card {\r\n  background: #fff;\r\n  border-radius: 16px;\r\n  width: 90%;\r\n  max-width: 420px;\r\n  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\r\n  overflow: hidden;\r\n}\r\n\r\n.realtime-settings-header {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  padding: 16px 20px;\r\n  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);\r\n  color: #fff;\r\n}\r\n\r\n.realtime-settings-header h3 {\r\n  margin: 0;\r\n  font-size: 16px;\r\n  font-weight: 700;\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n}\r\n\r\n.realtime-settings-close {\r\n  background: rgba(255, 255, 255, 0.2);\r\n  border: none;\r\n  color: #fff;\r\n  width: 28px;\r\n  height: 28px;\r\n  border-radius: 6px;\r\n  cursor: pointer;\r\n  font-size: 18px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  transition: background 0.2s;\r\n}\r\n\r\n.realtime-settings-close:hover {\r\n  background: rgba(255, 255, 255, 0.3);\r\n}\r\n\r\n.realtime-settings-body {\r\n  padding: 20px;\r\n}\r\n\r\n.realtime-settings-group {\r\n  margin-bottom: 20px;\r\n}\r\n\r\n.realtime-settings-label {\r\n  display: block;\r\n  font-size: 13px;\r\n  font-weight: 600;\r\n  color: var(--ink-1);\r\n  margin-bottom: 8px;\r\n}\r\n\r\n.realtime-settings-sublabel {\r\n  font-size: 11px;\r\n  color: var(--ink-2);\r\n  font-weight: 400;\r\n  display: block;\r\n  margin-top: 2px;\r\n}\r\n\r\n/* Engine selector */\r\n.realtime-engine-selector {\r\n  display: flex;\r\n  gap: 8px;\r\n}\r\n\r\n.realtime-engine-btn {\r\n  flex: 1;\r\n  padding: 10px 14px;\r\n  border: 2px solid #dde7f1;\r\n  border-radius: 8px;\r\n  background: #fff;\r\n  font-size: 13px;\r\n  font-weight: 600;\r\n  color: var(--ink-1);\r\n  cursor: pointer;\r\n  transition: all 0.2s;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  gap: 6px;\r\n}\r\n\r\n.realtime-engine-btn:hover {\r\n  border-color: #f59e0b;\r\n  background: #fffbeb;\r\n}\r\n\r\n.realtime-engine-btn.active {\r\n  border-color: #f59e0b;\r\n  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);\r\n  color: #fff;\r\n}\r\n\r\n/* Interval selector */\r\n.realtime-interval-selector {\r\n  display: flex;\r\n  gap: 8px;\r\n  flex-wrap: wrap;\r\n}\r\n\r\n.realtime-interval-btn {\r\n  padding: 8px 14px;\r\n  border: 2px solid #dde7f1;\r\n  border-radius: 8px;\r\n  background: #fff;\r\n  font-size: 13px;\r\n  font-weight: 600;\r\n  color: var(--ink-1);\r\n  cursor: pointer;\r\n  transition: all 0.2s;\r\n}\r\n\r\n.realtime-interval-btn:hover {\r\n  border-color: #f59e0b;\r\n  background: #fffbeb;\r\n}\r\n\r\n.realtime-interval-btn.active {\r\n  border-color: #f59e0b;\r\n  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);\r\n  color: #fff;\r\n}\r\n\r\n.realtime-settings-footer {\r\n  display: flex;\r\n  gap: 10px;\r\n  justify-content: flex-end;\r\n  padding: 16px 20px;\r\n  border-top: 1px solid #dde7f1;\r\n}\r\n\r\n.realtime-settings-btn-cancel,\r\n.realtime-settings-btn-save {\r\n  padding: 10px 20px;\r\n  border-radius: 8px;\r\n  font-size: 13px;\r\n  font-weight: 600;\r\n  cursor: pointer;\r\n  transition: all 0.2s;\r\n}\r\n\r\n.realtime-settings-btn-cancel {\r\n  background: #f1f5f9;\r\n  border: 1px solid #dde7f1;\r\n  color: var(--ink-1);\r\n}\r\n\r\n.realtime-settings-btn-cancel:hover {\r\n  background: #e2e8f0;\r\n}\r\n\r\n.realtime-settings-btn-save {\r\n  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);\r\n  border: none;\r\n  color: #fff;\r\n}\r\n\r\n.realtime-settings-btn-save:hover {\r\n  filter: brightness(1.1);\r\n}\r\n\r\n@keyframes fadeIn {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n@keyframes realtimePulse {\r\n  0%,\r\n  100% {\r\n    box-shadow: 0 2px 8px rgba(245, 158, 11, 0.35);\r\n  }\r\n  50% {\r\n    box-shadow: 0 2px 16px rgba(245, 158, 11, 0.55);\r\n  }\r\n}\r\n\r\n/* Real-Time Card Styles */\r\n.equip-card.realtime-mode {\r\n  border-color: #fbbf24;\r\n  box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.2), var(--shadow);\r\n}\r\n\r\n.equip-card.realtime-mode .realtime-badge {\r\n  position: absolute;\r\n  top: 8px;\r\n  right: 8px;\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 4px;\r\n  padding: 3px 8px;\r\n  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);\r\n  color: #ffffff;\r\n  font-size: 9px;\r\n  font-weight: 700;\r\n  border-radius: 4px;\r\n  text-transform: uppercase;\r\n  letter-spacing: 0.5px;\r\n  box-shadow: 0 2px 6px rgba(245, 158, 11, 0.3);\r\n}\r\n\r\n.equip-card.realtime-mode .realtime-badge .live-dot {\r\n  width: 6px;\r\n  height: 6px;\r\n  background: #ffffff;\r\n  border-radius: 50%;\r\n  animation: liveDotBlink 1s ease-in-out infinite;\r\n}\r\n\r\n@keyframes liveDotBlink {\r\n  0%,\r\n  100% {\r\n    opacity: 1;\r\n  }\r\n  50% {\r\n    opacity: 0.4;\r\n  }\r\n}\r\n\r\n.equip-card.realtime-mode .power-realtime {\r\n  font-size: var(--fs-xxl);\r\n  font-weight: 700;\r\n  color: #d97706;\r\n  letter-spacing: 0.2px;\r\n}\r\n\r\n.equip-card.realtime-mode .last-update {\r\n  font-size: var(--fs-2xs);\r\n  color: var(--ink-2);\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 4px;\r\n  margin-top: 2px;\r\n}\r\n\r\n.equip-card.realtime-mode .last-update .update-icon {\r\n  font-size: 10px;\r\n}\r\n\r\n.equip-card.realtime-mode .chip.online {\r\n  background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);\r\n  color: #ffffff;\r\n}\r\n\r\n.equip-card.realtime-mode .chip.offline {\r\n  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);\r\n  color: #ffffff;\r\n}\r\n",
      "controllerScript": "/* global self, window, document, localStorage, MyIOLibrary, requestAnimationFrame, $ */\r\n\r\n// ============================================\r\n// SHARED UTILITIES (from MAIN via window.MyIOUtils)\r\n// ============================================\r\n// Use shared utilities from MAIN, with fallback to local implementation\r\nconst LogHelper = window.MyIOUtils?.LogHelper || {\r\n  log: (...args) => console.log(...args),\r\n  warn: (...args) => console.warn(...args),\r\n  error: (...args) => console.error(...args),\r\n};\r\n\r\nconst getDataApiHost = () => {\r\n  const host = window.MyIOUtils?.DATA_API_HOST;\r\n  if (!host) {\r\n    console.error('[EQUIPMENTS] DATA_API_HOST not available - MAIN widget not loaded');\r\n  }\r\n  return host || '';\r\n};\r\n\r\n// RFC-0071: Device Profile functions (from MAIN)\r\nconst syncDeviceProfileAttributes = window.MyIOUtils?.syncDeviceProfileAttributes;\r\n\r\n// RFC-0078: Power Limits functions (from MAIN)\r\nconst getConsumptionRangesHierarchical = window.MyIOUtils?.getConsumptionRangesHierarchical;\r\nconst getCachedConsumptionLimits = window.MyIOUtils?.getCachedConsumptionLimits;\r\n\r\n// UI Helpers (from MAIN)\r\nconst formatRelativeTime =\r\n  window.MyIOUtils?.formatRelativeTime || ((ts) => (ts ? new Date(ts).toLocaleString() : '—'));\r\nconst formatarDuracao = window.MyIOUtils?.formatarDuracao || ((ms) => `${Math.round(ms / 1000)}s`);\r\nconst showLoadingOverlay =\r\n  window.MyIOUtils?.showLoadingOverlay ||\r\n  ((show) => {\r\n    const overlay = document.getElementById('equipments-loading-overlay');\r\n    if (overlay) overlay.style.display = show ? 'flex' : 'none';\r\n  });\r\nconst updateEquipmentStats = window.MyIOUtils?.updateEquipmentStats;\r\nconst getCustomerNameForDevice =\r\n  window.MyIOUtils?.getCustomerNameForDevice || ((device) => device.customerId || 'N/A');\r\n\r\n// ============================================\r\n// EQUIPMENTS WIDGET STATE\r\n// ============================================\r\nlet CUSTOMER_ID;\r\nlet CLIENT_ID;\r\nlet CLIENT_SECRET;\r\nlet MAP_INSTANTANEOUS_POWER;\r\nlet DELAY_TIME_CONNECTION_MINS;\r\nlet myIOAuth; // Instance of MyIO auth component from MyIOLibrary\r\nlet activeCardComponents = [];\r\n\r\n// RFC-0093: Centralized header controller\r\nlet equipHeaderController = null;\r\n\r\n// Card rendering options (from settings, with defaults)\r\nlet USE_NEW_COMPONENTS = true;\r\nlet ENABLE_SELECTION = true;\r\nlet ENABLE_DRAG_DROP = true;\r\nlet HIDE_INFO_MENU_ITEM = true;\r\nlet DEBUG_ACTIVE = false;\r\nlet ACTIVE_TOOLTIP_DEBUG = false;\r\n\r\nLogHelper.log('[MYIO EQUIPMENTS] Script loaded, using shared utilities:', !!window.MyIOUtils);\r\n\r\n// RFC-0071: Device Profile Synchronization - Global flag to track if sync has been completed\r\nlet __deviceProfileSyncComplete = false;\r\n\r\n// Store customer limits JSON globally for the widget session\r\nwindow.__customerPowerLimitsJSON = null;\r\n\r\n// findValue helper function (from MAIN via MyIOUtils)\r\n// RFC-0091: Fallback supports both { key, value } and { dataType, value } formats\r\nconst findValue =\r\n  window.MyIOUtils?.findValue ||\r\n  ((values, key, defaultValue = null) => {\r\n    console.error('[EQUIPMENTS] findValue not available - MAIN widget not loaded');\r\n    if (!Array.isArray(values)) return defaultValue;\r\n    const found = values.find((v) => v.key === key || v.dataType === key);\r\n    return found ? found.value : defaultValue;\r\n  });\r\n\r\n// NOTE: fetchCustomerServerScopeAttrs is provided by MAIN via window.MyIOUtils\r\nconst fetchCustomerServerScopeAttrs =\r\n  window.MyIOUtils?.fetchCustomerServerScopeAttrs ||\r\n  (() => {\r\n    console.error('[EQUIPMENTS] fetchCustomerServerScopeAttrs not available - MAIN widget not loaded');\r\n    return {};\r\n  });\r\n\r\n/**\r\n * Creates a proper modal backdrop\r\n * @returns {HTMLElement} The backdrop element\r\n */\r\nfunction createModalBackdrop() {\r\n  const backdrop = document.createElement('div');\r\n  backdrop.className = 'dashboard-modal-backdrop';\r\n  backdrop.style.cssText = `\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    background: rgba(0, 0, 0, 0.6);\r\n    z-index: 9998;\r\n    animation: fadeIn 0.2s ease-in;\r\n  `;\r\n\r\n  // Close on backdrop click\r\n  backdrop.addEventListener('click', (e) => {\r\n    if (e.target === backdrop) {\r\n      closeExistingModals();\r\n    }\r\n  });\r\n\r\n  return backdrop;\r\n}\r\n\r\n/**\r\n * Closes any existing modal instances to prevent conflicts\r\n */\r\nfunction closeExistingModals() {\r\n  // Close any existing energy dashboards\r\n  const existingModals = document.querySelectorAll(\r\n    '.energy-dashboard-modal, .dashboard-popup, .myio-modal-overlay'\r\n  );\r\n  existingModals.forEach((modal) => {\r\n    modal.remove();\r\n  });\r\n\r\n  // Remove backdrops\r\n  const backdrops = document.querySelectorAll('.dashboard-modal-backdrop, .modal-backdrop');\r\n  backdrops.forEach((backdrop) => {\r\n    backdrop.remove();\r\n  });\r\n\r\n  LogHelper.log('[EQUIPMENTS] [RFC-0072] Cleaned up existing modals');\r\n}\r\n\r\n// NOTE: getCustomerNameForDevice is now provided by MAIN via window.MyIOUtils (see const declaration at top of file)\r\n\r\n// ============================================\r\n// END RFC-0072 MODAL UTILITIES\r\n// ============================================\r\n\r\n// Initialize cards\r\n// Initialize cards\r\nfunction initializeCards(devices) {\r\n  // 1. LIMPEZA: Destrói instâncias antigas para remover ouvintes de eventos da memória\r\n  if (typeof activeCardComponents !== 'undefined' && Array.isArray(activeCardComponents)) {\r\n    activeCardComponents.forEach((comp) => {\r\n      if (comp && typeof comp.destroy === 'function') {\r\n        comp.destroy();\r\n      }\r\n    });\r\n    activeCardComponents = []; // Zera a lista\r\n  }\r\n\r\n  const grid = document.getElementById('cards-grid');\r\n  grid.innerHTML = '';\r\n\r\n  devices.forEach((device, _index) => {\r\n    const container = document.createElement('div');\r\n    //LogHelper.log(\"[EQUIPMENTS] Rendering device:\", device);\r\n    grid.appendChild(container);\r\n\r\n    // Garantir que o deviceStatus existe (fallback para no_info se não existir)\r\n    if (!device.deviceStatus) {\r\n      LogHelper.log('[EQUIPMENTS] Rendering device:', device);\r\n      device.deviceStatus = device.connectionStatus;\r\n    }\r\n\r\n    const customerName = getCustomerNameForDevice(device);\r\n    device.customerName = customerName;\r\n    device.domain = 'energy'; // RFC-0087: Energy domain for kWh/MWh/GWh formatting\r\n\r\n    // RFC-0091: delayTimeConnectionInMins - configurable via MAIN settings (required)\r\n    const delayTimeConnectionInMins = window.MyIOUtils?.getDelayTimeConnectionInMins?.();\r\n    if (delayTimeConnectionInMins === undefined || delayTimeConnectionInMins === null) {\r\n      LogHelper.error(\r\n        '[EQUIPMENTS] delayTimeConnectionInMins não informado. Verifique se MyIOUtils.getDelayTimeConnectionInMins() está disponível.'\r\n      );\r\n    }\r\n\r\n    // 2. RENDERIZAÇÃO: Capturamos a instância retornada na variável 'cardInstance'\r\n    const cardInstance = MyIOLibrary.renderCardComponentHeadOffice(container, {\r\n      entityObject: device,\r\n      debugActive: DEBUG_ACTIVE,\r\n      activeTooltipDebug: ACTIVE_TOOLTIP_DEBUG,\r\n      delayTimeConnectionInMins,\r\n\r\n      // 3. SELEÇÃO INICIAL: Verifica na Store se este card já deve nascer selecionado\r\n      isSelected: (function () {\r\n        const store = window.MyIOLibrary?.MyIOSelectionStore || window.MyIOSelectionStore;\r\n        // Verifica se a store existe e se o ID deste device está na lista\r\n        return store ? store.getSelectedIds().includes(device.entityId) : false;\r\n      })(),\r\n\r\n      handleActionDashboard: async () => {\r\n        // RFC-0072: Enhanced modal handling to prevent corruption\r\n        LogHelper.log('[EQUIPMENTS] [RFC-0072] Opening energy dashboard for:', device.entityId);\r\n\r\n        try {\r\n          // 1. Ensure component is available\r\n          if (typeof MyIOLibrary.openDashboardPopupEnergy !== 'function') {\r\n            LogHelper.error('[EQUIPMENTS] [RFC-0072] openDashboardPopupEnergy component not loaded');\r\n            window.window.alert('Dashboard component não disponível');\r\n            return;\r\n          }\r\n\r\n          // 2. Clean up any existing modal state\r\n          closeExistingModals();\r\n\r\n          // 3. Get tokens (RFC-0093: Guard against undefined myIOAuth)\r\n          if (!myIOAuth || typeof myIOAuth.getToken !== 'function') {\r\n            LogHelper.error('[EQUIPMENTS] myIOAuth not available');\r\n            window.alert('Autenticação não disponível. Recarregue a página.');\r\n            return;\r\n          }\r\n\r\n          const tokenIngestionDashBoard = await myIOAuth.getToken();\r\n          const myTbTokenDashBoard = localStorage.getItem('jwt_token');\r\n\r\n          if (!myTbTokenDashBoard) {\r\n            throw new Error('JWT token não encontrado');\r\n          }\r\n\r\n          // 4. Inject backdrop first\r\n          const backdrop = createModalBackdrop();\r\n          document.body.appendChild(backdrop);\r\n\r\n          // 5. Wait for next frame to ensure DOM is ready\r\n          await new Promise((resolve) => requestAnimationFrame(resolve));\r\n\r\n          // 6. Open modal with proper error handling\r\n          const modal = MyIOLibrary.openDashboardPopupEnergy({\r\n            deviceId: device.entityId,\r\n            readingType: 'energy',\r\n            startDate: self.ctx.$scope.startDateISO,\r\n            endDate: self.ctx.$scope.endDateISO,\r\n            tbJwtToken: myTbTokenDashBoard,\r\n            ingestionToken: tokenIngestionDashBoard,\r\n            clientId: CLIENT_ID,\r\n            clientSecret: CLIENT_SECRET,\r\n            onOpen: (context) => {\r\n              LogHelper.log('[EQUIPMENTS] [RFC-0072] Modal opened:', context);\r\n            },\r\n            onError: (error) => {\r\n              LogHelper.error('[EQUIPMENTS] [RFC-0072] Modal error:', error);\r\n              backdrop.remove();\r\n              window.alert(`Erro: ${error.message}`);\r\n            },\r\n            onClose: () => {\r\n              backdrop.remove();\r\n              const overlay = document.querySelector('.myio-modal-overlay');\r\n              if (overlay) {\r\n                overlay.remove();\r\n              }\r\n              LogHelper.log('[EQUIPMENTS] [RFC-0072] Energy dashboard closed');\r\n            },\r\n          });\r\n\r\n          // 7. Verify modal was created\r\n          if (!modal) {\r\n            LogHelper.error('[EQUIPMENTS] [RFC-0072] Modal failed to initialize');\r\n            backdrop.remove();\r\n            window.alert('Erro ao abrir dashboard');\r\n            return;\r\n          }\r\n\r\n          LogHelper.log('[EQUIPMENTS] [RFC-0072] Energy dashboard opened successfully');\r\n        } catch (err) {\r\n          LogHelper.error('[EQUIPMENTS] [RFC-0072] Error opening energy dashboard:', err);\r\n          closeExistingModals();\r\n          window.alert('Credenciais ainda carregando. Tente novamente em instantes.');\r\n        }\r\n      },\r\n\r\n      handleActionReport: async () => {\r\n        try {\r\n          // RFC-0093: Guard against undefined myIOAuth\r\n          if (!myIOAuth || typeof myIOAuth.getToken !== 'function') {\r\n            LogHelper.error('[EQUIPMENTS] myIOAuth not available for report');\r\n            window.alert('Autenticação não disponível. Recarregue a página.');\r\n            return;\r\n          }\r\n          const ingestionToken = await myIOAuth.getToken();\r\n\r\n          if (!ingestionToken) throw new Error('No ingestion token');\r\n\r\n          await MyIOLibrary.openDashboardPopupReport({\r\n            ingestionId: device.ingestionId,\r\n            identifier: device.deviceIdentifier,\r\n            label: device.labelOrName,\r\n            domain: 'energy',\r\n            api: {\r\n              dataApiBaseUrl: getDataApiHost(),\r\n              clientId: CLIENT_ID,\r\n              clientSecret: CLIENT_SECRET,\r\n              ingestionToken,\r\n            },\r\n          });\r\n        } catch (err) {\r\n          LogHelper.warn('[EQUIPMENTS] Report open blocked:', err?.message || err);\r\n          window.alert('Credenciais ainda carregando. Tente novamente em instantes.');\r\n        }\r\n      },\r\n\r\n      handleActionSettings: async () => {\r\n        // RFC-0072: Standardized settings handler following TELEMETRY pattern\r\n        const jwt = localStorage.getItem('jwt_token');\r\n\r\n        if (!jwt) {\r\n          LogHelper.error('[EQUIPMENTS] [RFC-0072] JWT token not found');\r\n          window.alert('Token de autenticação não encontrado');\r\n          return;\r\n        }\r\n\r\n        try {\r\n          // RFC-0072: Following exact TELEMETRY pattern with domain and connectionData\r\n          // RFC-0077: Added customerName and deviceType parameters\r\n          // RFC-0076: Added deviceProfile for 3F_MEDIDOR fallback rule\r\n          await MyIOLibrary.openDashboardPopupSettings({\r\n            deviceId: device.entityId, // TB deviceId\r\n            label: device.labelOrName,\r\n            jwtToken: jwt,\r\n            domain: 'energy', // Same as TELEMETRY WIDGET_DOMAIN\r\n            deviceType: device.deviceType, // RFC-0077: Pass deviceType for Power Limits feature\r\n            deviceProfile: device.deviceProfile, // RFC-0076: Pass deviceProfile for 3F_MEDIDOR fallback\r\n            customerName: device.customerName || getCustomerNameForDevice(device), // RFC-0077: Pass shopping name\r\n            connectionData: {\r\n              centralName: device.centralName || getCustomerNameForDevice(device),\r\n              connectionStatusTime: device.lastConnectTime,\r\n              timeVal: device.lastActivityTime || new Date('1970-01-01').getTime(),\r\n              deviceStatus:\r\n                device.deviceStatus !== 'power_off' && device.deviceStatus !== 'not_installed'\r\n                  ? 'power_on'\r\n                  : 'power_off',\r\n              lastDisconnectTime: device.lastDisconnectTime || 0,\r\n            },\r\n            ui: { title: 'Configurações', width: 900 },\r\n            mapInstantaneousPower: device.mapInstantaneousPower, // RFC-0078: Pass existing map if available\r\n            onSaved: (payload) => {\r\n              LogHelper.log('[EQUIPMENTS] [RFC-0072] Settings saved:', payload);\r\n              // Mostra modal global de sucesso com contador e reload\r\n              //showGlobalSuccessModal(6);\r\n            },\r\n            onClose: () => {\r\n              $('.myio-settings-modal-overlay').remove();\r\n              const overlay = document.querySelector('.myio-modal-overlay');\r\n              if (overlay) {\r\n                overlay.remove();\r\n              }\r\n              LogHelper.log('[EQUIPMENTS] [RFC-0072] Settings modal closed');\r\n            },\r\n          });\r\n        } catch (e) {\r\n          LogHelper.error('[EQUIPMENTS] [RFC-0072] Error opening settings:', e);\r\n          window.alert('Erro ao abrir configurações');\r\n        }\r\n      },\r\n\r\n      handleSelect: (checked, entity) => {\r\n        // Busca a Store global\r\n        const MyIOSelectionStore = window.MyIOLibrary?.MyIOSelectionStore || window.MyIOSelectionStore;\r\n        if (MyIOSelectionStore) {\r\n          if (checked) {\r\n            // 1. IMPORTANTE: Registra os dados (Nome, Valor, Unidade) na Store\r\n            if (MyIOSelectionStore.registerEntity) {\r\n              // console.log('[Main Widget] Registering entity in MyIOSelectionStore:', entity);\r\n              MyIOSelectionStore.registerEntity(entity);\r\n            }\r\n            // 2. Adiciona o ID na lista de selecionados\r\n            MyIOSelectionStore.add(entity.entityId || entity.id);\r\n          } else {\r\n            // 3. Remove o ID da lista\r\n            MyIOSelectionStore.remove(entity.entityId || entity.id);\r\n          }\r\n        } else {\r\n          console.warn('[Main Widget] MyIOSelectionStore não encontrada!');\r\n        }\r\n      },\r\n\r\n      handleClickCard: (ev, entity) => {\r\n        LogHelper.log(`Card clicked: ${entity.labelOrName} - Power: ${entity.val}kWh`);\r\n      },\r\n\r\n      useNewComponents: USE_NEW_COMPONENTS,\r\n      enableSelection: ENABLE_SELECTION,\r\n      enableDragDrop: ENABLE_DRAG_DROP,\r\n      // RFC-0072: Disable \"More Information\" menu item (redundant with card click)\r\n      hideInfoMenuItem: HIDE_INFO_MENU_ITEM,\r\n    });\r\n\r\n    // 4. PERSISTÊNCIA: Guarda a instância criada na lista global para limpeza futura\r\n    activeCardComponents.push(cardInstance);\r\n  });\r\n\r\n  LogHelper.log('[EQUIPMENTS] Cards initialized successfully (Event-Driven Mode)');\r\n}\r\n\r\nself.onInit = async function () {\r\n  // RFC-0091: Protection against duplicate onInit calls (use global scope for multiple widget instances)\r\n  if (window.__EQUIPMENTS_INITIALIZED__) {\r\n    LogHelper.log('[EQUIPMENTS] onInit - already initialized, skipping duplicate call');\r\n    return;\r\n  }\r\n  window.__EQUIPMENTS_INITIALIZED__ = true;\r\n\r\n  LogHelper.log('[EQUIPMENTS] onInit - ctx:', self.ctx);\r\n\r\n  // Load card rendering options from settings\r\n  USE_NEW_COMPONENTS = self.ctx.settings?.useNewComponents ?? true;\r\n  ENABLE_SELECTION = self.ctx.settings?.enableSelection ?? true;\r\n  ENABLE_DRAG_DROP = self.ctx.settings?.enableDragDrop ?? true;\r\n  HIDE_INFO_MENU_ITEM = self.ctx.settings?.hideInfoMenuItem ?? true;\r\n  DEBUG_ACTIVE = self.ctx.settings?.debugActive ?? false;\r\n  ACTIVE_TOOLTIP_DEBUG = self.ctx.settings?.activeTooltipDebug ?? false;\r\n  LogHelper.log(\r\n    `[EQUIPMENTS] Configured: debugActive=${DEBUG_ACTIVE}, activeTooltipDebug=${ACTIVE_TOOLTIP_DEBUG}`\r\n  );\r\n\r\n  // RFC-0093: Build centralized header via buildHeaderDevicesGrid\r\n  const buildHeaderDevicesGrid = window.MyIOUtils?.buildHeaderDevicesGrid;\r\n  if (buildHeaderDevicesGrid) {\r\n    equipHeaderController = buildHeaderDevicesGrid({\r\n      container: '#equipHeaderContainer',\r\n      domain: 'energy',\r\n      idPrefix: 'equip',\r\n      labels: {\r\n        total: 'Total de Equipamentos',\r\n        consumption: 'Consumo Total de Todos Equipamentos',\r\n      },\r\n      includeSearch: true,\r\n      includeFilter: true,\r\n      onSearchClick: () => {\r\n        STATE.searchActive = !STATE.searchActive;\r\n        if (STATE.searchActive) {\r\n          const input = equipHeaderController?.getSearchInput();\r\n          if (input) setTimeout(() => input.focus(), 100);\r\n        }\r\n      },\r\n      onFilterClick: () => {\r\n        openFilterModal();\r\n      },\r\n    });\r\n\r\n    // Setup search input listener\r\n    const searchInput = equipHeaderController?.getSearchInput();\r\n    if (searchInput) {\r\n      searchInput.addEventListener('input', (e) => {\r\n        STATE.searchTerm = e.target.value || '';\r\n        reflowCards();\r\n      });\r\n    }\r\n\r\n    LogHelper.log('[EQUIPMENTS] RFC-0093: Header built via buildHeaderDevicesGrid');\r\n  } else {\r\n    LogHelper.warn('[EQUIPMENTS] RFC-0093: buildHeaderDevicesGrid not available');\r\n  }\r\n\r\n  // ⭐ CRITICAL FIX: Show loading IMMEDIATELY before setTimeout\r\n  showLoadingOverlay(true);\r\n\r\n  setTimeout(async () => {\r\n    // -- util: aplica no $scope e roda digest\r\n    function applyParams(p) {\r\n      self.ctx.$scope.startDateISO = p?.globalStartDateFilter || null;\r\n      self.ctx.$scope.endDateISO = p?.globalEndDateFilter || null;\r\n      if (self.ctx?.$scope?.$applyAsync) self.ctx.$scope.$applyAsync();\r\n    }\r\n\r\n    // -- util: espera até ter datas (evento + polling), sem bloquear\r\n    function waitForDateParams({ pollMs = 300, timeoutMs = 15000 } = {}) {\r\n      return new Promise((resolve) => {\r\n        let resolved = false;\r\n        let poller = null;\r\n        let timer = null;\r\n\r\n        const tryResolve = (p) => {\r\n          const s = p?.globalStartDateFilter || null;\r\n          const e = p?.globalEndDateFilter || null;\r\n          if (s && e) {\r\n            resolved = true;\r\n            cleanup();\r\n            applyParams(p);\r\n            resolve({ start: s, end: e, from: 'state/event' });\r\n            return true;\r\n          }\r\n          return false;\r\n        };\r\n\r\n        const onEvt = (ev) => {\r\n          tryResolve(ev.detail);\r\n        };\r\n\r\n        const cleanup = () => {\r\n          window.removeEventListener('myio:date-params', onEvt);\r\n          if (poller) clearInterval(poller);\r\n          if (timer) clearTimeout(timer);\r\n        };\r\n\r\n        // 1) escuta evento do pai\r\n        window.addEventListener('myio:date-params', onEvt);\r\n\r\n        // 2) tenta estado atual imediatamente\r\n        if (tryResolve(window.myioStateParams || {})) return;\r\n\r\n        // 3) solicita explicitamente ao pai\r\n        window.dispatchEvent(new CustomEvent('myio:request-date-params'));\r\n\r\n        // 4) polling leve a cada 300ms\r\n        poller = setInterval(() => {\r\n          tryResolve(window.myioStateParams || {});\r\n        }, pollMs);\r\n\r\n        // 5) timeout de segurança -> usa fallback (últimos 7 dias)\r\n        timer = setTimeout(() => {\r\n          if (!resolved) {\r\n            cleanup();\r\n            const end = new Date();\r\n            const start = new Date(end.getTime() - 7 * 24 * 60 * 60 * 1000);\r\n            const startISO = start.toISOString();\r\n            const endISO = end.toISOString();\r\n            applyParams({\r\n              globalStartDateFilter: startISO,\r\n              globalEndDateFilter: endISO,\r\n            });\r\n            resolve({ start: startISO, end: endISO, from: 'fallback-7d' });\r\n          }\r\n        }, timeoutMs);\r\n      });\r\n    }\r\n\r\n    // ====== fluxo do widget ======\r\n    // tenta aplicar o que já existir (não bloqueia)\r\n    applyParams(window.myioStateParams || {});\r\n\r\n    // garante sincronização inicial antes de continuar\r\n    const datesFromParent = await waitForDateParams({\r\n      pollMs: 300,\r\n      timeoutMs: 15000,\r\n    });\r\n    LogHelper.log('[EQUIPMENTS] date params ready:', datesFromParent);\r\n\r\n    // agora já pode carregar dados / inicializar UI dependente de datas\r\n    if (typeof self.loadData === 'function') {\r\n      await self.loadData(self.ctx.$scope.startDateISO, self.ctx.$scope.endDateISO);\r\n    }\r\n\r\n    // mantém sincronizado em updates futuros do pai/irmão A\r\n    self._onDateParams = (ev) => {\r\n      applyParams(ev.detail);\r\n      if (typeof self.loadData === 'function') {\r\n        self.loadData(self.ctx.$scope.startDateISO, self.ctx.$scope.endDateISO);\r\n      }\r\n    };\r\n    window.addEventListener('myio:date-params', self._onDateParams);\r\n\r\n    // ✅ Listen for shopping filter from MENU\r\n    self._onFilterApplied = (ev) => {\r\n      LogHelper.log('[EQUIPMENTS] heard myio:filter-applied:', ev.detail);\r\n\r\n      // Extract shopping IDs from selection\r\n      const selection = ev.detail?.selection || [];\r\n      const shoppingIds = selection.map((s) => s.value).filter((v) => v);\r\n\r\n      LogHelper.log(\r\n        '[EQUIPMENTS] Applying shopping filter:',\r\n        shoppingIds.length === 0 ? 'ALL' : `${shoppingIds.length} shoppings`\r\n      );\r\n\r\n      // Update STATE and reflow cards\r\n      STATE.selectedShoppingIds = shoppingIds;\r\n\r\n      // Render shopping filter chips\r\n      renderShoppingFilterChips(selection);\r\n\r\n      reflowCards();\r\n    };\r\n    window.addEventListener('myio:filter-applied', self._onFilterApplied);\r\n\r\n    // Function to render shopping filter chips in toolbar\r\n    function renderShoppingFilterChips(selection) {\r\n      const chipsContainer = document.getElementById('shoppingFilterChips');\r\n      if (!chipsContainer) return;\r\n\r\n      chipsContainer.innerHTML = '';\r\n\r\n      LogHelper.log('[EQUIPMENTS] STATE.selectedShoppingIds', STATE.selectedShoppingIds);\r\n\r\n      if (!selection || selection.length === 0) {\r\n        return; // No filter applied, hide chips\r\n      }\r\n\r\n      selection.forEach((shopping) => {\r\n        const chip = document.createElement('span');\r\n        chip.className = 'filter-chip';\r\n        chip.innerHTML = `<span class=\"filter-chip-icon\">🏬</span><span>${shopping.name}</span>`;\r\n        chipsContainer.appendChild(chip);\r\n      });\r\n\r\n      LogHelper.log('[EQUIPMENTS] 📍 Rendered', selection.length, 'shopping filter chips');\r\n    }\r\n\r\n    // ============================================\r\n    // CREDENTIALS: Use MAIN's credentials via MyIOUtils\r\n    // ============================================\r\n    // Hierarchy:\r\n    // 1. window.MyIOUtils.getCredentials() - from MAIN (preferred)\r\n    // 2. fetchCustomerServerScopeAttrs() - direct fetch (fallback)\r\n    const mainCredentials = window.MyIOUtils?.getCredentials?.() || {};\r\n    CUSTOMER_ID = mainCredentials.customerId || window.myioHoldingCustomerId || ' ';\r\n\r\n    // Objeto principal para armazenar os dados dos dispositivos\r\n    const devices = {};\r\n\r\n    // 🗺️ NOVO: Mapa para conectar o ingestionId ao ID da entidade do ThingsBoard\r\n    const ingestionIdToEntityIdMap = new Map();\r\n\r\n    // --- FASE 1: Monta o objeto inicial e o mapa de IDs ---\r\n    self.ctx.data.forEach((data) => {\r\n      if (data.datasource.aliasName !== 'Shopping') {\r\n        const entityId = data.datasource.entity.id.id;\r\n\r\n        // Cria o objeto do dispositivo se for a primeira vez\r\n        if (!devices[entityId]) {\r\n          devices[entityId] = {\r\n            name: data.datasource.name,\r\n            label: data.datasource.entityLabel,\r\n            values: [],\r\n          };\r\n        }\r\n\r\n        // Adiciona o valor atual ao array\r\n        // RFC: Rename 'consumption' to 'consumption_power' to avoid confusion with API consumption (kWh)\r\n        const dataType = data.dataKey.name === 'consumption' ? 'consumption_power' : data.dataKey.name;\r\n        devices[entityId].values.push({\r\n          dataType: dataType,\r\n          value: data.data[0][1],\r\n          ts: data.data[0][0],\r\n        });\r\n\r\n        // ✅ LÓGICA DO MAPA: Se o dado for o ingestionId, guardamos a relação\r\n        if (data.dataKey.name === 'ingestionId' && data.data[0][1]) {\r\n          const ingestionId = data.data[0][1];\r\n          ingestionIdToEntityIdMap.set(ingestionId, entityId);\r\n        }\r\n      }\r\n    });\r\n\r\n    const boolExecSync = false;\r\n\r\n    // RFC-0071: Trigger device profile synchronization (runs once)\r\n    if (!__deviceProfileSyncComplete && boolExecSync) {\r\n      try {\r\n        LogHelper.log('[EQUIPMENTS] [RFC-0071] Triggering device profile sync...');\r\n        const syncResult = await syncDeviceProfileAttributes(self.ctx.data);\r\n        __deviceProfileSyncComplete = true;\r\n\r\n        if (syncResult.synced > 0) {\r\n          LogHelper.log(\r\n            '[EQUIPMENTS] [RFC-0071] ⚠️ Widget reload recommended to load new deviceProfile attributes'\r\n          );\r\n          LogHelper.log(\r\n            '[EQUIPMENTS] [RFC-0071] You may need to refresh the dashboard to see deviceProfile in ctx.data'\r\n          );\r\n        }\r\n      } catch (error) {\r\n        LogHelper.error('[EQUIPMENTS] [RFC-0071] Sync failed, continuing without it:', error);\r\n        // Don't block widget initialization if sync fails\r\n      }\r\n    }\r\n\r\n    // ============================================\r\n    // CREDENTIALS: Prefer MAIN's, fallback to direct fetch\r\n    // ============================================\r\n    // MAIN already fetched credentials, reuse them if available\r\n    if (mainCredentials.clientId && mainCredentials.clientSecret) {\r\n      CLIENT_ID = mainCredentials.clientId;\r\n      CLIENT_SECRET = mainCredentials.clientSecret;\r\n      LogHelper.log('[EQUIPMENTS] Using credentials from MAIN (MyIOUtils)');\r\n\r\n      // Still need to fetch mapInstantaneousPower (not in MAIN)\r\n      const customerCredentials = await fetchCustomerServerScopeAttrs(CUSTOMER_ID);\r\n      MAP_INSTANTANEOUS_POWER = customerCredentials.mapInstantaneousPower;\r\n      DELAY_TIME_CONNECTION_MINS = window.MyIOUtils?.getDelayTimeConnectionInMins();\r\n    } else {\r\n      // Fallback: fetch all credentials directly\r\n      LogHelper.log('[EQUIPMENTS] MAIN credentials not available, fetching directly...');\r\n      const customerCredentials = await fetchCustomerServerScopeAttrs(CUSTOMER_ID);\r\n      LogHelper.log('customerCredentials', customerCredentials);\r\n\r\n      CLIENT_ID = customerCredentials.client_id || ' ';\r\n      CLIENT_SECRET = customerCredentials.client_secret || ' ';\r\n      MAP_INSTANTANEOUS_POWER = customerCredentials.mapInstantaneousPower;\r\n      DELAY_TIME_CONNECTION_MINS = window.MyIOUtils?.getDelayTimeConnectionInMins();\r\n    }\r\n\r\n    // Initialize MyIO Auth using MyIOLibrary (like MAIN widget)\r\n    if (typeof MyIOLibrary !== 'undefined' && MyIOLibrary.buildMyioIngestionAuth) {\r\n      myIOAuth = MyIOLibrary.buildMyioIngestionAuth({\r\n        dataApiHost: getDataApiHost(),\r\n        clientId: CLIENT_ID,\r\n        clientSecret: CLIENT_SECRET,\r\n      });\r\n      LogHelper.log('[EQUIPMENTS] MyIO Auth initialized using MyIOLibrary');\r\n    } else {\r\n      LogHelper.error(\r\n        '[EQUIPMENTS] MyIOLibrary não está disponível. Verifique se a biblioteca foi carregada.'\r\n      );\r\n    }\r\n\r\n    // 🚨 RFC-0077: Fetch customer consumption limits ONCE before processing devices\r\n    // This will be used by getConsumptionRangesHierarchical as TIER 2 fallback\r\n    LogHelper.log(\r\n      '[EQUIPMENTS] [RFC-0077] Fetching customer consumption limits for CUSTOMER_ID:',\r\n      CUSTOMER_ID\r\n    );\r\n    try {\r\n      window.__customerConsumptionLimits = await getCachedConsumptionLimits(CUSTOMER_ID);\r\n      LogHelper.log(\r\n        '[EQUIPMENTS] [RFC-0077] Customer consumption limits loaded:',\r\n        window.__customerConsumptionLimits\r\n      );\r\n    } catch (error) {\r\n      LogHelper.error(\r\n        '[EQUIPMENTS] [RFC-0077] Failed to fetch customer consumption limits, will use hardcoded defaults:',\r\n        error\r\n      );\r\n      window.__customerConsumptionLimits = null;\r\n    }\r\n\r\n    // ✅ Loading overlay already shown at start of onInit (moved up for better UX)\r\n    async function renderDeviceCards() {\r\n      const promisesDeCards = Object.entries(devices)\r\n        .filter(([_entityId, device]) => device.values.some((valor) => valor.dataType === 'consumption'))\r\n        .map(async ([entityId, device]) => {\r\n          const lastConnectTimestamp = findValue(device.values, 'lastConnectTime', '');\r\n          const lastDisconnectTimestamp = findValue(device.values, 'lastDisconnectTime', '');\r\n          const deviceMapInstaneousPower = findValue(device.values, 'deviceMapInstaneousPower', '');\r\n\r\n          let operationHoursFormatted = '0s';\r\n\r\n          if (lastConnectTimestamp) {\r\n            const nowMs = new Date().getTime();\r\n            const durationMs = nowMs - lastConnectTimestamp;\r\n            operationHoursFormatted = formatarDuracao(durationMs > 0 ? durationMs : 0);\r\n          }\r\n\r\n          const deviceTemperature = 0;\r\n          const latestTimestamp = Math.max(...device.values.map((v) => v.ts || 0));\r\n          const updatedFormatted = formatRelativeTime(latestTimestamp);\r\n          const rawConnectionStatus = findValue(device.values, 'connectionStatus', 'offline');\r\n          const consumptionValue = findValue(device.values, 'consumption', 0);\r\n          const mappedConnectionStatus = window.MyIOUtils?.mapConnectionStatus?.(rawConnectionStatus);\r\n          const deviceProfile = findValue(device.values, 'deviceProfile', '').toUpperCase();\r\n          let deviceType = findValue(device.values, 'deviceType', '').toUpperCase();\r\n\r\n          if (deviceType === '3F_MEDIDOR' && deviceProfile !== 'N/D') {\r\n            deviceType = deviceProfile;\r\n          }\r\n\r\n          // 🚨 RFC-0077: HARDCODED SWITCH ELIMINATED!\r\n          // Now using hierarchical resolution: DeviceMap (ctx.data) → Device → Customer → Hardcoded defaults\r\n\r\n          // Get deviceId for TIER 1 lookup\r\n          const deviceId = entityId;\r\n\r\n          // RFC: Parse deviceMapInstaneousPower from ctx.data (TIER 0 - highest priority)\r\n          let deviceMapLimits = null;\r\n          if (deviceMapInstaneousPower && typeof deviceMapInstaneousPower === 'string') {\r\n            try {\r\n              deviceMapLimits = JSON.parse(deviceMapInstaneousPower);\r\n              //LogHelper.log(`[RFC-0078] ✅ Found deviceMapInstaneousPower in ctx.data for ${deviceId}`);\r\n            } catch (e) {\r\n              LogHelper.warn(\r\n                `[RFC-0078] Failed to parse deviceMapInstaneousPower for ${deviceId}:`,\r\n                e.message\r\n              );\r\n            }\r\n          }\r\n\r\n          // Get consumption ranges using hierarchical resolution\r\n          // If deviceMapLimits exists, use it instead of customerLimits (higher priority)\r\n          const rangesWithSource = await getConsumptionRangesHierarchical(\r\n            deviceId,\r\n            deviceType,\r\n            deviceMapLimits || window.__customerConsumptionLimits, // TIER 0 (deviceMap) > TIER 2 (customer)\r\n            'consumption',\r\n            null\r\n          );\r\n\r\n          // If deviceMapLimits was used, update the source to reflect it\r\n          if (deviceMapLimits && rangesWithSource.source === 'customer') {\r\n            rangesWithSource.source = 'deviceMap';\r\n            rangesWithSource.tier = 0;\r\n            LogHelper.log(`[RFC-0078] Using deviceMapInstaneousPower (TIER 0) for ${deviceId}`);\r\n          }\r\n\r\n          const findTimestampAtTelemetry = (values, dataType, defaultValue = 'N/D') => {\r\n            const item = values.find((v) => v.dataType === dataType);\r\n\r\n            if (!item) return defaultValue;\r\n            // Retorna a propriedade 'val' (da nossa API) ou 'value' (do ThingsBoard)\r\n            return item.ts;\r\n          };          \r\n\r\n          // Get instantaneous power from ctx.data (renamed to consumption_power to avoid confusion)\r\n          let instantaneousPower = findValue(device.values, 'consumption_power', 0);\r\n          const instantaneousPowerTs = new Date(\r\n            findTimestampAtTelemetry(device.values, 'consumption_power', 0) || 0\r\n          );\r\n          const now = new Date();\r\n          // RFC-0091: Use configurable delay time (in minutes) instead of hardcoded 15 minutes\r\n          const delayLimitTimeInMiliseconds = window.MyIOUtils?.getDelayTimeConnectionInMins?.() * 60 * 1000;\r\n          const timeSinceLastTelemetry = now.getTime() - instantaneousPowerTs.getTime();\r\n\r\n          if (timeSinceLastTelemetry > delayLimitTimeInMiliseconds) {\r\n            instantaneousPower = null;\r\n          }\r\n          \r\n          // Calculate device status using range-based calculation\r\n          const parsedInstantaneousPower = Number(instantaneousPower);\r\n          const lastConsumptionValue = Number.isNaN(parsedInstantaneousPower)\r\n            ? null\r\n            : parsedInstantaneousPower;\r\n\r\n          const deviceStatus = MyIOLibrary.calculateDeviceStatusWithRanges({\r\n            connectionStatus: mappedConnectionStatus,\r\n            lastConsumptionValue,\r\n            ranges: {\r\n              standbyRange: rangesWithSource.standbyRange,\r\n              normalRange: rangesWithSource.normalRange,\r\n              alertRange: rangesWithSource.alertRange,\r\n              failureRange: rangesWithSource.failureRange,\r\n            },\r\n          });\r\n\r\n          // DEBUG // TODO REMOVER DEPOIS\r\n          if (device.label && device.label.toLowerCase().includes('bomba cag6') && 3 > 2) {\r\n            console.log('╔══════════════════════════════════════════════════════════════╗');\r\n            console.log('║                    DEBUG ER 14 - EQUIPMENTS                  ║');\r\n            console.log('╚══════════════════════════════════════════════════════════════╝');\r\n            console.log('📋 device.label:', device.label);\r\n            console.log('📋 device.entityId:', device.entityId?.id);\r\n            console.log('');\r\n            console.log('🔌 CONNECTION STATUS:');\r\n            console.log('   rawConnectionStatus:', rawConnectionStatus);\r\n            console.log('   mappedConnectionStatus:', mappedConnectionStatus);\r\n            console.log('');\r\n            console.log('⚡ POWER:');\r\n            console.log('   instantaneousPower:', instantaneousPower);\r\n            console.log('   consumptionValue:', consumptionValue);\r\n            console.log('');\r\n            console.log('📊 RANGES:');\r\n            console.log('   rangesWithSource:', JSON.stringify(rangesWithSource, null, 2));\r\n            console.log('');\r\n            console.log('🎯 CALCULATED STATUS:');\r\n            console.log('   deviceStatus:', deviceStatus);\r\n            console.log('');\r\n            console.log('📦 RAW device.values:');\r\n            device.values?.forEach((v, i) => {\r\n              console.log(`   [${i}] ${v.dataKey?.name}: ${v.data?.[0]?.[1]}`);\r\n            });\r\n            console.log('════════════════════════════════════════════════════════════════');\r\n          }\r\n\r\n          const ingestionId = findValue(device.values, 'ingestionId', null);\r\n          let customerId = findValue(device.values, 'customerId', null);\r\n\r\n          // Fallback: Try to get customerId from MAIN's energyCache (API has it, ctx.data doesn't)\r\n          if (!customerId && ingestionId && energyCacheFromMain && energyCacheFromMain.has(ingestionId)) {\r\n            customerId = energyCacheFromMain.get(ingestionId).customerId;\r\n          }\r\n\r\n          // Populate global device-to-shopping map for filter fallback\r\n          if (ingestionId && customerId) {\r\n            if (!window.myioDeviceToShoppingMap) {\r\n              window.myioDeviceToShoppingMap = new Map();\r\n            }\r\n            window.myioDeviceToShoppingMap.set(ingestionId, customerId);\r\n          }\r\n\r\n          // Get identifier and normalize - if empty or contains \"sem identificador\", show \"Sem identificador\"\r\n          const rawIdentifier = String(findValue(device.values, 'identifier') || '').trim();\r\n          const deviceIdentifier = !rawIdentifier\r\n            ? 'Sem identificador'\r\n            : rawIdentifier.toUpperCase().includes('SEM IDENTIFICADOR')\r\n            ? 'Sem identificador'\r\n            : rawIdentifier;\r\n\r\n          return {\r\n            entityId: entityId,\r\n            labelOrName: device.label,\r\n            val: consumptionValue,\r\n            deviceIdentifier: deviceIdentifier,\r\n            centralName: findValue(device.values, 'centralName', null),\r\n            ingestionId: ingestionId,\r\n            customerId: customerId, // Shopping ingestionId for filtering\r\n            deviceType: deviceType,\r\n            deviceStatus: deviceStatus,\r\n            connectionStatus: mappedConnectionStatus, // RFC-0093: Add connectionStatus for online/offline display\r\n            valType: 'power_w',\r\n            perc: Math.floor(Math.random() * (95 - 70 + 1)) + 70,\r\n            temperatureC: deviceTemperature || 0, // RFC-0091: Fixed - deviceTemperature is a number, not array\r\n            operationHours: operationHoursFormatted || 0,\r\n            updated: updatedFormatted,\r\n            instantaneousPower: instantaneousPower, // Potência instantânea (kW) from ctx.data\r\n            lastDisconnectTime: lastDisconnectTimestamp,\r\n            lastConnectTime: lastConnectTimestamp,\r\n            lastActivityTime: findValue(device.values, 'lastActivityTime', null),\r\n            mapInstantaneousPower: MAP_INSTANTANEOUS_POWER,\r\n            deviceMapInstaneousPower: deviceMapInstaneousPower,\r\n            // RFC-0058: Add properties for MyIOSelectionStore (FOOTER)\r\n            id: entityId, // Alias for entityId\r\n            name: device.label, // Alias for labelOrName\r\n            lastValue: consumptionValue, // Alias for val\r\n            unit: 'kWh', // Energy unit\r\n            icon: 'energy', // Domain identifier for SelectionStore\r\n            domain: 'energy', // Domain for card component tooltip\r\n            // Power ranges for tooltip visualization\r\n            powerRanges: rangesWithSource\r\n              ? {\r\n                  standbyRange: rangesWithSource.standbyRange,\r\n                  normalRange: rangesWithSource.normalRange,\r\n                  alertRange: rangesWithSource.alertRange,\r\n                  failureRange: rangesWithSource.failureRange,\r\n                  source: rangesWithSource.source,\r\n                  tier: rangesWithSource.tier,\r\n                }\r\n              : null,\r\n          };\r\n        });\r\n\r\n      const devicesFormatadosParaCards = await Promise.all(promisesDeCards);\r\n\r\n      function isActuallyEquipment(device) {\r\n        // Non-3F_MEDIDOR devices are always equipment\r\n        if (device.deviceType !== '3F_MEDIDOR') {\r\n          return true;\r\n        }\r\n        // For 3F_MEDIDOR, check deviceProfile and labelOrName to determine if it's actually equipment\r\n        const equipmentKeywords = ['MOTOR', 'ELEVADOR', 'ESCADA_ROLANTE', 'CHILLER', 'BOMBA', 'FANCOIL'];\r\n        const profileUpper = (device.deviceProfile || '').toUpperCase();\r\n        const labelUpper = (device.labelOrName || '').toUpperCase();\r\n\r\n        return equipmentKeywords.some(\r\n          (keyword) => profileUpper.includes(keyword) || labelUpper.includes(keyword)\r\n        );\r\n      }\r\n\r\n      // Separate lojas from equipments based on deviceType\r\n      const lojasDevices = devicesFormatadosParaCards.filter((d) => !isActuallyEquipment(d));\r\n      const equipmentDevices = devicesFormatadosParaCards.filter((d) => isActuallyEquipment(d));\r\n\r\n      LogHelper.log('[EQUIPMENTS] Total devices:', devicesFormatadosParaCards.length);\r\n      LogHelper.log('[EQUIPMENTS] Equipment devices:', equipmentDevices.length);\r\n      LogHelper.log('[EQUIPMENTS] Lojas (actual 3F_MEDIDOR stores):', lojasDevices.length);\r\n\r\n      // ✅ Emit event to inform MAIN about lojas ingestionIds\r\n      const lojasIngestionIds = lojasDevices.map((d) => d.ingestionId).filter((id) => id); // Remove nulls\r\n\r\n      window.dispatchEvent(\r\n        new CustomEvent('myio:lojas-identified', {\r\n          detail: {\r\n            lojasIngestionIds,\r\n            lojasCount: lojasIngestionIds.length,\r\n            timestamp: Date.now(),\r\n          },\r\n        })\r\n      );\r\n\r\n      LogHelper.log('[EQUIPMENTS] ✅ Emitted myio:lojas-identified:', {\r\n        lojasCount: lojasIngestionIds.length,\r\n        lojasIngestionIds,\r\n      });\r\n\r\n      // ✅ Emit event to inform MAIN about equipment ingestionIds\r\n      const equipmentsIngestionIds = equipmentDevices.map((d) => d.ingestionId).filter((id) => id);\r\n\r\n      window.dispatchEvent(\r\n        new CustomEvent('myio:equipments-identified', {\r\n          detail: {\r\n            equipmentsIngestionIds,\r\n            equipmentsCount: equipmentsIngestionIds.length,\r\n            timestamp: Date.now(),\r\n          },\r\n        })\r\n      );\r\n\r\n      LogHelper.log('[EQUIPMENTS] ✅ Emitted myio:equipments-identified:', {\r\n        equipmentsCount: equipmentsIngestionIds.length,\r\n      });\r\n\r\n      // ✅ Save ONLY equipment devices to global STATE for filtering\r\n      STATE.allDevices = equipmentDevices;\r\n\r\n      // Log device-to-shopping mapping stats\r\n      if (window.myioDeviceToShoppingMap) {\r\n        LogHelper.log(\r\n          `[EQUIPMENTS] 🗺️ Device-to-shopping map populated: ${window.myioDeviceToShoppingMap.size} devices mapped`\r\n        );\r\n\r\n        // Debug: show sample mappings\r\n        if (window.myioDeviceToShoppingMap.size > 0) {\r\n          const samples = Array.from(window.myioDeviceToShoppingMap.entries()).slice(0, 3);\r\n          LogHelper.log(\r\n            `[EQUIPMENTS] 📋 Sample mappings:`,\r\n            samples.map(\r\n              ([deviceId, shopId]) => `${deviceId.substring(0, 8)}... → ${shopId.substring(0, 8)}...`\r\n            )\r\n          );\r\n        }\r\n      }\r\n\r\n      initializeCards(equipmentDevices);\r\n\r\n      // RFC-0093: Update statistics header via centralized controller\r\n      if (equipHeaderController) {\r\n        equipHeaderController.updateFromDevices(equipmentDevices, {\r\n          cache: energyCacheFromMain,\r\n          ctxData: self.ctx.data,\r\n        });\r\n      } else {\r\n        // Fallback to old function if header controller not available\r\n        updateEquipmentStats(equipmentDevices, energyCacheFromMain, self.ctx.data);\r\n      }\r\n\r\n      // RFC: Emit initial equipment count to HEADER\r\n      emitEquipmentCountEvent(equipmentDevices);\r\n\r\n      // Hide loading after rendering\r\n      showLoadingOverlay(false);\r\n    }\r\n\r\n    // Function to render all available shoppings as chips (default: all selected)\r\n    function renderAllShoppingsChips(customers) {\r\n      if (!customers || !Array.isArray(customers) || customers.length === 0) {\r\n        LogHelper.warn('[EQUIPMENTS] ⚠️ No customers provided to render as chips');\r\n        return;\r\n      }\r\n\r\n      LogHelper.log(`[EQUIPMENTS] 🏬 Rendering ${customers.length} shoppings as pre-selected`);\r\n\r\n      // Render chips with all customers\r\n      renderShoppingFilterChips(customers);\r\n    }\r\n\r\n    // ✅ Listen for customers ready event from MENU\r\n    self._onCustomersReady = (ev) => {\r\n      LogHelper.log('[EQUIPMENTS] 🔔 heard myio:customers-ready:', ev.detail);\r\n\r\n      const customers = ev.detail?.customers || [];\r\n      if (customers.length > 0) {\r\n        // RFC: Save total shoppings count for HEADER card logic\r\n        STATE.totalShoppings = customers.length;\r\n        LogHelper.log(`[EQUIPMENTS] 📊 Total shoppings available: ${STATE.totalShoppings}`);\r\n\r\n        renderAllShoppingsChips(customers);\r\n      }\r\n    };\r\n\r\n    window.addEventListener('myio:customers-ready', self._onCustomersReady, { once: true });\r\n\r\n    function enrichDevicesWithConsumption() {\r\n      if (!energyCacheFromMain) {\r\n        LogHelper.warn('[EQUIPMENTS] No energy from MAIN available yet');\r\n        return;\r\n      }\r\n\r\n      LogHelper.log('[EQUIPMENTS] Enriching devices with consumption from MAIN...');\r\n\r\n      // Iterate through devices and add consumption from cache\r\n      Object.entries(devices).forEach(([_entityId, device]) => {\r\n        // Find ingestionId for this device\r\n        const ingestionIdItem = device.values.find((v) => v.dataType === 'ingestionId');\r\n        if (ingestionIdItem && ingestionIdItem.value) {\r\n          const ingestionId = ingestionIdItem.value;\r\n          const cached = energyCacheFromMain.get(ingestionId);\r\n\r\n          if (cached) {\r\n            // Remove old consumption data if exists\r\n            // RFC-0091: Use 'value' property to match findValue expected format\r\n            const consumptionIndex = device.values.findIndex((v) => v.dataType === 'consumption');\r\n            if (consumptionIndex >= 0) {\r\n              device.values[consumptionIndex] = {\r\n                value: cached.total_value,\r\n                ts: cached.timestamp,\r\n                dataType: 'consumption',\r\n              };\r\n            } else {\r\n              device.values.push({\r\n                value: cached.total_value,\r\n                ts: cached.timestamp,\r\n                dataType: 'consumption',\r\n              });\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      // RFC-0076: CRITICAL FIX - Enrich energyCache with full device metadata\r\n      // This ensures ENERGY widget can classify elevators correctly\r\n      let enrichedCount = 0;\r\n      Object.entries(devices).forEach(([_entityId2, device]) => {\r\n        const ingestionIdItem = device.values.find((v) => v.dataType === 'ingestionId');\r\n        if (ingestionIdItem && ingestionIdItem.value) {\r\n          const ingestionId = ingestionIdItem.value;\r\n          const cached = energyCacheFromMain.get(ingestionId);\r\n\r\n          if (cached) {\r\n            // Get metadata from device.values\r\n            const deviceType = findValue(device.values, 'type', '');\r\n            const deviceProfile = findValue(device.values, 'deviceProfile', '');\r\n            const deviceIdentifier = findValue(device.values, 'deviceIdentifier', '');\r\n            const deviceName = findValue(device.values, 'name', '');\r\n\r\n            // RFC-0076: Enrich cache with full metadata\r\n            cached.deviceType = deviceType;\r\n            cached.deviceProfile = deviceProfile;\r\n            cached.deviceIdentifier = deviceIdentifier;\r\n            cached.name = cached.name || deviceName;\r\n\r\n            enrichedCount++;\r\n          }\r\n        }\r\n      });\r\n\r\n      LogHelper.log(`[EQUIPMENTS] ✅ Enriched ${enrichedCount} devices in energyCache with metadata`);\r\n\r\n      // RFC-0076: Force update on ENERGY widget by re-emitting the cache\r\n      const orchestrator = window.MyIOOrchestrator || window.parent?.MyIOOrchestrator;\r\n      if (orchestrator) {\r\n        LogHelper.log('[EQUIPMENTS] 🔄 Forcing ENERGY widget update...');\r\n        window.dispatchEvent(\r\n          new CustomEvent('myio:equipment-metadata-enriched', {\r\n            detail: {\r\n              cache: energyCacheFromMain,\r\n              deviceCount: enrichedCount,\r\n              timestamp: Date.now(),\r\n            },\r\n          })\r\n        );\r\n      }\r\n\r\n      // Re-render cards and hide loading\r\n      renderDeviceCards().then(() => {\r\n        showLoadingOverlay(false);\r\n      });\r\n    }\r\n\r\n    async function waitForOrchestrator(timeoutMs = 15000) {\r\n      return new Promise((resolve) => {\r\n        let interval;\r\n        const timeout = setTimeout(() => {\r\n          clearInterval(interval);\r\n          LogHelper.error('[EQUIPMENTS] Timeout: MyIOOrchestrator não foi encontrado na window.');\r\n          resolve(null);\r\n        }, timeoutMs);\r\n\r\n        interval = setInterval(() => {\r\n          // RFC-0057: No longer checking window.parent - not using iframes\r\n          const orchestrator = window.MyIOOrchestrator;\r\n          if (orchestrator) {\r\n            clearTimeout(timeout);\r\n            clearInterval(interval);\r\n            LogHelper.log('[EQUIPMENTS] MyIOOrchestrator encontrado!');\r\n            resolve(orchestrator);\r\n          }\r\n        }, 100); // Verifica a cada 100ms\r\n      });\r\n    }\r\n\r\n    // ===== EQUIPMENTS: Listen for energy cache from MAIN orchestrator =====\r\n    let energyCacheFromMain = null;\r\n\r\n    // Função para processar os dados recebidos e renderizar\r\n    async function processAndRender(cache) {\r\n      if (!cache || cache.size === 0) {\r\n        LogHelper.warn('[EQUIPMENTS] Cache de energia está vazio. Nenhum card será renderizado.');\r\n        showLoadingOverlay(false);\r\n\r\n        // RFC-0093: Show toast to reload page\r\n        const MyIOToast = MyIOLibrary?.MyIOToast || window.MyIOToast;\r\n        if (MyIOToast) {\r\n          MyIOToast.warning('Dados não carregados. Por favor, recarregue a página.', { duration: 8000 });\r\n        }\r\n        return;\r\n      }\r\n\r\n      energyCacheFromMain = cache;\r\n      enrichDevicesWithConsumption(); // A sua função original é chamada aqui\r\n      await renderDeviceCards(); // E a sua outra função original é chamada aqui\r\n    }\r\n\r\n    // Lógica principal: \"verificar-depois-ouvir\"\r\n    const orchestrator = await waitForOrchestrator();\r\n\r\n    if (orchestrator) {\r\n      const existingCache = orchestrator.getCache();\r\n\r\n      if (existingCache && existingCache.size > 0) {\r\n        // CAMINHO 1: (Navegação de volta)\r\n        LogHelper.log('[EQUIPMENTS] Cache do Orquestrador já existe. Usando-o diretamente.');\r\n        await processAndRender(existingCache);\r\n      } else {\r\n        // CAMINHO 2: (Primeiro carregamento)\r\n        LogHelper.log(\"[EQUIPMENTS] Cache vazio. Aguardando evento 'myio:energy-data-ready'...\");\r\n        const waitForEnergyCache = new Promise((resolve) => {\r\n          const handlerTimeout = setTimeout(() => {\r\n            LogHelper.warn('[EQUIPMENTS] Timeout esperando pelo evento de cache.');\r\n            resolve(null);\r\n          }, 15000);\r\n\r\n          const handler = (ev) => {\r\n            clearTimeout(handlerTimeout);\r\n            window.removeEventListener('myio:energy-data-ready', handler);\r\n            resolve(ev.detail.cache);\r\n          };\r\n          window.addEventListener('myio:energy-data-ready', handler);\r\n        });\r\n\r\n        const initialCache = await waitForEnergyCache;\r\n        await processAndRender(initialCache);\r\n      }\r\n    } else {\r\n      // O erro do timeout já terá sido logado pela função 'waitForOrchestrator'\r\n      showLoadingOverlay(false);\r\n    }\r\n  }, 0);\r\n\r\n  // ====== FILTER & SEARCH LOGIC ======\r\n  bindFilterEvents();\r\n\r\n  // RFC-0093: Bind real-time toggle button\r\n  bindRealTimeToggle();\r\n\r\n  // RFC-0103: Bind Power Limits Setup button\r\n  bindPowerLimitsButton();\r\n};\r\n\r\n// Global state for filters\r\nconst STATE = {\r\n  allDevices: [],\r\n  searchActive: false,\r\n  searchTerm: '',\r\n  selectedIds: null,\r\n  sortMode: 'cons_desc',\r\n  selectedShoppingIds: [], // Shopping filter from MENU\r\n  totalShoppings: 0, // Total number of shoppings available\r\n  // RFC-0093: Real-Time Mode State\r\n  realTimeActive: false,\r\n  realTimePowerMap: new Map(), // deviceId -> { value: number, timestamp: number }\r\n  realTimeIntervalId: null,\r\n  realTimeCountdownId: null,\r\n  realTimeStartedAt: null,\r\n  realTimeNextRefresh: 0,\r\n  // RFC-0093: WebSocket Engine State\r\n  realTimeEngine: 'websocket', // 'websocket' | 'rest'\r\n  wsConsecutiveFailures: 0,\r\n};\r\n\r\n// RFC-0093: Real-Time Mode Constants\r\nconst REALTIME_CONFIG = {\r\n  // Engine settings\r\n  DEFAULT_ENGINE: 'websocket',\r\n  FALLBACK_AFTER_FAILURES: 6,\r\n  // WebSocket settings\r\n  WS_URL: 'wss://dashboard.myio-bas.com/api/ws',\r\n  WS_RECONNECT_BACKOFF: [1000, 2000, 5000, 10000, 30000],\r\n  // REST fallback settings\r\n  REST_INTERVAL_MS: 30000,\r\n  BATCH_SIZE: 10,\r\n  BATCH_DELAY_MS: 50,\r\n  // General settings\r\n  MAX_RUNTIME_MS: 30 * 60 * 1000, // 30 minutes auto-disable\r\n  INTERVAL_OPTIONS: [10, 15, 30, 45, 60, 90, 120],\r\n  COUNTDOWN_UPDATE_MS: 100,\r\n};\r\n\r\n/**\r\n * RFC: Emit event to update HEADER equipment card\r\n * Sends total equipment count, filtered count, and category breakdown\r\n */\r\nfunction emitEquipmentCountEvent(filteredDevices) {\r\n  const totalEquipments = STATE.allDevices.length;\r\n  const filteredEquipments = filteredDevices.length;\r\n\r\n  // Check if all shoppings are selected (no filter or all selected)\r\n  const allShoppingsSelected =\r\n    STATE.selectedShoppingIds.length === 0 || STATE.selectedShoppingIds.length === STATE.totalShoppings;\r\n\r\n  // RFC: Calculate category breakdown for filtered devices\r\n  const categories = {\r\n    climatizacao: { total: 0, filtered: 0, label: 'Climatização', icon: '❄️' },\r\n    elevadores: { total: 0, filtered: 0, label: 'Elevadores', icon: '🛗' },\r\n    escadasRolantes: { total: 0, filtered: 0, label: 'Escadas Rolantes', icon: '📶' },\r\n    outros: { total: 0, filtered: 0, label: 'Outros Equipamentos', icon: '⚙️' },\r\n  };\r\n\r\n  // Count totals from all devices\r\n  STATE.allDevices.forEach((device) => {\r\n    if (isHVAC(device)) {\r\n      categories.climatizacao.total++;\r\n    } else if (isElevator(device)) {\r\n      categories.elevadores.total++;\r\n    } else if (isEscalator(device)) {\r\n      categories.escadasRolantes.total++;\r\n    } else {\r\n      categories.outros.total++;\r\n    }\r\n  });\r\n\r\n  // Count filtered devices\r\n  filteredDevices.forEach((device) => {\r\n    if (isHVAC(device)) {\r\n      categories.climatizacao.filtered++;\r\n    } else if (isElevator(device)) {\r\n      categories.elevadores.filtered++;\r\n    } else if (isEscalator(device)) {\r\n      categories.escadasRolantes.filtered++;\r\n    } else {\r\n      categories.outros.filtered++;\r\n    }\r\n  });\r\n\r\n  const eventData = {\r\n    totalEquipments,\r\n    filteredEquipments,\r\n    allShoppingsSelected,\r\n    categories,\r\n    timestamp: Date.now(),\r\n  };\r\n\r\n  window.dispatchEvent(\r\n    new CustomEvent('myio:equipment-count-updated', {\r\n      detail: eventData,\r\n    })\r\n  );\r\n\r\n  LogHelper.log('[EQUIPMENTS] ✅ Emitted myio:equipment-count-updated:', eventData);\r\n}\r\n\r\n/**\r\n * Apply filters and sorting to devices\r\n */\r\nfunction applyFilters(devices, searchTerm, selectedIds, sortMode) {\r\n  let filtered = devices.slice();\r\n\r\n  // Apply shopping filter (from MENU)\r\n  if (STATE.selectedShoppingIds && STATE.selectedShoppingIds.length > 0) {\r\n    const before = filtered.length;\r\n    filtered = filtered.filter((d) => {\r\n      // If device has no customerId, include it (safety)\r\n      if (!d.customerId) return true;\r\n      // Check if device's customerId is in the selected shoppings\r\n      return STATE.selectedShoppingIds.includes(d.customerId);\r\n    });\r\n    LogHelper.log(\r\n      `[EQUIPMENTS] Shopping filter applied: ${before} -> ${filtered.length} devices (${\r\n        before - filtered.length\r\n      } filtered out)`\r\n    );\r\n  }\r\n\r\n  // Apply multiselect filter\r\n  if (selectedIds && selectedIds.size > 0) {\r\n    filtered = filtered.filter((d) => selectedIds.has(d.entityId));\r\n  }\r\n\r\n  // Apply search filter\r\n  const query = (searchTerm || '').trim().toLowerCase();\r\n  if (query) {\r\n    filtered = filtered.filter(\r\n      (d) =>\r\n        String(d.labelOrName || '')\r\n          .toLowerCase()\r\n          .includes(query) ||\r\n        String(d.deviceIdentifier || '')\r\n          .toLowerCase()\r\n          .includes(query) ||\r\n        String(d.deviceType || '')\r\n          .toLowerCase()\r\n          .includes(query)\r\n    );\r\n  }\r\n\r\n  // Apply sorting\r\n  filtered.sort((a, b) => {\r\n    const valA = Number(a.val) || Number(a.lastValue) || 0;\r\n    const valB = Number(b.val) || Number(b.lastValue) || 0;\r\n    const nameA = String(a.labelOrName || '').toLowerCase();\r\n    const nameB = String(b.labelOrName || '').toLowerCase();\r\n\r\n    switch (sortMode) {\r\n      case 'cons_desc':\r\n        return valB !== valA ? valB - valA : nameA.localeCompare(nameB);\r\n      case 'cons_asc':\r\n        return valA !== valB ? valA - valB : nameA.localeCompare(nameB);\r\n      case 'alpha_asc':\r\n        return nameA.localeCompare(nameB);\r\n      case 'alpha_desc':\r\n        return nameB.localeCompare(nameA);\r\n      // RFC-0095: Status sorting\r\n      case 'status_asc': {\r\n        const statusA = (a.deviceStatus || a.connectionStatus || 'offline').toLowerCase();\r\n        const statusB = (b.deviceStatus || b.connectionStatus || 'offline').toLowerCase();\r\n        const cmp = statusA.localeCompare(statusB, 'pt-BR', { sensitivity: 'base' });\r\n        return cmp !== 0 ? cmp : nameA.localeCompare(nameB);\r\n      }\r\n      case 'status_desc': {\r\n        const statusA = (a.deviceStatus || a.connectionStatus || 'offline').toLowerCase();\r\n        const statusB = (b.deviceStatus || b.connectionStatus || 'offline').toLowerCase();\r\n        const cmp = statusB.localeCompare(statusA, 'pt-BR', { sensitivity: 'base' });\r\n        return cmp !== 0 ? cmp : nameA.localeCompare(nameB);\r\n      }\r\n      // RFC-0095: Shopping sorting\r\n      case 'shopping_asc': {\r\n        const shopA = (a.customerName || getCustomerNameForDevice(a) || '').toLowerCase();\r\n        const shopB = (b.customerName || getCustomerNameForDevice(b) || '').toLowerCase();\r\n        const cmp = shopA.localeCompare(shopB, 'pt-BR', { sensitivity: 'base' });\r\n        return cmp !== 0 ? cmp : nameA.localeCompare(nameB);\r\n      }\r\n      case 'shopping_desc': {\r\n        const shopA = (a.customerName || getCustomerNameForDevice(a) || '').toLowerCase();\r\n        const shopB = (b.customerName || getCustomerNameForDevice(b) || '').toLowerCase();\r\n        const cmp = shopB.localeCompare(shopA, 'pt-BR', { sensitivity: 'base' });\r\n        return cmp !== 0 ? cmp : nameA.localeCompare(nameB);\r\n      }\r\n      default:\r\n        return 0;\r\n    }\r\n  });\r\n\r\n  return filtered;\r\n}\r\n\r\n/**\r\n * Re-render cards with current filters\r\n */\r\nfunction reflowCards() {\r\n  const filtered = applyFilters(STATE.allDevices, STATE.searchTerm, STATE.selectedIds, STATE.sortMode);\r\n\r\n  LogHelper.log('[EQUIPMENTS] Reflow with filters:', {\r\n    total: STATE.allDevices.length,\r\n    filtered: filtered.length,\r\n    searchTerm: STATE.searchTerm,\r\n    selectedCount: STATE.selectedIds?.size || 0,\r\n    sortMode: STATE.sortMode,\r\n  });\r\n\r\n  initializeCards(filtered);\r\n\r\n  // RFC-0093: Update statistics header via centralized controller\r\n  const energyCache = window.MyIOOrchestrator?.getCache?.() || null;\r\n  if (equipHeaderController) {\r\n    equipHeaderController.updateFromDevices(filtered, {\r\n      cache: energyCache,\r\n      ctxData: self.ctx.data,\r\n    });\r\n  } else {\r\n    // Fallback to old function if header controller not available\r\n    updateEquipmentStats(filtered, energyCache, self.ctx.data);\r\n  }\r\n\r\n  // RFC: Emit event to update HEADER card\r\n  emitEquipmentCountEvent(filtered);\r\n}\r\n\r\n// ============================================\r\n// RFC-0090: EQUIPMENTS FILTER MODAL (using shared factory from MAIN)\r\n// ============================================\r\n\r\n// Helper functions for equipment classification\r\nfunction isElevator(device) {\r\n  const deviceType = (device.deviceType || '').toUpperCase();\r\n  const deviceProfile = (device.deviceProfile || '').toUpperCase();\r\n  return deviceType === 'ELEVADOR' || (deviceType === '3F_MEDIDOR' && deviceProfile === 'ELEVADOR');\r\n}\r\n\r\nfunction isEscalator(device) {\r\n  const deviceType = (device.deviceType || '').toUpperCase();\r\n  const deviceProfile = (device.deviceProfile || '').toUpperCase();\r\n  return (\r\n    deviceType === 'ESCADA_ROLANTE' || (deviceType === '3F_MEDIDOR' && deviceProfile === 'ESCADA_ROLANTE')\r\n  );\r\n}\r\n\r\nfunction isHVAC(device) {\r\n  const deviceType = (device.deviceType || '').toUpperCase();\r\n  const deviceProfile = (device.deviceProfile || '').toUpperCase();\r\n  const identifier = (device.deviceIdentifier || '').toUpperCase();\r\n  const hasCAG = identifier.includes('CAG');\r\n\r\n  return (\r\n    hasCAG ||\r\n    deviceType === 'CHILLER' ||\r\n    deviceType === 'FANCOIL' ||\r\n    deviceType === 'AR_CONDICIONADO' ||\r\n    deviceType === 'BOMBA' ||\r\n    deviceType === 'HVAC' ||\r\n    (deviceType === '3F_MEDIDOR' &&\r\n      (deviceProfile === 'CHILLER' ||\r\n        deviceProfile === 'FANCOIL' ||\r\n        deviceProfile === 'AR_CONDICIONADO' ||\r\n        deviceProfile === 'BOMBA' ||\r\n        deviceProfile === 'HVAC'))\r\n  );\r\n}\r\n\r\nfunction getDeviceConsumption(device) {\r\n  return Number(device.val) || Number(device.lastValue) || 0;\r\n}\r\n\r\nfunction getDeviceStatus(device) {\r\n  return (device.deviceStatus || '').toLowerCase();\r\n}\r\n\r\n// Filter modal instance (lazy initialized)\r\nlet equipmentsFilterModal = null;\r\n\r\n/**\r\n * RFC-0090: Initialize filter modal using shared factory from MAIN\r\n */\r\nfunction initFilterModal() {\r\n  const createFilterModal = window.MyIOUtils?.createFilterModal;\r\n\r\n  if (!createFilterModal) {\r\n    LogHelper.error('[EQUIPMENTS] createFilterModal not available from MAIN');\r\n    return null;\r\n  }\r\n\r\n  return createFilterModal({\r\n    widgetName: 'EQUIPMENTS',\r\n    containerId: 'equipmentsFilterModalGlobal',\r\n    modalClass: 'equip-modal',\r\n    primaryColor: '#2563eb',\r\n    itemIdAttr: 'data-device-id',\r\n\r\n    // Filter tabs configuration - specific for EQUIPMENTS\r\n    filterTabs: [\r\n      { id: 'all', label: 'Todos', filter: () => true },\r\n      { id: 'online', label: 'Online', filter: (d) => !['offline', 'no_info'].includes(getDeviceStatus(d)) },\r\n      { id: 'offline', label: 'Offline', filter: (d) => ['offline', 'no_info'].includes(getDeviceStatus(d)) },\r\n      {\r\n        id: 'normal',\r\n        label: 'Normal',\r\n        filter: (d) => getDeviceStatus(d) === 'power_on' || getDeviceStatus(d) === 'normal',\r\n      },\r\n      { id: 'standby', label: 'Stand By', filter: (d) => getDeviceStatus(d) === 'standby' },\r\n      {\r\n        id: 'alert',\r\n        label: 'Alerta',\r\n        filter: (d) => ['warning', 'alert', 'maintenance'].includes(getDeviceStatus(d)),\r\n      },\r\n      {\r\n        id: 'failure',\r\n        label: 'Falha',\r\n        filter: (d) => getDeviceStatus(d) === 'failure' || getDeviceStatus(d) === 'power_off',\r\n      },\r\n      { id: 'elevators', label: 'Elevadores', filter: isElevator },\r\n      { id: 'escalators', label: 'Escadas', filter: isEscalator },\r\n      { id: 'hvac', label: 'Climatização', filter: isHVAC },\r\n      { id: 'others', label: 'Outros', filter: (d) => !isElevator(d) && !isEscalator(d) && !isHVAC(d) },\r\n    ],\r\n\r\n    // Data accessors\r\n    getItemId: (device) => device.entityId,\r\n    getItemLabel: (device) => device.labelOrName || device.deviceIdentifier || device.entityId,\r\n    getItemValue: getDeviceConsumption,\r\n    getItemSubLabel: (device) => device.customerName || getCustomerNameForDevice(device),\r\n    formatValue: (val) => (MyIOLibrary?.formatEnergy ? MyIOLibrary.formatEnergy(val) : val.toFixed(2)),\r\n\r\n    // Callbacks\r\n    onApply: ({ selectedIds, sortMode }) => {\r\n      STATE.selectedIds = selectedIds;\r\n      STATE.sortMode = sortMode;\r\n      reflowCards();\r\n      LogHelper.log('[EQUIPMENTS] [RFC-0090] Filters applied via shared modal');\r\n    },\r\n\r\n    onReset: () => {\r\n      STATE.selectedIds = null;\r\n      STATE.sortMode = 'cons_desc';\r\n      STATE.searchTerm = '';\r\n      STATE.searchActive = false;\r\n\r\n      // RFC-0093: Reset UI via header controller\r\n      if (equipHeaderController) {\r\n        const searchInput = equipHeaderController.getSearchInput();\r\n        if (searchInput) searchInput.value = '';\r\n        equipHeaderController.toggleSearch(false);\r\n      }\r\n\r\n      reflowCards();\r\n      LogHelper.log('[EQUIPMENTS] [RFC-0090] Filters reset via shared modal');\r\n    },\r\n\r\n    onClose: () => {\r\n      LogHelper.log('[EQUIPMENTS] [RFC-0090] Filter modal closed');\r\n    },\r\n  });\r\n}\r\n\r\nfunction openFilterModal() {\r\n  // Lazy initialize modal\r\n  if (!equipmentsFilterModal) {\r\n    equipmentsFilterModal = initFilterModal();\r\n  }\r\n\r\n  if (!equipmentsFilterModal) {\r\n    LogHelper.error('[EQUIPMENTS] Failed to initialize filter modal');\r\n    window.alert('Erro ao inicializar modal de filtros. Verifique se o widget MAIN foi carregado.');\r\n    return;\r\n  }\r\n\r\n  // 1. Pega a lista completa de dispositivos\r\n  let items = STATE.allDevices || [];\r\n\r\n  // 2. APLICA O FILTRO DE SHOPPING (Correção aqui)\r\n  // Filtra a lista antes de mandar para o modal, assim o contador \"Todos\"\r\n  // mostrará apenas a quantidade do shopping selecionado.\r\n  if (STATE.selectedShoppingIds && STATE.selectedShoppingIds.length > 0) {\r\n    items = items.filter((d) => {\r\n      // Se não tem customerId ou não está na lista de selecionados, remove.\r\n      return d.customerId && STATE.selectedShoppingIds.includes(d.customerId);\r\n    });\r\n  }\r\n\r\n  // 3. Abre o modal com a lista filtrada\r\n  equipmentsFilterModal.open(items, {\r\n    selectedIds: STATE.selectedIds,\r\n    sortMode: STATE.sortMode,\r\n  });\r\n}\r\n\r\n// ============================================\r\n// RFC-0093: REAL-TIME WEBSOCKET SERVICE\r\n// ============================================\r\n\r\n// Store references\r\nlet realtimeSettingsModal = null;\r\nlet websocketService = null;\r\nlet filterDebounceTimer = null;\r\n\r\n/**\r\n * RFC-0093: WebSocket Real-Time Service Class\r\n */\r\nclass RealTimeWebSocketService {\r\n  constructor(config) {\r\n    this.config = {\r\n      wsUrl: REALTIME_CONFIG.WS_URL,\r\n      keys: ['power'],\r\n      onData: () => {},\r\n      onConnectionChange: () => {},\r\n      onError: () => {},\r\n      autoReconnect: true,\r\n      ...config,\r\n    };\r\n\r\n    this.ws = null;\r\n    this.cmdIdCounter = 0;\r\n    this.currentCmdId = null;\r\n    this.lastSubscribedDevices = [];\r\n    this.reconnectAttempts = 0;\r\n    this.reconnectTimeoutId = null;\r\n    this.isAuthenticated = false;\r\n  }\r\n\r\n  async connect() {\r\n    return new Promise((resolve, reject) => {\r\n      const token = localStorage.getItem('jwt_token');\r\n      if (!token) {\r\n        reject(new Error('No JWT token available'));\r\n        return;\r\n      }\r\n\r\n      try {\r\n        this.ws = new WebSocket(this.config.wsUrl);\r\n      } catch (err) {\r\n        reject(err);\r\n        return;\r\n      }\r\n\r\n      const connectionTimeout = setTimeout(() => {\r\n        if (this.ws && this.ws.readyState !== WebSocket.OPEN) {\r\n          this.ws.close();\r\n          reject(new Error('Connection timeout'));\r\n        }\r\n      }, 10000);\r\n\r\n      this.ws.onopen = () => {\r\n        clearTimeout(connectionTimeout);\r\n        LogHelper.log('[WebSocket] Connected to', this.config.wsUrl);\r\n        this.authenticate(token);\r\n        resolve();\r\n      };\r\n\r\n      this.ws.onmessage = (event) => {\r\n        try {\r\n          this.handleMessage(JSON.parse(event.data));\r\n        } catch (err) {\r\n          LogHelper.error('[WebSocket] Error parsing message:', err);\r\n        }\r\n      };\r\n\r\n      this.ws.onclose = (event) => {\r\n        clearTimeout(connectionTimeout);\r\n        LogHelper.log('[WebSocket] Disconnected:', event.code, event.reason);\r\n        this.isAuthenticated = false;\r\n        this.config.onConnectionChange(false);\r\n\r\n        if (this.config.autoReconnect && event.code !== 1000) {\r\n          this.scheduleReconnect();\r\n        }\r\n      };\r\n\r\n      this.ws.onerror = (error) => {\r\n        clearTimeout(connectionTimeout);\r\n        LogHelper.error('[WebSocket] Error:', error);\r\n        this.config.onError(error);\r\n      };\r\n    });\r\n  }\r\n\r\n  authenticate(token) {\r\n    const authCmd = {\r\n      authCmd: {\r\n        cmdId: this.nextCmdId(),\r\n        token: token,\r\n      },\r\n    };\r\n    this.ws.send(JSON.stringify(authCmd));\r\n    LogHelper.log('[WebSocket] Sent auth command');\r\n  }\r\n\r\n  subscribe(deviceIds) {\r\n    if (!this.isConnected()) {\r\n      LogHelper.warn('[WebSocket] Not connected, cannot subscribe');\r\n      return null;\r\n    }\r\n\r\n    if (!this.isAuthenticated) {\r\n      LogHelper.warn('[WebSocket] Not authenticated yet, waiting...');\r\n      // Queue subscription for after auth\r\n      setTimeout(() => this.subscribe(deviceIds), 500);\r\n      return null;\r\n    }\r\n\r\n    // Unsubscribe previous if exists\r\n    if (this.currentCmdId !== null) {\r\n      this.unsubscribe(this.currentCmdId);\r\n    }\r\n\r\n    const cmdId = this.nextCmdId();\r\n\r\n    const subscribeCmd = {\r\n      cmds: [\r\n        {\r\n          cmdId: cmdId,\r\n          type: 'ENTITY_DATA',\r\n          query: {\r\n            entityFilter: {\r\n              type: 'entityList',\r\n              entityType: 'DEVICE',\r\n              entityList: deviceIds,\r\n            },\r\n            entityFields: [{ type: 'ENTITY_FIELD', key: 'name' }],\r\n            latestValues: this.config.keys.map((key) => ({\r\n              type: 'TIME_SERIES',\r\n              key: key,\r\n            })),\r\n          },\r\n        },\r\n      ],\r\n    };\r\n\r\n    this.ws.send(JSON.stringify(subscribeCmd));\r\n    this.currentCmdId = cmdId;\r\n    this.lastSubscribedDevices = [...deviceIds];\r\n\r\n    LogHelper.log(`[WebSocket] Subscribed to ${deviceIds.length} devices (cmdId: ${cmdId})`);\r\n    return cmdId;\r\n  }\r\n\r\n  unsubscribe(cmdId) {\r\n    if (!this.isConnected() || cmdId === null) return;\r\n\r\n    const unsubscribeCmd = {\r\n      cmds: [\r\n        {\r\n          cmdId: cmdId,\r\n          type: 'ENTITY_DATA_UNSUBSCRIBE',\r\n        },\r\n      ],\r\n    };\r\n\r\n    this.ws.send(JSON.stringify(unsubscribeCmd));\r\n\r\n    if (this.currentCmdId === cmdId) {\r\n      this.currentCmdId = null;\r\n    }\r\n\r\n    LogHelper.log(`[WebSocket] Unsubscribed (cmdId: ${cmdId})`);\r\n  }\r\n\r\n  handleMessage(message) {\r\n    // Handle authentication response\r\n    if (message.authCmd !== undefined) {\r\n      if (message.authCmd.success !== false) {\r\n        LogHelper.log('[WebSocket] Authentication successful');\r\n        this.isAuthenticated = true;\r\n        this.reconnectAttempts = 0;\r\n        STATE.wsConsecutiveFailures = 0;\r\n        this.config.onConnectionChange(true);\r\n      } else {\r\n        LogHelper.error('[WebSocket] Authentication failed:', message.authCmd.errorMsg);\r\n        this.config.onError(new Error('Authentication failed: ' + (message.authCmd.errorMsg || 'Unknown')));\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle initial data\r\n    if (message.cmdId && message.data?.data) {\r\n      LogHelper.log(`[WebSocket] Received initial data for ${message.data.data.length} devices`);\r\n      this.processDataUpdate(message.data.data);\r\n    }\r\n\r\n    // Handle push updates\r\n    if (message.cmdId && message.update) {\r\n      LogHelper.log(`[WebSocket] Received update for ${message.update.length} devices`);\r\n      this.processDataUpdate(message.update);\r\n    }\r\n\r\n    // Handle errors\r\n    if (message.errorCode) {\r\n      LogHelper.error('[WebSocket] Error response:', message.errorCode, message.errorMsg);\r\n      this.config.onError(new Error(message.errorMsg || 'Unknown error'));\r\n    }\r\n  }\r\n\r\n  processDataUpdate(dataArray) {\r\n    if (!Array.isArray(dataArray)) return;\r\n\r\n    dataArray.forEach((item) => {\r\n      const deviceId = item.entityId?.id;\r\n      if (!deviceId) return;\r\n\r\n      const latest = item.latest?.TIME_SERIES || {};\r\n\r\n      Object.entries(latest).forEach(([key, entry]) => {\r\n        const value = parseFloat(entry.value) || 0;\r\n        const timestamp = entry.ts || Date.now();\r\n\r\n        this.config.onData(deviceId, key, value, timestamp);\r\n      });\r\n    });\r\n  }\r\n\r\n  scheduleReconnect() {\r\n    if (this.reconnectTimeoutId) {\r\n      clearTimeout(this.reconnectTimeoutId);\r\n    }\r\n\r\n    const backoff = REALTIME_CONFIG.WS_RECONNECT_BACKOFF;\r\n    const delay = backoff[Math.min(this.reconnectAttempts, backoff.length - 1)];\r\n\r\n    this.reconnectAttempts++;\r\n    STATE.wsConsecutiveFailures++;\r\n\r\n    if (STATE.wsConsecutiveFailures >= REALTIME_CONFIG.FALLBACK_AFTER_FAILURES) {\r\n      LogHelper.error('[WebSocket] Max reconnect attempts reached, triggering fallback to REST');\r\n      this.config.onError(new Error('Max reconnect attempts reached'));\r\n      return;\r\n    }\r\n\r\n    LogHelper.log(`[WebSocket] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);\r\n\r\n    this.reconnectTimeoutId = setTimeout(async () => {\r\n      try {\r\n        await this.connect();\r\n\r\n        // Re-subscribe to previous devices\r\n        if (this.lastSubscribedDevices.length > 0) {\r\n          setTimeout(() => this.subscribe(this.lastSubscribedDevices), 500);\r\n        }\r\n      } catch (err) {\r\n        LogHelper.error('[WebSocket] Reconnect failed:', err);\r\n        // Will trigger another reconnect via onclose\r\n      }\r\n    }, delay);\r\n  }\r\n\r\n  disconnect() {\r\n    this.config.autoReconnect = false;\r\n\r\n    if (this.reconnectTimeoutId) {\r\n      clearTimeout(this.reconnectTimeoutId);\r\n      this.reconnectTimeoutId = null;\r\n    }\r\n\r\n    if (this.ws) {\r\n      if (this.currentCmdId !== null) {\r\n        this.unsubscribe(this.currentCmdId);\r\n      }\r\n\r\n      this.ws.close(1000, 'Client disconnect');\r\n      this.ws = null;\r\n    }\r\n\r\n    this.currentCmdId = null;\r\n    this.lastSubscribedDevices = [];\r\n    this.isAuthenticated = false;\r\n  }\r\n\r\n  nextCmdId() {\r\n    return ++this.cmdIdCounter;\r\n  }\r\n\r\n  isConnected() {\r\n    return this.ws?.readyState === WebSocket.OPEN;\r\n  }\r\n\r\n  getSubscribedDevices() {\r\n    return [...this.lastSubscribedDevices];\r\n  }\r\n}\r\n\r\n// ============================================\r\n// RFC-0093: REAL-TIME MODE FUNCTIONS\r\n// ============================================\r\n\r\n/**\r\n * RFC-0093: Handle WebSocket data updates\r\n */\r\nfunction handleWebSocketData(deviceId, key, value, timestamp) {\r\n  if (key === 'power') {\r\n    STATE.realTimePowerMap.set(deviceId, { value, timestamp });\r\n    updateCardPowerDisplay(deviceId, { value, timestamp });\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0093: Handle WebSocket connection changes\r\n */\r\nfunction handleWebSocketConnectionChange(isConnected) {\r\n  updateConnectionIndicator(isConnected ? 'websocket' : 'disconnected');\r\n\r\n  if (isConnected && STATE.realTimeActive) {\r\n    // Subscribe to visible devices\r\n    const visibleDeviceIds = getVisibleDeviceIds();\r\n    if (visibleDeviceIds.length > 0 && websocketService) {\r\n      websocketService.subscribe(visibleDeviceIds);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0093: Handle WebSocket errors - trigger fallback to REST\r\n */\r\nfunction handleWebSocketError(error) {\r\n  LogHelper.error('[RealTime] WebSocket error:', error.message);\r\n\r\n  if (STATE.wsConsecutiveFailures >= REALTIME_CONFIG.FALLBACK_AFTER_FAILURES) {\r\n    LogHelper.warn('[RealTime] Falling back to REST polling mode');\r\n\r\n    // Show notification\r\n    const MyIOToast = MyIOLibrary?.MyIOToast || window.MyIOToast;\r\n    if (MyIOToast) {\r\n      MyIOToast.warning('WebSocket indisponível. Usando modo REST polling.', { duration: 5000 });\r\n    }\r\n\r\n    // Switch to REST mode\r\n    STATE.realTimeEngine = 'rest';\r\n    updateConnectionIndicator('rest');\r\n\r\n    // Start REST polling if real-time is still active\r\n    if (STATE.realTimeActive) {\r\n      startRestPollingMode();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0093: Get visible device IDs based on current filters\r\n */\r\nfunction getVisibleDeviceIds() {\r\n  const filtered = applyFilters(STATE.allDevices, STATE.searchTerm, STATE.selectedIds, STATE.sortMode);\r\n  return filtered.map((d) => d.entityId).filter((id) => id);\r\n}\r\n\r\n/**\r\n * RFC-0093: Update connection status indicator in UI\r\n */\r\nfunction updateConnectionIndicator(mode) {\r\n  const indicator = document.getElementById('realtimeConnectionIndicator');\r\n  if (!indicator) return;\r\n\r\n  indicator.className = 'realtime-connection-indicator';\r\n\r\n  switch (mode) {\r\n    case 'websocket':\r\n      indicator.innerHTML = '<span class=\"ws-dot\"></span> WebSocket';\r\n      indicator.classList.add('ws-connected');\r\n      break;\r\n    case 'rest':\r\n      indicator.innerHTML = '<span class=\"rest-dot\"></span> REST Polling';\r\n      indicator.classList.add('rest-mode');\r\n      break;\r\n    case 'disconnected':\r\n      indicator.innerHTML = '<span class=\"disconnected-dot\"></span> Reconectando...';\r\n      indicator.classList.add('disconnected');\r\n      break;\r\n    default:\r\n      indicator.innerHTML = '';\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0093: Start WebSocket real-time mode\r\n */\r\nasync function startWebSocketMode() {\r\n  LogHelper.log('[RealTime] Starting WebSocket mode...');\r\n\r\n  STATE.realTimeEngine = 'websocket';\r\n  STATE.wsConsecutiveFailures = 0;\r\n\r\n  // Create WebSocket service\r\n  websocketService = new RealTimeWebSocketService({\r\n    onData: handleWebSocketData,\r\n    onConnectionChange: handleWebSocketConnectionChange,\r\n    onError: handleWebSocketError,\r\n    autoReconnect: true,\r\n  });\r\n\r\n  try {\r\n    await websocketService.connect();\r\n    updateConnectionIndicator('websocket');\r\n  } catch (err) {\r\n    LogHelper.error('[RealTime] WebSocket connection failed:', err);\r\n    STATE.wsConsecutiveFailures++;\r\n\r\n    if (STATE.wsConsecutiveFailures >= REALTIME_CONFIG.FALLBACK_AFTER_FAILURES) {\r\n      handleWebSocketError(err);\r\n    } else {\r\n      // Try reconnecting\r\n      websocketService.scheduleReconnect();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0093: Start REST polling mode (fallback)\r\n */\r\nfunction startRestPollingMode() {\r\n  LogHelper.log('[RealTime] Starting REST polling mode...');\r\n\r\n  STATE.realTimeEngine = 'rest';\r\n  updateConnectionIndicator('rest');\r\n\r\n  // Initial fetch\r\n  fetchAllDevicesPowerREST();\r\n\r\n  // Start polling loop\r\n  STATE.realTimeIntervalId = setInterval(() => {\r\n    if (!STATE.realTimeActive) return;\r\n\r\n    // Check max runtime\r\n    if (Date.now() - STATE.realTimeStartedAt > REALTIME_CONFIG.MAX_RUNTIME_MS) {\r\n      LogHelper.log('[RealTime] Max runtime reached, stopping...');\r\n      stopRealTimeMode();\r\n      return;\r\n    }\r\n\r\n    fetchAllDevicesPowerREST();\r\n  }, REALTIME_CONFIG.REST_INTERVAL_MS);\r\n\r\n  // Start countdown update\r\n  STATE.realTimeCountdownId = setInterval(updateProgressBar, REALTIME_CONFIG.COUNTDOWN_UPDATE_MS);\r\n}\r\n\r\n/**\r\n * RFC-0093: Fetch power via REST API (fallback mode)\r\n */\r\nasync function fetchAllDevicesPowerREST() {\r\n  const filtered = applyFilters(STATE.allDevices, STATE.searchTerm, STATE.selectedIds, STATE.sortMode);\r\n\r\n  if (filtered.length === 0) {\r\n    LogHelper.log('[REST] No devices to fetch');\r\n    return;\r\n  }\r\n\r\n  setProgressFetchingState(true);\r\n  LogHelper.log(`[REST] Fetching power for ${filtered.length} devices...`);\r\n\r\n  const batches = [];\r\n  for (let i = 0; i < filtered.length; i += REALTIME_CONFIG.BATCH_SIZE) {\r\n    batches.push(filtered.slice(i, i + REALTIME_CONFIG.BATCH_SIZE));\r\n  }\r\n\r\n  let fetchedCount = 0;\r\n\r\n  for (const batch of batches) {\r\n    const promises = batch.map(async (device) => {\r\n      const entityId = device.entityId;\r\n      if (!entityId) return;\r\n\r\n      const powerData = await fetchDevicePowerREST(entityId);\r\n      if (powerData) {\r\n        STATE.realTimePowerMap.set(entityId, powerData);\r\n        updateCardPowerDisplay(entityId, powerData);\r\n        fetchedCount++;\r\n      }\r\n    });\r\n\r\n    await Promise.all(promises);\r\n\r\n    if (batches.indexOf(batch) < batches.length - 1) {\r\n      await new Promise((resolve) => setTimeout(resolve, REALTIME_CONFIG.BATCH_DELAY_MS));\r\n    }\r\n  }\r\n\r\n  setProgressFetchingState(false);\r\n  STATE.realTimeStartedAt = Date.now(); // Reset for countdown\r\n  LogHelper.log(`[REST] Updated ${fetchedCount} cards`);\r\n}\r\n\r\n/**\r\n * RFC-0093: Fetch single device power via REST (fallback)\r\n */\r\nasync function fetchDevicePowerREST(deviceId) {\r\n  try {\r\n    const token = localStorage.getItem('jwt_token');\r\n    if (!token) return null;\r\n\r\n    const tbHost = window.MyIOUtils?.getTbHost?.() || '';\r\n    const url = `${tbHost}/api/plugins/telemetry/DEVICE/${deviceId}/values/timeseries?keys=power&limit=1&agg=NONE&useStrictDataTypes=true`;\r\n\r\n    const response = await fetch(url, {\r\n      method: 'GET',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'X-Authorization': `Bearer ${token}`,\r\n      },\r\n    });\r\n\r\n    if (!response.ok) return null;\r\n\r\n    const data = await response.json();\r\n    if (data.power && data.power.length > 0) {\r\n      return {\r\n        value: Number(data.power[0].value) || 0,\r\n        timestamp: data.power[0].ts || Date.now(),\r\n      };\r\n    }\r\n\r\n    return { value: 0, timestamp: Date.now() };\r\n  } catch (err) {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0093: Set progress bar fetching state\r\n */\r\nfunction setProgressFetchingState(isFetching) {\r\n  const progressFill = document.getElementById('realtimeProgressFill');\r\n  const progressText = document.getElementById('realtimeProgressText');\r\n\r\n  if (progressFill) {\r\n    progressFill.classList.toggle('fetching', isFetching);\r\n    if (isFetching) progressFill.style.width = '100%';\r\n  }\r\n\r\n  if (progressText) {\r\n    progressText.classList.toggle('fetching', isFetching);\r\n    if (isFetching) progressText.textContent = '...';\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0093: Update a single card's power display\r\n */\r\nfunction updateCardPowerDisplay(entityId, powerData) {\r\n  const card = document.querySelector(`[data-entity-id=\"${entityId}\"]`);\r\n  if (!card) return;\r\n\r\n  if (!card.classList.contains('realtime-mode')) {\r\n    card.classList.add('realtime-mode');\r\n  }\r\n\r\n  const powerEl = card.querySelector('.power');\r\n  if (powerEl) {\r\n    const powerKw = (powerData.value / 1000).toFixed(2);\r\n    powerEl.textContent = powerKw;\r\n  }\r\n\r\n  let lastUpdateEl = card.querySelector('.last-update');\r\n  if (!lastUpdateEl) {\r\n    const subEl = card.querySelector('.sub');\r\n    if (subEl) {\r\n      subEl.innerHTML = `<span class=\"last-update\"><span class=\"update-icon\">🕐</span> ${formatTimeAgo(\r\n        powerData.timestamp\r\n      )}</span>`;\r\n    }\r\n  } else {\r\n    lastUpdateEl.innerHTML = `<span class=\"update-icon\">🕐</span> ${formatTimeAgo(powerData.timestamp)}`;\r\n  }\r\n\r\n  if (!card.querySelector('.realtime-badge')) {\r\n    const badge = document.createElement('div');\r\n    badge.className = 'realtime-badge';\r\n    badge.innerHTML = '<span class=\"live-dot\"></span> LIVE';\r\n    card.appendChild(badge);\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0093: Format timestamp as relative time\r\n */\r\nfunction formatTimeAgo(timestamp) {\r\n  const diff = Math.floor((Date.now() - timestamp) / 1000);\r\n  if (diff < 5) return 'agora';\r\n  if (diff < 60) return `há ${diff}s`;\r\n  if (diff < 3600) return `há ${Math.floor(diff / 60)}min`;\r\n  return `há ${Math.floor(diff / 3600)}h`;\r\n}\r\n\r\n/**\r\n * RFC-0093: Update progress bar (REST mode only)\r\n */\r\nfunction updateProgressBar() {\r\n  if (STATE.realTimeEngine !== 'rest') return;\r\n\r\n  const progressContainer = document.getElementById('realtimeProgressContainer');\r\n  const progressFill = document.getElementById('realtimeProgressFill');\r\n  const progressText = document.getElementById('realtimeProgressText');\r\n\r\n  if (!progressContainer || !progressFill || !progressText) return;\r\n  if (!STATE.realTimeActive) {\r\n    progressContainer.style.display = 'none';\r\n    return;\r\n  }\r\n\r\n  progressContainer.style.display = 'flex';\r\n\r\n  const elapsed = (Date.now() - STATE.realTimeStartedAt) % REALTIME_CONFIG.REST_INTERVAL_MS;\r\n  const remaining = Math.max(0, Math.ceil((REALTIME_CONFIG.REST_INTERVAL_MS - elapsed) / 1000));\r\n  const percentage = ((REALTIME_CONFIG.REST_INTERVAL_MS - elapsed) / REALTIME_CONFIG.REST_INTERVAL_MS) * 100;\r\n\r\n  progressFill.style.width = `${Math.max(0, percentage)}%`;\r\n  progressText.textContent = `${remaining}s`;\r\n}\r\n\r\n/**\r\n * RFC-0093: Start real-time mode (WebSocket default, REST fallback)\r\n */\r\nasync function startRealTimeMode() {\r\n  if (STATE.realTimeActive) return;\r\n\r\n  LogHelper.log('[RealTime] Starting real-time mode...');\r\n\r\n  STATE.realTimeActive = true;\r\n  STATE.realTimeStartedAt = Date.now();\r\n  STATE.realTimePowerMap.clear();\r\n  STATE.realTimeEngine = REALTIME_CONFIG.DEFAULT_ENGINE;\r\n  STATE.wsConsecutiveFailures = 0;\r\n\r\n  // Update toggle button UI\r\n  const toggleBtn = document.getElementById('realtimeToggleBtn');\r\n  if (toggleBtn) {\r\n    toggleBtn.classList.add('active');\r\n    toggleBtn.querySelector('.toggle-status').textContent = 'ON';\r\n    toggleBtn.title = 'Desativar modo tempo real';\r\n  }\r\n\r\n  // Show settings and connection indicator\r\n  const settingsBtn = document.getElementById('realtimeSettingsBtn');\r\n  if (settingsBtn) settingsBtn.style.display = 'flex';\r\n\r\n  const progressContainer = document.getElementById('realtimeProgressContainer');\r\n  if (progressContainer) progressContainer.style.display = 'flex';\r\n\r\n  const connectionIndicator = document.getElementById('realtimeConnectionIndicator');\r\n  if (connectionIndicator) connectionIndicator.style.display = 'flex';\r\n\r\n  // Start with WebSocket (default)\r\n  if (REALTIME_CONFIG.DEFAULT_ENGINE === 'websocket') {\r\n    await startWebSocketMode();\r\n  } else {\r\n    startRestPollingMode();\r\n  }\r\n\r\n  LogHelper.log(`[RealTime] Mode started (engine: ${STATE.realTimeEngine})`);\r\n}\r\n\r\n/**\r\n * RFC-0093: Stop real-time mode\r\n */\r\nfunction stopRealTimeMode() {\r\n  if (!STATE.realTimeActive) return;\r\n\r\n  LogHelper.log('[RealTime] Stopping real-time mode...');\r\n\r\n  STATE.realTimeActive = false;\r\n\r\n  // Stop WebSocket\r\n  if (websocketService) {\r\n    websocketService.disconnect();\r\n    websocketService = null;\r\n  }\r\n\r\n  // Clear REST intervals\r\n  if (STATE.realTimeIntervalId) {\r\n    clearInterval(STATE.realTimeIntervalId);\r\n    STATE.realTimeIntervalId = null;\r\n  }\r\n  if (STATE.realTimeCountdownId) {\r\n    clearInterval(STATE.realTimeCountdownId);\r\n    STATE.realTimeCountdownId = null;\r\n  }\r\n\r\n  // Clear debounce timer\r\n  if (filterDebounceTimer) {\r\n    clearTimeout(filterDebounceTimer);\r\n    filterDebounceTimer = null;\r\n  }\r\n\r\n  // Update toggle button UI\r\n  const toggleBtn = document.getElementById('realtimeToggleBtn');\r\n  if (toggleBtn) {\r\n    toggleBtn.classList.remove('active');\r\n    toggleBtn.querySelector('.toggle-status').textContent = 'OFF';\r\n    toggleBtn.title = 'Ativar modo tempo real';\r\n  }\r\n\r\n  // Hide UI elements\r\n  const settingsBtn = document.getElementById('realtimeSettingsBtn');\r\n  if (settingsBtn) settingsBtn.style.display = 'none';\r\n\r\n  const progressContainer = document.getElementById('realtimeProgressContainer');\r\n  if (progressContainer) progressContainer.style.display = 'none';\r\n\r\n  const connectionIndicator = document.getElementById('realtimeConnectionIndicator');\r\n  if (connectionIndicator) connectionIndicator.style.display = 'none';\r\n\r\n  // Remove realtime-mode from cards\r\n  document.querySelectorAll('.equip-card.realtime-mode').forEach((card) => {\r\n    card.classList.remove('realtime-mode');\r\n    const badge = card.querySelector('.realtime-badge');\r\n    if (badge) badge.remove();\r\n  });\r\n\r\n  // Re-render cards with original data\r\n  reflowCards();\r\n\r\n  STATE.realTimePowerMap.clear();\r\n  STATE.realTimeStartedAt = null;\r\n  STATE.realTimeEngine = REALTIME_CONFIG.DEFAULT_ENGINE;\r\n\r\n  LogHelper.log('[RealTime] Mode stopped');\r\n}\r\n\r\n/**\r\n * RFC-0093: Toggle real-time mode\r\n */\r\nfunction toggleRealTimeMode() {\r\n  if (STATE.realTimeActive) {\r\n    stopRealTimeMode();\r\n  } else {\r\n    startRealTimeMode();\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0093: Show settings modal\r\n */\r\nfunction showRealtimeSettingsModal() {\r\n  if (realtimeSettingsModal) realtimeSettingsModal.remove();\r\n\r\n  const currentInterval = REALTIME_CONFIG.REST_INTERVAL_MS / 1000;\r\n  const currentEngine = STATE.realTimeEngine;\r\n\r\n  const modalHTML = `\r\n    <div class=\"realtime-settings-modal\" id=\"realtimeSettingsModal\">\r\n      <div class=\"realtime-settings-card\">\r\n        <div class=\"realtime-settings-header\">\r\n          <h3>⚡ Configurações Tempo Real</h3>\r\n          <button class=\"realtime-settings-close\" id=\"realtimeSettingsClose\">×</button>\r\n        </div>\r\n        <div class=\"realtime-settings-body\">\r\n          <div class=\"realtime-settings-group\">\r\n            <label class=\"realtime-settings-label\">\r\n              Motor de Atualização\r\n              <span class=\"realtime-settings-sublabel\">WebSocket para true real-time, REST como fallback</span>\r\n            </label>\r\n            <div class=\"realtime-engine-selector\" id=\"engineSelector\">\r\n              <button class=\"realtime-engine-btn ${\r\n                currentEngine === 'websocket' ? 'active' : ''\r\n              }\" data-engine=\"websocket\">\r\n                <span>🔌</span> WebSocket\r\n              </button>\r\n              <button class=\"realtime-engine-btn ${\r\n                currentEngine === 'rest' ? 'active' : ''\r\n              }\" data-engine=\"rest\">\r\n                <span>🔄</span> REST Polling\r\n              </button>\r\n            </div>\r\n          </div>\r\n          <div class=\"realtime-settings-group\">\r\n            <label class=\"realtime-settings-label\">\r\n              Intervalo REST (fallback)\r\n              <span class=\"realtime-settings-sublabel\">Usado quando WebSocket não está disponível</span>\r\n            </label>\r\n            <div class=\"realtime-interval-selector\" id=\"intervalSelector\">\r\n              ${REALTIME_CONFIG.INTERVAL_OPTIONS.map(\r\n                (sec) =>\r\n                  `<button class=\"realtime-interval-btn ${\r\n                    sec === currentInterval ? 'active' : ''\r\n                  }\" data-interval=\"${sec}\">${sec}s</button>`\r\n              ).join('')}\r\n            </div>\r\n          </div>\r\n          <div class=\"realtime-settings-group\" style=\"margin-bottom: 0;\">\r\n            <label class=\"realtime-settings-label\">Informações</label>\r\n            <p style=\"font-size: 12px; color: var(--ink-2); margin: 0; line-height: 1.5;\">\r\n              • <b>WebSocket:</b> Atualizações instantâneas (< 100ms)<br>\r\n              • <b>REST:</b> Polling periódico, maior latência<br>\r\n              • Auto-fallback após 6 falhas de conexão<br>\r\n              • Desliga automaticamente após 30 minutos\r\n            </p>\r\n          </div>\r\n        </div>\r\n        <div class=\"realtime-settings-footer\">\r\n          <button class=\"realtime-settings-btn-cancel\" id=\"realtimeSettingsCancel\">Cancelar</button>\r\n          <button class=\"realtime-settings-btn-save\" id=\"realtimeSettingsSave\">Salvar</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  `;\r\n\r\n  const container = document.createElement('div');\r\n  container.innerHTML = modalHTML;\r\n  realtimeSettingsModal = container.firstElementChild;\r\n  document.body.appendChild(realtimeSettingsModal);\r\n\r\n  let selectedEngine = currentEngine;\r\n  let selectedInterval = currentInterval;\r\n\r\n  // Engine buttons\r\n  realtimeSettingsModal.querySelectorAll('.realtime-engine-btn').forEach((btn) => {\r\n    btn.addEventListener('click', () => {\r\n      realtimeSettingsModal\r\n        .querySelectorAll('.realtime-engine-btn')\r\n        .forEach((b) => b.classList.remove('active'));\r\n      btn.classList.add('active');\r\n      selectedEngine = btn.dataset.engine;\r\n    });\r\n  });\r\n\r\n  // Interval buttons\r\n  realtimeSettingsModal.querySelectorAll('.realtime-interval-btn').forEach((btn) => {\r\n    btn.addEventListener('click', () => {\r\n      realtimeSettingsModal\r\n        .querySelectorAll('.realtime-interval-btn')\r\n        .forEach((b) => b.classList.remove('active'));\r\n      btn.classList.add('active');\r\n      selectedInterval = parseInt(btn.dataset.interval, 10);\r\n    });\r\n  });\r\n\r\n  // Close/Cancel\r\n  realtimeSettingsModal\r\n    .querySelector('#realtimeSettingsClose')\r\n    .addEventListener('click', hideRealtimeSettingsModal);\r\n  realtimeSettingsModal\r\n    .querySelector('#realtimeSettingsCancel')\r\n    .addEventListener('click', hideRealtimeSettingsModal);\r\n\r\n  // Save\r\n  realtimeSettingsModal.querySelector('#realtimeSettingsSave').addEventListener('click', () => {\r\n    REALTIME_CONFIG.REST_INTERVAL_MS = selectedInterval * 1000;\r\n\r\n    // If engine changed and real-time is active, restart\r\n    if (selectedEngine !== STATE.realTimeEngine && STATE.realTimeActive) {\r\n      stopRealTimeMode();\r\n      REALTIME_CONFIG.DEFAULT_ENGINE = selectedEngine;\r\n      startRealTimeMode();\r\n    } else {\r\n      REALTIME_CONFIG.DEFAULT_ENGINE = selectedEngine;\r\n    }\r\n\r\n    LogHelper.log(`[RealTime] Settings saved - Engine: ${selectedEngine}, Interval: ${selectedInterval}s`);\r\n    hideRealtimeSettingsModal();\r\n  });\r\n\r\n  // Click outside / ESC\r\n  realtimeSettingsModal.addEventListener('click', (e) => {\r\n    if (e.target === realtimeSettingsModal) hideRealtimeSettingsModal();\r\n  });\r\n\r\n  const escHandler = (e) => {\r\n    if (e.key === 'Escape') {\r\n      hideRealtimeSettingsModal();\r\n      document.removeEventListener('keydown', escHandler);\r\n    }\r\n  };\r\n  document.addEventListener('keydown', escHandler);\r\n}\r\n\r\n/**\r\n * RFC-0093: Hide settings modal\r\n */\r\nfunction hideRealtimeSettingsModal() {\r\n  if (realtimeSettingsModal) {\r\n    realtimeSettingsModal.remove();\r\n    realtimeSettingsModal = null;\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0093: Bind real-time toggle and settings events\r\n */\r\nfunction bindRealTimeToggle() {\r\n  const toggleBtn = document.getElementById('realtimeToggleBtn');\r\n  if (toggleBtn) {\r\n    toggleBtn.addEventListener('click', toggleRealTimeMode);\r\n    LogHelper.log('[RealTime] Toggle button bound');\r\n  }\r\n\r\n  const settingsBtn = document.getElementById('realtimeSettingsBtn');\r\n  if (settingsBtn) {\r\n    settingsBtn.addEventListener('click', showRealtimeSettingsModal);\r\n    LogHelper.log('[RealTime] Settings button bound');\r\n  }\r\n}\r\n\r\n// ============================================\r\n// END RFC-0093: REAL-TIME WEBSOCKET SERVICE\r\n// ============================================\r\n\r\n// ============================================\r\n// RFC-0103: POWER LIMITS SETUP MODAL\r\n// ============================================\r\n\r\n/**\r\n * RFC-0103: Bind Power Limits Setup button\r\n */\r\nfunction bindPowerLimitsButton() {\r\n  const powerLimitsBtn = document.getElementById('powerLimitsBtn');\r\n  if (powerLimitsBtn) {\r\n    powerLimitsBtn.addEventListener('click', openPowerLimitsModal);\r\n    LogHelper.log('[PowerLimits] Button bound');\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0103: Open Power Limits Setup Modal\r\n */\r\nasync function openPowerLimitsModal() {\r\n  LogHelper.log('[PowerLimits] Opening modal...');\r\n\r\n  try {\r\n    // Check if MyIOLibrary is available\r\n    if (typeof MyIOLibrary === 'undefined' || !MyIOLibrary.openPowerLimitsSetupModal) {\r\n      console.error('[PowerLimits] MyIOLibrary.openPowerLimitsSetupModal not available');\r\n      window.alert('Configuração de limites não disponível. Verifique se a biblioteca está carregada.');\r\n      return;\r\n    }\r\n\r\n    // Get JWT token from widgetContext\r\n    //const jwtToken = self.ctx?.http?.getJwtToken?.() || self.ct/x?.dashboard?.getJwtToken?.();\r\n    const jwtToken = localStorage.getItem('jwt_token');\r\n    if (!jwtToken) {\r\n      console.error('[PowerLimits] JWT token not available');\r\n      window.alert('Erro de autenticação. Por favor, atualize a página.');\r\n      return;\r\n    }\r\n\r\n    // Get ThingsBoard base URL\r\n    const tbBaseUrl = window.location.origin;\r\n\r\n    // Open the modal\r\n    await MyIOLibrary.openPowerLimitsSetupModal({\r\n      token: jwtToken,\r\n      customerId: CUSTOMER_ID,\r\n      tbBaseUrl: tbBaseUrl,\r\n      domain: 'energy', // RFC-0103: EQUIPMENTS widget uses energy domain\r\n      existingMapPower: MAP_INSTANTANEOUS_POWER || null,\r\n      onSave: (updatedJson) => {\r\n        LogHelper.log('[PowerLimits] Configuration saved:', updatedJson);\r\n        // Update local cache\r\n        MAP_INSTANTANEOUS_POWER = updatedJson;\r\n        // Show success notification\r\n        showPowerLimitsNotification('Limites salvos com sucesso!', 'success');\r\n      },\r\n      onClose: () => {\r\n        LogHelper.log('[PowerLimits] Modal closed');\r\n      },\r\n    });\r\n\r\n    LogHelper.log('[PowerLimits] Modal opened successfully');\r\n  } catch (error) {\r\n    console.error('[PowerLimits] Error opening modal:', error);\r\n    window.alert('Erro ao abrir configuração de limites: ' + error.message);\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0103: Show notification for Power Limits actions\r\n */\r\nfunction showPowerLimitsNotification(message, type = 'info') {\r\n  // Use existing toast system if available, otherwise console\r\n  if (typeof MyIOLibrary !== 'undefined' && MyIOLibrary.MyIOToast) {\r\n    MyIOLibrary.MyIOToast.show(message, type);\r\n  } else {\r\n    console.log(`[PowerLimits][${type.toUpperCase()}] ${message}`);\r\n  }\r\n}\r\n\r\n// ============================================\r\n// END RFC-0103: POWER LIMITS SETUP MODAL\r\n// ============================================\r\n\r\n/**\r\n * Bind all filter-related events\r\n * RFC-0093: Search and filter button events are now handled by buildHeaderDevicesGrid\r\n */\r\nfunction bindFilterEvents() {\r\n  // RFC-0093: Search and filter buttons are now configured in onInit via buildHeaderDevicesGrid\r\n  // This function is kept for backwards compatibility but the main logic is in the header controller\r\n\r\n  // RFC-0072: All filter-related handlers (filter tabs, search, apply, reset)\r\n  // are now set up in setupModalCloseHandlers() when modal is moved to document.body\r\n  LogHelper.log('[EQUIPMENTS] bindFilterEvents - events managed by header controller');\r\n}\r\n\r\nself.onDestroy = function () {\r\n  if (self._onDateParams) {\r\n    window.removeEventListener('myio:date-params', self._onDateParams);\r\n  }\r\n  if (self._onFilterApplied) {\r\n    window.removeEventListener('myio:filter-applied', self._onFilterApplied);\r\n  }\r\n  if (self._onCustomersReady) {\r\n    window.removeEventListener('myio:customers-ready', self._onCustomersReady);\r\n  }\r\n\r\n  // RFC-0093: Cleanup real-time mode and WebSocket\r\n  if (STATE.realTimeActive) {\r\n    stopRealTimeMode();\r\n  }\r\n  if (websocketService) {\r\n    websocketService.disconnect();\r\n    websocketService = null;\r\n  }\r\n  if (STATE.realTimeIntervalId) {\r\n    clearInterval(STATE.realTimeIntervalId);\r\n    STATE.realTimeIntervalId = null;\r\n  }\r\n  if (STATE.realTimeCountdownId) {\r\n    clearInterval(STATE.realTimeCountdownId);\r\n    STATE.realTimeCountdownId = null;\r\n  }\r\n  if (filterDebounceTimer) {\r\n    clearTimeout(filterDebounceTimer);\r\n    filterDebounceTimer = null;\r\n  }\r\n  LogHelper.log('[EQUIPMENTS] [RFC-0093] Real-time mode and WebSocket cleanup complete');\r\n\r\n  // RFC-0093: Cleanup header controller\r\n  if (equipHeaderController) {\r\n    equipHeaderController.destroy();\r\n    equipHeaderController = null;\r\n    LogHelper.log('[EQUIPMENTS] [RFC-0093] Header controller destroyed');\r\n  }\r\n\r\n  // RFC-0090: Cleanup filter modal using shared factory\r\n  if (equipmentsFilterModal) {\r\n    equipmentsFilterModal.destroy();\r\n    equipmentsFilterModal = null;\r\n    LogHelper.log('[EQUIPMENTS] [RFC-0090] Filter modal destroyed');\r\n  }\r\n};\r\n",
      "settingsSchema": "{\r\n  \"schema\": {\r\n    \"type\": \"object\",\r\n    \"title\": \"Equipments Widget Settings\",\r\n    \"properties\": {\r\n        \"useNewComponents\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Use New Components\",\r\n            \"default\": true\r\n        },\r\n        \"enableSelection\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Enable Selection\",\r\n            \"default\": true\r\n        },\r\n        \"enableDragDrop\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Enable Drag Drop\",\r\n            \"default\": true\r\n        },\r\n        \"hideInfoMenuItem\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Hide Info Menu Item\",\r\n            \"default\": true\r\n        },\r\n        \"debugActive\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Debug Active\",\r\n            \"default\": false\r\n        },\r\n        \"activeTooltipDebug\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Active Tooltip Debug\",\r\n            \"default\": false\r\n        }\r\n    }\r\n  },\r\n  \"form\": [\r\n    \"useNewComponents\",\r\n    \"enableSelection\",\r\n    \"enableDragDrop\",\r\n    \"hideInfoMenuItem\",\r\n    \"debugActive\",\r\n    \"activeTooltipDebug\"\r\n  ]\r\n}\r\n",
      "dataKeySettingsSchema": "{}\n",
      "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Widget Head Office - EQUIPMENTS - v.5.2.0\",\"decimals\":null}"
    },
    "externalId": null,
    "resources": null,
    "id": {
      "entityType": "WIDGET_TYPE",
      "id": "c7e67050-c975-11f0-84a2-1f4ed3957b2a"
    },
    "scada": false,
    "tags": null
  },
  "relations": [],
  "attributes": {
    "SERVER_SCOPE": []
  }
}