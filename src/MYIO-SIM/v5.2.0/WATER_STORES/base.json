{
  "entityType": "WIDGET_TYPE",
  "entity": {
    "fqn": "widget_head_office_water_stores_v_5_2_0",
    "name": "Widget Head Office - WATER STORES  - v.5.2.0",
    "deprecated": false,
    "image": null,
    "description": null,
    "descriptor": {
      "type": "latest",
      "sizeX": 7.5,
      "sizeY": 3,
      "resources": [
        {
          "url": "https://graphs.staging.apps.myio-bas.com/sdk/energy-chart-sdk.umd.js"
        },
        {
          "url": "https://unpkg.com/myio-js-library@0.1.177/dist/myio-js-library.umd.min.js"
        },
        {
          "url": "https://cdn.jsdelivr.net/npm/chart.js"
        }
      ],
      "templateHtml": "<section class=\"water-stores-root\" id=\"waterStoresWrap\">\r\n  <!-- RFC-0094: Water Stores widget simplified following STORES/EQUIPMENTS pattern -->\r\n\r\n  <div class=\"toolbar-zoom\">\r\n    <div class=\"shopping-filter-chips\" id=\"waterStoresShoppingFilterChips\"></div>\r\n  </div>\r\n\r\n  <!-- RFC-0094: Header injected dynamically via buildHeaderDevicesGrid -->\r\n  <div id=\"waterStoresHeaderContainer\"></div>\r\n\r\n  <section id=\"waterStoresList\" class=\"water-stores-list\"></section>\r\n\r\n  <!-- RFC-0094: Filter Modal injected dynamically via createFilterModal -->\r\n</section>\r\n",
      "templateCss": "/* ====== TOKENS (escopo no wrap) - matching EQUIPMENTS ====== */\r\n.water-stores-root {\r\n  /* escala global de fontes (ajustada via JS) */\r\n  --fs: 0.94;\r\n\r\n  /* cores e layout - Water themed */\r\n  --card-grad: linear-gradient(180deg, #ffffff 0%, #f0f9ff 100%);\r\n  --card-bd: #bae6fd;\r\n  --ink-1: #0c4a6e;\r\n  --ink-2: #64748b;\r\n  --blue: #0288d1;\r\n  --accent: #0ea5e9;\r\n  --danger: #e54848;\r\n  --shadow: 0 8px 24px rgba(2, 136, 209, 0.08);\r\n  --shadow-hover: 0 14px 36px rgba(2, 136, 209, 0.16);\r\n  --radius: 20px;\r\n  --brand: #0288d1;\r\n  --brand-ghost: rgba(2, 136, 209, 0.08);\r\n\r\n  /* tipografia derivada da escala */\r\n  --fs-2xs: calc(11px * var(--fs));\r\n  --fs-xs: calc(12px * var(--fs));\r\n  --fs-sm: calc(13px * var(--fs));\r\n  --fs-md: calc(14px * var(--fs));\r\n  --fs-lg: calc(16px * var(--fs));\r\n  --fs-xl: calc(20px * var(--fs));\r\n  --fs-xxl: calc(28px * var(--fs));\r\n\r\n  /* padding para nÃ£o \"encostar\" no contorno do widget */\r\n  position: relative;\r\n  box-sizing: border-box;\r\n  padding: 12px;\r\n  width: 100%;\r\n  height: 100%;\r\n  overflow: auto; /* FIX: Same as STORES - allows vertical scroll */\r\n  background: transparent;\r\n}\r\n\r\n/* ====== CONTROLES DE ZOOM ====== */\r\n.water-stores-root .toolbar-zoom {\r\n  position: sticky;\r\n  top: 6px;\r\n  z-index: 2;\r\n  display: flex;\r\n  gap: 6px;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  margin-bottom: 8px;\r\n}\r\n\r\n.water-stores-root .toolbar-zoom button {\r\n  border: 1px solid var(--card-bd);\r\n  background: #fff;\r\n  border-radius: 10px;\r\n  padding: 4px 10px;\r\n  font-size: var(--fs-lg);\r\n  color: var(--ink-1);\r\n  cursor: pointer;\r\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);\r\n}\r\n\r\n.water-stores-root .toolbar-zoom button:hover {\r\n  background: #f0f9ff;\r\n}\r\n\r\n/* ====== SHOPPING FILTER CHIPS ====== */\r\n.water-stores-root .shopping-filter-chips {\r\n  display: flex;\r\n  gap: 6px;\r\n  flex-wrap: wrap;\r\n  align-items: center;\r\n  flex: 1;\r\n  margin-right: 12px;\r\n}\r\n\r\n.water-stores-root .shopping-filter-chips .filter-chip {\r\n  display: inline-flex;\r\n  align-items: center;\r\n  gap: 6px;\r\n  background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);\r\n  border: 1px solid #7dd3fc;\r\n  border-radius: 8px;\r\n  padding: 3px 8px;\r\n  font-size: var(--fs-xs);\r\n  color: #0c4a6e;\r\n  font-weight: 500;\r\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);\r\n  white-space: nowrap;\r\n}\r\n\r\n.water-stores-root .shopping-filter-chips .filter-chip-icon {\r\n  font-size: 10px;\r\n  opacity: 0.7;\r\n}\r\n\r\n/* ====== CARDS GRID (matching EQUIPMENTS) ====== */\r\n.water-stores-root .water-stores-list {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\r\n  gap: 16px;\r\n  margin-top: 24px;\r\n  padding-bottom: 100px;\r\n}\r\n\r\n.water-stores-root .water-stores-list > * {\r\n  min-width: 0;\r\n  width: auto;\r\n  box-sizing: border-box;\r\n}\r\n\r\n/* Responsive grid - matching EQUIPMENTS */\r\n@media (min-width: 1920px) {\r\n  .water-stores-root .water-stores-list {\r\n    grid-template-columns: repeat(6, 1fr);\r\n    gap: 14px;\r\n  }\r\n}\r\n\r\n@media (min-width: 1600px) and (max-width: 1919px) {\r\n  .water-stores-root .water-stores-list {\r\n    grid-template-columns: repeat(5, 1fr);\r\n    gap: 15px;\r\n  }\r\n}\r\n\r\n@media (min-width: 1280px) and (max-width: 1599px) {\r\n  .water-stores-root .water-stores-list {\r\n    grid-template-columns: repeat(5, 1fr);\r\n    gap: 14px;\r\n  }\r\n}\r\n\r\n@media (min-width: 1024px) and (max-width: 1279px) {\r\n  .water-stores-root .water-stores-list {\r\n    grid-template-columns: repeat(4, 1fr);\r\n    gap: 16px;\r\n  }\r\n}\r\n\r\n@media (max-width: 1023px) {\r\n  .water-stores-root .water-stores-list {\r\n    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\r\n    gap: 12px;\r\n  }\r\n}\r\n\r\n/* RFC-0093: Filter actions, search, modal, and button styles now injected from MAIN via injectHeaderAndModalCSS() */\r\n\r\n/* ====== LOADING OVERLAY ====== */\r\n.water-stores-root .water-stores-loading-overlay {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  background: rgba(255, 255, 255, 0.95);\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  z-index: 1000;\r\n  backdrop-filter: blur(4px);\r\n}\r\n\r\n.water-stores-root .loading-spinner {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  gap: 16px;\r\n}\r\n\r\n.water-stores-root .loading-spinner p {\r\n  font-size: var(--fs-md);\r\n  font-weight: 600;\r\n  color: var(--ink-1);\r\n  margin: 0;\r\n}\r\n\r\n/* ====== SCROLLBAR ====== */\r\n.water-stores-root .water-stores-list::-webkit-scrollbar {\r\n  width: 8px;\r\n}\r\n\r\n.water-stores-root .water-stores-list::-webkit-scrollbar-thumb {\r\n  background: #7dd3fc;\r\n  border-radius: 6px;\r\n}\r\n\r\n/* ====== CARD ACTIONS (side buttons) ====== */\r\n.water-stores-root .device-card-centered .card-actions {\r\n  top: 50% !important;\r\n  transform: translateY(-50%) !important;\r\n  left: 12px !important;\r\n  gap: 10px !important;\r\n}\r\n\r\n.water-stores-root .device-card-centered .card-action {\r\n  width: 38px !important;\r\n  height: 38px !important;\r\n  min-width: 38px;\r\n  min-height: 38px;\r\n  border-radius: 12px !important;\r\n}\r\n\r\n.water-stores-root .device-card-centered .card-action img {\r\n  width: 20px !important;\r\n  height: 20px !important;\r\n}\r\n\r\n/* ====== ANIMATIONS ====== */\r\n@keyframes fadeIn {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n@keyframes spin {\r\n  0% {\r\n    transform: rotate(0deg);\r\n  }\r\n  100% {\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n\r\n/* RFC-0093: Modal styling now injected from MAIN via injectHeaderAndModalCSS() */\r\n",
      "controllerScript": "/* =========================================================================\n * ThingsBoard Widget: Water Stores - Device Cards for Water Meters (MyIO)\n * RFC-0094: Aligned with STORES pattern using buildHeaderDevicesGrid and createFilterModal\n * - Filters devices by aliasName = 'Todos Hidrometros Lojas'\n * - Uses domain='water' for MÂ³ formatting\n * - Datas obrigatÃ³rias: startDateISO / endDateISO\n * - Se ausentes no onInit: usa \"current month so far\" (1Âº dia 00:00 â†’ hoje 23:59)\n * - Modal premium (busy) no widget durante carregamentos\n * - Modal premium global (fora do widget) para sucesso, com contador e reload\n * - onDataUpdated: no-op\n * - Evento (myio:update-date): mostra modal + atualiza\n * =========================================================================*/\n\n/* eslint-disable no-undef, no-unused-vars */\n\n// ============================================\n// SHARED UTILITIES (from MAIN via window.MyIOUtils)\n// ============================================\nconst LogHelper = window.MyIOUtils?.LogHelper || {\n  log: (...args) => console.log(...args),\n  warn: (...args) => console.warn(...args),\n  error: (...args) => console.error(...args),\n};\n\nconst getDataApiHost =\n  window.MyIOUtils?.getDataApiHost ||\n  (() => {\n    console.error('[WATER_STORES] getDataApiHost not available - MAIN widget not loaded');\n    return localStorage.getItem('__MYIO_DATA_API_HOST__') || 'https://api.data.apps.myio-bas.com';\n  });\n\n// RFC-0071: Device Profile functions (from MAIN)\nconst fetchDeviceProfiles =\n  window.MyIOUtils?.fetchDeviceProfiles ||\n  (() => {\n    console.error('[WATER_STORES] fetchDeviceProfiles not available - MAIN widget not loaded');\n    return Promise.resolve(new Map());\n  });\n\nconst fetchDeviceDetails =\n  window.MyIOUtils?.fetchDeviceDetails ||\n  (() => {\n    console.error('[WATER_STORES] fetchDeviceDetails not available - MAIN widget not loaded');\n    return Promise.resolve({});\n  });\n\nconst addDeviceProfileAttribute =\n  window.MyIOUtils?.addDeviceProfileAttribute ||\n  (() => {\n    console.error('[WATER_STORES] addDeviceProfileAttribute not available - MAIN widget not loaded');\n    return Promise.resolve({ ok: false, status: 0, data: null });\n  });\n\nconst syncDeviceProfileAttributes =\n  window.MyIOUtils?.syncDeviceProfileAttributes ||\n  (() => {\n    console.error('[WATER_STORES] syncDeviceProfileAttributes not available - MAIN widget not loaded');\n    return Promise.resolve({ synced: 0, skipped: 0, errors: 0 });\n  });\n\n// RFC-0094: UI Helper from MAIN (replaces local getCustomerNameForDevice)\nconst getCustomerNameForDevice =\n  window.MyIOUtils?.getCustomerNameForDevice ||\n  ((device) => {\n    console.error('[WATER_STORES] getCustomerNameForDevice not available - MAIN widget not loaded');\n    return device?.customerId ? `ID: ${device.customerId.substring(0, 8)}...` : 'N/A';\n  });\n\n// RFC-0094: Device status calculation functions from MAIN\nconst getConsumptionRangesHierarchical = window.MyIOUtils?.getConsumptionRangesHierarchical;\nconst mapConnectionStatus = window.MyIOUtils?.mapConnectionStatus || ((status) => status || 'offline');\n\n// RFC-0094: formatarDuracao for operationHours calculation (from MAIN)\nconst formatarDuracao = window.MyIOUtils?.formatarDuracao || ((ms) => `${Math.round(ms / 1000)}s`);\n\n// RFC-0094: Global MAP_INSTANTANEOUS_POWER (will be loaded from settings if available)\nlet MAP_INSTANTANEOUS_POWER = null;\n\nLogHelper.log('ðŸš€ [WATER_STORES] Controller loaded - VERSION WITH RFC-0094 PATTERN');\n\nconst MAX_FIRST_HYDRATES = 1;\n\nlet __deviceProfileSyncComplete = false;\n\n// RFC-0094: Centralized header controller\nlet waterStoresHeaderController = null;\n\nlet dateUpdateHandler = null;\nlet dataProvideHandler = null; // RFC-0042: Orchestrator data listener\nlet waterDataReadyHandler = null; // FIX: Handler for myio:water-data-ready from MAIN\nlet MyIO = null;\nlet hasRequestedInitialData = false; // Flag to prevent duplicate initial requests\nlet lastProcessedPeriodKey = null; // Track last processed periodKey to prevent duplicate processing\nlet busyTimeoutId = null; // Timeout ID for busy fallback\n\n// RFC-0094: Widget configuration (from settings) - WATER DOMAIN\nlet WIDGET_DOMAIN = 'water';\n\n// RFC-0063: Classification mode configuration\nlet USE_IDENTIFIER_CLASSIFICATION = false; // Flag to enable identifier-based classification\nlet USE_HYBRID_CLASSIFICATION = false; // Flag to enable hybrid mode (identifier + labels)\n\n/** ===================== STATE ===================== **/\nlet CLIENT_ID = '';\nlet CLIENT_SECRET = '';\nlet CUSTOMER_ING_ID = '';\nlet MyIOAuth = null;\n\nconst STATE = {\n  itemsBase: [], // lista autoritativa (TB)\n  itemsEnriched: [], // lista com totals + perc\n  searchActive: false,\n  searchTerm: '',\n  selectedIds: /** @type {Set<string> | null} */ (null),\n  sortMode: /** @type {'cons_desc'|'cons_asc'|'alpha_asc'|'alpha_desc'} */ ('cons_desc'),\n  firstHydrates: 0,\n  selectedShoppingIds: [], // RFC-0093: Shopping filter from MENU\n};\n\nlet hydrating = false;\n\n/** ===================== HELPERS (DOM) ===================== **/\nconst $root = () => $(self.ctx.$container[0]);\nconst $list = () => $root().find('#waterStoresList');\nconst $count = () => $root().find('#waterStoresCount');\nconst $total = () => $root().find('#waterStoresTotal');\nconst $modal = () => $root().find('#filterModal');\n\n/** ===================== BUSY MODAL (no widget) ===================== **/\nconst BUSY_ID = 'myio-busy-modal';\nfunction ensureBusyModalDOM() {\n  let $m = $root().find(`#${BUSY_ID}`);\n  if ($m.length) return $m;\n\n  const html = `\n  <div id=\"${BUSY_ID}\" style=\"\n      position:absolute; inset:0; display:none;\n      background: rgba(150,132,181,0.45); /* #9684B5 com transparÃªncia */\n      backdrop-filter: blur(5px);\n      z-index:9999; align-items:center; justify-content:center;\n      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;\">\n    <div style=\"\n        background:#2d1458; color:#fff;\n        border:1px solid rgba(255,255,255,0.10);\n        box-shadow:0 12px 40px rgba(0,0,0,.35);\n        border-radius:18px; padding:22px 26px; min-width:320px;\">\n      <div style=\"display:flex; align-items:center; gap:12px;\">\n        <div class=\"spinner\" style=\"\n            width:22px;height:22px;border-radius:50%;\n            border:3px solid rgba(255,255,255,.25);\n            border-top-color:#ffffff; animation:spin .9s linear infinite;\"></div>\n        <div id=\"${BUSY_ID}-msg\" style=\"font-weight:600; font-size:14px; letter-spacing:.2px;\">\n          aguarde.. carregando os dados...\n        </div>\n      </div>\n    </div>\n  </div>\n  <style>\n    @keyframes spin { from{transform:rotate(0)} to{transform:rotate(360deg)} }\n  </style>`;\n  $root().css('position', 'relative'); // garante overlay correto\n  $root().append(html);\n  return $root().find(`#${BUSY_ID}`);\n}\n\n// RFC-0044: Use centralized busy management\nfunction showBusy(message, timeoutMs = 35000) {\n  LogHelper.log(`[WATER_STORES] ðŸ”„ showBusy() called with message: \"${message || 'default'}\"`);\n\n  // Prevent multiple simultaneous busy calls\n  if (window.busyInProgress) {\n    LogHelper.log(`[WATER_STORES] â­ï¸ Skipping duplicate showBusy() call`);\n    return;\n  }\n\n  window.busyInProgress = true;\n\n  // Centralized busy with enhanced synchronization\n  const safeShowBusy = () => {\n    try {\n      if (window.MyIOOrchestrator && typeof window.MyIOOrchestrator.showGlobalBusy === 'function') {\n        const text = (message && String(message).trim()) || 'Carregando dados...';\n        window.MyIOOrchestrator.showGlobalBusy(WIDGET_DOMAIN, text, timeoutMs);\n        LogHelper.log(`[WATER_STORES] âœ… Using centralized busy for domain: ${WIDGET_DOMAIN}`);\n      } else {\n        LogHelper.warn(`[WATER_STORES] âš ï¸ Orchestrator not available, using fallback busy`);\n        const $m = ensureBusyModalDOM();\n        const text = (message && String(message).trim()) || 'aguarde.. carregando os dados...';\n        $m.find(`#${BUSY_ID}-msg`).text(text);\n        $m.css('display', 'flex');\n      }\n    } catch (err) {\n      LogHelper.error(`[WATER_STORES] âŒ Error in showBusy:`, err);\n    } finally {\n      // Always reset busy flag after a short delay\n      setTimeout(() => {\n        window.busyInProgress = false;\n      }, 500);\n    }\n  };\n\n  safeShowBusy();\n}\n\nfunction hideBusy() {\n  LogHelper.log(`[WATER_STORES] âœ… hideBusy() called`);\n\n  // RFC-0044: Use centralized busy management\n  if (window.MyIOOrchestrator && typeof window.MyIOOrchestrator.hideGlobalBusy === 'function') {\n    window.MyIOOrchestrator.hideGlobalBusy(WIDGET_DOMAIN);\n  }\n\n  // Also hide local fallback\n  const $m = $root().find(`#${BUSY_ID}`);\n  if ($m.length) $m.css('display', 'none');\n}\n\n/** ===================== GLOBAL SUCCESS MODAL ===================== **/\nconst SUCCESS_MODAL_ID = 'myio-global-success-modal';\nfunction showGlobalSuccessModal(countdown = 5) {\n  LogHelper.log('[WATER_STORES] showGlobalSuccessModal');\n  let $m = $(document.body).find(`#${SUCCESS_MODAL_ID}`);\n  if (!$m.length) {\n    const html = `\n    <div id=\"${SUCCESS_MODAL_ID}\" style=\"\n        position:fixed; inset:0; display:flex;\n        background:rgba(0,0,0,.5); backdrop-filter:blur(6px);\n        z-index:999999; align-items:center; justify-content:center;\n        font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif;\">\n      <div style=\"background:#fff;border-radius:18px;padding:28px 36px;\n          min-width:420px;box-shadow:0 15px 50px rgba(0,0,0,.3);text-align:center;\">\n        <div style=\"font-size:48px; margin-bottom:14px;\">âœ…</div>\n        <div style=\"font-weight:700;font-size:20px;color:#1C2743;margin-bottom:8px;\">Tudo certo!</div>\n        <div style=\"font-size:14px;color:#555;margin-bottom:22px;\">\n          ConfiguraÃ§Ãµes salvas com sucesso.<br>\n          Recarregando em <span id=\"${SUCCESS_MODAL_ID}-counter\">${countdown}</span>s...\n        </div>\n        <button id=\"${SUCCESS_MODAL_ID}-btn\" style=\"\n            padding:10px 28px; font-size:15px; font-weight:600;\n            border-radius:10px; border:none; cursor:pointer;\n            background:#3E1A7D; color:#fff;\">\n          Recarregar agora\n        </button>\n      </div>\n    </div>`;\n    $(document.body).append(html);\n    $m = $(document.body).find(`#${SUCCESS_MODAL_ID}`);\n    $m.find(`#${SUCCESS_MODAL_ID}-btn`).on('click', () => {\n      location.reload();\n    });\n  }\n  $m.css('display', 'flex');\n\n  let sec = countdown;\n  const $c = $m.find(`#${SUCCESS_MODAL_ID}-counter`);\n  const iv = setInterval(() => {\n    sec--;\n    $c.text(sec);\n    if (sec <= 0) {\n      clearInterval(iv);\n      location.reload();\n    }\n  }, 1000);\n}\n\nfunction hideGlobalSuccessModal() {\n  const $m = $(document.body).find(`#${SUCCESS_MODAL_ID}`);\n  if ($m.length) $m.remove();\n}\n\n/** ===================== ESCAPE HTML ===================== **/\nfunction escapeHtml(str) {\n  if (typeof str !== 'string') return '';\n  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\n}\n\n/** ===================== HELPERS ===================== **/\nfunction isValidUUID(s) {\n  return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(String(s));\n}\n\nfunction toSpOffsetNoMs(iso, isEndDate = false) {\n  const d = new Date(iso);\n  if (isNaN(d)) return null;\n  const tzOffsetMs = -3 * 60 * 60 * 1000;\n  const localMs = d.getTime() + tzOffsetMs;\n  const localDate = new Date(localMs);\n  const YYYY = localDate.getUTCFullYear();\n  const MM = String(localDate.getUTCMonth() + 1).padStart(2, '0');\n  const DD = String(localDate.getUTCDate()).padStart(2, '0');\n  let HH, mm, ss;\n  if (isEndDate) {\n    HH = '23';\n    mm = '59';\n    ss = '59';\n  } else {\n    HH = String(localDate.getUTCHours()).padStart(2, '0');\n    mm = String(localDate.getUTCMinutes()).padStart(2, '0');\n    ss = String(localDate.getUTCSeconds()).padStart(2, '0');\n  }\n  return `${YYYY}-${MM}-${DD}T${HH}:${mm}:${ss}-03:00`;\n}\n\nfunction mustGetDateRange() {\n  const startISO = self.ctx.$scope?.startDateISO || self.ctx?.scope?.startDateISO;\n  const endISO = self.ctx.$scope?.endDateISO || self.ctx?.scope?.endDateISO;\n  if (!startISO || !endISO) {\n    throw new Error('Missing start/end date');\n  }\n  return { startISO, endISO };\n}\n\n/** ===================== TB INDEXES ===================== **/\nfunction buildTbAttrIndex() {\n  const byTbId = new Map();\n  const rows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\n  for (const row of rows) {\n    // RFC-0094: Filter by aliasName = 'Todos Hidrometros Lojas'\n    const aliasName = row?.datasource?.aliasName || '';\n    if (aliasName !== 'Todos Hidrometros Lojas') continue;\n\n    const key = String(row?.dataKey?.name || '').toLowerCase();\n    const tbId = row?.datasource?.entityId?.id || row?.datasource?.entityId || null;\n    const val = row?.data?.[0]?.[1];\n    if (!tbId || val == null) continue;\n    if (!byTbId.has(tbId))\n      byTbId.set(tbId, {\n        slaveId: null,\n        centralId: null,\n        deviceType: null,\n        centralName: null,\n        lastConnectTime: null,\n        lastActivityTime: null,\n        lastDisconnectTime: null,\n        deviceMapInstaneousPower: null,\n        customerId: null,\n        connectionStatus: null,\n        pulses: null, // FIX: Water meters use pulses (litros), not consumption_power\n        ingestionId: null,\n        identifier: null,\n        label: null,\n        deviceProfile: null,\n      });\n    const slot = byTbId.get(tbId);\n    if (key === 'slaveid') slot.slaveId = val;\n    if (key === 'centralid') slot.centralId = val;\n    if (key === 'devicetype') slot.deviceType = val;\n    if (key === 'deviceprofile') slot.deviceProfile = val;\n    if (key === 'centralname') slot.centralName = val;\n    if (key === 'lastconnecttime') slot.lastConnectTime = val;\n    if (key === 'lastactivitytime') slot.lastActivityTime = val;\n    if (key === 'lastdisconnecttime') slot.lastDisconnectTime = val;\n    if (key === 'devicemapinstaneouspower') slot.deviceMapInstaneousPower = val;\n    if (key === 'customerid') slot.customerId = val;\n    if (key === 'connectionstatus') slot.connectionStatus = val;\n    if (key === 'pulses') slot.pulses = val; // FIX: Water meters use pulses (litros)\n    if (key === 'ingestionid') slot.ingestionId = val;\n    if (key === 'identifier') slot.identifier = val;\n    if (key === 'label') slot.label = val;\n  }\n  return byTbId;\n}\n\nfunction buildTbIdIndexes() {\n  const byIdentifier = new Map(); // identifier -> tbId\n  const byIngestion = new Map(); // ingestionId -> tbId\n  const rows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\n  for (const row of rows) {\n    // RFC-0094: Filter by aliasName = 'Todos Hidrometros Lojas'\n    const aliasName = row?.datasource?.aliasName || '';\n    if (aliasName !== 'Todos Hidrometros Lojas') continue;\n\n    const key = String(row?.dataKey?.name || '').toLowerCase();\n    const tbId = row?.datasource?.entityId?.id || row?.datasource?.entityId || null;\n    const val = row?.data?.[0]?.[1];\n    if (!tbId || val == null) continue;\n    if (key === 'identifier') byIdentifier.set(String(val), tbId);\n    if (key === 'ingestionid') byIngestion.set(String(val), tbId);\n  }\n  return { byIdentifier, byIngestion };\n}\n\n/** ===================== CORE: DATA PIPELINE ===================== **/\nfunction buildAuthoritativeItems() {\n  // RFC-0094: Filter datasources by aliasName = 'Todos Hidrometros Lojas'\n  const filteredDatasources = (self.ctx.datasources || []).filter(\n    (ds) => ds.aliasName === 'Todos Hidrometros Lojas'\n  );\n  const filteredData = (self.ctx.data || []).filter(\n    (d) => d?.datasource?.aliasName === 'Todos Hidrometros Lojas'\n  );\n\n  LogHelper.log(`[WATER_STORES] buildAuthoritativeItems: Filtered ${filteredDatasources.length} datasources, ${filteredData.length} data rows for 'Todos Hidrometros Lojas'`);\n\n  // items da LIB: [{ id: ingestionId, identifier, label }, ...]\n  const base = MyIO.buildListItemsThingsboardByUniqueDatasource(filteredDatasources, filteredData) || [];\n  const ok = Array.isArray(base) ? base.filter((x) => x && x.id) : [];\n\n  const tbIdIdx = buildTbIdIndexes(); // { byIdentifier, byIngestion }\n  const attrsByTb = buildTbAttrIndex(); // tbId -> { slaveId, centralId, deviceType }\n\n  const mapped = ok.map((r) => {\n    const ingestionId = r.id;\n    const tbFromIngestion = ingestionId ? tbIdIdx.byIngestion.get(ingestionId) : null;\n    const tbFromIdentifier = r.identifier ? tbIdIdx.byIdentifier.get(r.identifier) : null;\n\n    let tbId = tbFromIngestion || tbFromIdentifier || null;\n    if (tbFromIngestion && tbFromIdentifier && tbFromIngestion !== tbFromIdentifier) {\n      tbId = tbFromIngestion;\n    }\n\n    const attrs = tbId ? attrsByTb.get(tbId) || {} : {};\n    const deviceProfile = attrs.deviceProfile || 'HIDROMETRO';\n    let deviceTypeToDisplay = attrs.deviceType || 'HIDROMETRO';\n\n    if (deviceTypeToDisplay === '3F_MEDIDOR' && deviceProfile !== 'N/D') {\n      deviceTypeToDisplay = deviceProfile;\n    }\n\n    return {\n      id: tbId || ingestionId, // para seleÃ§Ã£o/toggle\n      tbId, // ThingsBoard deviceId (Settings)\n      ingestionId, // join key API (totals/Report)\n      identifier: r.identifier,\n      label: attrs.label || r.label,\n      slaveId: attrs.slaveId ?? null,\n      centralId: attrs.centralId ?? null,\n      centralName: attrs.centralName ?? null,\n      deviceType: deviceTypeToDisplay,\n      deviceProfile: deviceProfile,\n      updatedIdentifiers: {},\n      connectionStatusTime: attrs.lastConnectTime ?? null,\n      timeVal: attrs.lastActivityTime ?? null,\n      lastDisconnectTime: attrs.lastDisconnectTime ?? null,\n      lastConnectTime: attrs.lastConnectTime ?? null,\n      deviceMapInstaneousPower: attrs.deviceMapInstaneousPower ?? null,\n      customerId: attrs.customerId ?? null,\n      connectionStatus: attrs.connectionStatus ?? 'offline',\n      pulses: attrs.pulses ?? null, // FIX: Water meters use pulses (litros instantÃ¢neos)\n    };\n  });\n\n  LogHelper.log(`[WATER_STORES] buildAuthoritativeItems: Built ${mapped.length} water meter items`);\n  return mapped;\n}\n\nfunction enrichItemsWithTotals(items, apiMap) {\n  return items.map((it) => {\n    let raw = 0;\n    let cachedCustomerId = null; // VariÃ¡vel para guardar o ID vindo da API\n\n    if (it.ingestionId && isValidUUID(it.ingestionId)) {\n      const row = apiMap.get(String(it.ingestionId));\n      \n      // 1. Recupera o valor\n      raw = Number(row?.total_value ?? 0);\n      \n      // 2. FIX: Tenta recuperar o customerId do cache se disponÃ­vel\n      // A API pode retornar como 'customerId' ou 'customer_id' dependendo do endpoint\n      cachedCustomerId = row?.customerId || row?.customer_id || null;\n    }\n\n    const value = Number(raw || 0);\n\n    // 3. FIX: Prioriza o ID que jÃ¡ existia (TB), senÃ£o usa o do Cache (API)\n    const finalCustomerId = it.customerId || cachedCustomerId;\n\n    return { \n        ...it, \n        value, \n        perc: 0,\n        customerId: finalCustomerId // Atualiza o objeto com o ID encontrado\n    };\n  });\n}\n\n/** ===================== FILTERS / SORT / PERC ===================== **/\nfunction applyFilters(enriched, searchTerm, selectedIds, sortMode) {\n  let v = enriched.slice();\n\n  // RFC-0093: Apply shopping filter (from MENU) - same logic as EQUIPMENTS/STORES\n  if (STATE.selectedShoppingIds && STATE.selectedShoppingIds.length > 0) {\n    const before = v.length;\n    v = v.filter((x) => {\n      // If device has no customerId, include it (safety)\n      if (!x.customerId) return true;\n      // Check if device's customerId is in the selected shoppings\n      return STATE.selectedShoppingIds.includes(x.customerId);\n    });\n    LogHelper.log(\n      `[WATER_STORES] Shopping filter applied: ${before} -> ${v.length} devices (${before - v.length} filtered out)`\n    );\n  }\n\n  if (selectedIds && selectedIds.size) {\n    v = v.filter((x) => selectedIds.has(String(x.id)));\n  }\n\n  const q = (searchTerm || '').trim().toLowerCase();\n  if (q) {\n    v = v.filter(\n      (x) =>\n        (x.label || '').toLowerCase().includes(q) ||\n        String(x.identifier || '')\n          .toLowerCase()\n          .includes(q)\n    );\n  }\n\n  v.sort((a, b) => {\n    if (sortMode === 'cons_desc') {\n      if (a.value !== b.value) return b.value - a.value;\n      return (a.label || '').localeCompare(b.label || '', 'pt-BR', {\n        sensitivity: 'base',\n      });\n    }\n    if (sortMode === 'cons_asc') {\n      if (a.value !== b.value) return a.value - b.value;\n      return (a.label || '').localeCompare(b.label || '', 'pt-BR', {\n        sensitivity: 'base',\n      });\n    }\n    if (sortMode === 'alpha_desc') {\n      return (\n        (b.label || '').localeCompare(a.label || '', 'pt-BR', {\n          sensitivity: 'base',\n        }) || b.value - a.value\n      );\n    }\n    // RFC-0095: Status sorting\n    if (sortMode === 'status_asc') {\n      const statusA = (a.connectionStatus || 'offline').toLowerCase();\n      const statusB = (b.connectionStatus || 'offline').toLowerCase();\n      const cmp = statusA.localeCompare(statusB, 'pt-BR', { sensitivity: 'base' });\n      return cmp !== 0 ? cmp : (a.label || '').localeCompare(b.label || '', 'pt-BR', { sensitivity: 'base' });\n    }\n    if (sortMode === 'status_desc') {\n      const statusA = (a.connectionStatus || 'offline').toLowerCase();\n      const statusB = (b.connectionStatus || 'offline').toLowerCase();\n      const cmp = statusB.localeCompare(statusA, 'pt-BR', { sensitivity: 'base' });\n      return cmp !== 0 ? cmp : (a.label || '').localeCompare(b.label || '', 'pt-BR', { sensitivity: 'base' });\n    }\n    // RFC-0095: Shopping sorting\n    if (sortMode === 'shopping_asc') {\n      const shopA = getCustomerNameForDevice(a) || '';\n      const shopB = getCustomerNameForDevice(b) || '';\n      const cmp = shopA.localeCompare(shopB, 'pt-BR', { sensitivity: 'base' });\n      return cmp !== 0 ? cmp : (a.label || '').localeCompare(b.label || '', 'pt-BR', { sensitivity: 'base' });\n    }\n    if (sortMode === 'shopping_desc') {\n      const shopA = getCustomerNameForDevice(a) || '';\n      const shopB = getCustomerNameForDevice(b) || '';\n      const cmp = shopB.localeCompare(shopA, 'pt-BR', { sensitivity: 'base' });\n      return cmp !== 0 ? cmp : (a.label || '').localeCompare(b.label || '', 'pt-BR', { sensitivity: 'base' });\n    }\n    // Default: alpha_asc\n    return (\n      (a.label || '').localeCompare(b.label || '', 'pt-BR', {\n        sensitivity: 'base',\n      }) || a.value - b.value\n    );\n  });\n\n  return v;\n}\n\nfunction recomputePercentages(visible) {\n  const groupSum = visible.reduce((acc, x) => acc + (x.value || 0), 0);\n  const updated = visible.map((x) => ({\n    ...x,\n    perc: groupSum > 0 ? (x.value / groupSum) * 100 : 0,\n  }));\n  return { visible: updated, groupSum };\n}\n\n/** ===================== RENDER ===================== **/\n\n/**\n * Update water stores statistics header (Conectividade, Total, etc)\n * RFC-0094: Aligned with STORES/EQUIPMENTS logic for consistent stats\n * @param {Array} stores - Array of store items to calculate stats from\n */\nfunction updateWaterStoresStats(stores) {\n  // Use $root() to find elements within widget scope (not document.getElementById)\n  const $widget = $root();\n  const connectivityEl = $widget.find('#waterStoresStatsConnectivity')[0];\n  const totalEl = $widget.find('#waterStoresStatsTotal')[0];\n  const consumptionEl = $widget.find('#waterStoresStatsConsumption')[0];\n  const zeroEl = $widget.find('#waterStoresStatsZero')[0];\n\n  if (!connectivityEl || !totalEl || !consumptionEl || !zeroEl) {\n    LogHelper.warn('[WATER_STORES] Stats header elements not found in widget scope');\n    return;\n  }\n\n  // RFC-0094: Calculate connectivity from connectionStatus (same as STORES)\n  let onlineCount = 0;\n  let totalWithStatus = 0;\n  let totalConsumption = 0;\n  let zeroConsumptionCount = 0;\n\n  stores.forEach((store) => {\n    // Connectivity: based on connectionStatus, not consumption\n    const status = (store.connectionStatus || '').toLowerCase();\n    if (status) {\n      totalWithStatus++;\n      if (status === 'online') {\n        onlineCount++;\n      }\n    }\n\n    // Consumption calculation\n    const consumption = Number(store.value) || Number(store.val) || 0;\n    totalConsumption += consumption;\n\n    if (consumption === 0) {\n      zeroConsumptionCount++;\n    }\n  });\n\n  // If no connectionStatus available, fallback to total count\n  if (totalWithStatus === 0) {\n    totalWithStatus = stores.length;\n  }\n\n  // Calculate connectivity percentage\n  const connectivityPercentage =\n    totalWithStatus > 0 ? ((onlineCount / totalWithStatus) * 100).toFixed(1) : '0.0';\n\n  // Update UI - RFC-0094: Use MÂ³ formatting for water domain\n  connectivityEl.textContent = `${onlineCount}/${totalWithStatus} (${connectivityPercentage}%)`;\n  totalEl.textContent = stores.length.toString();\n  consumptionEl.textContent = MyIO.formatWaterVolumeM3(totalConsumption);\n  zeroEl.textContent = zeroConsumptionCount.toString();\n\n  LogHelper.log('[WATER_STORES] Stats updated:', {\n    connectivity: `${onlineCount}/${totalWithStatus} (${connectivityPercentage}%)`,\n    total: stores.length,\n    consumption: totalConsumption,\n    zeroCount: zeroConsumptionCount,\n  });\n}\n\n/**\n * RFC-0094: Render list of water meter cards\n * Follows STORES pattern with renderCardComponentHeadOffice\n */\nasync function renderList(visible) {\n  const listElement = $list()[0];\n  if (!listElement) {\n    console.error('[WATER_STORES] waterStoresList element not found via $list()');\n    return;\n  }\n\n  listElement.innerHTML = '';\n\n  for (const it of visible) {\n    const container = document.createElement('div');\n    listElement.appendChild(container);\n\n    const valNum = Number(it.value || 0);\n\n    // RFC-0094: Calculate device status using STORES pattern\n    let deviceStatus = 'power_off';\n    if (it.connectionStatus) {\n      const status = mapConnectionStatus(it.connectionStatus);\n      deviceStatus = status === 'online' ? 'power_on' : 'power_off';\n    } else if (valNum > 0) {\n      deviceStatus = 'power_on';\n    }\n\n    // RFC-0094: Resolve TB id\n    let resolvedTbId = it.tbId;\n    if (!resolvedTbId || !isValidUUID(resolvedTbId)) {\n      const idx = buildTbIdIndexes();\n      resolvedTbId =\n        (it.ingestionId && idx.byIngestion.get(it.ingestionId)) ||\n        (it.identifier && idx.byIdentifier.get(it.identifier)) ||\n        null;\n    }\n\n    // RFC-0094: Safe identifier handling\n    let deviceIdentifierToDisplay = 'HIDROMETRO';\n    if (it.identifier) {\n      if (String(it.identifier).includes('Sem Identificador')) {\n        deviceIdentifierToDisplay = 'HIDROMETRO';\n      } else {\n        deviceIdentifierToDisplay = it.identifier;\n      }\n    }\n\n    // Get customer name for this device\n    const customerName = getCustomerNameForDevice(it);\n    \n\n    // RFC-0094: Calculate operationHours based on lastConnectTime (like EQUIPMENTS)\n    let operationHoursFormatted = '-';\n    const lastConnectTimestamp = it.lastConnectTime || 0;\n    if (lastConnectTimestamp > 0) {\n      const nowMs = Date.now();\n      const durationMs = nowMs - lastConnectTimestamp;\n      operationHoursFormatted = formatarDuracao(durationMs > 0 ? durationMs : 0);\n    }\n\n    // RFC-0094: Build entity object following STORES pattern\n    const entityObject = {\n      // Identificadores\n      entityId: resolvedTbId,\n      id: resolvedTbId,\n\n      // Labels e Nomes\n      labelOrName: it.label,\n      name: it.label,\n      customerName: customerName,\n      centralName: it.centralName || 'N/A',\n      deviceIdentifier: deviceIdentifierToDisplay,\n\n      // Valores e Tipos - RFC-0094: Water domain uses MÂ³\n      val: valNum,\n      value: valNum,\n      lastValue: valNum,\n      valType: 'volume_m3',\n      unit: 'mÂ³',\n      icon: 'water',\n      domain: 'water',\n      pulses: it.pulses || 0,\n\n      // Metadados\n      deviceType: it.deviceType || 'HIDROMETRO',\n      deviceProfile: it.deviceProfile || 'HIDROMETRO',\n      deviceStatus: deviceStatus,\n      perc: it.perc ?? 0,\n\n      // IDs secundÃ¡rios\n      slaveId: it.slaveId || 'N/A',\n      ingestionId: it.ingestionId || 'N/A',\n      centralId: it.centralId || 'N/A',\n      customerId: it.customerId || null,\n\n      updatedIdentifiers: it.updatedIdentifiers || {},\n      connectionStatusTime: it.connectionStatusTime || Date.now(),\n      timeVal: it.timeVal || Date.now(),\n\n      // Additional data for Settings modal and card display\n      lastDisconnectTime: it.lastDisconnectTime || 0,\n      lastConnectTime: it.lastConnectTime || 0,\n      lastActivityTime: it.timeVal || null,\n      instantaneousPower: 0, // Not applicable for water meters\n      operationHours: operationHoursFormatted, // RFC-0094: Calculated from lastConnectTime\n      temperatureC: 0,\n      mapInstantaneousPower: MAP_INSTANTANEOUS_POWER,\n      deviceMapInstaneousPower: it.deviceMapInstaneousPower || null,\n    };\n    \n\n    // RFC-0094: Use renderCardComponentHeadOffice like STORES\n    const handle = MyIOLibrary.renderCardComponentHeadOffice(container, {\n      entityObject: entityObject,\n      delayTimeConnectionInMins: window.MyIOUtils?.getDelayTimeConnectionInMins?.() ?? 60,\n\n      handleClickCard: (ev, entity) => {\n        console.log(`[WATER_STORES] Card clicked: ${entity.name}`);\n      },\n\n      handleActionDashboard: async () => {\n        console.log('[WATER_STORES] [RFC-0094] Opening water dashboard for:', entityObject.entityId);\n        try {\n          if (typeof MyIOLibrary.openDashboardPopupEnergy !== 'function') {\n            alert('Dashboard component nÃ£o disponÃ­vel');\n            return;\n          }\n          const startDate = self.ctx.scope?.startDateISO;\n          const endDate = self.ctx.scope?.endDateISO;\n          if (!startDate || !endDate) {\n            alert('PerÃ­odo de datas nÃ£o definido.');\n            return;\n          }\n          if (!MyIOAuth || typeof MyIOAuth.getToken !== 'function') {\n            LogHelper.error('[WATER_STORES] MyIOAuth not available');\n            alert('AutenticaÃ§Ã£o nÃ£o disponÃ­vel. Recarregue a pÃ¡gina.');\n            return;\n          }\n          const tokenIngestionDashBoard = await MyIOAuth.getToken();\n          const myTbTokenDashBoard = localStorage.getItem('jwt_token');\n\n          MyIOLibrary.openDashboardPopupEnergy({\n            deviceId: entityObject.entityId,\n            readingType: 'water', // RFC-0094: Water reading type\n            startDate,\n            endDate,\n            tbJwtToken: myTbTokenDashBoard,\n            ingestionToken: tokenIngestionDashBoard,\n            clientId: CLIENT_ID,\n            clientSecret: CLIENT_SECRET,\n            onClose: () => {\n              const o = document.querySelector('.myio-modal-overlay');\n              if (o) o.remove();\n            },\n          });\n        } catch (err) {\n          console.error(err);\n          alert('Erro ao abrir dashboard');\n        }\n      },\n\n      handleActionReport: async () => {\n        try {\n          if (!MyIOAuth || typeof MyIOAuth.getToken !== 'function') {\n            LogHelper.error('[WATER_STORES] MyIOAuth not available for report');\n            alert('AutenticaÃ§Ã£o nÃ£o disponÃ­vel. Recarregue a pÃ¡gina.');\n            return;\n          }\n          const ingestionToken = await MyIOAuth.getToken();\n          await MyIOLibrary.openDashboardPopupReport({\n            ingestionId: it.ingestionId,\n            identifier: it.identifier,\n            label: it.label,\n            domain: 'water', // RFC-0094: Water domain\n            api: {\n              dataApiBaseUrl: getDataApiHost(),\n              clientId: CLIENT_ID,\n              clientSecret: CLIENT_SECRET,\n              ingestionToken,\n            },\n          });\n        } catch (err) {\n          alert('Erro ao abrir relatÃ³rio');\n        }\n      },\n\n      handleActionSettings: async () => {\n        const jwt = localStorage.getItem('jwt_token');\n\n        if (!jwt) {\n          LogHelper.error('[WATER_STORES] [RFC-0094] JWT token not found');\n          window.alert('Token de autenticaÃ§Ã£o nÃ£o encontrado');\n          return;\n        }\n\n        const tbId = entityObject.entityId;\n        if (!tbId || tbId === it.ingestionId) {\n          alert('ID invÃ¡lido');\n          return;\n        }\n\n        try {\n          await MyIOLibrary.openDashboardPopupSettings({\n            deviceId: tbId,\n            label: it.label,\n            jwtToken: jwt,\n            domain: WIDGET_DOMAIN,\n            deviceType: entityObject.deviceType,\n            deviceProfile: entityObject.deviceProfile,\n            customerName: entityObject.customerName,\n            connectionData: {\n              centralName: entityObject.centralName,\n              connectionStatusTime: entityObject.connectionStatusTime,\n              timeVal: entityObject.timeVal || new Date('1970-01-01').getTime(),\n              deviceStatus:\n                entityObject.deviceStatus !== 'power_off' && entityObject.deviceStatus !== 'not_installed'\n                  ? 'power_on'\n                  : 'power_off',\n              lastDisconnectTime: entityObject.lastDisconnectTime || 0,\n            },\n            ui: { title: 'ConfiguraÃ§Ãµes', width: 900 },\n            mapInstantaneousPower: entityObject.mapInstantaneousPower,\n            onSaved: (payload) => {\n              LogHelper.log('[WATER_STORES] [RFC-0094] Settings saved:', payload);\n              showGlobalSuccessModal(6);\n            },\n            onClose: () => {\n              $('.myio-settings-modal-overlay').remove();\n              const overlay = document.querySelector('.myio-modal-overlay');\n              if (overlay) {\n                overlay.remove();\n              }\n              LogHelper.log('[WATER_STORES] [RFC-0094] Settings modal closed');\n            },\n          });\n        } catch (e) {\n          LogHelper.error('[WATER_STORES] [RFC-0094] Error opening settings:', e);\n          window.alert('Erro ao abrir configuraÃ§Ãµes');\n        }\n      },\n\n      handleSelect: (checked, entity) => {\n        const MyIOSelectionStore = window.MyIOLibrary?.MyIOSelectionStore || window.MyIOSelectionStore;\n        if (MyIOSelectionStore) {\n          if (checked) {\n            if (MyIOSelectionStore.registerEntity) MyIOSelectionStore.registerEntity(entity);\n            MyIOSelectionStore.add(entity.entityId || entity.id);\n          } else {\n            MyIOSelectionStore.remove(entity.entityId || entity.id);\n          }\n        }\n      },\n\n      useNewComponents: true,\n      enableSelection: true,\n      enableDragDrop: true,\n      hideInfoMenuItem: true,\n    });\n  }\n\n  console.log(`[WATER_STORES] Rendered ${visible.length} water meter cards`);\n}\n\n/** ===================== UI BINDINGS ===================== **/\n/**\n * RFC-0094: Search and filter button events are now handled by buildHeaderDevicesGrid\n * This function is kept for backwards compatibility but the main logic is in the header controller\n */\nfunction bindHeader() {\n  // RFC-0094: Events are now managed by waterStoresHeaderController in onInit\n  LogHelper.log('[WATER_STORES] bindHeader - events managed by header controller');\n}\n\n// ============================================\n// RFC-0094: WATER_STORES FILTER MODAL (using shared factory from MAIN)\n// ============================================\n\n// Helper function to get store consumption value\nfunction getStoreConsumption(store) {\n  return Number(store.value) || Number(store.consumption) || Number(store.val) || 0;\n}\n\n// Filter modal instance (lazy initialized)\nlet waterStoresFilterModal = null;\n\n/**\n * RFC-0094: Initialize filter modal using shared factory from MAIN\n */\nfunction initFilterModal() {\n  const createFilterModal = window.MyIOUtils?.createFilterModal;\n\n  if (!createFilterModal) {\n    LogHelper.error('[WATER_STORES] createFilterModal not available from MAIN');\n    return null;\n  }\n\n  return createFilterModal({\n    widgetName: 'WATER_STORES',\n    containerId: 'waterStoresFilterModalGlobal',\n    modalClass: 'water-stores-modal',\n    primaryColor: '#0288D1', // Blue for water\n    itemIdAttr: 'data-entity',\n\n    // Filter tabs configuration - specific for WATER_STORES\n    filterTabs: [\n      { id: 'all', label: 'Todos', filter: () => true },\n      { id: 'online', label: 'Online', filter: (s) => getStoreConsumption(s) > 0 },\n      { id: 'offline', label: 'Offline', filter: (s) => getStoreConsumption(s) === 0 },\n      { id: 'withConsumption', label: 'Com Consumo', filter: (s) => getStoreConsumption(s) > 0 },\n      { id: 'noConsumption', label: 'Sem Consumo', filter: (s) => getStoreConsumption(s) === 0 },\n    ],\n\n    // Data accessors\n    getItemId: (store) => store.id,\n    getItemLabel: (store) => store.label || store.identifier || store.id,\n    getItemValue: getStoreConsumption,\n    getItemSubLabel: (store) => getCustomerNameForDevice(store),\n    formatValue: (val) => MyIO.formatWaterVolumeM3(val), // RFC-0094: MÂ³ formatting\n\n    // Callbacks\n    onApply: ({ selectedIds, sortMode }) => {\n      STATE.selectedIds = selectedIds;\n      STATE.sortMode = sortMode;\n      reflowFromState();\n      LogHelper.log('[WATER_STORES] [RFC-0094] Filters applied via shared modal');\n    },\n\n    onReset: () => {\n      STATE.selectedIds = null;\n      STATE.sortMode = 'cons_desc';\n      STATE.searchTerm = '';\n      STATE.searchActive = false;\n\n      // RFC-0094: Reset UI via header controller\n      if (waterStoresHeaderController) {\n        const searchInput = waterStoresHeaderController.getSearchInput();\n        if (searchInput) searchInput.value = '';\n        waterStoresHeaderController.toggleSearch(false);\n      }\n\n      reflowFromState();\n      LogHelper.log('[WATER_STORES] [RFC-0094] Filters reset via shared modal');\n    },\n\n    onClose: () => {\n      LogHelper.log('[WATER_STORES] [RFC-0094] Filter modal closed');\n    },\n  });\n}\n\n/**\n * RFC-0094: Open filter modal\n */\nfunction openFilterModal() {\n  // Lazy initialize modal\n  if (!waterStoresFilterModal) {\n    waterStoresFilterModal = initFilterModal();\n  }\n\n  if (!waterStoresFilterModal) {\n    LogHelper.error('[WATER_STORES] Failed to initialize filter modal');\n    window.alert('Erro ao inicializar modal de filtros. Verifique se o widget MAIN foi carregado.');\n    return;\n  }\n\n  // Use itemsEnriched if available (has consumption values), otherwise itemsBase\n  const items =\n    STATE.itemsEnriched && STATE.itemsEnriched.length > 0 ? STATE.itemsEnriched : STATE.itemsBase || [];\n\n  // Open with current stores and state\n  waterStoresFilterModal.open(items, {\n    selectedIds: STATE.selectedIds,\n    sortMode: STATE.sortMode,\n  });\n}\n\n/**\n * RFC-0094: Close filter modal (for backward compatibility)\n */\nfunction closeFilterModal() {\n  if (waterStoresFilterModal) {\n    waterStoresFilterModal.close();\n  }\n}\n\nfunction bindModal() {\n  // RFC-0094: Modal is now handled by shared factory, but keep legacy bindings for fallback\n  $root().on('click', '#closeFilter', closeFilterModal);\n}\n\n/** ===================== RECOMPUTE (local only) ===================== **/\nasync function filterAndRender() {\n  const visible = applyFilters(STATE.itemsEnriched, STATE.searchTerm, STATE.selectedIds, STATE.sortMode);\n  const { visible: withPerc, groupSum } = recomputePercentages(visible);\n  await renderList(withPerc);\n\n  // RFC-0094: Update stats header via centralized controller\n  if (STATE.itemsEnriched && STATE.itemsEnriched.length > 0) {\n    if (waterStoresHeaderController) {\n      waterStoresHeaderController.updateFromDevices(STATE.itemsEnriched, {});\n    } else {\n      updateWaterStoresStats(STATE.itemsEnriched);\n    }\n  }\n}\n\nfunction reflowFromState() {\n  filterAndRender();\n}\n\n/** ===================== AUTH ===================== **/\nfunction isAuthReady() {\n  return !!CLIENT_ID && !!CLIENT_SECRET && !!MyIOAuth;\n}\n\nasync function ensureAuthReady(timeout = 5000, interval = 100) {\n  const start = Date.now();\n  while (!isAuthReady()) {\n    if (Date.now() - start > timeout) {\n      LogHelper.warn('[WATER_STORES] Auth timeout waiting for credentials');\n      return false;\n    }\n    await new Promise((r) => setTimeout(r, interval));\n  }\n  return true;\n}\n\n/** ===================== HYDRATE (end-to-end) ===================== **/\nasync function fetchApiTotals(startISO, endISO) {\n  if (!isAuthReady()) throw new Error('Auth not ready');\n  const token = await MyIOAuth.getToken();\n  if (!token) throw new Error('No ingestion token');\n\n  // RFC-0094: Use water endpoint\n  const url = new URL(`${getDataApiHost()}/api/v1/telemetry/customers/${CUSTOMER_ING_ID}/water/devices/totals`);\n  url.searchParams.set('startTime', toSpOffsetNoMs(startISO));\n  url.searchParams.set('endTime', toSpOffsetNoMs(endISO, true));\n  url.searchParams.set('deep', '1');\n\n  const res = await fetch(url.toString(), {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  if (!res.ok) {\n    LogHelper.warn('[WATER_STORES] API fetch failed:', res.status);\n    return new Map();\n  }\n\n  const json = await res.json();\n  const rows = Array.isArray(json) ? json : json?.data ?? [];\n  const map = new Map();\n  for (const r of rows) if (r && r.id) map.set(String(r.id), r);\n  return map;\n}\n\nasync function hydrateAndRender() {\n  if (hydrating) return;\n  hydrating = true;\n\n  showBusy();\n\n  try {\n    // 0) Datas: obrigatÃ³rias\n    let range;\n    try {\n      range = mustGetDateRange();\n    } catch (_e) {\n      LogHelper.warn('[WATER_STORES] Aguardando intervalo de datas (startDateISO/endDateISO).');\n      return;\n    }\n\n    // 1) Auth\n    const okAuth = await ensureAuthReady(6000, 150);\n    if (!okAuth) {\n      LogHelper.warn('[WATER_STORES] Auth not ready; adiando hidrataÃ§Ã£o.');\n      return;\n    }\n\n    // 2) Lista autoritativa\n    STATE.itemsBase = buildAuthoritativeItems();\n\n    // 3) Totais na API\n    let apiMap = new Map();\n    try {\n      apiMap = await fetchApiTotals(range.startISO, range.endISO);\n    } catch (err) {\n      LogHelper.error('[WATER_STORES] API error:', err);\n      apiMap = new Map();\n    }\n\n    // 4) Enrich + render\n    STATE.itemsEnriched = enrichItemsWithTotals(STATE.itemsBase, apiMap);\n\n    // 5) Sanitiza seleÃ§Ã£o\n    if (STATE.selectedIds && STATE.selectedIds.size) {\n      const valid = new Set(STATE.itemsBase.map((x) => String(x.id)));\n      const next = new Set([...STATE.selectedIds].filter((id) => valid.has(String(id))));\n      STATE.selectedIds = next.size ? next : null;\n    }\n\n    reflowFromState();\n  } finally {\n    hydrating = false;\n    hideBusy();\n  }\n}\n\n/** ===================== TB LIFE CYCLE ===================== **/\nself.onInit = async function () {\n  $(self.ctx.$container).css({\n    height: '100%',\n    overflow: 'hidden',\n    display: 'flex',\n    flexDirection: 'column',\n    position: 'relative',\n  });\n\n  MyIO = (typeof MyIOLibrary !== 'undefined' && MyIOLibrary) ||\n    (typeof window !== 'undefined' && window.MyIOLibrary) || {\n      showAlert: function () {\n        alert('A Biblioteca Myio nÃ£o foi carregada corretamente!');\n      },\n    };\n\n  // RFC-0094: Set widget configuration from settings FIRST - WATER DOMAIN\n  WIDGET_DOMAIN = self.ctx.settings?.DOMAIN || 'water';\n  LogHelper.log(`[WATER_STORES] Configured EARLY: domain=${WIDGET_DOMAIN}`);\n\n  // RFC-0094: Build centralized header via buildHeaderDevicesGrid\n  const buildHeaderDevicesGrid = window.MyIOUtils?.buildHeaderDevicesGrid;\n  if (buildHeaderDevicesGrid) {\n    // FIX: Use $root().find() to get container within widget scope, not document.querySelector\n    const headerContainerEl = $root().find('#waterStoresHeaderContainer')[0];\n    if (headerContainerEl) {\n      waterStoresHeaderController = buildHeaderDevicesGrid({\n        container: headerContainerEl, // Pass element directly, not selector string\n        domain: 'water',\n        idPrefix: 'waterStores',\n        labels: {\n          total: 'Total de HidrÃ´metros',\n          consumption: 'Consumo Total (mÂ³)',\n        },\n        includeSearch: true,\n        includeFilter: true,\n        onSearchClick: () => {\n          STATE.searchActive = !STATE.searchActive;\n          if (STATE.searchActive) {\n            const input = waterStoresHeaderController?.getSearchInput();\n            if (input) setTimeout(() => input.focus(), 100);\n          }\n        },\n        onFilterClick: () => {\n          openFilterModal();\n        },\n      });\n\n      // Setup search input listener\n      const searchInput = waterStoresHeaderController?.getSearchInput();\n      if (searchInput) {\n        searchInput.addEventListener('input', (e) => {\n          STATE.searchTerm = e.target.value || '';\n          filterAndRender();\n        });\n      }\n\n      LogHelper.log('[WATER_STORES] [RFC-0094] Header controller initialized');\n    } else {\n      LogHelper.warn('[WATER_STORES] Header container element not found in widget scope');\n    }\n  } else {\n    LogHelper.warn('[WATER_STORES] buildHeaderDevicesGrid not available - using fallback');\n  }\n\n  // RFC-0042: Request data from orchestrator (defined early for use in handlers)\n  function requestDataFromOrchestrator() {\n    if (!self.ctx.scope?.startDateISO || !self.ctx.scope?.endDateISO) {\n      LogHelper.warn('[WATER_STORES] No date range set, cannot request data');\n      return;\n    }\n\n    const period = {\n      startISO: self.ctx.scope.startDateISO,\n      endISO: self.ctx.scope.endDateISO,\n      granularity: window.calcGranularity\n        ? window.calcGranularity(self.ctx.scope.startDateISO, self.ctx.scope.endDateISO)\n        : 'day',\n      tz: 'America/Sao_Paulo',\n    };\n\n    LogHelper.log(`[WATER_STORES] Requesting data for domain=${WIDGET_DOMAIN}, period:`, period);\n\n    window.dispatchEvent(\n      new CustomEvent('myio:telemetry:request-data', {\n        detail: { domain: WIDGET_DOMAIN, period },\n      })\n    );\n  }\n\n  dateUpdateHandler = function (ev) {\n    LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] âœ… DATE UPDATE EVENT RECEIVED!`, ev.detail);\n\n    try {\n      let startISO, endISO;\n      if (ev.detail?.period) {\n        startISO = ev.detail.period.startISO;\n        endISO = ev.detail.period.endISO;\n      } else {\n        const { startDate, endDate } = ev.detail || {};\n        startISO = new Date(startDate).toISOString();\n        endISO = new Date(endDate).toISOString();\n      }\n\n      LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] Date range updated:`, startISO, endISO);\n\n      self.ctx.scope = self.ctx.scope || {};\n      self.ctx.scope.startDateISO = startISO;\n      self.ctx.scope.endDateISO = endISO;\n\n      hydrateAndRender();\n    } catch (err) {\n      LogHelper.error(`[WATER_STORES ${WIDGET_DOMAIN}] dateUpdateHandler error:`, err);\n      hideBusy();\n    }\n  };\n\n  LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] ðŸ“¡ Registering myio:update-date listener...`);\n  window.addEventListener('myio:update-date', dateUpdateHandler);\n  LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] âœ… myio:update-date listener registered!`);\n\n  // RFC-0042: Listen for clear event from HEADER (when user clicks \"Limpar\" button)\n  window.addEventListener('myio:telemetry:clear', (ev) => {\n    const { domain } = ev.detail;\n\n    if (domain !== WIDGET_DOMAIN) {\n      LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] Ignoring clear event for domain: ${domain}`);\n      return;\n    }\n\n    LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] ðŸ§¹ Received clear event - clearing visual content`);\n\n    try {\n      STATE.itemsBase = [];\n      STATE.itemsEnriched = [];\n      STATE.selectedIds = null;\n\n      const $widget = $root();\n      const $waterStoresList = $widget.find('#waterStoresList');\n      if ($waterStoresList.length > 0) {\n        $waterStoresList.empty();\n        LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] âœ… waterStoresList cleared`);\n      }\n\n      LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] ðŸ§¹ Clear completed successfully`);\n    } catch (err) {\n      LogHelper.error(`[WATER_STORES ${WIDGET_DOMAIN}] âŒ Error during clear:`, err);\n    }\n  });\n\n  // RFC-0093: Function to render shopping filter chips in toolbar (same as EQUIPMENTS/STORES)\n  function renderShoppingFilterChips(selection) {\n    const chipsContainer = document.getElementById('waterStoresShoppingFilterChips');\n    if (!chipsContainer) return;\n\n    chipsContainer.innerHTML = '';\n\n    if (!selection || selection.length === 0) {\n      return; // No filter applied, hide chips\n    }\n\n    selection.forEach((shopping) => {\n      const chip = document.createElement('span');\n      chip.className = 'filter-chip';\n      chip.innerHTML = `<span class=\"filter-chip-icon\">ðŸ’§</span><span>${shopping.name}</span>`;\n      chipsContainer.appendChild(chip);\n    });\n\n    LogHelper.log('[WATER_STORES] ðŸ“ Rendered', selection.length, 'shopping filter chips');\n  }\n\n  // RFC-0093: Listen for shopping filter changes\n  window.addEventListener('myio:filter-applied', (ev) => {\n    const selection = ev.detail?.selection || [];\n    LogHelper.log('[WATER_STORES] ðŸ”¥ heard myio:filter-applied:', selection.length, 'shoppings');\n\n    // Extract shopping IDs (ingestionIds) from selection\n    const shoppingIds = selection.map((s) => s.value).filter((v) => v);\n\n    LogHelper.log(\n      '[WATER_STORES] Applying shopping filter:',\n      shoppingIds.length === 0 ? 'ALL' : `${shoppingIds.length} shoppings`\n    );\n\n    // Update STATE and reflow cards\n    STATE.selectedShoppingIds = shoppingIds;\n\n    // Render shopping filter chips\n    renderShoppingFilterChips(selection);\n\n    // Reflow to apply filter\n    reflowFromState();\n  });\n\n  // RFC-0093: Check for pre-existing filter when WATER_STORES initializes\n  if (\n    window.custumersSelected &&\n    Array.isArray(window.custumersSelected) &&\n    window.custumersSelected.length > 0\n  ) {\n    LogHelper.log('[WATER_STORES] ðŸ”„ Applying pre-existing filter:', window.custumersSelected.length, 'shoppings');\n    const shoppingIds = window.custumersSelected.map((s) => s.value).filter((v) => v);\n    STATE.selectedShoppingIds = shoppingIds;\n    renderShoppingFilterChips(window.custumersSelected);\n  }\n\n  // Test if listener is working\n  setTimeout(() => {\n    LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] ðŸ§ª Testing listener registration...`);\n    if (typeof dateUpdateHandler === 'function') {\n      LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] âœ… dateUpdateHandler is defined and ready`);\n    } else {\n      LogHelper.error(`[WATER_STORES ${WIDGET_DOMAIN}] âŒ dateUpdateHandler is NOT defined!`);\n    }\n  }, 100);\n\n  let pendingProvideData = null;\n\n  dataProvideHandler = function (ev) {\n    LogHelper.log(\n      `[WATER_STORES ${WIDGET_DOMAIN}] ðŸ“¦ Received provide-data event for domain ${\n        ev.detail.domain\n      }, periodKey: ${ev.detail.periodKey}, items: ${ev.detail.items?.length || 0}`\n    );\n    const { domain, periodKey, items } = ev.detail;\n\n    if (domain !== WIDGET_DOMAIN) {\n      LogHelper.log(\n        `[WATER_STORES ${WIDGET_DOMAIN}] â­ï¸ Ignoring event for domain ${domain}, my domain is ${WIDGET_DOMAIN}`\n      );\n      return;\n    }\n\n    if (lastProcessedPeriodKey === periodKey) {\n      LogHelper.log(`[WATER_STORES] â­ï¸ Skipping duplicate provide-data for periodKey: ${periodKey}`);\n      return;\n    }\n\n    const myPeriod = {\n      startISO: self.ctx.scope?.startDateISO,\n      endISO: self.ctx.scope?.endDateISO,\n    };\n\n    if (!myPeriod.startISO || !myPeriod.endISO) {\n      LogHelper.warn(`[WATER_STORES] â¸ï¸ Period not set yet, storing provide-data event for later processing`);\n      pendingProvideData = { domain, periodKey, items };\n      return;\n    }\n\n    lastProcessedPeriodKey = periodKey;\n\n    LogHelper.log(`[WATER_STORES] ðŸ”„ Processing data from orchestrator...`);\n    LogHelper.log(`[WATER_STORES] Received ${items.length} items from orchestrator for domain ${domain}`);\n\n    const myDatasourceIds = extractDatasourceIds(self.ctx.datasources);\n    const datasourceIdSet = new Set(myDatasourceIds);\n    let filtered = items.filter((item) => {\n      return datasourceIdSet.has(item.id) || datasourceIdSet.has(item.tbId);\n    });\n\n    LogHelper.log(\n      `[WATER_STORES] Filtered ${items.length} items down to ${filtered.length} items matching datasources`\n    );\n\n    if (filtered.length === 0) {\n      LogHelper.warn(`[WATER_STORES] No items match datasource IDs! Using all items as fallback.`);\n      filtered = items;\n    }\n\n    filtered = filtered.map((item) => ({\n      id: item.tbId || item.id,\n      tbId: item.tbId || item.id,\n      ingestionId: item.ingestionId || item.id,\n      identifier: item.identifier || item.id,\n      label: item.label || item.identifier || item.id,\n      value: Number(item.value || 0),\n      perc: 0,\n      deviceType: item.deviceType || 'HIDROMETRO',\n      slaveId: item.slaveId || null,\n      centralId: item.centralId || null,\n      updatedIdentifiers: {},\n    }));\n\n    LogHelper.log(`[WATER_STORES] Using ${filtered.length} items after processing`);\n\n    if (!STATE.itemsBase || STATE.itemsBase.length === 0) {\n      LogHelper.log(`[WATER_STORES] Building itemsBase from TB data...`);\n      STATE.itemsBase = buildAuthoritativeItems();\n      LogHelper.log(`[WATER_STORES] Built ${STATE.itemsBase.length} items from TB`);\n    }\n\n    const orchestratorValues = new Map();\n    filtered.forEach((item) => {\n      if (item.ingestionId) {\n        const value = Number(item.value || 0);\n        orchestratorValues.set(item.ingestionId, value);\n      }\n    });\n    LogHelper.log(`[WATER_STORES] Orchestrator values map size: ${orchestratorValues.size}`);\n\n    STATE.itemsEnriched = STATE.itemsBase.map((tbItem) => {\n      const orchestratorValue = orchestratorValues.get(tbItem.ingestionId);\n\n      return {\n        ...tbItem,\n        value: orchestratorValue !== undefined ? orchestratorValue : tbItem.value || 0,\n        perc: 0,\n      };\n    });\n\n    LogHelper.log(`[WATER_STORES] Enriched ${STATE.itemsEnriched.length} items with orchestrator values`);\n\n    if (STATE.selectedIds && STATE.selectedIds.size) {\n      const valid = new Set(STATE.itemsBase.map((x) => String(x.id)));\n      const next = new Set([...STATE.selectedIds].filter((id) => valid.has(String(id))));\n      STATE.selectedIds = next.size ? next : null;\n    }\n\n    reflowFromState();\n\n    LogHelper.log(`[WATER_STORES] ðŸ Data processed successfully - ensuring busy is hidden`);\n\n    setTimeout(() => {\n      hideBusy();\n      if (window.MyIOOrchestrator && window.MyIOOrchestrator.getBusyState) {\n        const busyState = window.MyIOOrchestrator.getBusyState();\n        if (busyState.isVisible) {\n          LogHelper.warn(\n            `[WATER_STORES] âš ï¸ Orchestrator busy still visible after data processing - force hiding`\n          );\n          window.MyIOOrchestrator.hideGlobalBusy();\n        }\n      }\n    }, 100);\n  };\n\n  /**\n   * Extracts ingestionIds from ThingsBoard ctx.data\n   * RFC-0094: Only extracts from 'Todos Hidrometros Lojas' alias\n   */\n  function extractDatasourceIds(datasources) {\n    const ingestionIds = new Set();\n    const rows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\n\n    for (const row of rows) {\n      // RFC-0094: Filter by aliasName = 'Todos Hidrometros Lojas'\n      const aliasName = row?.datasource?.aliasName || '';\n      if (aliasName !== 'Todos Hidrometros Lojas') continue;\n\n      const key = String(row?.dataKey?.name || '').toLowerCase();\n      const val = row?.data?.[0]?.[1];\n\n      if (key === 'ingestionid' && val && isValidUUID(String(val))) {\n        ingestionIds.add(String(val));\n      }\n    }\n\n    return Array.from(ingestionIds);\n  }\n\n  window.addEventListener('myio:telemetry:provide-data', dataProvideHandler);\n\n  // FIX: Add handler for myio:water-data-ready from MAIN waterCache\n  waterDataReadyHandler = function (ev) {\n    const { cache, totalDevices, fromCache } = ev.detail || {};\n\n    // Only process if cache is a Map with data\n    if (!(cache instanceof Map) || cache.size === 0) {\n      LogHelper.log('[WATER_STORES] Ignoring water-data-ready: no cache or empty');\n      return;\n    }\n\n    LogHelper.log(`[WATER_STORES] ðŸ“¦ Received water-data-ready: ${cache.size} devices (fromCache: ${fromCache})`);\n\n    // Check if widget has items to enrich\n    if (!STATE.itemsBase || STATE.itemsBase.length === 0) {\n      LogHelper.log('[WATER_STORES] No itemsBase yet, building...');\n      STATE.itemsBase = buildAuthoritativeItems();\n    }\n\n    if (STATE.itemsBase.length === 0) {\n      LogHelper.warn('[WATER_STORES] Still no items after buildAuthoritativeItems, skipping');\n      return;\n    }\n\n    // Enrich items with data from MAIN waterCache\n    STATE.itemsEnriched = enrichItemsWithTotals(STATE.itemsBase, cache);\n    LogHelper.log(`[WATER_STORES] Enriched ${STATE.itemsEnriched.length} items from MAIN waterCache`);\n\n    // Render\n    reflowFromState();\n  };\n\n  window.addEventListener('myio:water-data-ready', waterDataReadyHandler);\n\n  // RFC-0094: Use credentials from MAIN via MyIOUtils (already fetched by MAIN)\n  const jwt = localStorage.getItem('jwt_token');\n\n  const mainCredentials = window.MyIOUtils?.getCredentials?.();\n  if (mainCredentials?.clientId && mainCredentials?.clientSecret) {\n    CLIENT_ID = mainCredentials.clientId;\n    CLIENT_SECRET = mainCredentials.clientSecret;\n    CUSTOMER_ING_ID = mainCredentials.customerIngestionId || '';\n    LogHelper.log('[WATER_STORES] Using credentials from MAIN (MyIOUtils)');\n  } else {\n    LogHelper.log('[WATER_STORES] MAIN credentials not available, fetching directly...');\n    const customerTB_ID = window.MyIOUtils?.getCustomerId?.() || self.ctx.settings?.customerTB_ID || '';\n\n    try {\n      const attrs = await MyIO.fetchThingsboardCustomerAttrsFromStorage(customerTB_ID, jwt);\n      CLIENT_ID = attrs?.client_id || '';\n      CLIENT_SECRET = attrs?.client_secret || '';\n      CUSTOMER_ING_ID = attrs?.ingestionId || '';\n    } catch (err) {\n      LogHelper.error('[WATER_STORES] Failed to fetch credentials:', err);\n    }\n  }\n\n  // Initialize auth if we have credentials\n  if (CLIENT_ID && CLIENT_SECRET) {\n    try {\n      MyIOAuth = MyIO.buildMyioIngestionAuth({\n        dataApiHost: getDataApiHost(),\n        clientId: CLIENT_ID,\n        clientSecret: CLIENT_SECRET,\n      });\n\n      LogHelper.log('[WATER_STORES] Auth init OK');\n      try {\n        await MyIOAuth.getToken();\n      } catch (_e) {\n        /* ignore token errors */\n      }\n    } catch (err) {\n      LogHelper.error('[WATER_STORES] Auth init FAIL', err);\n    }\n  } else {\n    LogHelper.warn('[WATER_STORES] No credentials available for auth initialization');\n  }\n\n  // Bind UI\n  bindHeader();\n  bindModal();\n\n  // ---------- Datas iniciais: \"Current Month So Far\" ----------\n  if (!self.ctx?.scope?.startDateISO || !self.ctx?.scope?.endDateISO) {\n    const now = new Date();\n    const start = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0);\n    const end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 0);\n    self.ctx.scope = self.ctx.scope || {};\n    self.ctx.scope.startDateISO = start.toISOString();\n    self.ctx.scope.endDateISO = end.toISOString();\n  }\n\n  const hasData = Array.isArray(self.ctx.data) && self.ctx.data.length > 0;\n  LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] onInit - Waiting for orchestrator data...`);\n\n  if (hasData && (!STATE.itemsBase || STATE.itemsBase.length === 0)) {\n    LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] Building itemsBase from TB data in onInit...`);\n    STATE.itemsBase = buildAuthoritativeItems();\n    LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] Built ${STATE.itemsBase.length} items from TB`);\n\n    STATE.itemsEnriched = STATE.itemsBase.map((item) => ({\n      ...item,\n      value: 0,\n      perc: 0,\n    }));\n    reflowFromState();\n  }\n\n  if (self.ctx?.scope?.startDateISO && self.ctx?.scope?.endDateISO) {\n    LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] Initial period defined, showing busy...`);\n    showBusy();\n  } else {\n    LogHelper.log(`[WATER_STORES ${WIDGET_DOMAIN}] No initial period, waiting for myio:update-date event...`);\n  }\n\n  if (hasData) {\n    STATE.firstHydrates++;\n    if (STATE.firstHydrates <= MAX_FIRST_HYDRATES) {\n      await hydrateAndRender();\n    }\n  } else {\n    const waiter = setInterval(async () => {\n      if (Array.isArray(self.ctx.data) && self.ctx.data.length > 0) {\n        clearInterval(waiter);\n        STATE.firstHydrates++;\n        if (STATE.firstHydrates <= MAX_FIRST_HYDRATES) await hydrateAndRender();\n      }\n    }, 200);\n  }\n};\n\nself.onDataUpdated = function () {\n  /* no-op */\n};\n\nself.onResize = function () {};\n\nself.onDestroy = function () {\n  if (dateUpdateHandler) {\n    window.removeEventListener('myio:update-date', dateUpdateHandler);\n    LogHelper.log(\"[WATER_STORES] Event listener 'myio:update-date' removido.\");\n  }\n  if (dataProvideHandler) {\n    window.removeEventListener('myio:telemetry:provide-data', dataProvideHandler);\n    LogHelper.log(\"[WATER_STORES] Event listener 'myio:telemetry:provide-data' removido.\");\n  }\n  if (waterDataReadyHandler) {\n    window.removeEventListener('myio:water-data-ready', waterDataReadyHandler);\n    LogHelper.log(\"[WATER_STORES] Event listener 'myio:water-data-ready' removido.\");\n  }\n\n  // RFC-0094: Cleanup header controller\n  if (waterStoresHeaderController) {\n    waterStoresHeaderController.destroy();\n    waterStoresHeaderController = null;\n    LogHelper.log('[WATER_STORES] [RFC-0094] Header controller destroyed');\n  }\n\n  // RFC-0094: Cleanup filter modal using shared factory\n  if (waterStoresFilterModal) {\n    waterStoresFilterModal.destroy();\n    waterStoresFilterModal = null;\n    LogHelper.log('[WATER_STORES] [RFC-0094] Filter modal destroyed');\n  }\n\n  try {\n    $root().off();\n  } catch (_e) {\n    /* ignore cleanup errors */\n  }\n  hideBusy();\n  hideGlobalSuccessModal();\n};\n",
      "settingsSchema": "{\r\n  \"schema\": {\r\n    \"type\": \"object\",\r\n    \"title\": \"Water Common Area Widget Settings\",\r\n    \"properties\": {\r\n        \"labelWidget\":{\r\n            \"type\":\"string\",\r\n            \"title\": \"Widget Label\",\r\n            \"default\": \"HidrÃ´metros de Ãreas Comuns\"\r\n        },\r\n        \"useNewComponents\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Use New Components\",\r\n            \"default\": true\r\n        },\r\n        \"enableSelection\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Enable Selection\",\r\n            \"default\": true\r\n        },\r\n        \"enableDragDrop\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Enable Drag Drop\",\r\n            \"default\": true\r\n        },\r\n        \"hideInfoMenuItem\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Hide Info Menu Item\",\r\n            \"default\": true\r\n        },\r\n        \"debugActive\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Debug Active\",\r\n            \"default\": false\r\n        },\r\n        \"activeTooltipDebug\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Active Tooltip Debug\",\r\n            \"default\": false\r\n        }\r\n    }\r\n  },\r\n  \"form\": [\r\n    \"labelWidget\",\r\n    \"useNewComponents\",\r\n    \"enableSelection\",\r\n    \"enableDragDrop\",\r\n    \"hideInfoMenuItem\",\r\n    \"debugActive\",\r\n    \"activeTooltipDebug\"\r\n  ]\r\n}\r\n",
      "dataKeySettingsSchema": "{}\n",
      "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Widget Head Office - WATER STORES  - v.5.2.0\",\"decimals\":null}"
    },
    "externalId": null,
    "resources": null,
    "id": {
      "entityType": "WIDGET_TYPE",
      "id": "89ce7940-cec3-11f0-998e-25174baff087"
    },
    "scada": false,
    "tags": null
  },
  "relations": [],
  "attributes": {
    "SERVER_SCOPE": []
  }
}