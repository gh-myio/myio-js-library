{
  "entityType": "WIDGET_TYPE",
  "entity": {
    "fqn": "widget_head_office_main_v_5_2_0",
    "name": "Widget Head Office - MAIN - v.5.2.0",
    "deprecated": false,
    "image": null,
    "description": null,
    "descriptor": {
      "type": "latest",
      "sizeX": 7.5,
      "sizeY": 3,
      "resources": [
        {
          "url": "https://unpkg.com/myio-js-library@0.1.181/dist/myio-js-library.umd.min.js"
        }
      ],
      "templateHtml": "<section style=\"height: 145px; min-height: 145px; max-height: 145px; overflow: none; background: transparent\">\r\n  <tb-dashboard-state class=\"content\" [ctx]=\"ctx\" stateId=\"header\"></tb-dashboard-state>\r\n</section>\r\n\r\n<section style=\"height: 80px; min-height: 80px; max-height: 80px; overflow: hidden; background: transparent\">\r\n  <tb-dashboard-state class=\"content\" [ctx]=\"ctx\" stateId=\"menu\"></tb-dashboard-state>\r\n</section>\r\n\r\n<!-- RFC-0057: All content states pre-rendered with show/hide logic (no dynamic innerHTML!) -->\r\n<section id=\"mainView\" style=\"height: calc(100% - 271px); overflow: auto; background: transparent\">\r\n  <div data-content-state=\"content_equipments\" style=\"display: block; height: 100%; width: 100%\">\r\n    <tb-dashboard-state class=\"content\" [ctx]=\"ctx\" stateId=\"content_equipments\"></tb-dashboard-state>\r\n  </div>\r\n  <div data-content-state=\"content_energy\" style=\"display: none; height: 100%; width: 100%\">\r\n    <tb-dashboard-state class=\"content\" [ctx]=\"ctx\" stateId=\"content_energy\"></tb-dashboard-state>\r\n  </div>\r\n  <!-- RFC-0087: Water states (summary, common area, stores) -->\r\n  <div data-content-state=\"content_water\" style=\"display: none; height: 100%; width: 100%\">\r\n    <tb-dashboard-state class=\"content\" [ctx]=\"ctx\" stateId=\"content_water\"></tb-dashboard-state>\r\n  </div>\r\n  <div data-content-state=\"content_water_common_area\" style=\"display: none; height: 100%; width: 100%\">\r\n    <tb-dashboard-state class=\"content\" [ctx]=\"ctx\" stateId=\"content_water_common_area\"></tb-dashboard-state>\r\n  </div>\r\n  <div data-content-state=\"content_water_stores\" style=\"display: none; height: 100%; width: 100%\">\r\n    <tb-dashboard-state class=\"content\" [ctx]=\"ctx\" stateId=\"content_water_stores\"></tb-dashboard-state>\r\n  </div>\r\n  <div data-content-state=\"content_temperature\" style=\"display: none; height: 100%; width: 100%\">\r\n    <tb-dashboard-state class=\"content\" [ctx]=\"ctx\" stateId=\"content_temperature\"></tb-dashboard-state>\r\n  </div>\r\n  <div data-content-state=\"content_temperature_sensors\" style=\"display: none; height: 100%; width: 100%\">\r\n    <tb-dashboard-state\r\n      class=\"content\"\r\n      [ctx]=\"ctx\"\r\n      stateId=\"content_temperature_sensors\"\r\n    ></tb-dashboard-state>\r\n  </div>\r\n  <div\r\n    data-content-state=\"content_temperature_sensors_external\"\r\n    style=\"display: none; height: 100%; width: 100%\"\r\n  >\r\n    <tb-dashboard-state\r\n      class=\"content\"\r\n      [ctx]=\"ctx\"\r\n      stateId=\"content_temperature_sensors_external\"\r\n    ></tb-dashboard-state>\r\n  </div>\r\n  <div\r\n    data-content-state=\"content_store\"\r\n    style=\"display: none; height: 100%; width: 100%; position: relative\"\r\n  >\r\n    <tb-dashboard-state class=\"content\" [ctx]=\"ctx\" stateId=\"content_store\"></tb-dashboard-state>\r\n  </div>\r\n</section>\r\n\r\n<!-- RFC-0058: Footer with device selection and comparison -->\r\n<section>\r\n  <tb-dashboard-state [ctx]=\"ctx\" stateId=\"footer\"></tb-dashboard-state>\r\n</section>\r\n",
      "templateCss": "#container {\r\n  display: flex;\r\n  height: 100%;\r\n  flex-direction: column;\r\n  align-items: stretch;\r\n  justify-content: normal;\r\n  background: transparent !important;\r\n}\r\n\r\n/* For√ßa transpar√™ncia nas sections que N√ÉO s√£o o footer */\r\n#container > section {\r\n  background: transparent !important;\r\n  background-color: transparent !important;\r\n  background-image: none !important;\r\n  overflow: hidden;\r\n}\r\n\r\n/* --- REGRAS ESSENCIAIS E DE DIMENSIONAMENTO DO FOOTER (√öltima Section) --- */\r\n\r\n#container > section:last-child {\r\n  height: 50px !important;\r\n  min-height: 50px !important;\r\n  max-height: 50px !important;\r\n  margin: 0 !important;\r\n  overflow: visible !important; /* CR√çTICO: Permite que tooltips e popups sejam vis√≠veis */\r\n  z-index: 99999 !important; /* Prioridade m√°xima de Z-index */\r\n  position: relative;\r\n  background: transparent !important;\r\n}\r\n\r\n#container > section:last-child tb-dashboard-state,\r\n#container > section:last-child .content,\r\n#container > section:last-child .tb-widget-container,\r\n#container > section:last-child .tb-widget,\r\n#container > section:last-child .tb-widget-content,\r\n#container > section:last-child .tb-absolute-container,\r\n#container > section:last-child .mat-card,\r\n#container > section:last-child .mat-mdc-card,\r\n#container > section:last-child .tb-dashboard-state-component,\r\n#container > section:last-child tb-dynamic-component {\r\n  height: 100% !important;\r\n  width: 1630px !important;\r\n  margin: 0 !important;\r\n  padding: 0 !important;\r\n  background: transparent !important;\r\n  background-color: transparent !important;\r\n  box-shadow: none !important;\r\n  border: none !important;\r\n\r\n  overflow: visible !important;\r\n  display: block !important;\r\n}\r\n\r\n#container > section:last-child .myio-footer {\r\n  background-color: #2e5848 !important;\r\n}\r\n\r\n/* Limpa o padding do ThingsBoard no wrapper mais interno */\r\n#myio-root .myio-footer .tb-child {\r\n  padding: 0 !important;\r\n  background: transparent !important;\r\n  box-shadow: none !important;\r\n  border: none !important;\r\n}\r\n\r\n/* --- REGRAS DO MAIN VIEW E OUTRAS GERAIS --- */\r\n\r\n#mainView > div > .content {\r\n  height: 100%;\r\n}\r\n\r\n.tb-dashboard-toolbar {\r\n  display: none !important;\r\n}\r\n\r\n/* --- EXCE√á√ïES ESPEC√çFICAS QUE PRECISAM DE FUNDO (Manter) --- */\r\n\r\nsection .myio-card.v2.myio-card-logo {\r\n  background: #5e35b1 !important;\r\n  background-color: #5e35b1 !important;\r\n}\r\n\r\nsection .myio-bar,\r\nsection .myio-bar-fill,\r\nsection .dot-ok {\r\n  background: revert !important;\r\n}\r\n\r\nsection button[style*='background-color: #6A1B9A'] {\r\n  background-color: #6a1b9a !important;\r\n}\r\n\r\n/* Remove o padding do container principal do gridster */\r\n#gridster-child {\r\n  padding: 0px !important;\r\n}\r\n",
      "controllerScript": "/* global self, window, document, localStorage, MyIOLibrary */\r\n\r\n// ============================================\r\n// MYIO SHARED UTILITIES (exposed globally)\r\n// ============================================\r\n\r\n// Debug configuration - can be toggled at runtime via window.MyIOUtils.setDebug(true/false)\r\nlet DEBUG_ACTIVE = true;\r\n\r\n// LogHelper utility - shared across all widgets\r\nconst LogHelper = {\r\n  log: function (...args) {\r\n    if (DEBUG_ACTIVE) {\r\n      console.log(...args);\r\n    }\r\n  },\r\n  warn: function (...args) {\r\n    if (DEBUG_ACTIVE) {\r\n      console.warn(...args);\r\n    }\r\n  },\r\n  error: function (...args) {\r\n    // Errors always logged regardless of DEBUG_ACTIVE\r\n    console.error(...args);\r\n  },\r\n};\r\n\r\n// RFC-0086: Get DATA_API_HOST from window global (set by MAIN onInit)\r\nfunction getDataApiHost() {\r\n  const host = window.__MYIO_DATA_API_HOST__;\r\n  if (!host) {\r\n    LogHelper.error('[MAIN] DATA_API_HOST not available - onInit not executed yet');\r\n    return '';\r\n  }\r\n  return host;\r\n}\r\n\r\n/**\r\n * RFC-0094/RFC-0097: Fetch energy consumption for a customer within a time range\r\n * Used by ENERGY widget for chart and other consumption queries\r\n *\r\n * IMPORTANT: Only counts devices that have a match with ingestionIds from\r\n * ThingsBoard datasources (Equipamentos e Lojas)\r\n *\r\n * @param {string} customerId - Customer ID for ingestion API\r\n * @param {number} startTs - Start timestamp in milliseconds\r\n * @param {number} endTs - End timestamp in milliseconds\r\n * @param {string} granularity - Data granularity: '1d' (day) or '1h' (hour). Default: '1d'\r\n * @returns {Promise<{devices: Array, total: number}>} - Devices list and total consumption\r\n */\r\nasync function fetchEnergyDayConsumption(customerId, startTs, endTs, granularity = '1d') {\r\n  if (!customerId) {\r\n    LogHelper.warn('[MAIN] fetchEnergyDayConsumption: Missing customerId');\r\n    return { devices: [], total: 0 };\r\n  }\r\n\r\n  // Convert timestamps to ISO 8601 format with .000Z milliseconds (API requirement)\r\n  const formatDateISO = (ts) => {\r\n    const d = new Date(ts);\r\n    d.setMilliseconds(0); // Zero out milliseconds for API compatibility\r\n    return d.toISOString();\r\n  };\r\n\r\n  const startTimeISO = formatDateISO(startTs);\r\n  const endTimeISO = formatDateISO(endTs);\r\n\r\n  // RFC-0097: Use granularity parameter\r\n  const url = `${getDataApiHost()}/api/v1/telemetry/customers/${customerId}/energy/devices/totals/?deep=1&granularity=${granularity}&startTime=${encodeURIComponent(\r\n    startTimeISO\r\n  )}&endTime=${encodeURIComponent(endTimeISO)}`;\r\n\r\n  try {\r\n    const TOKEN_INGESTION_EnergyDayConsumption = await myIOAuth.getToken();\r\n    const response = await fetch(url, {\r\n      method: 'GET',\r\n      headers: {\r\n        Authorization: `Bearer ${TOKEN_INGESTION_EnergyDayConsumption}`,\r\n        'Content-Type': 'application/json',\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      LogHelper.warn(`[MAIN] fetchEnergyDayConsumption: Failed with status ${response.status}`);\r\n      return { devices: [], total: 0 };\r\n    }\r\n\r\n    const data = await response.json();\r\n\r\n    // RFC-0097: API returns array directly, not { devices: [...] }\r\n    // Format: [{ id, name, type, consumption: [{ timestamp, value }] }]\r\n    const allDevices = Array.isArray(data) ? data : data?.devices || data?.data || [];\r\n\r\n    // Get valid energy ingestionIds from ThingsBoard datasources (Equipamentos e Lojas)\r\n    const orchestrator = window.MyIOOrchestrator;\r\n    const validIds = orchestrator?.getEnergyValidIds?.() || new Set();\r\n\r\n    // Filter devices: only include those with matching ingestionId\r\n    const hasValidIds = validIds.size > 0;\r\n    let total = 0;\r\n    let matchedCount = 0;\r\n    let filteredDevices = [];\r\n\r\n    if (Array.isArray(allDevices)) {\r\n      allDevices.forEach((device) => {\r\n        const deviceId = device.id || device.ingestionId;\r\n\r\n        // Only count if device.id matches a valid ingestionId from TB datasources\r\n        // If no valid IDs registered yet, skip filtering (will use all devices as fallback)\r\n        if (hasValidIds && !validIds.has(deviceId)) {\r\n          return; // Skip devices not in TB datasources\r\n        }\r\n\r\n        matchedCount++;\r\n        filteredDevices.push(device);\r\n\r\n        // Handle both formats: direct value or consumption array\r\n        if (Array.isArray(device.consumption)) {\r\n          device.consumption.forEach((entry) => {\r\n            total += Number(entry.value) || 0;\r\n          });\r\n        } else {\r\n          const value = device.total_value || device.value || 0;\r\n          total += Number(value) || 0;\r\n        }\r\n      });\r\n    }\r\n\r\n    LogHelper.log(\r\n      `[MAIN] fetchEnergyDayConsumption: API returned ${\r\n        allDevices.length\r\n      } devices, matched ${matchedCount} with TB datasources, total=${total.toFixed(2)}`\r\n    );\r\n\r\n    return { devices: filteredDevices, total };\r\n  } catch (error) {\r\n    LogHelper.error('[MAIN] fetchEnergyDayConsumption: Error', error);\r\n    return { devices: [], total: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0098: Fetch water consumption for a customer within a time range\r\n * Used by WATER widget for chart and other consumption queries\r\n * Same as fetchEnergyDayConsumption but for water domain\r\n *\r\n * IMPORTANT: Only counts devices that have a match with ingestionIds from\r\n * ThingsBoard datasources (HidrometrosAreaComum + Todos Hidrometros Lojas)\r\n *\r\n * @param {string} customerId - Customer ID for ingestion API\r\n * @param {number} startTs - Start timestamp in milliseconds\r\n * @param {number} endTs - End timestamp in milliseconds\r\n * @param {string} granularity - Data granularity: '1d' (day) or '1h' (hour). Default: '1d'\r\n * @returns {Promise<{devices: Array, total: number}>} - Devices list and total consumption\r\n */\r\nasync function fetchWaterDayConsumption(customerId, startTs, endTs, granularity = '1d') {\r\n  if (!customerId) {\r\n    LogHelper.warn('[MAIN] fetchWaterDayConsumption: Missing customerId');\r\n    return { devices: [], total: 0 };\r\n  }\r\n\r\n  const formatDateISO = (ts) => {\r\n    const d = new Date(ts);\r\n    d.setMilliseconds(0);\r\n    return d.toISOString();\r\n  };\r\n\r\n  const startTimeISO = formatDateISO(startTs);\r\n  const endTimeISO = formatDateISO(endTs);\r\n\r\n  // RFC-0098: Water API returns total_value per device (not consumption array like energy)\r\n  // Use /water/devices/totals endpoint\r\n  const url = `${getDataApiHost()}/api/v1/telemetry/customers/${customerId}/water/devices/totals?deep=1&startTime=${encodeURIComponent(\r\n    startTimeISO\r\n  )}&endTime=${encodeURIComponent(endTimeISO)}`;\r\n\r\n  try {\r\n    const TOKEN_INGESTION_WaterDayConsumption = await myIOAuth.getToken();\r\n    const response = await fetch(url, {\r\n      method: 'GET',\r\n      headers: {\r\n        Authorization: `Bearer ${TOKEN_INGESTION_WaterDayConsumption}`,\r\n        'Content-Type': 'application/json',\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      LogHelper.warn(`[MAIN] fetchWaterDayConsumption: Failed with status ${response.status}`);\r\n      return { devices: [], total: 0 };\r\n    }\r\n\r\n    const data = await response.json();\r\n    const allDevices = Array.isArray(data) ? data : data?.devices || data?.data || [];\r\n\r\n    // Get valid water ingestionIds from ThingsBoard datasources (HidrometrosAreaComum + Todos Hidrometros Lojas)\r\n    const orchestrator = window.MyIOOrchestrator;\r\n    const validIds = orchestrator?.getWaterValidIds?.() || { commonArea: new Set(), stores: new Set() };\r\n    const allValidIds = new Set([...validIds.commonArea, ...validIds.stores]);\r\n\r\n    // Filter devices: only include those with matching ingestionId\r\n    const hasValidIds = allValidIds.size > 0;\r\n    let total = 0;\r\n    let matchedCount = 0;\r\n    let filteredDevices = [];\r\n\r\n    if (Array.isArray(allDevices)) {\r\n      allDevices.forEach((device) => {\r\n        const deviceId = device.id || device.ingestionId;\r\n\r\n        // Only count if device.id matches a valid ingestionId from TB datasources\r\n        // If no valid IDs registered yet, skip filtering (will use all devices as fallback)\r\n        if (hasValidIds && !allValidIds.has(deviceId)) {\r\n          return; // Skip devices not in TB datasources\r\n        }\r\n\r\n        matchedCount++;\r\n        filteredDevices.push(device);\r\n\r\n        if (Array.isArray(device.consumption)) {\r\n          device.consumption.forEach((entry) => {\r\n            total += Number(entry.value) || 0;\r\n          });\r\n        } else {\r\n          const value = device.total_value || device.value || 0;\r\n          total += Number(value) || 0;\r\n        }\r\n      });\r\n    }\r\n\r\n    LogHelper.log(\r\n      `[MAIN] fetchWaterDayConsumption: API returned ${\r\n        allDevices.length\r\n      } devices, matched ${matchedCount} with TB datasources, total=${total.toFixed(2)}`\r\n    );\r\n\r\n    return { devices: filteredDevices, total };\r\n  } catch (error) {\r\n    LogHelper.error('[MAIN] fetchWaterDayConsumption: Error', error);\r\n    return { devices: [], total: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * Shows/hides loading overlay for equipments widget\r\n * @param {boolean} show - Whether to show or hide the overlay\r\n */\r\nfunction showLoadingOverlay(show) {\r\n  const overlay = document.getElementById('equipments-loading-overlay');\r\n  if (overlay) {\r\n    overlay.style.display = show ? 'flex' : 'none';\r\n  }\r\n}\r\n\r\n// ============================================\r\n// RFC-0071: DEVICE PROFILE SYNCHRONIZATION\r\n// ============================================\r\n\r\n/**\r\n * Fetches all active device profiles from ThingsBoard\r\n * @returns {Promise<Map<string, string>>} Map of profileId -> profileName\r\n */\r\nasync function fetchDeviceProfiles() {\r\n  const token = localStorage.getItem('jwt_token');\r\n  if (!token) throw new Error('[RFC-0071] JWT token not found');\r\n\r\n  const url = '/api/deviceProfile/names?activeOnly=true';\r\n\r\n  LogHelper.log('[MAIN] [RFC-0071] Fetching device profiles...');\r\n\r\n  const response = await fetch(url, {\r\n    headers: {\r\n      'X-Authorization': `Bearer ${token}`,\r\n      'Content-Type': 'application/json',\r\n    },\r\n  });\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`[RFC-0071] Failed to fetch device profiles: ${response.status}`);\r\n  }\r\n\r\n  const profiles = await response.json();\r\n\r\n  const profileMap = new Map();\r\n  profiles.forEach((profile) => {\r\n    const profileId = profile.id.id;\r\n    const profileName = profile.name;\r\n    profileMap.set(profileId, profileName);\r\n  });\r\n\r\n  LogHelper.log(\r\n    `[MAIN] [RFC-0071] Loaded ${profileMap.size} device profiles:`,\r\n    Array.from(profileMap.entries())\r\n      .map(([_id, name]) => name)\r\n      .join(', ')\r\n  );\r\n\r\n  return profileMap;\r\n}\r\n\r\n/**\r\n * Fetches device details including deviceProfileId\r\n * @param {string} deviceId - Device entity ID\r\n * @returns {Promise<Object>}\r\n */\r\nasync function fetchDeviceDetails(deviceId) {\r\n  const token = localStorage.getItem('jwt_token');\r\n  if (!token) throw new Error('[RFC-0071] JWT token not found');\r\n\r\n  const url = `/api/device/${deviceId}`;\r\n\r\n  const response = await fetch(url, {\r\n    headers: {\r\n      'X-Authorization': `Bearer ${token}`,\r\n      'Content-Type': 'application/json',\r\n    },\r\n  });\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`[RFC-0071] Failed to fetch device ${deviceId}: ${response.status}`);\r\n  }\r\n\r\n  return await response.json();\r\n}\r\n\r\n/**\r\n * Saves deviceProfile as a server-scope attribute on the device\r\n * @param {string} deviceId - Device entity ID\r\n * @param {string} deviceProfile - Profile name (e.g., \"MOTOR\", \"3F_MEDIDOR\")\r\n * @returns {Promise<{ok: boolean, status: number, data: any}>}\r\n */\r\nasync function addDeviceProfileAttribute(deviceId, deviceProfile) {\r\n  const t = Date.now();\r\n\r\n  try {\r\n    if (!deviceId) throw new Error('deviceId is required');\r\n    if (deviceProfile == null || deviceProfile === '') {\r\n      throw new Error('deviceProfile is required');\r\n    }\r\n\r\n    const token = localStorage.getItem('jwt_token');\r\n    if (!token) throw new Error('jwt_token not found in localStorage');\r\n\r\n    const url = `/api/plugins/telemetry/DEVICE/${deviceId}/attributes/SERVER_SCOPE`;\r\n    const headers = {\r\n      'Content-Type': 'application/json',\r\n      'X-Authorization': `Bearer ${token}`,\r\n    };\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers,\r\n      body: JSON.stringify({ deviceProfile }),\r\n    });\r\n\r\n    const bodyText = await res.text().catch(() => '');\r\n\r\n    if (!res.ok) {\r\n      throw new Error(`[RFC-0071] HTTP ${res.status} ${res.statusText} - ${bodyText}`);\r\n    }\r\n\r\n    let data = null;\r\n    try {\r\n      data = bodyText ? JSON.parse(bodyText) : null;\r\n    } catch {\r\n      // Response may not be JSON\r\n    }\r\n\r\n    const dt = Date.now() - t;\r\n    LogHelper.log(\r\n      `[MAIN] [RFC-0071] ‚úÖ Saved deviceProfile | device=${deviceId} | \"${deviceProfile}\" | ${dt}ms`\r\n    );\r\n\r\n    return { ok: true, status: res.status, data };\r\n  } catch (err) {\r\n    const dt = Date.now() - t;\r\n    LogHelper.error(\r\n      `[MAIN] [RFC-0071] ‚ùå Failed to save deviceProfile | device=${deviceId} | \"${deviceProfile}\" | ${dt}ms | error: ${\r\n        err?.message || err\r\n      }`\r\n    );\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Main synchronization function - syncs missing deviceProfile attributes\r\n * NOTE: Requires ctx.data to be available (call from widget context)\r\n * @param {Array} ctxData - The ctx.data array from widget context\r\n * @returns {Promise<{synced: number, skipped: number, errors: number}>}\r\n */\r\nasync function syncDeviceProfileAttributes(ctxData) {\r\n  LogHelper.log('[MAIN] [RFC-0071] üîÑ Starting device profile synchronization...');\r\n\r\n  try {\r\n    const profileMap = await fetchDeviceProfiles();\r\n\r\n    let synced = 0;\r\n    let skipped = 0;\r\n    let errors = 0;\r\n\r\n    const deviceMap = new Map();\r\n\r\n    ctxData.forEach((data) => {\r\n      const entityId = data.datasource?.entity?.id?.id;\r\n      const existingProfile = data.datasource?.deviceProfile;\r\n\r\n      if (!entityId) return;\r\n\r\n      if (existingProfile) {\r\n        skipped++;\r\n        return;\r\n      }\r\n\r\n      if (!deviceMap.has(entityId)) {\r\n        deviceMap.set(entityId, {\r\n          entityLabel: data.datasource?.entityLabel,\r\n          entityName: data.datasource?.entityName,\r\n          name: data.datasource?.name,\r\n        });\r\n      }\r\n    });\r\n\r\n    LogHelper.log(`[MAIN] [RFC-0071] Found ${deviceMap.size} devices without deviceProfile attribute`);\r\n    LogHelper.log(`[MAIN] [RFC-0071] Skipped ${skipped} devices that already have deviceProfile`);\r\n\r\n    if (deviceMap.size === 0) {\r\n      LogHelper.log('[MAIN] [RFC-0071] ‚úÖ All devices already synchronized!');\r\n      return { synced: 0, skipped, errors: 0 };\r\n    }\r\n\r\n    let processed = 0;\r\n    for (const [entityId, deviceInfo] of deviceMap) {\r\n      processed++;\r\n      const deviceLabel = deviceInfo.entityLabel || deviceInfo.entityName || deviceInfo.name || entityId;\r\n\r\n      try {\r\n        LogHelper.log(`[MAIN] [RFC-0071] Processing ${processed}/${deviceMap.size}: ${deviceLabel}`);\r\n\r\n        const deviceDetails = await fetchDeviceDetails(entityId);\r\n        const deviceProfileId = deviceDetails.deviceProfileId?.id;\r\n\r\n        if (!deviceProfileId) {\r\n          LogHelper.warn(`[MAIN] [RFC-0071] ‚ö†Ô∏è Device ${deviceLabel} has no deviceProfileId`);\r\n          errors++;\r\n          continue;\r\n        }\r\n\r\n        const profileName = profileMap.get(deviceProfileId);\r\n\r\n        if (!profileName) {\r\n          LogHelper.warn(`[MAIN] [RFC-0071] ‚ö†Ô∏è Profile ID ${deviceProfileId} not found in map`);\r\n          errors++;\r\n          continue;\r\n        }\r\n\r\n        await addDeviceProfileAttribute(entityId, profileName);\r\n        synced++;\r\n\r\n        LogHelper.log(`[MAIN] [RFC-0071] ‚úÖ Synced ${deviceLabel} -> ${profileName}`);\r\n\r\n        await new Promise((resolve) => setTimeout(resolve, 100));\r\n      } catch (error) {\r\n        LogHelper.error(`[MAIN] [RFC-0071] ‚ùå Failed to sync device ${deviceLabel}:`, error);\r\n        errors++;\r\n      }\r\n    }\r\n\r\n    LogHelper.log(\r\n      `[MAIN] [RFC-0071] üéâ Sync complete: ${synced} synced, ${skipped} skipped, ${errors} errors`\r\n    );\r\n\r\n    return { synced, skipped, errors };\r\n  } catch (error) {\r\n    LogHelper.error('[MAIN] [RFC-0071] ‚ùå Fatal error during sync:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// ============================================\r\n// RFC-0078: UNIFIED JSON POWER LIMITS CONFIGURATION\r\n// ============================================\r\n\r\n/**\r\n * Default consumption ranges for each device type (TIER 3 - fallback)\r\n */\r\nconst DEFAULT_CONSUMPTION_RANGES = {\r\n  ELEVADOR: {\r\n    standbyRange: { down: 0, up: 150 },\r\n    normalRange: { down: 151, up: 800 },\r\n    alertRange: { down: 801, up: 1200 },\r\n    failureRange: { down: 1201, up: 99999 },\r\n  },\r\n  ESCADA_ROLANTE: {\r\n    standbyRange: { down: 0, up: 200 },\r\n    normalRange: { down: 201, up: 1000 },\r\n    alertRange: { down: 1001, up: 1500 },\r\n    failureRange: { down: 1501, up: 99999 },\r\n  },\r\n  CHILLER: {\r\n    standbyRange: { down: 0, up: 1000 },\r\n    normalRange: { down: 1001, up: 6000 },\r\n    alertRange: { down: 6001, up: 8000 },\r\n    failureRange: { down: 8001, up: 99999 },\r\n  },\r\n  AR_CONDICIONADO: {\r\n    standbyRange: { down: 0, up: 500 },\r\n    normalRange: { down: 501, up: 3000 },\r\n    alertRange: { down: 3001, up: 5000 },\r\n    failureRange: { down: 5001, up: 99999 },\r\n  },\r\n  HVAC: {\r\n    standbyRange: { down: 0, up: 500 },\r\n    normalRange: { down: 501, up: 3000 },\r\n    alertRange: { down: 3001, up: 5000 },\r\n    failureRange: { down: 5001, up: 99999 },\r\n  },\r\n  MOTOR: {\r\n    standbyRange: { down: 0, up: 200 },\r\n    normalRange: { down: 201, up: 1000 },\r\n    alertRange: { down: 1001, up: 1500 },\r\n    failureRange: { down: 1501, up: 99999 },\r\n  },\r\n  BOMBA: {\r\n    standbyRange: { down: 0, up: 200 },\r\n    normalRange: { down: 201, up: 1000 },\r\n    alertRange: { down: 1001, up: 1500 },\r\n    failureRange: { down: 1501, up: 99999 },\r\n  },\r\n  DEFAULT: {\r\n    standbyRange: { down: 0, up: 100 },\r\n    normalRange: { down: 101, up: 1000 },\r\n    alertRange: { down: 1001, up: 2000 },\r\n    failureRange: { down: 2001, up: 99999 },\r\n  },\r\n};\r\n\r\n// Cache for JSON power limits configuration\r\nconst powerLimitsJSONCache = new Map();\r\nconst POWER_LIMITS_CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\r\n\r\n/**\r\n * RFC-0078: Fetch unified JSON power limits from ThingsBoard entity\r\n * @param {string} entityId - Entity ID (device or customer)\r\n * @param {string} entityType - 'DEVICE' or 'CUSTOMER'\r\n * @returns {Promise<Object|null>} Parsed JSON configuration or null\r\n */\r\nasync function fetchInstantaneousPowerLimits(entityId, entityType = 'CUSTOMER') {\r\n  const token = localStorage.getItem('jwt_token');\r\n  if (!token) {\r\n    LogHelper.warn('[RFC-0078] JWT token not found');\r\n    return null;\r\n  }\r\n\r\n  LogHelper.log('[RFC-0078] entityId', entityId);\r\n\r\n  const url = `/api/plugins/telemetry/${entityType}/${entityId}/values/attributes/SERVER_SCOPE`;\r\n\r\n  try {\r\n    const response = await fetch(url, {\r\n      headers: {\r\n        'X-Authorization': `Bearer ${token}`,\r\n        'Content-Type': 'application/json',\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      if (response.status === 404) {\r\n        LogHelper.log(`[RFC-0078] No attributes found for ${entityType} ${entityId}`);\r\n        return null;\r\n      }\r\n      LogHelper.warn(`[RFC-0078] Failed to fetch ${entityType} attributes: ${response.status}`);\r\n      return null;\r\n    }\r\n\r\n    const attributes = await response.json();\r\n\r\n    LogHelper.log('[RFC-0078] attributes', attributes);\r\n\r\n    const powerLimitsAttr = attributes.find((attr) => attr.key === 'mapInstantaneousPower');\r\n\r\n    if (!powerLimitsAttr) {\r\n      return null;\r\n    }\r\n\r\n    let limits;\r\n    if (typeof powerLimitsAttr.value === 'string') {\r\n      try {\r\n        limits = JSON.parse(powerLimitsAttr.value);\r\n      } catch (parseError) {\r\n        LogHelper.error(`[RFC-0078] Failed to parse JSON for ${entityType} ${entityId}:`, parseError);\r\n        return null;\r\n      }\r\n    } else {\r\n      limits = powerLimitsAttr.value;\r\n    }\r\n\r\n    LogHelper.log(`[RFC-0078] ‚úÖ Loaded mapInstantaneousPower from ${entityType} ${entityId}:`, {\r\n      version: limits.version,\r\n      telemetryTypes: limits.limitsByInstantaneoustPowerType?.length || 0,\r\n    });\r\n\r\n    return limits;\r\n  } catch (error) {\r\n    LogHelper.error(`[RFC-0078] Error fetching ${entityType} power limits:`, error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0078: Extract consumption ranges from unified JSON structure\r\n * @param {Object} powerLimitsJSON - The mapInstantaneousPower JSON object\r\n * @param {string} deviceType - Device type (e.g., 'ELEVADOR')\r\n * @param {string} telemetryType - Telemetry type (default: 'consumption')\r\n * @returns {Object|null} Range configuration or null\r\n */\r\nfunction extractLimitsFromJSON(powerLimitsJSON, deviceType, telemetryType = 'consumption') {\r\n  if (!powerLimitsJSON || !powerLimitsJSON.limitsByInstantaneoustPowerType) {\r\n    return null;\r\n  }\r\n\r\n  // RFC-0091: Skip extraction if deviceType is empty/invalid (avoids log spam)\r\n  if (!deviceType || typeof deviceType !== 'string' || deviceType.trim() === '') {\r\n    return null;\r\n  }\r\n\r\n  const telemetryConfig = powerLimitsJSON.limitsByInstantaneoustPowerType.find(\r\n    (config) => config.telemetryType === telemetryType\r\n  );\r\n\r\n  if (!telemetryConfig) {\r\n    LogHelper.log(`[RFC-0078] Telemetry type ${telemetryType} not found in JSON`);\r\n    return null;\r\n  }\r\n\r\n  const deviceTypeUpper = deviceType.toUpperCase();\r\n  const deviceConfig = telemetryConfig.itemsByDeviceType.find(\r\n    (item) => item.deviceType === deviceType || item.deviceType === deviceTypeUpper\r\n  );\r\n\r\n  if (!deviceConfig) {\r\n    // RFC-0091: Only log once per deviceType to avoid spam (use warn level for visibility)\r\n    if (!extractLimitsFromJSON._warnedTypes) extractLimitsFromJSON._warnedTypes = new Set();\r\n    if (!extractLimitsFromJSON._warnedTypes.has(deviceTypeUpper)) {\r\n      extractLimitsFromJSON._warnedTypes.add(deviceTypeUpper);\r\n      LogHelper.warn(`[RFC-0078] Device type \"${deviceType}\" not found for telemetry ${telemetryType}`);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  const ranges = {\r\n    standbyRange: { down: 0, up: 0 },\r\n    normalRange: { down: 0, up: 0 },\r\n    alertRange: { down: 0, up: 0 },\r\n    failureRange: { down: 0, up: 0 },\r\n  };\r\n\r\n  deviceConfig.limitsByDeviceStatus.forEach((status) => {\r\n    const baseValue = status.limitsValues?.baseValue ?? status.limitsVales?.baseValue ?? 0;\r\n    const topValue = status.limitsValues?.topValue ?? status.limitsVales?.topValue ?? 99999;\r\n\r\n    switch (status.deviceStatusName) {\r\n      case 'standBy':\r\n        ranges.standbyRange = { down: baseValue, up: topValue };\r\n        break;\r\n      case 'normal':\r\n        ranges.normalRange = { down: baseValue, up: topValue };\r\n        break;\r\n      case 'alert':\r\n        ranges.alertRange = { down: baseValue, up: topValue };\r\n        break;\r\n      case 'failure':\r\n        ranges.failureRange = { down: baseValue, up: topValue };\r\n        break;\r\n    }\r\n  });\r\n\r\n  return {\r\n    ...ranges,\r\n    source: 'json',\r\n    tier: 2,\r\n    metadata: {\r\n      name: deviceConfig.name,\r\n      description: deviceConfig.description,\r\n      version: powerLimitsJSON.version,\r\n      telemetryType: telemetryType,\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * RFC-0078: Gets default ranges for a device type (TIER 3)\r\n * @param {string} deviceType - Device type\r\n * @returns {Object} Default ranges\r\n */\r\nfunction getDefaultRanges(deviceType) {\r\n  const upperDeviceType = deviceType.toUpperCase();\r\n  return DEFAULT_CONSUMPTION_RANGES[upperDeviceType] || DEFAULT_CONSUMPTION_RANGES['DEFAULT'];\r\n}\r\n\r\n/**\r\n * RFC-0078: Gets cached or fetches power limits JSON\r\n * @param {string} entityId - Entity ID\r\n * @param {string} entityType - 'DEVICE' or 'CUSTOMER'\r\n * @param {Object} ctxData - Optional ctx.data array from widget context\r\n * @returns {Promise<Object|null>} JSON configuration\r\n */\r\nasync function getCachedPowerLimitsJSON(entityId, entityType = 'CUSTOMER', ctxData = null) {\r\n  if (!entityId) return null;\r\n\r\n  const cacheKey = `${entityType}:${entityId}`;\r\n  const cached = powerLimitsJSONCache.get(cacheKey);\r\n  const now = Date.now();\r\n\r\n  if (cached && now - cached.timestamp < POWER_LIMITS_CACHE_TTL_MS) {\r\n    return cached.json;\r\n  }\r\n\r\n  let json = null;\r\n\r\n  if (entityType === 'DEVICE' && ctxData) {\r\n    const powerLimitsData = ctxData.find((d) => d.dataKey && d.dataKey.name === 'mapInstantaneousPower');\r\n\r\n    if (powerLimitsData && powerLimitsData.data && powerLimitsData.data.length > 0) {\r\n      const latestValue = powerLimitsData.data[powerLimitsData.data.length - 1];\r\n      const rawValue = latestValue[1];\r\n\r\n      if (typeof rawValue === 'string') {\r\n        try {\r\n          json = JSON.parse(rawValue);\r\n          LogHelper.log(`[RFC-0078] ‚úÖ Loaded mapInstantaneousPower from ctx.data for DEVICE ${entityId}:`, {\r\n            version: json.version,\r\n            telemetryTypes: json.limitsByInstantaneoustPowerType?.length || 0,\r\n          });\r\n        } catch (parseError) {\r\n          LogHelper.warn(`[RFC-0078] Failed to parse DEVICE JSON from ctx.data:`, parseError);\r\n          json = { version: '1.0.0', limitsByInstantaneoustPowerType: [] };\r\n        }\r\n      } else if (typeof rawValue === 'object') {\r\n        json = rawValue;\r\n        LogHelper.log(\r\n          `[RFC-0078] ‚úÖ Loaded mapInstantaneousPower (object) from ctx.data for DEVICE ${entityId}`\r\n        );\r\n      }\r\n    } else {\r\n      LogHelper.log(\r\n        `[RFC-0078] mapInstantaneousPower not found in ctx.data for DEVICE ${entityId}, using empty fallback`\r\n      );\r\n      json = { version: '1.0.0', limitsByInstantaneoustPowerType: [] };\r\n    }\r\n  } else if (entityType === 'CUSTOMER') {\r\n    LogHelper.log('[RFC-0078] entityId getCachedPowerLimitsJSON', entityId);\r\n    json = await fetchInstantaneousPowerLimits(entityId, entityType);\r\n  } else {\r\n    json = { version: '1.0.0', limitsByInstantaneoustPowerType: [] };\r\n  }\r\n\r\n  powerLimitsJSONCache.set(cacheKey, {\r\n    json: json,\r\n    timestamp: now,\r\n  });\r\n\r\n  return json;\r\n}\r\n\r\n/**\r\n * RFC-0078: Gets consumption limits with hierarchical resolution\r\n * TIER 1: Device-level (highest priority)\r\n * TIER 2: Customer-level\r\n * TIER 3: Hardcoded defaults (fallback)\r\n *\r\n * @param {string} deviceId - Device entity ID\r\n * @param {string} deviceType - Device type\r\n * @param {Object} customerLimitsJSON - Pre-fetched customer JSON (TIER 2)\r\n * @param {string} telemetryType - Telemetry type (default: 'consumption')\r\n * @param {Object} ctxData - Optional ctx.data array\r\n * @returns {Promise<Object>} Consumption ranges with source indicator\r\n */\r\nasync function getConsumptionRangesHierarchical(\r\n  deviceId,\r\n  deviceType,\r\n  customerLimitsJSON,\r\n  telemetryType = 'consumption',\r\n  ctxData = null\r\n) {\r\n  // TIER 1: Try device-level JSON first\r\n  const deviceLimitsJSON = await getCachedPowerLimitsJSON(deviceId, 'DEVICE', ctxData);\r\n  if (\r\n    deviceLimitsJSON &&\r\n    deviceLimitsJSON.limitsByInstantaneoustPowerType &&\r\n    deviceLimitsJSON.limitsByInstantaneoustPowerType.length > 0\r\n  ) {\r\n    const deviceRanges = extractLimitsFromJSON(deviceLimitsJSON, deviceType, telemetryType);\r\n    if (deviceRanges) {\r\n      return { ...deviceRanges, source: 'device', tier: 1 };\r\n    }\r\n  }\r\n\r\n  // TIER 2: Try customer-level JSON\r\n  if (customerLimitsJSON) {\r\n    const customerRanges = extractLimitsFromJSON(customerLimitsJSON, deviceType, telemetryType);\r\n    if (customerRanges) {\r\n      return { ...customerRanges, source: 'customer', tier: 2 };\r\n    }\r\n  }\r\n\r\n  // TIER 3: Hardcoded defaults\r\n  //LogHelper.log(`[RFC-0078] Using HARDCODED defaults for ${deviceType} (TIER 3)`);\r\n  const defaultRanges = getDefaultRanges(deviceType);\r\n  return {\r\n    ...defaultRanges,\r\n    source: 'hardcoded',\r\n    tier: 3,\r\n    metadata: {\r\n      name: `Default${deviceType}`,\r\n      description: `System default for ${deviceType}`,\r\n      version: '0.0.0',\r\n      telemetryType: telemetryType,\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * RFC-0078: Alias for backward compatibility\r\n * @param {string} customerId - Customer ID\r\n * @returns {Promise<Object|null>} Customer power limits JSON\r\n */\r\nasync function getCachedConsumptionLimits(customerId) {\r\n  LogHelper.log(`[RFC-0078] getCachedConsumptionLimits called for customer ${customerId}`);\r\n  return getCachedPowerLimitsJSON(customerId, 'CUSTOMER');\r\n}\r\n\r\n// ============================================\r\n// END RFC-0078\r\n// ============================================\r\n\r\n/**\r\n * RFC-0072: Get customer name for a device\r\n * @param {Object} device - Device object with customerId and ingestionId\r\n * @returns {string} Customer name or fallback\r\n */\r\nfunction getCustomerNameForDevice(device) {\r\n  // Priority 1: Check if customerId exists and look it up\r\n  if (device.customerId && window.custumersSelected && Array.isArray(window.custumersSelected)) {\r\n    const shopping = window.custumersSelected.find((c) => c.value === device.customerId);\r\n    if (shopping) return shopping.name;\r\n  }\r\n\r\n  // Priority 2: Try to get from energyCache via ingestionId\r\n  if (device.ingestionId) {\r\n    const orchestrator = window.MyIOOrchestrator || window.parent?.MyIOOrchestrator;\r\n    if (orchestrator && typeof orchestrator.getEnergyCache === 'function') {\r\n      const energyCache = orchestrator.getEnergyCache();\r\n      const cached = energyCache.get(device.ingestionId);\r\n      if (cached && cached.customerName) {\r\n        return cached.customerName;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Priority 3: Fallback to customerId substring\r\n  if (device.customerId) {\r\n    return `Shopping ${device.customerId.substring(0, 8)}...`;\r\n  }\r\n\r\n  return 'N/A';\r\n}\r\n\r\n/**\r\n * Update equipment statistics header\r\n * NOTE: This function expects DOM elements from EQUIPMENTS widget\r\n * @param {Array} devices - Array of device objects with consumption data\r\n * @param {Map} energyCache - Energy cache from MAIN orchestrator (optional)\r\n * @param {Array} ctxData - The ctx.data array from widget context\r\n */\r\nfunction updateEquipmentStats(devices, energyCache = null, ctxData = null) {\r\n  const connectivityEl = document.getElementById('equipStatsConnectivity');\r\n  const totalEl = document.getElementById('equipStatsTotal');\r\n  const consumptionEl = document.getElementById('equipStatsConsumption');\r\n  const zeroEl = document.getElementById('equipStatsZero');\r\n\r\n  if (!connectivityEl || !totalEl || !consumptionEl || !zeroEl) {\r\n    LogHelper.warn('[MAIN] Stats header elements not found');\r\n    return;\r\n  }\r\n\r\n  // Calculate connectivity (online vs total) from ctx.data\r\n  const deviceMap = new Map();\r\n\r\n  if (ctxData && Array.isArray(ctxData)) {\r\n    ctxData.forEach((data) => {\r\n      const entityId = data.datasource?.entityId;\r\n      const dataKeyName = data.dataKey?.name;\r\n\r\n      if (!entityId) return;\r\n\r\n      if (!deviceMap.has(entityId)) {\r\n        deviceMap.set(entityId, { hasConnectionStatus: false, isOnline: false });\r\n      }\r\n\r\n      if (dataKeyName === 'connectionStatus') {\r\n        const status = String(data.data?.[0]?.[1] || '').toLowerCase();\r\n        deviceMap.get(entityId).hasConnectionStatus = true;\r\n        deviceMap.get(entityId).isOnline = status === 'online';\r\n      }\r\n    });\r\n  }\r\n\r\n  // Count online devices\r\n  let onlineCount = 0;\r\n  let totalWithStatus = 0;\r\n\r\n  devices.forEach((device) => {\r\n    const deviceData = deviceMap.get(device.entityId);\r\n    if (deviceData && deviceData.hasConnectionStatus) {\r\n      totalWithStatus++;\r\n      if (deviceData.isOnline) {\r\n        onlineCount++;\r\n      }\r\n    }\r\n  });\r\n\r\n  // Calculate consumption from FILTERED devices array\r\n  let totalConsumption = 0;\r\n  devices.forEach((device) => {\r\n    const ingestionId = device.ingestionId;\r\n\r\n    let consumption = 0;\r\n    if (ingestionId && energyCache) {\r\n      const cached = energyCache.get(ingestionId);\r\n      if (cached) {\r\n        consumption = Number(cached.total_value) || 0;\r\n      }\r\n    }\r\n\r\n    if (consumption === 0) {\r\n      consumption = Number(device.val) || Number(device.lastValue) || 0;\r\n    }\r\n\r\n    totalConsumption += consumption;\r\n  });\r\n\r\n  LogHelper.log(\r\n    '[MAIN] Consumption calculated from',\r\n    devices.length,\r\n    'filtered devices:',\r\n    totalConsumption,\r\n    'kWh'\r\n  );\r\n\r\n  // Calculate zero consumption count\r\n  let zeroConsumptionCount = 0;\r\n  devices.forEach((device) => {\r\n    const consumption = Number(device.val) || Number(device.lastValue) || 0;\r\n    if (consumption === 0) {\r\n      zeroConsumptionCount++;\r\n    }\r\n  });\r\n\r\n  // Calculate connectivity percentage\r\n  const connectivityPercentage =\r\n    totalWithStatus > 0 ? ((onlineCount / totalWithStatus) * 100).toFixed(1) : '0.0';\r\n\r\n  // Update UI\r\n  connectivityEl.textContent = `${onlineCount}/${totalWithStatus} (${connectivityPercentage}%)`;\r\n  totalEl.textContent = devices.length.toString();\r\n  consumptionEl.textContent = MyIOLibrary.formatEnergy(totalConsumption);\r\n  zeroEl.textContent = zeroConsumptionCount.toString();\r\n\r\n  LogHelper.log('[MAIN] Stats updated:', {\r\n    connectivity: `${onlineCount}/${totalWithStatus} (${connectivityPercentage}%)`,\r\n    total: devices.length,\r\n    consumptionFromOrchestrator: totalConsumption,\r\n    zeroCount: zeroConsumptionCount,\r\n  });\r\n}\r\n\r\n// ============================================\r\n// RFC-0093: CENTRALIZED HEADER DEVICES GRID\r\n// Reusable header component for EQUIPMENTS, STORES, WATER, TEMPERATURE widgets\r\n// ============================================\r\n\r\n/**\r\n * RFC-0093: Centralized CSS for header and filter modal\r\n * Injected once into document head\r\n */\r\nconst HEADER_AND_MODAL_CSS = `\r\n/* ====== RFC-0093: CENTRALIZED HEADER STYLES ====== */\r\n.equip-stats-header {\r\n  display: flex !important;\r\n  flex-direction: row !important;\r\n  flex-wrap: nowrap !important;\r\n  gap: 16px;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);\r\n  border: 1px solid #e2e8f0;\r\n  border-radius: 12px;\r\n  padding: 10px 16px;\r\n  margin-bottom: 16px;\r\n  border-bottom: 3px solid #cbd5e1;\r\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);\r\n  width: 100%;\r\n}\r\n\r\n.equip-stats-header .stat-item {\r\n  display: flex !important;\r\n  flex-direction: column !important;\r\n  gap: 2px;\r\n  flex: 1;\r\n  min-width: 0;\r\n  text-align: center;\r\n}\r\n\r\n.equip-stats-header .stat-item.highlight {\r\n  background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);\r\n  border-radius: 8px;\r\n  padding: 6px 12px;\r\n  border: 1px solid #93c5fd;\r\n}\r\n\r\n.equip-stats-header .stat-label {\r\n  font-size: 12px;\r\n  color: #6b7a90;\r\n  font-weight: 500;\r\n  text-transform: uppercase;\r\n  letter-spacing: 0.5px;\r\n}\r\n\r\n.equip-stats-header .stat-value {\r\n  font-size: 16px;\r\n  color: #1c2743;\r\n  font-weight: 700;\r\n}\r\n\r\n.equip-stats-header .stat-item.highlight .stat-value {\r\n  color: #1d4ed8;\r\n  font-size: 20px;\r\n}\r\n\r\n/* ====== FILTER ACTIONS ====== */\r\n.equip-stats-header .filter-actions {\r\n  display: flex;\r\n  gap: 8px;\r\n  align-items: center;\r\n  margin-left: auto;\r\n}\r\n\r\n.equip-stats-header .search-wrap {\r\n  position: relative;\r\n  width: 0;\r\n  overflow: hidden;\r\n  transition: width 0.3s ease;\r\n}\r\n\r\n.equip-stats-header .search-wrap.active {\r\n  width: 200px;\r\n}\r\n\r\n.equip-stats-header .search-wrap input {\r\n  width: 100%;\r\n  padding: 6px 12px;\r\n  border: 1px solid #dde7f1;\r\n  border-radius: 8px;\r\n  font-size: 13px;\r\n  outline: none;\r\n}\r\n\r\n.equip-stats-header .search-wrap input:focus {\r\n  border-color: #1f6fb5;\r\n  box-shadow: 0 0 0 2px rgba(31, 111, 181, 0.1);\r\n}\r\n\r\n.equip-stats-header .icon-btn {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  width: 36px;\r\n  height: 36px;\r\n  border: 1px solid #dde7f1;\r\n  background: #fff;\r\n  border-radius: 8px;\r\n  cursor: pointer;\r\n  transition: all 0.2s;\r\n}\r\n\r\n.equip-stats-header .icon-btn:hover {\r\n  background: #f8f9fa;\r\n  border-color: #1f6fb5;\r\n}\r\n\r\n.equip-stats-header .icon-btn svg {\r\n  fill: #1c2743;\r\n}\r\n\r\n/* ====== RFC-0090: CENTRALIZED FILTER MODAL STYLES ====== */\r\n.myio-filter-modal {\r\n  position: fixed;\r\n  inset: 0;\r\n  background: rgba(0, 0, 0, 0.6);\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  z-index: 999999;\r\n  backdrop-filter: blur(4px);\r\n  left: 0 !important;\r\n  top: 0 !important;\r\n  right: 0 !important;\r\n  bottom: 0 !important;\r\n  width: 100vw !important;\r\n  height: 100vh !important;\r\n  animation: myioFadeIn 0.2s ease-in;\r\n}\r\n\r\n.myio-filter-modal.hidden {\r\n  display: none;\r\n}\r\n\r\n.myio-filter-modal-card {\r\n  background: #fff;\r\n  border-radius: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  max-width: 100%;\r\n  max-height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  box-shadow: none;\r\n  overflow: hidden;\r\n}\r\n\r\n@media (min-width: 768px) {\r\n  .myio-filter-modal-card {\r\n    border-radius: 16px;\r\n    width: 90%;\r\n    max-width: 900px;\r\n    height: auto;\r\n    max-height: 90vh;\r\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\r\n  }\r\n}\r\n\r\n.myio-filter-modal-header {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  padding: 16px 20px;\r\n  border-bottom: 1px solid #dde7f1;\r\n}\r\n\r\n.myio-filter-modal-header h3 {\r\n  margin: 0;\r\n  font-size: 16px;\r\n  font-weight: 700;\r\n  color: #1c2743;\r\n}\r\n\r\n.myio-filter-modal-body {\r\n  flex: 1;\r\n  overflow-y: auto;\r\n  padding: 20px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 20px;\r\n}\r\n\r\n.myio-filter-modal-footer {\r\n  display: flex;\r\n  gap: 12px;\r\n  justify-content: flex-end;\r\n  padding: 16px 20px;\r\n  border-top: 1px solid #dde7f1;\r\n}\r\n\r\n/* Filter Blocks */\r\n.myio-filter-modal .filter-block {\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 12px;\r\n}\r\n\r\n.myio-filter-modal .block-label {\r\n  font-size: 14px;\r\n  font-weight: 600;\r\n  color: #1c2743;\r\n}\r\n\r\n.myio-filter-modal .filter-tabs {\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  gap: 8px;\r\n  margin-bottom: 16px;\r\n}\r\n\r\n.myio-filter-modal .filter-tab {\r\n  display: inline-flex;\r\n  align-items: center;\r\n  gap: 4px;\r\n  padding: 8px 12px;\r\n  background: #fff;\r\n  border: 1px solid #dde7f1;\r\n  border-radius: 8px;\r\n  font-size: 12px;\r\n  font-weight: 600;\r\n  letter-spacing: 0.3px;\r\n  color: #6b7a90;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n  white-space: nowrap;\r\n}\r\n\r\n.myio-filter-modal .filter-tab:hover {\r\n  background: #f8f9fa;\r\n  border-color: #1f6fb5;\r\n  color: #1f6fb5;\r\n}\r\n\r\n.myio-filter-modal .filter-tab.active {\r\n  background: rgba(31, 111, 181, 0.1);\r\n  border-color: #1f6fb5;\r\n  color: #1f6fb5;\r\n  font-weight: 700;\r\n  box-shadow: 0 2px 6px rgba(31, 111, 181, 0.15);\r\n}\r\n\r\n.myio-filter-modal .filter-search {\r\n  position: relative;\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n  border: 1px solid #dde7f1;\r\n  border-radius: 8px;\r\n  padding: 8px 12px;\r\n}\r\n\r\n.myio-filter-modal .filter-search svg {\r\n  width: 18px;\r\n  height: 18px;\r\n  fill: #6b7a90;\r\n}\r\n\r\n.myio-filter-modal .filter-search input {\r\n  flex: 1;\r\n  border: none;\r\n  outline: none;\r\n  font-size: 13px;\r\n}\r\n\r\n.myio-filter-modal .filter-search .clear-x {\r\n  border: none;\r\n  background: transparent;\r\n  cursor: pointer;\r\n  padding: 0;\r\n  display: flex;\r\n  align-items: center;\r\n  opacity: 0.5;\r\n  transition: opacity 0.2s;\r\n}\r\n\r\n.myio-filter-modal .filter-search .clear-x:hover {\r\n  opacity: 1;\r\n}\r\n\r\n/* Checklist */\r\n.myio-filter-modal .checklist {\r\n  max-height: 300px;\r\n  overflow-y: auto;\r\n  border: 1px solid #dde7f1;\r\n  border-radius: 8px;\r\n  padding: 8px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 4px;\r\n}\r\n\r\n.myio-filter-modal .check-item {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n  padding: 8px;\r\n  border-radius: 6px;\r\n  cursor: pointer;\r\n  transition: background 0.2s;\r\n}\r\n\r\n.myio-filter-modal .check-item:hover {\r\n  background: #f8f9fa;\r\n}\r\n\r\n.myio-filter-modal .check-item input[type=\"checkbox\"] {\r\n  width: 18px;\r\n  height: 18px;\r\n  cursor: pointer;\r\n}\r\n\r\n.myio-filter-modal .check-item label,\r\n.myio-filter-modal .check-item span {\r\n  flex: 1;\r\n  cursor: pointer;\r\n  font-size: 13px;\r\n  color: #1c2743;\r\n}\r\n\r\n/* Radio Grid */\r\n.myio-filter-modal .radio-grid {\r\n  display: grid;\r\n  grid-template-columns: repeat(2, 1fr);\r\n  gap: 8px;\r\n}\r\n\r\n.myio-filter-modal .radio-grid label {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n  padding: 8px;\r\n  border: 1px solid #dde7f1;\r\n  border-radius: 8px;\r\n  cursor: pointer;\r\n  transition: all 0.2s;\r\n  font-size: 13px;\r\n}\r\n\r\n.myio-filter-modal .radio-grid label:hover {\r\n  background: #f8f9fa;\r\n  border-color: #1f6fb5;\r\n}\r\n\r\n.myio-filter-modal .radio-grid input[type=\"radio\"] {\r\n  width: 16px;\r\n  height: 16px;\r\n  cursor: pointer;\r\n}\r\n\r\n.myio-filter-modal .muted {\r\n  font-size: 12px;\r\n  color: #6b7a90;\r\n  margin: 0;\r\n}\r\n\r\n/* Buttons */\r\n.myio-filter-modal .btn {\r\n  padding: 10px 20px;\r\n  border: 1px solid #dde7f1;\r\n  background: #fff;\r\n  border-radius: 8px;\r\n  font-size: 14px;\r\n  font-weight: 600;\r\n  cursor: pointer;\r\n  transition: all 0.2s;\r\n}\r\n\r\n.myio-filter-modal .btn:hover {\r\n  background: #f8f9fa;\r\n}\r\n\r\n.myio-filter-modal .btn.primary {\r\n  background: #1f6fb5;\r\n  color: #fff;\r\n  border-color: #1f6fb5;\r\n}\r\n\r\n.myio-filter-modal .btn.primary:hover {\r\n  background: #1a5a8f;\r\n  border-color: #1a5a8f;\r\n}\r\n\r\n.myio-filter-modal .icon-btn {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  width: 36px;\r\n  height: 36px;\r\n  border: 1px solid #dde7f1;\r\n  background: #fff;\r\n  border-radius: 8px;\r\n  cursor: pointer;\r\n  transition: all 0.2s;\r\n}\r\n\r\n.myio-filter-modal .icon-btn:hover {\r\n  background: #f8f9fa;\r\n  border-color: #1f6fb5;\r\n}\r\n\r\n.myio-filter-modal .icon-btn svg {\r\n  fill: #1c2743;\r\n}\r\n\r\n@keyframes myioFadeIn {\r\n  from { opacity: 0; }\r\n  to { opacity: 1; }\r\n}\r\n\r\n/* Prevent body scroll when modal is open */\r\nbody.filter-modal-open {\r\n  overflow: hidden !important;\r\n}\r\n`;\r\n\r\nlet headerAndModalCssInjected = false;\r\n\r\n// RFC: Accumulator for water widget consumption totals\r\n// The HEADER should show the sum of actual widgets (WATER_COMMON_AREA + WATER_STORES),\r\n// NOT all devices from the API cache (which may include devices not in any widget)\r\nconst waterWidgetConsumption = {\r\n  waterCommonArea: 0,\r\n  waterStores: 0,\r\n};\r\n\r\n/**\r\n * Get total water consumption from widgets (not from API cache)\r\n * @returns {number} Total water consumption from WATER_COMMON_AREA + WATER_STORES\r\n */\r\nfunction getTotalWaterConsumptionFromWidgets() {\r\n  return waterWidgetConsumption.waterCommonArea + waterWidgetConsumption.waterStores;\r\n}\r\n\r\n// Expose globally for HEADER to use\r\nwindow.MyIOUtils = window.MyIOUtils || {};\r\nwindow.MyIOUtils.getTotalWaterConsumptionFromWidgets = getTotalWaterConsumptionFromWidgets;\r\n\r\n/**\r\n * Inject centralized CSS for header and modal (once)\r\n */\r\nfunction injectHeaderAndModalCSS() {\r\n  if (headerAndModalCssInjected) return;\r\n\r\n  const styleEl = document.createElement('style');\r\n  styleEl.id = 'myio-header-modal-css';\r\n  styleEl.textContent = HEADER_AND_MODAL_CSS;\r\n  document.head.appendChild(styleEl);\r\n\r\n  headerAndModalCssInjected = true;\r\n  LogHelper.log('[MAIN] RFC-0093: Centralized header and modal CSS injected');\r\n}\r\n\r\n/**\r\n * Configuration for header labels per domain\r\n */\r\nconst HEADER_DOMAIN_CONFIG = {\r\n  energy: {\r\n    totalLabel: 'Total de Equipamentos',\r\n    consumptionLabel: 'Consumo Total',\r\n    zeroLabel: 'Sem Consumo',\r\n    formatValue: (val) => MyIOLibrary.formatEnergy(val),\r\n  },\r\n  stores: {\r\n    totalLabel: 'Total de Lojas',\r\n    consumptionLabel: 'Consumo Total',\r\n    zeroLabel: 'Sem Consumo',\r\n    formatValue: (val) => MyIOLibrary.formatEnergy(val),\r\n  },\r\n  water: {\r\n    totalLabel: 'Total de Hidr√¥metros',\r\n    consumptionLabel: 'Consumo Total',\r\n    zeroLabel: 'Sem Consumo',\r\n    formatValue: (val) => MyIOLibrary.formatWaterVolumeM3(val),\r\n  },\r\n  temperature: {\r\n    totalLabel: 'Total de Sensores',\r\n    consumptionLabel: 'M√©dia de Temperatura',\r\n    zeroLabel: 'Sem Leitura',\r\n    formatValue: (val) => MyIOLibrary.formatTemperature(val),\r\n  },\r\n};\r\n\r\n/**\r\n * Build and inject a centralized header for device grids\r\n * @param {Object} config - Configuration object\r\n * @param {HTMLElement|string} config.container - Container element or selector to inject header\r\n * @param {string} config.domain - Domain type: 'energy', 'stores', 'water', 'temperature'\r\n * @param {string} config.idPrefix - ID prefix for elements (e.g., 'equip', 'stores', 'water', 'temp')\r\n * @param {Object} [config.labels] - Optional custom labels override\r\n * @param {string} [config.labels.connectivity] - Custom connectivity label (default: 'Conectividade')\r\n * @param {string} [config.labels.total] - Custom total label\r\n * @param {string} [config.labels.consumption] - Custom consumption label\r\n * @param {string} [config.labels.zero] - Custom zero/no-data label\r\n * @param {boolean} [config.includeSearch=true] - Include search button\r\n * @param {boolean} [config.includeFilter=true] - Include filter button\r\n * @param {Function} [config.onSearchClick] - Callback for search button click\r\n * @param {Function} [config.onFilterClick] - Callback for filter button click\r\n * @returns {Object} Controller object with update methods\r\n */\r\nfunction buildHeaderDevicesGrid(config) {\r\n  // RFC-0093: Inject CSS once\r\n  injectHeaderAndModalCSS();\r\n\r\n  const {\r\n    container,\r\n    domain = 'energy',\r\n    idPrefix = 'devices',\r\n    labels = {},\r\n    includeSearch = true,\r\n    includeFilter = true,\r\n    onSearchClick,\r\n    onFilterClick,\r\n  } = config;\r\n\r\n  // Get container element\r\n  const containerEl = typeof container === 'string' ? document.querySelector(container) : container;\r\n  if (!containerEl) {\r\n    LogHelper.error('[MAIN] buildHeaderDevicesGrid: Container not found');\r\n    return null;\r\n  }\r\n\r\n  // Get domain config with fallback\r\n  const domainConfig = HEADER_DOMAIN_CONFIG[domain] || HEADER_DOMAIN_CONFIG.energy;\r\n\r\n  // Merge labels with domain defaults\r\n  const finalLabels = {\r\n    connectivity: labels.connectivity || 'Conectividade',\r\n    total: labels.total || domainConfig.totalLabel,\r\n    consumption: labels.consumption || domainConfig.consumptionLabel,\r\n    zero: labels.zero || domainConfig.zeroLabel,\r\n  };\r\n\r\n  // Generate unique IDs\r\n  const ids = {\r\n    header: `${idPrefix}StatsHeader`,\r\n    connectivity: `${idPrefix}StatsConnectivity`,\r\n    total: `${idPrefix}StatsTotal`,\r\n    consumption: `${idPrefix}StatsConsumption`,\r\n    zero: `${idPrefix}StatsZero`,\r\n    searchWrap: `${idPrefix}SearchWrap`,\r\n    searchInput: `${idPrefix}Search`,\r\n    btnSearch: `${idPrefix}BtnSearch`,\r\n    btnFilter: `${idPrefix}BtnFilter`,\r\n  };\r\n\r\n  // Build HTML\r\n  const searchButtonHTML = includeSearch\r\n    ? `\r\n    <button class=\"icon-btn\" id=\"${ids.btnSearch}\" title=\"Buscar\" aria-label=\"Buscar\">\r\n      <svg viewBox=\"0 0 24 24\" width=\"18\" height=\"18\" aria-hidden=\"true\">\r\n        <path d=\"M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79L20 21.5 21.5 20l-6-6zM4 9.5C4 6.46 6.46 4 9.5 4S15 6.46 15 9.5 12.54 15 9.5 15 4 12.54 4 9.5z\"/>\r\n      </svg>\r\n    </button>`\r\n    : '';\r\n\r\n  const filterButtonHTML = includeFilter\r\n    ? `\r\n    <button class=\"icon-btn\" id=\"${ids.btnFilter}\" title=\"Filtros\" aria-label=\"Filtros\">\r\n      <svg viewBox=\"0 0 24 24\" width=\"18\" height=\"18\" aria-hidden=\"true\">\r\n        <path d=\"M3 4h18l-7 8v6l-4 2v-8L3 4z\"/>\r\n      </svg>\r\n    </button>`\r\n    : '';\r\n\r\n  const headerHTML = `\r\n    <div class=\"equip-stats-header\" id=\"${ids.header}\" style=\"display: flex !important; flex-direction: row !important;\">\r\n      <div class=\"stat-item\">\r\n        <span class=\"stat-label\">${finalLabels.connectivity}</span>\r\n        <span class=\"stat-value\" id=\"${ids.connectivity}\">-</span>\r\n      </div>\r\n      <div class=\"stat-item\">\r\n        <span class=\"stat-label\">${finalLabels.total}</span>\r\n        <span class=\"stat-value\" id=\"${ids.total}\">-</span>\r\n      </div>\r\n      <div class=\"stat-item highlight\">\r\n        <span class=\"stat-label\">${finalLabels.consumption}</span>\r\n        <span class=\"stat-value\" id=\"${ids.consumption}\">-</span>\r\n      </div>\r\n      <div class=\"stat-item\">\r\n        <span class=\"stat-label\">${finalLabels.zero}</span>\r\n        <span class=\"stat-value\" id=\"${ids.zero}\">-</span>\r\n      </div>\r\n      <div class=\"filter-actions\">\r\n        <div class=\"search-wrap\" id=\"${ids.searchWrap}\">\r\n          <input type=\"text\" id=\"${ids.searchInput}\" placeholder=\"Buscar...\" autocomplete=\"off\">\r\n        </div>\r\n        ${searchButtonHTML}\r\n        ${filterButtonHTML}\r\n      </div>\r\n    </div>\r\n  `;\r\n\r\n  // Inject HTML\r\n  containerEl.insertAdjacentHTML('afterbegin', headerHTML);\r\n\r\n  // Setup event listeners\r\n  if (includeSearch && onSearchClick) {\r\n    const btnSearch = document.getElementById(ids.btnSearch);\r\n    const searchWrap = document.getElementById(ids.searchWrap);\r\n    if (btnSearch) {\r\n      btnSearch.addEventListener('click', () => {\r\n        if (searchWrap) {\r\n          searchWrap.classList.toggle('active');\r\n          if (searchWrap.classList.contains('active')) {\r\n            const input = document.getElementById(ids.searchInput);\r\n            if (input) input.focus();\r\n          }\r\n        }\r\n        onSearchClick();\r\n      });\r\n    }\r\n  }\r\n\r\n  if (includeFilter && onFilterClick) {\r\n    const btnFilter = document.getElementById(ids.btnFilter);\r\n    if (btnFilter) {\r\n      btnFilter.addEventListener('click', onFilterClick);\r\n    }\r\n  }\r\n\r\n  // Return controller object\r\n  const controller = {\r\n    ids,\r\n    domain,\r\n    domainConfig,\r\n\r\n    /**\r\n     * Update header statistics\r\n     * @param {Object} stats - Statistics object\r\n     * @param {number} stats.online - Number of online devices\r\n     * @param {number} stats.total - Total number of devices\r\n     * @param {number} stats.consumption - Total consumption value\r\n     * @param {number} stats.zeroCount - Number of devices with zero consumption\r\n     */\r\n    updateStats(stats) {\r\n      const { online = 0, total = 0, consumption = 0, zeroCount = 0 } = stats;\r\n\r\n      const connectivityEl = document.getElementById(ids.connectivity);\r\n      const totalEl = document.getElementById(ids.total);\r\n      const consumptionEl = document.getElementById(ids.consumption);\r\n      const zeroEl = document.getElementById(ids.zero);\r\n\r\n      if (!connectivityEl || !totalEl || !consumptionEl || !zeroEl) {\r\n        LogHelper.warn(`[MAIN] buildHeaderDevicesGrid: Stats elements not found for ${idPrefix}`);\r\n        return;\r\n      }\r\n\r\n      const percentage = total > 0 ? ((online / total) * 100).toFixed(1) : '0.0';\r\n\r\n      connectivityEl.textContent = `${online}/${total} (${percentage}%)`;\r\n      totalEl.textContent = total.toString();\r\n      consumptionEl.textContent = domainConfig.formatValue(consumption);\r\n      zeroEl.textContent = zeroCount.toString();\r\n\r\n      // RFC: Update water widget consumption accumulator for HEADER\r\n      if (domain === 'water' && idPrefix in waterWidgetConsumption) {\r\n        waterWidgetConsumption[idPrefix] = consumption;\r\n        LogHelper.log(\r\n          `[MAIN] Water widget consumption updated: ${idPrefix} = ${consumption}, total = ${getTotalWaterConsumptionFromWidgets()}`\r\n        );\r\n      }\r\n\r\n      LogHelper.log(`[MAIN] Header stats updated for ${idPrefix}:`, stats);\r\n    },\r\n\r\n    /**\r\n     * Calculate and update stats from devices array\r\n     * @param {Array} devices - Array of device objects\r\n     * @param {Object} [options] - Options\r\n     * @param {Map} [options.cache] - Energy/consumption cache\r\n     * @param {Array} [options.ctxData] - ThingsBoard ctx.data for connection status\r\n     */\r\n    updateFromDevices(devices, options = {}) {\r\n      const { cache, ctxData } = options;\r\n\r\n      // Calculate online count from ctxData if available\r\n      let online = 0;\r\n      let totalWithStatus = 0;\r\n\r\n      if (ctxData && Array.isArray(ctxData)) {\r\n        const deviceMap = new Map();\r\n        ctxData.forEach((data) => {\r\n          const entityId = data.datasource?.entityId;\r\n          const dataKeyName = data.dataKey?.name;\r\n          if (!entityId) return;\r\n          if (!deviceMap.has(entityId)) {\r\n            deviceMap.set(entityId, { hasConnectionStatus: false, isOnline: false });\r\n          }\r\n          if (dataKeyName === 'connectionStatus') {\r\n            const status = String(data.data?.[0]?.[1] || '').toLowerCase();\r\n            deviceMap.get(entityId).hasConnectionStatus = true;\r\n            deviceMap.get(entityId).isOnline = status === 'online';\r\n          }\r\n        });\r\n\r\n        devices.forEach((device) => {\r\n          const deviceData = deviceMap.get(device.entityId);\r\n          if (deviceData && deviceData.hasConnectionStatus) {\r\n            totalWithStatus++;\r\n            if (deviceData.isOnline) online++;\r\n          }\r\n        });\r\n      } else {\r\n        // Fallback: count based on device status or consumption\r\n        devices.forEach((device) => {\r\n          const status = (device.connectionStatus || device.deviceStatus || '').toLowerCase();\r\n          if (status === 'online' || status === 'power_on' || status === 'normal') {\r\n            online++;\r\n          }\r\n        });\r\n        totalWithStatus = devices.length;\r\n      }\r\n\r\n      // Calculate consumption\r\n      let totalConsumption = 0;\r\n      let zeroCount = 0;\r\n\r\n      devices.forEach((device) => {\r\n        let consumption = 0;\r\n\r\n        // Try cache first\r\n        if (cache && device.ingestionId) {\r\n          const cached = cache.get(device.ingestionId);\r\n          if (cached) {\r\n            consumption = Number(cached.total_value) || 0;\r\n          }\r\n        }\r\n\r\n        // Fallback to device value\r\n        if (consumption === 0) {\r\n          consumption = Number(device.val) || Number(device.value) || Number(device.lastValue) || 0;\r\n        }\r\n\r\n        totalConsumption += consumption;\r\n        if (consumption === 0) zeroCount++;\r\n      });\r\n\r\n      this.updateStats({\r\n        online,\r\n        total: devices.length,\r\n        consumption: totalConsumption,\r\n        zeroCount,\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Get search input element\r\n     * @returns {HTMLInputElement|null}\r\n     */\r\n    getSearchInput() {\r\n      return document.getElementById(ids.searchInput);\r\n    },\r\n\r\n    /**\r\n     * Toggle search wrap visibility\r\n     * @param {boolean} [active] - Force state\r\n     */\r\n    toggleSearch(active) {\r\n      const searchWrap = document.getElementById(ids.searchWrap);\r\n      if (searchWrap) {\r\n        if (active !== undefined) {\r\n          searchWrap.classList.toggle('active', active);\r\n        } else {\r\n          searchWrap.classList.toggle('active');\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Destroy the header (remove from DOM)\r\n     */\r\n    destroy() {\r\n      const header = document.getElementById(ids.header);\r\n      if (header) header.remove();\r\n    },\r\n  };\r\n\r\n  LogHelper.log(`[MAIN] Header built for domain '${domain}' with prefix '${idPrefix}'`);\r\n\r\n  return controller;\r\n}\r\n\r\n/**\r\n * Fetch customer server-scope attributes from ThingsBoard\r\n * @param {string} customerTbId - ThingsBoard customer ID\r\n * @returns {Promise<Object>} Map of attribute key -> value\r\n */\r\nasync function fetchCustomerServerScopeAttrs(customerTbId) {\r\n  if (!customerTbId) return {};\r\n  const tbToken = localStorage.getItem('jwt_token');\r\n  if (!tbToken) throw new Error('JWT do ThingsBoard n√£o encontrado (localStorage.jwt_token).');\r\n\r\n  const url = `/api/plugins/telemetry/CUSTOMER/${customerTbId}/values/attributes/SERVER_SCOPE`;\r\n  const res = await fetch(url, {\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      'X-Authorization': `Bearer ${tbToken}`,\r\n    },\r\n  });\r\n  if (!res.ok) {\r\n    LogHelper.warn(`[MAIN] [customer attrs] HTTP ${res.status}`);\r\n    return {};\r\n  }\r\n  const payload = await res.json();\r\n\r\n  const map = {};\r\n  if (Array.isArray(payload)) {\r\n    for (const it of payload) map[it.key] = it.value;\r\n  } else if (payload && typeof payload === 'object') {\r\n    for (const k of Object.keys(payload)) {\r\n      const v = payload[k];\r\n      if (Array.isArray(v) && v.length) map[k] = v[0]?.value ?? v[0];\r\n    }\r\n  }\r\n  return map;\r\n}\r\n\r\n// ============================================\r\n// RFC-0090: SHARED FILTER MODAL FACTORY\r\n// Creates reusable filter modal for EQUIPMENTS and STORES widgets\r\n// ============================================\r\n\r\n/**\r\n * Factory function to create a filter modal with customizable filter tabs\r\n * @param {Object} config - Modal configuration\r\n * @param {string} config.widgetName - Widget identifier (e.g., 'EQUIPMENTS', 'STORES')\r\n * @param {string} config.containerId - Global container ID (e.g., 'equipmentsFilterModalGlobal')\r\n * @param {string} config.modalClass - CSS class for modal (e.g., 'equip-modal', 'shops-modal')\r\n * @param {string} config.primaryColor - Primary theme color (e.g., '#2563eb', '#3E1A7D')\r\n * @param {string} config.itemIdAttr - Data attribute for item ID (e.g., 'data-device-id', 'data-entity')\r\n * @param {Array} config.filterTabs - Array of filter tab configurations\r\n * @param {Function} config.getItemId - Function to get item ID from item object\r\n * @param {Function} config.getItemLabel - Function to get item label from item object\r\n * @param {Function} config.getItemValue - Function to get item consumption value\r\n * @param {Function} config.getItemSubLabel - Function to get secondary label (shopping name)\r\n * @param {Function} config.formatValue - Function to format consumption value\r\n * @param {Function} config.onApply - Callback when filters are applied\r\n * @param {Function} config.onReset - Callback when filters are reset\r\n * @param {Function} config.onClose - Callback when modal is closed\r\n * @returns {Object} Modal controller with open, close, and destroy methods\r\n */\r\nfunction createFilterModal(config) {\r\n  // RFC-0093: Inject centralized header and modal CSS\r\n  injectHeaderAndModalCSS();\r\n\r\n  const {\r\n    widgetName = 'WIDGET',\r\n    containerId,\r\n    modalClass = 'filter-modal',\r\n    primaryColor = '#2563eb',\r\n    itemIdAttr = 'data-item-id',\r\n    filterTabs = [],\r\n    getItemId = (item) => item.id,\r\n    getItemLabel = (item) => item.label || item.name,\r\n    getItemValue = (item) => Number(item.value) || 0,\r\n    getItemSubLabel = () => '',\r\n    formatValue = (val) => val.toFixed(2),\r\n    onApply = () => {},\r\n    onReset = () => {},\r\n    onClose = () => {},\r\n  } = config;\r\n\r\n  let globalContainer = null;\r\n  let escHandler = null;\r\n\r\n  // Generate CSS styles with customizable primary color\r\n  function generateStyles() {\r\n    return `\r\n      /* RFC-0090: Shared Filter Modal Styles for ${widgetName} */\r\n      #${containerId} .${modalClass} {\r\n        position: fixed;\r\n        inset: 0;\r\n        background: rgba(0, 0, 0, 0.6);\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: center;\r\n        z-index: 999999;\r\n        backdrop-filter: blur(4px);\r\n        animation: filterModalFadeIn 0.2s ease-in;\r\n      }\r\n\r\n      #${containerId} .${modalClass}.hidden {\r\n        display: none;\r\n      }\r\n\r\n      #${containerId} .${modalClass}-card {\r\n        background: #fff;\r\n        border-radius: 0;\r\n        width: 100%;\r\n        height: 100%;\r\n        max-width: 100%;\r\n        max-height: 100%;\r\n        display: flex;\r\n        flex-direction: column;\r\n        box-shadow: none;\r\n        overflow: hidden;\r\n      }\r\n\r\n      @media (min-width: 768px) {\r\n        #${containerId} .${modalClass}-card {\r\n          border-radius: 16px;\r\n          width: 90%;\r\n          max-width: 1000px;\r\n          height: auto;\r\n          max-height: 90vh;\r\n          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\r\n        }\r\n      }\r\n\r\n      #${containerId} .${modalClass}-header {\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: space-between;\r\n        padding: 16px 20px;\r\n        border-bottom: 1px solid #DDE7F1;\r\n      }\r\n\r\n      #${containerId} .${modalClass}-header h3 {\r\n        margin: 0;\r\n        font-size: 18px;\r\n        font-weight: 700;\r\n        color: #1C2743;\r\n      }\r\n\r\n      #${containerId} .${modalClass}-body {\r\n        flex: 1;\r\n        overflow-y: auto;\r\n        padding: 20px;\r\n        display: flex;\r\n        flex-direction: column;\r\n        gap: 20px;\r\n      }\r\n\r\n      #${containerId} .${modalClass}-footer {\r\n        display: flex;\r\n        gap: 12px;\r\n        justify-content: flex-end;\r\n        padding: 16px 20px;\r\n        border-top: 1px solid #DDE7F1;\r\n      }\r\n\r\n      #${containerId} .filter-block {\r\n        display: flex;\r\n        flex-direction: column;\r\n        gap: 12px;\r\n      }\r\n\r\n      #${containerId} .block-label {\r\n        font-size: 14px;\r\n        font-weight: 600;\r\n        color: #1C2743;\r\n      }\r\n\r\n      #${containerId} .filter-tabs {\r\n        display: flex;\r\n        gap: 6px;\r\n        flex-wrap: wrap;\r\n        margin-bottom: 12px;\r\n        padding-bottom: 10px;\r\n        border-bottom: 2px solid #E6EEF5;\r\n      }\r\n\r\n      #${containerId} .filter-tab {\r\n        border: 1px solid #DDE7F1;\r\n        background: #fff;\r\n        padding: 6px 10px;\r\n        border-radius: 6px;\r\n        font-size: 10px;\r\n        font-weight: 700;\r\n        letter-spacing: 0.2px;\r\n        cursor: pointer;\r\n        transition: all 0.2s;\r\n        color: #6b7a90;\r\n        white-space: nowrap;\r\n      }\r\n\r\n      #${containerId} .filter-tab:hover {\r\n        transform: translateY(-1px);\r\n        box-shadow: 0 2px 6px rgba(0,0,0,0.1);\r\n      }\r\n\r\n      /* RFC-0095: Color-coded filter tabs */\r\n      #${containerId} .filter-tab[data-filter=\"all\"] {\r\n        border-color: #9ca3af;\r\n        color: #4b5563;\r\n      }\r\n      #${containerId} .filter-tab[data-filter=\"all\"]:hover,\r\n      #${containerId} .filter-tab[data-filter=\"all\"].active {\r\n        background: #6b7280;\r\n        border-color: #6b7280;\r\n        color: #fff;\r\n      }\r\n\r\n      #${containerId} .filter-tab[data-filter=\"online\"] {\r\n        border-color: #3b82f6;\r\n        color: #2563eb;\r\n      }\r\n      #${containerId} .filter-tab[data-filter=\"online\"]:hover,\r\n      #${containerId} .filter-tab[data-filter=\"online\"].active {\r\n        background: #3b82f6;\r\n        border-color: #3b82f6;\r\n        color: #fff;\r\n      }\r\n\r\n      #${containerId} .filter-tab[data-filter=\"offline\"] {\r\n        border-color: #ef4444;\r\n        color: #dc2626;\r\n      }\r\n      #${containerId} .filter-tab[data-filter=\"offline\"]:hover,\r\n      #${containerId} .filter-tab[data-filter=\"offline\"].active {\r\n        background: #ef4444;\r\n        border-color: #ef4444;\r\n        color: #fff;\r\n      }\r\n\r\n      #${containerId} .filter-tab[data-filter=\"withConsumption\"] {\r\n        border-color: #22c55e;\r\n        color: #16a34a;\r\n      }\r\n      #${containerId} .filter-tab[data-filter=\"withConsumption\"]:hover,\r\n      #${containerId} .filter-tab[data-filter=\"withConsumption\"].active {\r\n        background: #22c55e;\r\n        border-color: #22c55e;\r\n        color: #fff;\r\n      }\r\n\r\n      #${containerId} .filter-tab[data-filter=\"noConsumption\"] {\r\n        border-color: #9ca3af;\r\n        color: #6b7280;\r\n      }\r\n      #${containerId} .filter-tab[data-filter=\"noConsumption\"]:hover,\r\n      #${containerId} .filter-tab[data-filter=\"noConsumption\"].active {\r\n        background: #9ca3af;\r\n        border-color: #9ca3af;\r\n        color: #fff;\r\n      }\r\n\r\n      #${containerId} .filter-tab span {\r\n        font-weight: 700;\r\n      }\r\n\r\n      #${containerId} .filter-search {\r\n        position: relative;\r\n        display: flex;\r\n        align-items: center;\r\n        margin-bottom: 8px;\r\n      }\r\n\r\n      #${containerId} .filter-search svg {\r\n        position: absolute;\r\n        left: 10px;\r\n        width: 14px;\r\n        height: 14px;\r\n        fill: #6b7a90;\r\n        pointer-events: none;\r\n      }\r\n\r\n      #${containerId} .filter-search input {\r\n        width: 100%;\r\n        padding: 8px 32px 8px 32px;\r\n        border: 1px solid #DDE7F1;\r\n        border-radius: 8px;\r\n        font-size: 12px;\r\n        outline: none;\r\n        box-sizing: border-box;\r\n      }\r\n\r\n      #${containerId} .filter-search input:focus {\r\n        border-color: ${primaryColor};\r\n        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);\r\n      }\r\n\r\n      #${containerId} .filter-search .clear-x {\r\n        position: absolute;\r\n        right: 6px;\r\n        top: 50%;\r\n        transform: translateY(-50%);\r\n        border: 0;\r\n        background: #f3f4f6;\r\n        cursor: pointer;\r\n        padding: 4px;\r\n        border-radius: 4px;\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: center;\r\n        transition: background 0.2s;\r\n      }\r\n\r\n      #${containerId} .filter-search .clear-x:hover {\r\n        background: #e5e7eb;\r\n      }\r\n\r\n      #${containerId} .filter-search .clear-x svg {\r\n        position: static;\r\n        width: 12px;\r\n        height: 12px;\r\n        fill: #6b7280;\r\n      }\r\n\r\n      /* RFC-0093: Inline actions (Select All / Clear) */\r\n      #${containerId} .inline-actions {\r\n        display: flex;\r\n        gap: 8px;\r\n        margin-top: 8px;\r\n      }\r\n\r\n      #${containerId} .tiny-btn {\r\n        padding: 6px 12px;\r\n        border: 1px solid #DDE7F1;\r\n        border-radius: 6px;\r\n        background: #fff;\r\n        font-size: 12px;\r\n        font-weight: 500;\r\n        color: #1C2743;\r\n        cursor: pointer;\r\n        transition: all 0.2s;\r\n      }\r\n\r\n      #${containerId} .tiny-btn:hover {\r\n        background: #f0f4f8;\r\n        border-color: ${primaryColor};\r\n        color: ${primaryColor};\r\n      }\r\n\r\n      #${containerId} .tiny-btn:active {\r\n        background: #e0e8f0;\r\n      }\r\n\r\n      #${containerId} .checklist {\r\n        min-height: 120px;\r\n        max-height: 340px;\r\n        overflow-y: auto;\r\n        border: 1px solid #DDE7F1;\r\n        border-radius: 8px;\r\n        padding: 4px;\r\n        display: flex;\r\n        flex-direction: column;\r\n        gap: 2px;\r\n      }\r\n\r\n      #${containerId} .check-item {\r\n        display: flex;\r\n        align-items: center;\r\n        gap: 6px;\r\n        padding: 5px 6px;\r\n        border-radius: 4px;\r\n        transition: background 0.2s;\r\n      }\r\n\r\n      #${containerId} .check-item:hover {\r\n        background: #f8f9fa;\r\n      }\r\n\r\n      #${containerId} .check-item input[type=\"checkbox\"] {\r\n        width: 14px;\r\n        height: 14px;\r\n        cursor: pointer;\r\n        flex-shrink: 0;\r\n      }\r\n\r\n      #${containerId} .check-item label {\r\n        flex: 1;\r\n        cursor: pointer;\r\n        font-size: 11px;\r\n        color: #1C2743;\r\n        line-height: 1.3;\r\n      }\r\n\r\n      #${containerId} .check-item .item-sublabel {\r\n        font-size: 9px;\r\n        color: #6b7a90;\r\n        margin-left: auto;\r\n        flex-shrink: 0;\r\n      }\r\n\r\n      #${containerId} .radio-grid {\r\n        display: grid;\r\n        grid-template-columns: repeat(3, 1fr);\r\n        gap: 6px;\r\n      }\r\n\r\n      #${containerId} .radio-grid label {\r\n        display: flex;\r\n        align-items: center;\r\n        gap: 6px;\r\n        padding: 6px 8px;\r\n        border: 1px solid #DDE7F1;\r\n        border-radius: 6px;\r\n        cursor: pointer;\r\n        transition: all 0.2s;\r\n        font-size: 11px;\r\n        color: #1C2743;\r\n      }\r\n\r\n      #${containerId} .radio-grid label:hover {\r\n        background: #f8f9fa;\r\n        border-color: ${primaryColor};\r\n      }\r\n\r\n      #${containerId} .radio-grid input[type=\"radio\"] {\r\n        width: 12px;\r\n        height: 12px;\r\n        cursor: pointer;\r\n        flex-shrink: 0;\r\n      }\r\n\r\n      #${containerId} .radio-grid input[type=\"radio\"]:checked + span,\r\n      #${containerId} .radio-grid label:has(input:checked) {\r\n        background: rgba(37, 99, 235, 0.08);\r\n        border-color: ${primaryColor};\r\n        color: ${primaryColor};\r\n        font-weight: 600;\r\n      }\r\n\r\n      #${containerId} .btn {\r\n        padding: 10px 16px;\r\n        border: 1px solid #DDE7F1;\r\n        border-radius: 10px;\r\n        font-size: 14px;\r\n        font-weight: 600;\r\n        cursor: pointer;\r\n        transition: all 0.2s;\r\n      }\r\n\r\n      #${containerId} .btn:hover {\r\n        background: #f8f9fa;\r\n      }\r\n\r\n      #${containerId} .btn.primary {\r\n        background: ${primaryColor};\r\n        color: #fff;\r\n        border-color: ${primaryColor};\r\n      }\r\n\r\n      #${containerId} .btn.primary:hover {\r\n        filter: brightness(0.9);\r\n      }\r\n\r\n      #${containerId} .icon-btn {\r\n        border: 0;\r\n        background: transparent;\r\n        cursor: pointer;\r\n        padding: 4px;\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: center;\r\n        border-radius: 6px;\r\n        transition: background 0.2s;\r\n      }\r\n\r\n      #${containerId} .icon-btn:hover {\r\n        background: #f0f0f0;\r\n      }\r\n\r\n      #${containerId} .icon-btn svg {\r\n        width: 18px;\r\n        height: 18px;\r\n        fill: #1C2743;\r\n      }\r\n\r\n      @keyframes filterModalFadeIn {\r\n        from { opacity: 0; }\r\n        to { opacity: 1; }\r\n      }\r\n\r\n      body.filter-modal-open {\r\n        overflow: hidden !important;\r\n      }\r\n    `;\r\n  }\r\n\r\n  // Generate filter tabs HTML\r\n  function generateFilterTabsHTML(counts) {\r\n    return filterTabs\r\n      .map(\r\n        (tab) => `\r\n        <button class=\"filter-tab${tab.id === 'all' ? ' active' : ''}\" data-filter=\"${tab.id}\">\r\n          ${tab.label} (<span id=\"count${tab.id.charAt(0).toUpperCase() + tab.id.slice(1)}\">${\r\n          counts[tab.id] || 0\r\n        }</span>)\r\n        </button>\r\n      `\r\n      )\r\n      .join('');\r\n  }\r\n\r\n  // Generate modal HTML\r\n  function generateModalHTML() {\r\n    return `\r\n      <div id=\"filterModal\" class=\"${modalClass} hidden\">\r\n        <div class=\"${modalClass}-card\">\r\n          <div class=\"${modalClass}-header\">\r\n            <h3>Filtrar e Ordenar</h3>\r\n            <button class=\"icon-btn\" id=\"closeFilter\">\r\n              <svg viewBox=\"0 0 24 24\"><path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"/></svg>\r\n            </button>\r\n          </div>\r\n          <div class=\"${modalClass}-body\">\r\n            <!-- Filter Tabs -->\r\n            <div class=\"filter-block\">\r\n              <div class=\"filter-tabs\" id=\"filterTabsContainer\"></div>\r\n            </div>\r\n\r\n            <!-- Search -->\r\n            <div class=\"filter-block\">\r\n              <div class=\"filter-search\">\r\n                <svg viewBox=\"0 0 24 24\"><path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\"/></svg>\r\n                <input type=\"text\" id=\"filterDeviceSearch\" placeholder=\"Buscar...\">\r\n                <button class=\"clear-x\" id=\"filterDeviceClear\">\r\n                  <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\"><path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" fill=\"#6b7a90\"/></svg>\r\n                </button>\r\n              </div>\r\n              <!-- RFC-0093: Select All / Clear Selection buttons -->\r\n              <div class=\"inline-actions\" style=\"margin-bottom: 8px;\">\r\n                <button class=\"tiny-btn\" id=\"selectAllItems\">Selecionar Todos</button>\r\n                <button class=\"tiny-btn\" id=\"clearAllItems\">Limpar Sele√ß√£o</button>\r\n              </div>\r\n              <div class=\"checklist\" id=\"deviceChecklist\"></div>\r\n            </div>\r\n\r\n            <!-- Sort Options -->\r\n            <div class=\"filter-block\">\r\n              <span class=\"block-label\">Ordenar por</span>\r\n              <div class=\"radio-grid\">\r\n                <label><input type=\"radio\" name=\"sortMode\" value=\"cons_desc\" checked> Maior consumo</label>\r\n                <label><input type=\"radio\" name=\"sortMode\" value=\"cons_asc\"> Menor consumo</label>\r\n                <label><input type=\"radio\" name=\"sortMode\" value=\"alpha_asc\"> Nome A ‚Üí Z</label>\r\n                <label><input type=\"radio\" name=\"sortMode\" value=\"alpha_desc\"> Nome Z ‚Üí A</label>\r\n                <label><input type=\"radio\" name=\"sortMode\" value=\"status_asc\"> Status A ‚Üí Z</label>\r\n                <label><input type=\"radio\" name=\"sortMode\" value=\"status_desc\"> Status Z ‚Üí A</label>\r\n                <label><input type=\"radio\" name=\"sortMode\" value=\"shopping_asc\"> Shopping A ‚Üí Z</label>\r\n                <label><input type=\"radio\" name=\"sortMode\" value=\"shopping_desc\"> Shopping Z ‚Üí A</label>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"${modalClass}-footer\">\r\n            <button class=\"btn\" id=\"resetFilters\">Fechar</button>\r\n            <button class=\"btn primary\" id=\"applyFilters\">Ordenar</button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    `;\r\n  }\r\n\r\n  // Setup event handlers\r\n  function setupHandlers(modal, items, _state) {\r\n    // Close button\r\n    const closeBtn = modal.querySelector('#closeFilter');\r\n    if (closeBtn) {\r\n      closeBtn.addEventListener('click', close);\r\n    }\r\n\r\n    // Backdrop click\r\n    modal.addEventListener('click', (e) => {\r\n      if (e.target === modal) {\r\n        close();\r\n      }\r\n    });\r\n\r\n    // Apply filters\r\n    const applyBtn = modal.querySelector('#applyFilters');\r\n    if (applyBtn) {\r\n      applyBtn.addEventListener('click', () => {\r\n        const checkboxes = modal.querySelectorAll(`#deviceChecklist input[type='checkbox']:checked`);\r\n        const selectedSet = new Set();\r\n        checkboxes.forEach((cb) => {\r\n          const itemId = cb.getAttribute(itemIdAttr);\r\n          if (itemId) selectedSet.add(itemId);\r\n        });\r\n\r\n        const sortRadio = modal.querySelector('input[name=\"sortMode\"]:checked');\r\n        const sortMode = sortRadio ? sortRadio.value : 'cons_desc';\r\n\r\n        LogHelper.log(`[${widgetName}] Filters applied:`, {\r\n          selectedCount: selectedSet.size,\r\n          totalItems: items.length,\r\n          sortMode,\r\n        });\r\n\r\n        onApply({\r\n          selectedIds: selectedSet.size === items.length ? null : selectedSet,\r\n          sortMode,\r\n        });\r\n\r\n        close();\r\n      });\r\n    }\r\n\r\n    // RFC-0095: Close button (renamed from Reset Filters)\r\n    const resetBtn = modal.querySelector('#resetFilters');\r\n    if (resetBtn) {\r\n      resetBtn.addEventListener('click', () => {\r\n        LogHelper.log(`[${widgetName}] Modal closed`);\r\n        close();\r\n      });\r\n    }\r\n\r\n    // RFC-0093: Select All button\r\n    const selectAllBtn = modal.querySelector('#selectAllItems');\r\n    if (selectAllBtn) {\r\n      selectAllBtn.addEventListener('click', () => {\r\n        const checkboxes = modal.querySelectorAll(`#deviceChecklist input[type='checkbox']`);\r\n        checkboxes.forEach((cb) => {\r\n          cb.checked = true;\r\n        });\r\n        LogHelper.log(`[${widgetName}] All items selected: ${checkboxes.length}`);\r\n      });\r\n    }\r\n\r\n    // RFC-0093: Clear Selection button\r\n    const clearAllBtn = modal.querySelector('#clearAllItems');\r\n    if (clearAllBtn) {\r\n      clearAllBtn.addEventListener('click', () => {\r\n        const checkboxes = modal.querySelectorAll(`#deviceChecklist input[type='checkbox']`);\r\n        checkboxes.forEach((cb) => {\r\n          cb.checked = false;\r\n        });\r\n        LogHelper.log(`[${widgetName}] All items cleared`);\r\n      });\r\n    }\r\n\r\n    // Filter tabs\r\n    const filterTabsEl = modal.querySelectorAll('.filter-tab');\r\n    filterTabsEl.forEach((tab) => {\r\n      tab.addEventListener('click', () => {\r\n        const filterType = tab.getAttribute('data-filter');\r\n\r\n        // Update active state\r\n        filterTabsEl.forEach((t) => t.classList.remove('active'));\r\n        tab.classList.add('active');\r\n\r\n        // Apply filter to checkboxes\r\n        const checkboxes = modal.querySelectorAll(`#deviceChecklist input[type='checkbox']`);\r\n        checkboxes.forEach((cb) => {\r\n          const itemId = cb.getAttribute(itemIdAttr);\r\n          const item = items.find((i) => getItemId(i) === itemId);\r\n\r\n          if (!item) return;\r\n\r\n          // Find the filter function for this tab\r\n          const tabConfig = filterTabs.find((t) => t.id === filterType);\r\n          cb.checked = tabConfig ? tabConfig.filter(item) : true;\r\n        });\r\n\r\n        const checkedCount = Array.from(checkboxes).filter((cb) => cb.checked).length;\r\n        LogHelper.log(\r\n          `[${widgetName}] Filter tab: ${filterType}, checked: ${checkedCount}/${checkboxes.length}`\r\n        );\r\n      });\r\n    });\r\n\r\n    // Search inside modal\r\n    const searchInput = modal.querySelector('#filterDeviceSearch');\r\n    if (searchInput) {\r\n      searchInput.addEventListener('input', (e) => {\r\n        const query = (e.target.value || '').trim().toLowerCase();\r\n        const checkItems = modal.querySelectorAll('#deviceChecklist .check-item');\r\n\r\n        checkItems.forEach((item) => {\r\n          const label = item.querySelector('label');\r\n          const text = (label?.textContent || '').toLowerCase();\r\n          item.style.display = text.includes(query) ? 'flex' : 'none';\r\n        });\r\n      });\r\n    }\r\n\r\n    // Clear search\r\n    const clearBtn = modal.querySelector('#filterDeviceClear');\r\n    if (clearBtn && searchInput) {\r\n      clearBtn.addEventListener('click', () => {\r\n        searchInput.value = '';\r\n        const checkItems = modal.querySelectorAll('#deviceChecklist .check-item');\r\n        checkItems.forEach((item) => (item.style.display = 'flex'));\r\n        searchInput.focus();\r\n      });\r\n    }\r\n\r\n    // ESC key handler\r\n    escHandler = (e) => {\r\n      if (e.key === 'Escape' && !modal.classList.contains('hidden')) {\r\n        close();\r\n      }\r\n    };\r\n    document.addEventListener('keydown', escHandler);\r\n\r\n    LogHelper.log(`[${widgetName}] Modal handlers bound`);\r\n  }\r\n\r\n  // Calculate counts for each filter tab\r\n  function calculateCounts(items) {\r\n    const counts = {};\r\n    filterTabs.forEach((tab) => {\r\n      counts[tab.id] = items.filter(tab.filter).length;\r\n    });\r\n    return counts;\r\n  }\r\n\r\n  // Populate checklist with items\r\n  function populateChecklist(modal, items, selectedIds) {\r\n    const checklist = modal.querySelector('#deviceChecklist');\r\n    if (!checklist) return;\r\n\r\n    checklist.innerHTML = '';\r\n\r\n    // 1. CORRE√á√ÉO: Usa window.custumersSelected que √© global, em vez de selectedShoppingIds que √© privada\r\n    const globalSelection = window.custumersSelected || [];\r\n\r\n    // Verifica se o filtro est√° ativo: tem itens selecionados E n√£o selecionou \"todos\" (se sua l√≥gica de \"todos\" for lista vazia ou igual ao total)\r\n    // Assumindo que se window.custumersSelected tiver valor, o filtro est√° valendo.\r\n    const isFiltered = globalSelection.length > 0;\r\n\r\n    // 2. Cria c√≥pia da lista\r\n    let itemsProcessing = items.slice();\r\n\r\n    // 3. APLICA O FILTRO\r\n    if (isFiltered) {\r\n      // Extrai os IDs dos shoppings selecionados\r\n      const allowedShoppingIds = globalSelection.map((c) => c.value); // c.value geralmente √© o customerId/ingestionId\r\n\r\n      itemsProcessing = itemsProcessing.filter((item) => {\r\n        // Filtra comparando o customerId do item com os IDs permitidos\r\n        return item.customerId && allowedShoppingIds.includes(item.customerId);\r\n      });\r\n    }\r\n\r\n    // 4. Ordena a lista (j√° filtrada)\r\n    const sortedItems = itemsProcessing.sort((a, b) =>\r\n      (getItemLabel(a) || '').localeCompare(getItemLabel(b) || '', 'pt-BR', { sensitivity: 'base' })\r\n    );\r\n\r\n    // 5. Renderiza\r\n    if (sortedItems.length === 0) {\r\n      checklist.innerHTML =\r\n        '<div style=\"padding:10px; color:#666; font-size:12px; text-align:center;\">Nenhum dispositivo encontrado para os filtros selecionados.</div>';\r\n      return;\r\n    }\r\n\r\n    sortedItems.forEach((item) => {\r\n      const itemId = getItemId(item);\r\n      const isChecked = !selectedIds || selectedIds.has(String(itemId));\r\n      const subLabel = getItemSubLabel(item);\r\n      const value = getItemValue(item);\r\n      const formattedValue = formatValue(value);\r\n\r\n      const div = document.createElement('div');\r\n      div.className = 'check-item';\r\n      div.innerHTML = `\r\n      <input type=\"checkbox\" id=\"check-${itemId}\" ${isChecked ? 'checked' : ''} ${itemIdAttr}=\"${itemId}\">\r\n      <label for=\"check-${itemId}\" style=\"flex: 1;\">${getItemLabel(item)}</label>\r\n      ${\r\n        subLabel ? `<span style=\"color: #64748b; font-size: 11px; margin-right: 8px;\">${subLabel}</span>` : ''\r\n      }\r\n      <span style=\"color: ${\r\n        value > 0 ? '#16a34a' : '#94a3b8'\r\n      }; font-size: 11px; font-weight: 600; min-width: 70px; text-align: right;\">${formattedValue}</span>\r\n    `;\r\n      checklist.appendChild(div);\r\n    });\r\n  }\r\n  // Open the modal\r\n  function open(items, state = {}) {\r\n    if (!items || items.length === 0) {\r\n      LogHelper.warn(`[${widgetName}] No items to display in filter modal`);\r\n      window.alert('Nenhum item encontrado. Por favor, aguarde o carregamento dos dados.');\r\n      return;\r\n    }\r\n\r\n    LogHelper.log(`[${widgetName}] Opening filter modal with ${items.length} items`);\r\n\r\n    // Create global container if needed\r\n    if (!globalContainer) {\r\n      globalContainer = document.getElementById(containerId);\r\n\r\n      if (!globalContainer) {\r\n        globalContainer = document.createElement('div');\r\n        globalContainer.id = containerId;\r\n        globalContainer.innerHTML = `<style>${generateStyles()}</style>${generateModalHTML()}`;\r\n        document.body.appendChild(globalContainer);\r\n\r\n        const modal = globalContainer.querySelector('#filterModal');\r\n        if (modal) {\r\n          setupHandlers(modal, items, state);\r\n        }\r\n\r\n        LogHelper.log(`[${widgetName}] Modal created and attached to document.body`);\r\n      }\r\n    }\r\n\r\n    const modal = globalContainer.querySelector('#filterModal');\r\n    if (!modal) return;\r\n\r\n    // Calculate and update counts\r\n    const counts = calculateCounts(items);\r\n    const tabsContainer = modal.querySelector('#filterTabsContainer');\r\n    if (tabsContainer) {\r\n      tabsContainer.innerHTML = generateFilterTabsHTML(counts);\r\n\r\n      // Re-bind tab click handlers after updating HTML\r\n      const filterTabsEl = tabsContainer.querySelectorAll('.filter-tab');\r\n      filterTabsEl.forEach((tab) => {\r\n        tab.addEventListener('click', () => {\r\n          const filterType = tab.getAttribute('data-filter');\r\n          filterTabsEl.forEach((t) => t.classList.remove('active'));\r\n          tab.classList.add('active');\r\n\r\n          const checkboxes = modal.querySelectorAll(`#deviceChecklist input[type='checkbox']`);\r\n          checkboxes.forEach((cb) => {\r\n            const itemId = cb.getAttribute(itemIdAttr);\r\n            const item = items.find((i) => String(getItemId(i)) === String(itemId));\r\n            if (!item) return;\r\n\r\n            const tabConfig = filterTabs.find((t) => t.id === filterType);\r\n            cb.checked = tabConfig ? tabConfig.filter(item) : true;\r\n          });\r\n        });\r\n      });\r\n    }\r\n\r\n    // Populate checklist\r\n    populateChecklist(modal, items, state.selectedIds);\r\n\r\n    // Set sort mode\r\n    const sortRadio = modal.querySelector(`input[name=\"sortMode\"][value=\"${state.sortMode || 'cons_desc'}\"]`);\r\n    if (sortRadio) sortRadio.checked = true;\r\n\r\n    // Show modal\r\n    modal.classList.remove('hidden');\r\n    document.body.classList.add('filter-modal-open');\r\n\r\n    LogHelper.log(`[${widgetName}] Filter modal opened`);\r\n  }\r\n\r\n  // Close the modal\r\n  function close() {\r\n    if (!globalContainer) return;\r\n\r\n    const modal = globalContainer.querySelector('#filterModal');\r\n    if (modal) {\r\n      modal.classList.add('hidden');\r\n    }\r\n\r\n    document.body.classList.remove('filter-modal-open');\r\n    onClose();\r\n\r\n    LogHelper.log(`[${widgetName}] Filter modal closed`);\r\n  }\r\n\r\n  // Destroy the modal\r\n  function destroy() {\r\n    if (escHandler) {\r\n      document.removeEventListener('keydown', escHandler);\r\n      escHandler = null;\r\n    }\r\n\r\n    if (globalContainer) {\r\n      globalContainer.remove();\r\n      globalContainer = null;\r\n    }\r\n\r\n    document.body.classList.remove('filter-modal-open');\r\n\r\n    LogHelper.log(`[${widgetName}] Filter modal destroyed`);\r\n  }\r\n\r\n  return { open, close, destroy };\r\n}\r\n\r\n// ‚úÖ Expose shared utilities globally for child widgets\r\nwindow.MyIOUtils = {\r\n  // Logging\r\n  LogHelper,\r\n  isDebugActive: () => DEBUG_ACTIVE,\r\n  setDebug: (active) => {\r\n    DEBUG_ACTIVE = !!active;\r\n    console.log(`[MyIOUtils] Debug mode ${DEBUG_ACTIVE ? 'enabled' : 'disabled'}`);\r\n  },\r\n\r\n  // API & Formatting\r\n  getDataApiHost,\r\n  fetchEnergyDayConsumption,\r\n  fetchWaterDayConsumption,\r\n\r\n  // Formatting functions (from MyIOLibrary - evaluated at runtime)\r\n  formatEnergy: (val) => MyIOLibrary.formatEnergy(val),\r\n  formatWater: (val) => MyIOLibrary.formatWater(val),\r\n  mapConnectionStatus: (status) => MyIOLibrary.mapConnectionStatus(status),\r\n  formatRelativeTime: (ts) => MyIOLibrary.formatRelativeTime(ts),\r\n  formatarDuracao: (ms) => MyIOLibrary.formatarDuracao(ms),\r\n  findValue: (values, key, defaultValue) => MyIOLibrary.findValueWithDefault(values, key, defaultValue),\r\n\r\n  // Credentials (getters - populated after onInit)\r\n  getCustomerId: () => window.myioHoldingCustomerId,\r\n  getClientId: () => window.__MYIO_CLIENT_ID__,\r\n  getClientSecret: () => window.__MYIO_CLIENT_SECRET__,\r\n  getCustomerIngestionId: () => window.__MYIO_CUSTOMER_INGESTION_ID__,\r\n\r\n  // RFC-0091: Connection delay time getter (required - no fallback)\r\n  getDelayTimeConnectionInMins: () => window.__MYIO_DELAY_TIME_CONNECTION_MINS__,\r\n\r\n  // RFC-0086: DATA_API_HOST getter (exposed directly for child widgets)\r\n  get DATA_API_HOST() {\r\n    const host = window.__MYIO_DATA_API_HOST__;\r\n    if (!host) {\r\n      LogHelper.error('[MyIOUtils] DATA_API_HOST not available - MAIN onInit not executed yet');\r\n      return '';\r\n    }\r\n    return host;\r\n  },\r\n\r\n  // Convenience: get all credentials at once\r\n  getCredentials: () => ({\r\n    customerId: window.myioHoldingCustomerId,\r\n    customerIngestionId: window.__MYIO_CUSTOMER_INGESTION_ID__,\r\n    clientId: window.__MYIO_CLIENT_ID__,\r\n    clientSecret: window.__MYIO_CLIENT_SECRET__,\r\n    dataApiHost: getDataApiHost(),\r\n  }),\r\n\r\n  // RFC-0071: Device Profile Sync\r\n  fetchDeviceProfiles,\r\n  fetchDeviceDetails,\r\n  addDeviceProfileAttribute,\r\n  syncDeviceProfileAttributes,\r\n\r\n  // RFC-0078: Power Limits\r\n  DEFAULT_CONSUMPTION_RANGES,\r\n  fetchInstantaneousPowerLimits,\r\n  extractLimitsFromJSON,\r\n  getDefaultRanges,\r\n  getCachedPowerLimitsJSON,\r\n  getConsumptionRangesHierarchical,\r\n  getCachedConsumptionLimits,\r\n\r\n  // UI Helpers\r\n  showLoadingOverlay,\r\n  updateEquipmentStats,\r\n  getCustomerNameForDevice,\r\n\r\n  // RFC-0093: Centralized Header Builder\r\n  buildHeaderDevicesGrid,\r\n  HEADER_DOMAIN_CONFIG,\r\n\r\n  // ThingsBoard API\r\n  fetchCustomerServerScopeAttrs,\r\n\r\n  // RFC-0090: Shared Filter Modal Factory\r\n  createFilterModal,\r\n\r\n  // RFC-0092: Temperature Utilities\r\n  formatTemperature: (value) => {\r\n    if (value === null || value === undefined || isNaN(value)) return '--';\r\n    return `${Number(value).toFixed(1)}¬∞C`;\r\n  },\r\n  getTemperatureStatus: (temp, min = 18, max = 26) => {\r\n    if (temp === null || temp === undefined || isNaN(temp)) return 'no_info';\r\n    if (temp < min) return 'cold';\r\n    if (temp > max) return 'hot';\r\n    return 'normal';\r\n  },\r\n};\r\n\r\nconsole.log('[MAIN] MyIOUtils exposed globally:', Object.keys(window.MyIOUtils));\r\n\r\nlet CUSTOMER_ID_TB; // ThingsBoard Customer ID\r\nlet CUSTOMER_INGESTION_ID; // Ingestion API Customer ID\r\nlet CLIENT_ID_INGESTION;\r\nlet CLIENT_SECRET_INGESTION;\r\nlet myIOAuth; // Instance of MyIO auth component\r\n\r\n// NOTE: fetchCustomerServerScopeAttrs is defined above and exposed via MyIOUtils\r\n\r\n// NOTE: Fun√ß√µes de rendering e device data removidas\r\n// Essas responsabilidades agora pertencem aos widgets HEADER e EQUIPMENTS\r\n\r\n// ===== ORCHESTRATOR: Energy Cache Management =====\r\nconst MyIOOrchestrator = (() => {\r\n  // ========== BUSY OVERLAY MANAGEMENT ==========\r\n  const BUSY_OVERLAY_ID = 'myio-orchestrator-busy-overlay';\r\n  let globalBusyState = {\r\n    isVisible: false,\r\n    timeoutId: null,\r\n    startTime: null,\r\n    currentDomain: null,\r\n    requestCount: 0,\r\n  };\r\n\r\n  function ensureOrchestratorBusyDOM() {\r\n    let el = document.getElementById(BUSY_OVERLAY_ID);\r\n    if (el) return el;\r\n\r\n    el = document.createElement('div');\r\n    el.id = BUSY_OVERLAY_ID;\r\n    el.style.cssText = `\r\n      position: fixed;\r\n      inset: 0;\r\n      background: rgba(45, 20, 88, 0.6);\r\n      backdrop-filter: blur(3px);\r\n      display: none;\r\n      align-items: center;\r\n      justify-content: center;\r\n      z-index: 99999;\r\n      font-family: Inter, system-ui, sans-serif;\r\n    `;\r\n\r\n    const container = document.createElement('div');\r\n    container.style.cssText = `\r\n      background: #2d1458;\r\n      color: #fff;\r\n      border-radius: 18px;\r\n      padding: 24px 32px;\r\n      box-shadow: 0 12px 40px rgba(0,0,0,0.35);\r\n      border: 1px solid rgba(255,255,255,0.1);\r\n      display: flex;\r\n      align-items: center;\r\n      gap: 16px;\r\n      min-width: 320px;\r\n    `;\r\n\r\n    const spinner = document.createElement('div');\r\n    spinner.style.cssText = `\r\n      width: 24px;\r\n      height: 24px;\r\n      border: 3px solid rgba(255,255,255,0.25);\r\n      border-top-color: #ffffff;\r\n      border-radius: 50%;\r\n      animation: spin 0.9s linear infinite;\r\n    `;\r\n\r\n    const message = document.createElement('div');\r\n    message.id = `${BUSY_OVERLAY_ID}-message`;\r\n    message.style.cssText = `\r\n      font-weight: 600;\r\n      font-size: 14px;\r\n      letter-spacing: 0.2px;\r\n    `;\r\n    message.textContent = 'Carregando dados...';\r\n\r\n    container.appendChild(spinner);\r\n    container.appendChild(message);\r\n    el.appendChild(container);\r\n    document.body.appendChild(el);\r\n\r\n    // Add CSS animation\r\n    if (!document.querySelector('#myio-busy-styles')) {\r\n      const styleEl = document.createElement('style');\r\n      styleEl.id = 'myio-busy-styles';\r\n      styleEl.textContent = `\r\n        @keyframes spin {\r\n          from { transform: rotate(0deg); }\r\n          to { transform: rotate(360deg); }\r\n        }\r\n      `;\r\n      document.head.appendChild(styleEl);\r\n    }\r\n\r\n    return el;\r\n  }\r\n\r\n  function showGlobalBusy(domain = 'energy', message = 'Carregando dados de energia...') {\r\n    LogHelper.log(`[Orchestrator] üîÑ showGlobalBusy() domain=${domain} message=\"${message}\"`);\r\n\r\n    const el = ensureOrchestratorBusyDOM();\r\n    const messageEl = el.querySelector(`#${BUSY_OVERLAY_ID}-message`);\r\n\r\n    if (messageEl) {\r\n      messageEl.textContent = message;\r\n    }\r\n\r\n    // Clear existing timeout\r\n    if (globalBusyState.timeoutId) {\r\n      clearTimeout(globalBusyState.timeoutId);\r\n      globalBusyState.timeoutId = null;\r\n    }\r\n\r\n    // Update state\r\n    globalBusyState.isVisible = true;\r\n    globalBusyState.currentDomain = domain;\r\n    globalBusyState.startTime = Date.now();\r\n    globalBusyState.requestCount++;\r\n\r\n    el.style.display = 'flex';\r\n\r\n    // Extended timeout (25s)\r\n    globalBusyState.timeoutId = setTimeout(() => {\r\n      LogHelper.warn(`[Orchestrator] ‚ö†Ô∏è BUSY TIMEOUT (25s) for domain ${domain}`);\r\n      hideGlobalBusy();\r\n      globalBusyState.timeoutId = null;\r\n    }, 25000);\r\n\r\n    LogHelper.log(`[Orchestrator] ‚úÖ Global busy shown for ${domain}`);\r\n  }\r\n\r\n  function hideGlobalBusy() {\r\n    LogHelper.log(`[Orchestrator] ‚è∏Ô∏è hideGlobalBusy() called`);\r\n\r\n    const el = document.getElementById(BUSY_OVERLAY_ID);\r\n    if (el) {\r\n      el.style.display = 'none';\r\n    }\r\n\r\n    // Clear timeout\r\n    if (globalBusyState.timeoutId) {\r\n      clearTimeout(globalBusyState.timeoutId);\r\n      globalBusyState.timeoutId = null;\r\n    }\r\n\r\n    // Update state\r\n    globalBusyState.isVisible = false;\r\n    globalBusyState.currentDomain = null;\r\n    globalBusyState.startTime = null;\r\n\r\n    LogHelper.log(`[Orchestrator] ‚úÖ Global busy hidden`);\r\n  }\r\n\r\n  // RFC-0057: Simplified - memory-only cache (no localStorage)\r\n  let energyCache = new Map(); // Map<ingestionId, energyData>\r\n  let waterCache = new Map();\r\n  let isFetching = false;\r\n  let lastFetchParams = null;\r\n  let lastFetchTimestamp = null;\r\n\r\n  // ===== WATER: Registro de IDs v√°lidos por categoria (vindos dos Aliases TB) =====\r\n  // Os widgets WATER_COMMON_AREA e WATER_STORES registram seus IDs aqui\r\n  // O Orchestrator s√≥ soma devices que existem nesses registros\r\n  const waterValidIds = {\r\n    commonArea: new Set(), // IDs do alias 'HidrometrosAreaComum'\r\n    stores: new Set(), // IDs do alias 'Todos Hidrometros Lojas'\r\n  };\r\n\r\n  // Totais calculados apenas para IDs v√°lidos\r\n  let waterTotals = {\r\n    commonArea: 0,\r\n    stores: 0,\r\n    total: 0,\r\n  };\r\n\r\n  // ===== ENERGY: Registro de IDs v√°lidos (vindos do Alias TB 'Equipamentos e Lojas') =====\r\n  // O Orchestrator s√≥ soma devices que existem nesse registro\r\n  let energyValidIds = new Set(); // IDs do alias 'Equipamentos e Lojas'\r\n\r\n  // ===== ENERGY DEVICES METADATA: Full TB device info + classification =====\r\n  // Map<entityId, deviceMetadata> - stores ALL TB metadata (connectionStatus, deviceProfile, etc.)\r\n  let energyDevicesMetadata = new Map();\r\n  // Classified device lists\r\n  let classifiedDevices = {\r\n    lojas: [], // deviceType=3F_MEDIDOR AND deviceProfile=3F_MEDIDOR\r\n    equipments: [], // deviceType!=3F_MEDIDOR OR (deviceType=3F_MEDIDOR AND deviceProfile!=3F_MEDIDOR)\r\n    all: [],\r\n  };\r\n\r\n  /**\r\n   * RFC-0102: Classification logic for energy devices\r\n   * - Loja: deviceType = '3F_MEDIDOR' AND deviceProfile = '3F_MEDIDOR'\r\n   * - Equipamento: deviceType != '3F_MEDIDOR' OR (deviceType = '3F_MEDIDOR' AND deviceProfile != '3F_MEDIDOR')\r\n   */\r\n  function isEquipment(device) {\r\n    const deviceType = (device.deviceType || '').toUpperCase();\r\n    const deviceProfile = (device.deviceProfile || '').toUpperCase();\r\n\r\n    // Non-3F_MEDIDOR devices are always equipment\r\n    if (deviceType !== '3F_MEDIDOR') {\r\n      return true;\r\n    }\r\n    // For 3F_MEDIDOR, check if deviceProfile differs (real equipment type)\r\n    return deviceProfile !== '3F_MEDIDOR';\r\n  }\r\n\r\n  /**\r\n   * RFC-0102: Extract ALL device metadata from TB datasource \"Equipamentos e Lojas\"\r\n   * Called by processEnergyDatasourcesFromTB() after data is available\r\n   */\r\n  function extractEnergyDevicesMetadata() {\r\n    const data = self.ctx?.data || [];\r\n    const deviceMap = new Map();\r\n\r\n    // Filter data for \"Equipamentos e Lojas\" alias\r\n    const energyData = data.filter((d) => d?.datasource?.aliasName === 'Equipamentos e Lojas');\r\n\r\n    if (energyData.length === 0) {\r\n      LogHelper.log('[MAIN] extractEnergyDevicesMetadata: No data for \"Equipamentos e Lojas\"');\r\n      return;\r\n    }\r\n\r\n    // Build device metadata map from ctx.data\r\n    energyData.forEach((row) => {\r\n      const entityId = row?.datasource?.entity?.id?.id || row?.datasource?.entityId;\r\n      if (!entityId) return;\r\n\r\n      if (!deviceMap.has(entityId)) {\r\n        const entity = row.datasource?.entity || {};\r\n        deviceMap.set(entityId, {\r\n          entityId,\r\n          tbId: entityId,\r\n          name: entity.name || row.datasource?.name || null,\r\n          label: entity.label || null,\r\n          // Will be populated from dataKeys below\r\n          ingestionId: null,\r\n          identifier: null,\r\n          deviceType: null,\r\n          deviceProfile: null,\r\n          connectionStatus: null,\r\n          centralName: null,\r\n          ownerName: null,\r\n          lastActivityTime: null,\r\n          lastConnectTime: null,\r\n          lastDisconnectTime: null,\r\n          consumption: null,\r\n          consumptionTimestamp: null,\r\n          // Additional fields needed by EQUIPMENTS\r\n          deviceMapInstaneousPower: null,\r\n          customerId: null,\r\n        });\r\n      }\r\n\r\n      // Extract value from dataKey\r\n      const keyName = row?.dataKey?.name || '';\r\n      const value = row?.data?.[0]?.[1] ?? null;\r\n      const timestamp = row?.data?.[0]?.[0] ?? null;\r\n      const device = deviceMap.get(entityId);\r\n\r\n      const keyLower = keyName.toLowerCase();\r\n      if (keyLower === 'ingestionid') device.ingestionId = value;\r\n      else if (keyLower === 'identifier') device.identifier = value;\r\n      else if (keyLower === 'devicetype') device.deviceType = value;\r\n      else if (keyLower === 'deviceprofile') device.deviceProfile = value;\r\n      else if (keyLower === 'connectionstatus') device.connectionStatus = value;\r\n      else if (keyLower === 'centralname') device.centralName = value;\r\n      else if (keyLower === 'ownername') device.ownerName = value;\r\n      else if (keyLower === 'lastactivitytime') device.lastActivityTime = value;\r\n      else if (keyLower === 'lastconnecttime') device.lastConnectTime = value;\r\n      else if (keyLower === 'lastdisconnecttime') device.lastDisconnectTime = value;\r\n      else if (keyLower === 'label' && value) device.label = value;\r\n      else if (keyLower === 'consumption') {\r\n        device.consumption = value;\r\n        device.consumption_power = value;\r\n        device.consumptionTimestamp = timestamp;\r\n      }\r\n      // Additional fields needed by EQUIPMENTS\r\n      else if (keyLower === 'devicemapinstaneouspower') device.deviceMapInstaneousPower = value;\r\n      else if (keyLower === 'customerid') device.customerId = value;\r\n    });\r\n\r\n    // Update the metadata cache\r\n    energyDevicesMetadata = deviceMap;\r\n    LogHelper.log(\r\n      `[MAIN] extractEnergyDevicesMetadata: Extracted ${deviceMap.size} devices with full TB metadata`\r\n    );\r\n\r\n    // Classify devices into lojas vs equipments\r\n    classifyEnergyDevices();\r\n  }\r\n\r\n  /**\r\n   * RFC-0102: Classify extracted devices into lojas vs equipments\r\n   */\r\n  function classifyEnergyDevices() {\r\n    const lojas = [];\r\n    const equipments = [];\r\n    const all = [];\r\n\r\n    energyDevicesMetadata.forEach((device, entityId) => {\r\n      // Add to all list\r\n      all.push(device);\r\n\r\n      // Classify\r\n      if (isEquipment(device)) {\r\n        equipments.push(device);\r\n      } else {\r\n        lojas.push(device);\r\n      }\r\n    });\r\n\r\n    classifiedDevices = { lojas, equipments, all };\r\n\r\n    LogHelper.log(\r\n      `[MAIN] classifyEnergyDevices: ${lojas.length} lojas, ${equipments.length} equipments, ${all.length} total`\r\n    );\r\n\r\n    // Update lojasIngestionIds and equipmentsIngestionIds Sets\r\n    const lojasIds = lojas.map((d) => d.ingestionId).filter(Boolean);\r\n    const equipmentIds = equipments.map((d) => d.ingestionId).filter(Boolean);\r\n\r\n    lojasIngestionIds = new Set(lojasIds);\r\n    equipmentsIngestionIds = new Set(equipmentIds);\r\n\r\n    LogHelper.log(\r\n      `[MAIN] Updated lojasIngestionIds (${lojasIngestionIds.size}) and equipmentsIngestionIds (${equipmentsIngestionIds.size})`\r\n    );\r\n\r\n    // Dispatch event so other widgets know classification is ready\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:devices-classified', {\r\n        detail: {\r\n          lojasCount: lojas.length,\r\n          equipmentsCount: equipments.length,\r\n          totalCount: all.length,\r\n          lojasIngestionIds: lojasIds,\r\n          equipmentsIngestionIds: equipmentIds,\r\n          timestamp: Date.now(),\r\n        },\r\n      })\r\n    );\r\n    LogHelper.log('[MAIN] Dispatched myio:devices-classified');\r\n\r\n    // Recalculate totals now that we have classified devices\r\n    dispatchEnergySummaryIfReady('classifyEnergyDevices');\r\n  }\r\n\r\n  /**\r\n   * RFC-0102: Get all lojas devices with full TB metadata\r\n   * Merged with energyCache consumption data AND fresh consumption telemetry\r\n   */\r\n  function getLojasDevices() {\r\n    // Get fresh consumption values from live ctx.data\r\n    const freshConsumption = getFreshConsumptionFromCtxData();\r\n\r\n    return classifiedDevices.lojas.map((device) => {\r\n      // Merge with energyCache consumption data if available\r\n      const cached = device.ingestionId ? energyCache.get(device.ingestionId) : null;\r\n      // Get fresh consumption for this device\r\n      const fresh = freshConsumption.get(device.entityId);\r\n\r\n      return {\r\n        ...device,\r\n        // Fresh consumption telemetry (instantaneous power)\r\n        consumption: fresh?.consumption ?? device.consumption ?? null,\r\n        consumptionTimestamp: fresh?.consumptionTimestamp ?? device.consumptionTimestamp ?? null,\r\n        // From energyCache (API consumption data)\r\n        total_value: cached?.total_value ?? null,\r\n        customerId: cached?.customerId ?? device.customerId ?? null,\r\n        customerName: cached?.customerName ?? null,\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * RFC-0102: Get fresh consumption telemetry from live ctx.data\r\n   * Returns Map<entityId, {consumption, consumptionTimestamp}>\r\n   */\r\n  function getFreshConsumptionFromCtxData() {\r\n    const data = self.ctx?.data || [];\r\n    const consumptionMap = new Map();\r\n\r\n    // DEBUG: Force console.log to ensure we see this\r\n    console.log('[MAIN] üîç getFreshConsumptionFromCtxData CALLED - ctx.data exists:', !!self.ctx?.data);\r\n    console.log('[MAIN] üîç ctx.data.length:', data.length);\r\n\r\n    // DEBUG: Log all unique aliasNames and dataKey names\r\n    const aliasNames = new Set();\r\n    const dataKeyNames = new Set();\r\n    data.forEach((d) => {\r\n      if (d?.datasource?.aliasName) aliasNames.add(d.datasource.aliasName);\r\n      if (d?.dataKey?.name) dataKeyNames.add(d.dataKey.name);\r\n    });\r\n\r\n    console.log('[MAIN] üîç aliasNames in ctx.data:', [...aliasNames]);\r\n    console.log('[MAIN] üîç dataKeyNames in ctx.data:', [...dataKeyNames]);\r\n\r\n    // Filter by alias \"Equipamentos e Lojas\" or \"Lojas e Equipamentos\"\r\n    const energyData = data.filter((d) => {\r\n      const alias = d?.datasource?.aliasName || '';\r\n      return alias === 'Equipamentos e Lojas' || alias === 'Lojas e Equipamentos';\r\n    });\r\n\r\n    console.log('[MAIN] üîç energyData.length after alias filter:', energyData.length);\r\n\r\n    // Count consumption entries\r\n    let consumptionCount = 0;\r\n    energyData.forEach((row) => {\r\n      const entityId = row?.datasource?.entity?.id?.id || row?.datasource?.entityId;\r\n      const keyName = (row?.dataKey?.name || '').toLowerCase();\r\n\r\n      if (entityId && keyName === 'consumption') {\r\n        const value = row?.data?.[0]?.[1] ?? null;\r\n        const timestamp = row?.data?.[0]?.[0] ?? null;\r\n        consumptionMap.set(entityId, { consumption: value, consumptionTimestamp: timestamp });\r\n        consumptionCount++;\r\n      }\r\n    });\r\n\r\n    console.log('[MAIN] üîç consumption entries found:', consumptionCount);\r\n    console.log('[MAIN] üîç consumptionMap.size:', consumptionMap.size);\r\n\r\n    // Log first 3 entries if any\r\n    if (consumptionMap.size > 0) {\r\n      let count = 0;\r\n      consumptionMap.forEach((val, key) => {\r\n        if (count < 3) {\r\n          console.log(`[MAIN] üîç Sample [${count}]: entityId=${key}, consumption=${val.consumption}`);\r\n          count++;\r\n        }\r\n      });\r\n    }\r\n\r\n    return consumptionMap;\r\n  }\r\n\r\n  /**\r\n   * RFC-0102: Get all equipment devices with full TB metadata\r\n   * Merged with energyCache consumption data AND fresh consumption telemetry\r\n   */\r\n  function getEquipmentDevices() {\r\n    // Get fresh consumption values from live ctx.data\r\n    const freshConsumption = getFreshConsumptionFromCtxData();\r\n\r\n    // DEBUG: Log fresh consumption map size\r\n    LogHelper.log(\r\n      `[MAIN] getEquipmentDevices: freshConsumption map size = ${freshConsumption.size}, equipments count = ${classifiedDevices.equipments.length}`\r\n    );\r\n\r\n    // DEBUG: Log sample of fresh consumption (first 3)\r\n    if (freshConsumption.size > 0) {\r\n      let count = 0;\r\n      freshConsumption.forEach((val, key) => {\r\n        if (count < 3) {\r\n          LogHelper.log(\r\n            `[MAIN] Fresh consumption sample [${count}]: entityId=${key}, consumption=${\r\n              val.consumption\r\n            }, ts=${val.consumptionTimestamp} (${new Date(val.consumptionTimestamp).toLocaleString('pt-BR')})`\r\n          );\r\n          count++;\r\n        }\r\n      });\r\n    }\r\n\r\n    return classifiedDevices.equipments.map((device) => {\r\n      const cached = device.ingestionId ? energyCache.get(device.ingestionId) : null;\r\n      // Get fresh consumption for this device\r\n      const fresh = freshConsumption.get(device.entityId);\r\n\r\n      // DEBUG: Log for specific device (ER 14)\r\n      if (device.label && device.label.toLowerCase().includes('er 14')) {\r\n        LogHelper.log(`[MAIN] DEBUG ER 14:`, {\r\n          entityId: device.entityId,\r\n          label: device.label,\r\n          'device.consumption': device.consumption,\r\n          'device.consumptionTimestamp': device.consumptionTimestamp,\r\n          'fresh found': !!fresh,\r\n          'fresh?.consumption': fresh?.consumption,\r\n          'fresh?.consumptionTimestamp': fresh?.consumptionTimestamp,\r\n          'freshConsumption has entityId': freshConsumption.has(device.entityId),\r\n        });\r\n      }\r\n\r\n      return {\r\n        ...device,\r\n        // Fresh consumption telemetry (instantaneous power)\r\n        consumption: fresh?.consumption ?? device.consumption ?? null,\r\n        consumptionTimestamp: fresh?.consumptionTimestamp ?? device.consumptionTimestamp ?? null,\r\n        // From API cache\r\n        total_value: cached?.total_value ?? null,\r\n        customerId: cached?.customerId ?? device.customerId ?? null,\r\n        customerName: cached?.customerName ?? null,\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * RFC-0102: Get all energy devices (lojas + equipments) with full TB metadata\r\n   * Merged with fresh consumption telemetry\r\n   */\r\n  function getAllEnergyDevices() {\r\n    // Get fresh consumption values from live ctx.data\r\n    const freshConsumption = getFreshConsumptionFromCtxData();\r\n\r\n    return classifiedDevices.all.map((device) => {\r\n      const cached = device.ingestionId ? energyCache.get(device.ingestionId) : null;\r\n      const fresh = freshConsumption.get(device.entityId);\r\n\r\n      return {\r\n        ...device,\r\n        consumption: fresh?.consumption ?? device.consumption ?? null,\r\n        consumptionTimestamp: fresh?.consumptionTimestamp ?? device.consumptionTimestamp ?? null,\r\n        total_value: cached?.total_value ?? null,\r\n        customerId: cached?.customerId ?? device.customerId ?? null,\r\n        customerName: cached?.customerName ?? null,\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * RFC-0102: Get a single device by entityId or ingestionId\r\n   */\r\n  function getEnergyDevice(id) {\r\n    // Try entityId first\r\n    if (energyDevicesMetadata.has(id)) {\r\n      const device = energyDevicesMetadata.get(id);\r\n      const cached = device.ingestionId ? energyCache.get(device.ingestionId) : null;\r\n      return { ...device, total_value: cached?.total_value ?? null };\r\n    }\r\n    // Try ingestionId\r\n    for (const device of energyDevicesMetadata.values()) {\r\n      if (device.ingestionId === id) {\r\n        const cached = energyCache.get(id);\r\n        return { ...device, total_value: cached?.total_value ?? null };\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Widgets registram seus IDs v√°lidos de √°gua\r\n   * @param {string} category - 'commonArea' ou 'stores'\r\n   * @param {string[]} ids - Array de ingestionIds v√°lidos\r\n   */\r\n  function registerWaterDeviceIds(category, ids) {\r\n    if (category !== 'commonArea' && category !== 'stores') {\r\n      LogHelper.warn(`[Orchestrator] Invalid water category: ${category}`);\r\n      return;\r\n    }\r\n\r\n    waterValidIds[category] = new Set(ids.filter(Boolean));\r\n    LogHelper.log(\r\n      `[Orchestrator] Registered ${waterValidIds[category].size} valid IDs for water ${category}`\r\n    );\r\n\r\n    // Recalcular totais com IDs v√°lidos\r\n    recalculateWaterTotals();\r\n  }\r\n\r\n  /**\r\n   * Calcula totais de √°gua apenas para IDs v√°lidos (dos Aliases TB)\r\n   * IDs que n√£o est√£o em nenhum alias s√£o IGNORADOS\r\n   */\r\n  function recalculateWaterTotals() {\r\n    let commonAreaTotal = 0;\r\n    let storesTotal = 0;\r\n\r\n    waterCache.forEach((device, id) => {\r\n      const value = Number(device.total_value || 0);\r\n      if (waterValidIds.commonArea.has(id)) {\r\n        commonAreaTotal += value;\r\n      } else if (waterValidIds.stores.has(id)) {\r\n        storesTotal += value;\r\n      }\r\n      // IDs que n√£o est√£o em nenhum alias s√£o IGNORADOS (n√£o somados)\r\n    });\r\n\r\n    waterTotals = {\r\n      commonArea: commonAreaTotal,\r\n      stores: storesTotal,\r\n      total: commonAreaTotal + storesTotal,\r\n    };\r\n\r\n    LogHelper.log(`[Orchestrator] Water totals recalculated:`, waterTotals);\r\n    LogHelper.log(\r\n      `[Orchestrator] Valid IDs: commonArea=${waterValidIds.commonArea.size}, stores=${waterValidIds.stores.size}`\r\n    );\r\n    LogHelper.log(\r\n      `[Orchestrator] Ignored devices: ${\r\n        waterCache.size - waterValidIds.commonArea.size - waterValidIds.stores.size\r\n      }`\r\n    );\r\n\r\n    // Disparar evento para atualizar HEADER e WATER\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:water-totals-updated', {\r\n        detail: { ...waterTotals, timestamp: Date.now() },\r\n      })\r\n    );\r\n\r\n    // Disparar evento com dados completos para tooltip e comparativo\r\n    // Delayed to ensure getWaterWidgetData is available\r\n    setTimeout(() => {\r\n      if (typeof getWaterWidgetData === 'function') {\r\n        const summary = getWaterWidgetData();\r\n        window.dispatchEvent(new CustomEvent('myio:water-summary-ready', { detail: summary }));\r\n        LogHelper.log('[MAIN] [Orchestrator] üîî water-summary-ready dispatched', summary);\r\n      }\r\n    }, 100);\r\n  }\r\n\r\n  /**\r\n   * Retorna os totais de √°gua calculados (apenas IDs v√°lidos)\r\n   */\r\n  function getWaterTotals() {\r\n    return { ...waterTotals };\r\n  }\r\n\r\n  /**\r\n   * Retorna os IDs v√°lidos de √°gua por categoria\r\n   * @returns {{ commonArea: Set<string>, stores: Set<string> }}\r\n   */\r\n  function getWaterValidIds() {\r\n    return {\r\n      commonArea: new Set(waterValidIds.commonArea),\r\n      stores: new Set(waterValidIds.stores),\r\n    };\r\n  }\r\n\r\n  // ===== ENERGY: Fun√ß√µes para registro de IDs v√°lidos =====\r\n\r\n  /**\r\n   * Registra IDs v√°lidos de energia (do alias 'Equipamentos e Lojas')\r\n   * @param {string[]} ids - Array de ingestionIds v√°lidos\r\n   */\r\n  function registerEnergyDeviceIds(ids) {\r\n    energyValidIds = new Set(ids.filter(Boolean));\r\n    LogHelper.log(`[Orchestrator] Registered ${energyValidIds.size} valid IDs for energy`);\r\n  }\r\n\r\n  /**\r\n   * Retorna os IDs v√°lidos de energia\r\n   * @returns {Set<string>}\r\n   */\r\n  function getEnergyValidIds() {\r\n    return new Set(energyValidIds);\r\n  }\r\n\r\n  // ===== RFC-0100: TEMPERATURE DATA MANAGEMENT =====\r\n  let temperatureCache = null;\r\n  let temperatureRanges = new Map();\r\n  let temperatureAverages = new Map();\r\n  let temperatureFetching = false;\r\n\r\n  /**\r\n   * RFC-0100: Extract temperature devices from ctx.data (AllTemperatureDevices alias)\r\n   * @returns {Array<{id: string, ownerName: string, connectionStatus: string, ingestionId: string}>}\r\n   */\r\n  function extractTemperatureDevices() {\r\n    const deviceMap = new Map();\r\n    const ctxData = self.ctx?.data || [];\r\n\r\n    ctxData.forEach((data) => {\r\n      if (data.datasource?.aliasName !== 'AllTemperatureDevices') return;\r\n\r\n      const entityId =\r\n        data.datasource?.entityId?.id || data.datasource?.entity?.id?.id || data.datasource?.entityId;\r\n\r\n      if (!entityId) return;\r\n\r\n      let device = deviceMap.get(entityId) || {\r\n        id: entityId,\r\n        ownerName: null,\r\n        connectionStatus: null,\r\n        ingestionId: null,\r\n      };\r\n\r\n      const keyName = data.dataKey?.name;\r\n      const value = data.data?.[0]?.[1];\r\n\r\n      if (keyName === 'ownerName' && value) {\r\n        device.ownerName = value;\r\n      }\r\n      if (keyName === 'connectionStatus' && value) {\r\n        device.connectionStatus = value;\r\n      }\r\n      if (keyName === 'ingestionId' && value) {\r\n        device.ingestionId = value;\r\n      }\r\n\r\n      deviceMap.set(entityId, device);\r\n    });\r\n\r\n    LogHelper.log(`[MAIN] RFC-0100: Extracted ${deviceMap.size} temperature devices`);\r\n    return Array.from(deviceMap.values());\r\n  }\r\n\r\n  /**\r\n   * RFC-0100: Extract temperature ranges from ctx.data (customers datasource)\r\n   * Filters by datasource.name === 'customers' and extracts minTemperature/maxTemperature per customer\r\n   * @returns {Map<string, {min: number, max: number, entityLabel: string}>}\r\n   */\r\n  function extractTemperatureRanges() {\r\n    const rangesMap = new Map();\r\n    const ctxData = self.ctx?.data || [];\r\n\r\n    // Debug: Log all datasource names and aliasNames to find customers\r\n    const datasourceInfo = new Set();\r\n    ctxData.forEach((data) => {\r\n      const name = data.datasource?.name;\r\n      const aliasName = data.datasource?.aliasName;\r\n      const keyName = data.dataKey?.name;\r\n      if (keyName === 'minTemperature' || keyName === 'maxTemperature') {\r\n        datasourceInfo.add(`name=${name}, aliasName=${aliasName}, key=${keyName}`);\r\n      }\r\n    });\r\n    if (datasourceInfo.size > 0) {\r\n      LogHelper.log(`[MAIN] RFC-0100: Found temperature keys in datasources:`, Array.from(datasourceInfo));\r\n    }\r\n\r\n    ctxData.forEach((data) => {\r\n      // Filter by datasource name OR aliasName = 'customers'\r\n      const datasourceName = data.datasource?.name;\r\n      const aliasName = data.datasource?.aliasName;\r\n      if (datasourceName !== 'customers' && aliasName !== 'customers') return;\r\n\r\n      const entityLabel = data.datasource?.entityLabel || 'Unknown';\r\n      const entityId = data.datasource?.entityId || entityLabel;\r\n\r\n      // Look for minTemperature and maxTemperature dataKeys\r\n      const keyName = data.dataKey?.name;\r\n      if (keyName !== 'minTemperature' && keyName !== 'maxTemperature') return;\r\n\r\n      if (!rangesMap.has(entityId)) {\r\n        rangesMap.set(entityId, { min: null, max: null, entityLabel });\r\n      }\r\n\r\n      const entry = rangesMap.get(entityId);\r\n\r\n      if (keyName === 'maxTemperature' && data.data?.[0]?.[1] != null) {\r\n        entry.max = Number(data.data[0][1]);\r\n      }\r\n      if (keyName === 'minTemperature' && data.data?.[0]?.[1] != null) {\r\n        entry.min = Number(data.data[0][1]);\r\n      }\r\n    });\r\n\r\n    // Filter only valid ranges (both min and max present)\r\n    const validRanges = new Map();\r\n    rangesMap.forEach((value, key) => {\r\n      if (value.min != null && value.max != null) {\r\n        validRanges.set(key, value);\r\n      }\r\n    });\r\n\r\n    temperatureRanges = validRanges;\r\n    LogHelper.log(\r\n      `[MAIN] RFC-0100: Extracted ${validRanges.size} temperature ranges from customers datasource`\r\n    );\r\n    return validRanges;\r\n  }\r\n\r\n  /**\r\n   * RFC-0100: Calculate average from temperature data array\r\n   * @param {Array<{value: string|number}>} dataArray\r\n   * @returns {number}\r\n   */\r\n  function calcularMediaTemperatura(dataArray) {\r\n    if (!dataArray || dataArray.length === 0) return 0;\r\n\r\n    const sum = dataArray.reduce((acc, item) => {\r\n      const val = parseFloat(item.value);\r\n      return !isNaN(val) ? acc + val : acc;\r\n    }, 0);\r\n\r\n    return dataArray.length > 0 ? sum / dataArray.length : 0;\r\n  }\r\n\r\n  /**\r\n   * RFC-0100: Fetch temperature averages for all devices via ThingsBoard API\r\n   * @param {number} startTs - Start timestamp in milliseconds\r\n   * @param {number} endTs - End timestamp in milliseconds\r\n   * @returns {Promise<Map<string, {avg: number, ownerName: string, deviceCount: number}>>}\r\n   */\r\n  async function fetchTemperatureAverages(startTs, endTs) {\r\n    const tbToken = localStorage.getItem('jwt_token');\r\n    if (!tbToken) {\r\n      LogHelper.warn('[MAIN] RFC-0100: JWT not found for temperature fetch');\r\n      return new Map();\r\n    }\r\n\r\n    const devices = extractTemperatureDevices();\r\n    const shoppingTemps = new Map();\r\n\r\n    for (const device of devices) {\r\n      try {\r\n        const url =\r\n          `/api/plugins/telemetry/DEVICE/${device.id}/values/timeseries` +\r\n          `?keys=temperature` +\r\n          `&startTs=${encodeURIComponent(startTs)}` +\r\n          `&endTs=${encodeURIComponent(endTs)}` +\r\n          `&limit=50000` +\r\n          `&intervalType=MILLISECONDS` +\r\n          `&interval=7200000` +\r\n          `&agg=AVG`;\r\n\r\n        const response = await fetch(url, {\r\n          headers: {\r\n            'X-Authorization': `Bearer ${tbToken}`,\r\n            'Content-Type': 'application/json',\r\n          },\r\n        });\r\n\r\n        if (!response.ok) continue;\r\n\r\n        const data = await response.json();\r\n        const temperatureData = data.temperature || [];\r\n        const avgTemp = calcularMediaTemperatura(temperatureData);\r\n\r\n        if (avgTemp != null && !isNaN(avgTemp) && avgTemp > 0) {\r\n          const ownerName = device.ownerName || 'Unknown';\r\n          if (!shoppingTemps.has(ownerName)) {\r\n            shoppingTemps.set(ownerName, { temps: [], ownerName, deviceCount: 0 });\r\n          }\r\n          const entry = shoppingTemps.get(ownerName);\r\n          entry.temps.push(avgTemp);\r\n          entry.deviceCount++;\r\n        }\r\n      } catch (err) {\r\n        LogHelper.error(`[MAIN] RFC-0100: Error fetching temperature for device ${device.id}:`, err);\r\n      }\r\n    }\r\n\r\n    // Calculate average per shopping\r\n    const result = new Map();\r\n    shoppingTemps.forEach((value, key) => {\r\n      const sum = value.temps.reduce((a, b) => a + b, 0);\r\n      const avg = value.temps.length > 0 ? sum / value.temps.length : null;\r\n      result.set(key, { avg, ownerName: value.ownerName, deviceCount: value.deviceCount });\r\n    });\r\n\r\n    temperatureAverages = result;\r\n    LogHelper.log(`[MAIN] RFC-0100: Calculated temperature averages for ${result.size} shoppings`);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * RFC-0100: Fetch temperature DAY averages for all devices via ThingsBoard API\r\n   * Returns per-day temperature averages for each shopping over the specified period\r\n   * Used by TEMPERATURE widget for 7-day chart\r\n   * @param {number} startTs - Start timestamp in milliseconds\r\n   * @param {number} endTs - End timestamp in milliseconds\r\n   * @returns {Promise<{labels: string[], dailyTotals: number[], shoppingData: Object, shoppingNames: Object}>}\r\n   */\r\n  async function fetchTemperatureDayAverages(startTs, endTs) {\r\n    const tbToken = localStorage.getItem('jwt_token');\r\n    if (!tbToken) {\r\n      LogHelper.warn('[MAIN] RFC-0100: JWT not found for temperature day averages fetch');\r\n      return { labels: [], dailyTotals: [], shoppingData: {}, shoppingNames: {} };\r\n    }\r\n\r\n    const devices = extractTemperatureDevices();\r\n    LogHelper.log(`[MAIN] RFC-0100: Fetching day averages for ${devices.length} temperature devices`);\r\n\r\n    // Calculate number of days in period\r\n    const dayMs = 24 * 60 * 60 * 1000;\r\n    const numDays = Math.ceil((endTs - startTs) / dayMs);\r\n\r\n    // Generate date labels\r\n    const labels = [];\r\n    for (let i = 0; i < numDays; i++) {\r\n      const dayDate = new Date(startTs + i * dayMs);\r\n      labels.push(dayDate.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' }));\r\n    }\r\n\r\n    // Collect daily data per shopping\r\n    const shoppingDailyData = new Map(); // Map<ownerName, Map<dayIndex, {sum, count}>>\r\n\r\n    for (const device of devices) {\r\n      try {\r\n        // Use daily aggregation (86400000ms = 24 hours)\r\n        const url =\r\n          `/api/plugins/telemetry/DEVICE/${device.id}/values/timeseries` +\r\n          `?keys=temperature` +\r\n          `&startTs=${encodeURIComponent(startTs)}` +\r\n          `&endTs=${encodeURIComponent(endTs)}` +\r\n          `&limit=50000` +\r\n          `&intervalType=MILLISECONDS` +\r\n          `&interval=86400000` +\r\n          `&agg=AVG`;\r\n\r\n        const response = await fetch(url, {\r\n          headers: {\r\n            'X-Authorization': `Bearer ${tbToken}`,\r\n            'Content-Type': 'application/json',\r\n          },\r\n        });\r\n\r\n        if (!response.ok) continue;\r\n\r\n        const data = await response.json();\r\n        const temperatureData = data.temperature || [];\r\n\r\n        if (temperatureData.length === 0) continue;\r\n\r\n        const ownerName = device.ownerName || 'Unknown';\r\n        if (!shoppingDailyData.has(ownerName)) {\r\n          shoppingDailyData.set(ownerName, new Map());\r\n        }\r\n        const shopData = shoppingDailyData.get(ownerName);\r\n\r\n        // Map each temperature reading to its day index\r\n        temperatureData.forEach((reading) => {\r\n          const ts = reading.ts;\r\n          const value = parseFloat(reading.value);\r\n          if (isNaN(value)) return;\r\n\r\n          const dayIndex = Math.floor((ts - startTs) / dayMs);\r\n          if (dayIndex < 0 || dayIndex >= numDays) return;\r\n\r\n          if (!shopData.has(dayIndex)) {\r\n            shopData.set(dayIndex, { sum: 0, count: 0 });\r\n          }\r\n          const dayData = shopData.get(dayIndex);\r\n          dayData.sum += value;\r\n          dayData.count++;\r\n        });\r\n      } catch (err) {\r\n        // Skip failing devices\r\n      }\r\n    }\r\n\r\n    // Build result structure\r\n    const shoppingData = {};\r\n    const shoppingNames = {};\r\n    const dailyTotals = new Array(numDays).fill(0);\r\n    const dailyCounts = new Array(numDays).fill(0);\r\n\r\n    shoppingDailyData.forEach((shopData, ownerName) => {\r\n      const shopId = ownerName.replace(/\\s+/g, '-').toLowerCase();\r\n      shoppingNames[shopId] = ownerName;\r\n      shoppingData[shopId] = new Array(numDays).fill(null);\r\n\r\n      shopData.forEach((dayData, dayIndex) => {\r\n        const avg = dayData.count > 0 ? dayData.sum / dayData.count : null;\r\n        if (avg !== null) {\r\n          shoppingData[shopId][dayIndex] = Math.round(avg * 10) / 10;\r\n          dailyTotals[dayIndex] += avg;\r\n          dailyCounts[dayIndex]++;\r\n        }\r\n      });\r\n    });\r\n\r\n    // Calculate daily averages (average of shopping averages)\r\n    for (let i = 0; i < numDays; i++) {\r\n      dailyTotals[i] = dailyCounts[i] > 0 ? Math.round((dailyTotals[i] / dailyCounts[i]) * 10) / 10 : null;\r\n    }\r\n\r\n    LogHelper.log(\r\n      `[MAIN] RFC-0100: Temperature day averages calculated for ${shoppingDailyData.size} shoppings, ${numDays} days`\r\n    );\r\n\r\n    return {\r\n      labels,\r\n      dailyTotals,\r\n      shoppingData,\r\n      shoppingNames,\r\n      fetchTimestamp: Date.now(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * RFC-0100: Main temperature data fetch function\r\n   * Fetches temperature data and emits myio:temperature-data-ready event\r\n   * @param {number} startTs - Start timestamp in milliseconds\r\n   * @param {number} endTs - End timestamp in milliseconds\r\n   * @returns {Promise<Object>} Temperature cache object\r\n   */\r\n  async function fetchTemperatureData(startTs, endTs) {\r\n    if (temperatureFetching) {\r\n      LogHelper.log('[MAIN] RFC-0100: Temperature fetch already in progress, skipping');\r\n      return temperatureCache;\r\n    }\r\n\r\n    temperatureFetching = true;\r\n    LogHelper.log('[MAIN] RFC-0100: Fetching temperature data...');\r\n\r\n    try {\r\n      // Extract ranges from ctx.data\r\n      const ranges = extractTemperatureRanges();\r\n\r\n      // Fetch averages from ThingsBoard API\r\n      const averages = await fetchTemperatureAverages(startTs, endTs);\r\n\r\n      // Build all shoppings data for comparison\r\n      const allShoppingsData = [];\r\n      averages.forEach((avgData, ownerName) => {\r\n        if (avgData.avg != null) {\r\n          allShoppingsData.push({ ownerName, avg: avgData.avg });\r\n        }\r\n      });\r\n\r\n      // Calculate global average (all shoppings)\r\n      let globalSum = 0;\r\n      let globalCount = 0;\r\n      averages.forEach((avgData) => {\r\n        if (avgData.avg != null) {\r\n          globalSum += avgData.avg;\r\n          globalCount++;\r\n        }\r\n      });\r\n      const globalAvg = globalCount > 0 ? globalSum / globalCount : null;\r\n\r\n      // Calculate filtered average based on selected shoppings\r\n      let filteredAvg = globalAvg;\r\n      let filteredCount = globalCount;\r\n      const isFiltered =\r\n        selectedShoppingIds.length > 0 && selectedShoppingIds.length < allShoppingsData.length;\r\n\r\n      if (isFiltered) {\r\n        const selectedNames = (window.custumersSelected || []).map((s) => s.name);\r\n        const normalize = (str) =>\r\n          (str || '')\r\n            .toLowerCase()\r\n            .normalize('NFD')\r\n            .replace(/[\\u0300-\\u036f]/g, '')\r\n            .trim();\r\n\r\n        let filteredSum = 0;\r\n        filteredCount = 0;\r\n\r\n        averages.forEach((avgData, ownerName) => {\r\n          if (avgData.avg == null) return;\r\n          const normalizedOwner = normalize(ownerName);\r\n          const matchesFilter = selectedNames.some((name) => {\r\n            const normalizedName = normalize(name);\r\n            return (\r\n              normalizedOwner === normalizedName ||\r\n              normalizedOwner.includes(normalizedName) ||\r\n              normalizedName.includes(normalizedOwner)\r\n            );\r\n          });\r\n\r\n          if (matchesFilter) {\r\n            filteredSum += avgData.avg;\r\n            filteredCount++;\r\n          }\r\n        });\r\n\r\n        filteredAvg = filteredCount > 0 ? filteredSum / filteredCount : globalAvg;\r\n      }\r\n\r\n      // Analyze in-range vs out-of-range vs unknown-range shoppings\r\n      const shoppingsInRange = [];\r\n      const shoppingsOutOfRange = [];\r\n      const shoppingsUnknownRange = []; // Shoppings without defined temperature range\r\n\r\n      averages.forEach((avgData, ownerName) => {\r\n        if (avgData.avg == null) return;\r\n\r\n        const normalize = (str) =>\r\n          (str || '')\r\n            .toLowerCase()\r\n            .normalize('NFD')\r\n            .replace(/[\\u0300-\\u036f]/g, '')\r\n            .trim();\r\n        const normalizedOwner = normalize(ownerName);\r\n\r\n        // Find matching range\r\n        let matchedRange = null;\r\n        ranges.forEach((range) => {\r\n          const normalizedLabel = normalize(range.entityLabel);\r\n          if (\r\n            normalizedLabel === normalizedOwner ||\r\n            normalizedLabel.includes(normalizedOwner) ||\r\n            normalizedOwner.includes(normalizedLabel)\r\n          ) {\r\n            matchedRange = range;\r\n          }\r\n        });\r\n\r\n        // NO fallback - if no match, it's unknown range\r\n        // Log range match for debugging\r\n        if (matchedRange) {\r\n          LogHelper.log(\r\n            `[MAIN] RFC-0100: Range for \"${ownerName}\": ${matchedRange.min}‚Äì${matchedRange.max}¬∞C`\r\n          );\r\n        } else {\r\n          LogHelper.warn(`[MAIN] RFC-0100: No range found for \"${ownerName}\" - marking as unknown`);\r\n        }\r\n\r\n        const shoppingInfo = {\r\n          name: ownerName,\r\n          avg: avgData.avg,\r\n          min: matchedRange?.min,\r\n          max: matchedRange?.max,\r\n        };\r\n\r\n        // Classify: in range, out of range, or unknown range\r\n        if (!matchedRange) {\r\n          // No range defined - unknown\r\n          shoppingsUnknownRange.push(shoppingInfo);\r\n        } else if (avgData.avg >= matchedRange.min && avgData.avg <= matchedRange.max) {\r\n          // Within defined range\r\n          shoppingsInRange.push(shoppingInfo);\r\n        } else {\r\n          // Outside defined range\r\n          shoppingsOutOfRange.push(shoppingInfo);\r\n        }\r\n      });\r\n\r\n      // Build cache\r\n      temperatureCache = {\r\n        devices: extractTemperatureDevices(),\r\n        ranges,\r\n        averages,\r\n        allShoppingsData,\r\n        globalAvg,\r\n        filteredAvg,\r\n        filteredCount,\r\n        totalCount: globalCount,\r\n        isFiltered,\r\n        shoppingsInRange,\r\n        shoppingsOutOfRange,\r\n        shoppingsUnknownRange, // Shoppings without defined temperature range\r\n        startTs,\r\n        endTs,\r\n        fetchTimestamp: Date.now(),\r\n      };\r\n\r\n      // Dispatch event for HEADER and other widgets\r\n      window.dispatchEvent(\r\n        new CustomEvent('myio:temperature-data-ready', {\r\n          detail: temperatureCache,\r\n        })\r\n      );\r\n\r\n      LogHelper.log('[MAIN] RFC-0100: Temperature data ready:', {\r\n        deviceCount: temperatureCache.devices.length,\r\n        rangeCount: ranges.size,\r\n        averageCount: averages.size,\r\n        globalAvg: globalAvg?.toFixed(1),\r\n        filteredAvg: filteredAvg?.toFixed(1),\r\n        isFiltered,\r\n        inRange: shoppingsInRange.length,\r\n        outOfRange: shoppingsOutOfRange.length,\r\n        unknownRange: shoppingsUnknownRange.length,\r\n      });\r\n\r\n      return temperatureCache;\r\n    } catch (err) {\r\n      LogHelper.error('[MAIN] RFC-0100: Error fetching temperature data:', err);\r\n      return null;\r\n    } finally {\r\n      temperatureFetching = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * RFC-0100: Get current temperature cache\r\n   */\r\n  function getTemperatureCache() {\r\n    return temperatureCache;\r\n  }\r\n\r\n  /**\r\n   * RFC-0100: Get temperature ranges\r\n   */\r\n  function getTemperatureRanges() {\r\n    return temperatureRanges;\r\n  }\r\n\r\n  /**\r\n   * RFC-0100: Get temperature averages\r\n   */\r\n  function getTemperatureAverages() {\r\n    return temperatureAverages;\r\n  }\r\n\r\n  /**\r\n   * RFC-0100: Recalculate temperature filtered values using cached data\r\n   * Called when shopping filter changes but date range stays the same\r\n   * Avoids unnecessary API calls by reusing cached averages\r\n   */\r\n  function recalculateTemperatureFiltered() {\r\n    if (!temperatureCache || !temperatureCache.averages) {\r\n      LogHelper.log('[MAIN] RFC-0100: No temperature cache available for recalculation');\r\n      return null;\r\n    }\r\n\r\n    const { averages, ranges, allShoppingsData, globalAvg, startTs, endTs } = temperatureCache;\r\n    const globalCount = allShoppingsData?.length || 0;\r\n\r\n    LogHelper.log('[MAIN] RFC-0100: Recalculating temperature filtered values (no API call)');\r\n\r\n    // Calculate filtered average based on selected shoppings\r\n    let filteredAvg = globalAvg;\r\n    let filteredCount = globalCount;\r\n    const isFiltered = selectedShoppingIds.length > 0 && selectedShoppingIds.length < globalCount;\r\n\r\n    const normalize = (str) =>\r\n      (str || '')\r\n        .toLowerCase()\r\n        .normalize('NFD')\r\n        .replace(/[\\u0300-\\u036f]/g, '')\r\n        .trim();\r\n\r\n    if (isFiltered) {\r\n      const selectedNames = (window.custumersSelected || []).map((s) => s.name);\r\n\r\n      let filteredSum = 0;\r\n      filteredCount = 0;\r\n\r\n      averages.forEach((avgData, ownerName) => {\r\n        if (avgData.avg == null) return;\r\n        const normalizedOwner = normalize(ownerName);\r\n        const matchesFilter = selectedNames.some((name) => {\r\n          const normalizedName = normalize(name);\r\n          return (\r\n            normalizedOwner === normalizedName ||\r\n            normalizedOwner.includes(normalizedName) ||\r\n            normalizedName.includes(normalizedOwner)\r\n          );\r\n        });\r\n\r\n        if (matchesFilter) {\r\n          filteredSum += avgData.avg;\r\n          filteredCount++;\r\n        }\r\n      });\r\n\r\n      filteredAvg = filteredCount > 0 ? filteredSum / filteredCount : globalAvg;\r\n    }\r\n\r\n    // Analyze in-range vs out-of-range vs unknown-range shoppings\r\n    const shoppingsInRange = [];\r\n    const shoppingsOutOfRange = [];\r\n    const shoppingsUnknownRange = [];\r\n\r\n    averages.forEach((avgData, ownerName) => {\r\n      if (avgData.avg == null) return;\r\n\r\n      const normalizedOwner = normalize(ownerName);\r\n\r\n      // Find matching range\r\n      let matchedRange = null;\r\n      ranges.forEach((range) => {\r\n        const normalizedLabel = normalize(range.entityLabel);\r\n        if (\r\n          normalizedLabel === normalizedOwner ||\r\n          normalizedLabel.includes(normalizedOwner) ||\r\n          normalizedOwner.includes(normalizedLabel)\r\n        ) {\r\n          matchedRange = range;\r\n        }\r\n      });\r\n\r\n      const shoppingInfo = {\r\n        name: ownerName,\r\n        avg: avgData.avg,\r\n        min: matchedRange?.min,\r\n        max: matchedRange?.max,\r\n      };\r\n\r\n      // Classify: in range, out of range, or unknown range\r\n      if (!matchedRange) {\r\n        shoppingsUnknownRange.push(shoppingInfo);\r\n      } else if (avgData.avg >= matchedRange.min && avgData.avg <= matchedRange.max) {\r\n        shoppingsInRange.push(shoppingInfo);\r\n      } else {\r\n        shoppingsOutOfRange.push(shoppingInfo);\r\n      }\r\n    });\r\n\r\n    // Update cache with recalculated values\r\n    temperatureCache = {\r\n      ...temperatureCache,\r\n      filteredAvg,\r\n      filteredCount,\r\n      isFiltered,\r\n      shoppingsInRange,\r\n      shoppingsOutOfRange,\r\n      shoppingsUnknownRange,\r\n    };\r\n\r\n    // Dispatch event for HEADER and other widgets\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:temperature-data-ready', {\r\n        detail: temperatureCache,\r\n      })\r\n    );\r\n\r\n    LogHelper.log('[MAIN] RFC-0100: Temperature data recalculated:', {\r\n      globalAvg: globalAvg?.toFixed(1),\r\n      filteredAvg: filteredAvg?.toFixed(1),\r\n      isFiltered,\r\n      inRange: shoppingsInRange.length,\r\n      outOfRange: shoppingsOutOfRange.length,\r\n      unknownRange: shoppingsUnknownRange.length,\r\n    });\r\n\r\n    return temperatureCache;\r\n  }\r\n\r\n  // ===== RFC-0100: SHOPPING DATA MANAGEMENT =====\r\n  let shoppingsCache = [];\r\n\r\n  /**\r\n   * RFC-0100: Extract shopping list from ctx.data (Shopping alias)\r\n   * @returns {Array<{name: string, value: string}>}\r\n   */\r\n  function extractShoppings() {\r\n    const shoppings = [];\r\n    const ctxData = self.ctx?.data || [];\r\n\r\n    ctxData.forEach((data) => {\r\n      if (data.datasource?.aliasName === 'Shopping') {\r\n        shoppings.push({\r\n          name: data.datasource.entityLabel,\r\n          value: data.data?.[0]?.[1] || null,\r\n        });\r\n      }\r\n    });\r\n\r\n    shoppingsCache = shoppings;\r\n    // Set totalShoppings for filter comparison (to detect \"all selected\" = no filter)\r\n    totalShoppings = shoppings.length;\r\n    LogHelper.log(\r\n      `[MAIN] RFC-0100: Extracted ${shoppings.length} shoppings from ctx.data, totalShoppings set`\r\n    );\r\n    return shoppings;\r\n  }\r\n\r\n  /**\r\n   * RFC-0100: Get cached shoppings list\r\n   */\r\n  function getShoppings() {\r\n    return shoppingsCache;\r\n  }\r\n\r\n  /**\r\n   * RFC-0100: Dispatch shoppings data to HEADER and other widgets\r\n   */\r\n  function dispatchShoppingsData() {\r\n    const shoppings = extractShoppings();\r\n\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:shoppings-data-ready', {\r\n        detail: {\r\n          shoppings,\r\n          count: shoppings.length,\r\n          timestamp: Date.now(),\r\n        },\r\n      })\r\n    );\r\n\r\n    LogHelper.log(`[MAIN] RFC-0100: Dispatched myio:shoppings-data-ready with ${shoppings.length} shoppings`);\r\n    return shoppings;\r\n  }\r\n\r\n  // ===== STATE para montar o resumo ENERGY =====\r\n  let customerTotalConsumption = null; // total do cliente (vem do HEADER)\r\n  let lojasIngestionIds = new Set(); // ingestionIds das lojas (3F_MEDIDOR) - vem do EQUIPMENTS\r\n  let equipmentsIngestionIds = new Set(); // ingestionIds dos equipamentos - vem do EQUIPMENTS\r\n  let selectedShoppingIds = []; // Shopping ingestionIds selecionados no filtro (vem do MENU)\r\n  let totalShoppings = 0; // Total de shoppings dispon√≠veis (para determinar se \"todos\" est√£o selecionados)\r\n\r\n  // ===== DEVICE-TO-SHOPPING MAPPING (Fallback for missing customerId) =====\r\n  // Map<deviceIngestionId, shoppingIngestionId> - populated from EQUIPMENTS ctx.data\r\n  window.myioDeviceToShoppingMap = window.myioDeviceToShoppingMap || new Map();\r\n\r\n  function haveEquipments() {\r\n    return energyCache && energyCache.size > 0;\r\n  }\r\n  function haveCustomerTotal() {\r\n    return typeof customerTotalConsumption === 'number' && !Number.isNaN(customerTotalConsumption);\r\n  }\r\n\r\n  /**\r\n   * Verifica se um device deve ser inclu√≠do no c√°lculo baseado no filtro de shoppings\r\n   * @param {Object} device - Device data from energyCache\r\n   * @returns {boolean} - True if device should be included\r\n   */\r\n  function shouldIncludeDevice(device) {\r\n    // Se nenhum shopping foi selecionado (filtro vazio), inclui todos\r\n    if (!selectedShoppingIds || selectedShoppingIds.length === 0) {\r\n      return true;\r\n    }\r\n\r\n    // Tenta obter customerId do device ou do mapa de fallback\r\n    let customerId = device.customerId;\r\n\r\n    // Fallback: se n√£o tem customerId, tenta buscar no mapa global\r\n    if (!customerId && window.myioDeviceToShoppingMap) {\r\n      customerId = window.myioDeviceToShoppingMap.get(device.ingestionId);\r\n    }\r\n\r\n    // Se ainda n√£o tem customerId, inclui (safety - n√£o filtra dispositivos sem mapeamento)\r\n    if (!customerId) {\r\n      return true;\r\n    }\r\n\r\n    // Verifica se o customerId do device est√° na lista de shoppings selecionados\r\n    return selectedShoppingIds.includes(customerId);\r\n  }\r\n\r\n  function dispatchEnergySummaryIfReady(reason = 'unknown') {\r\n    if (!haveEquipments() || !haveCustomerTotal()) {\r\n      LogHelper.log(\r\n        `[MAIN] [Orchestrator] Resumo ainda n√£o pronto (equip=${haveEquipments()} total=${haveCustomerTotal()}) [${reason}]`\r\n      );\r\n      return;\r\n    }\r\n    const summary = getEnergyWidgetData(customerTotalConsumption);\r\n    window.dispatchEvent(new CustomEvent('myio:energy-summary-ready', { detail: summary }));\r\n    LogHelper.log(`[MAIN] [Orchestrator] üîî energy-summary-ready dispatched (${reason})`, summary);\r\n  }\r\n\r\n  function cacheKey(customerIngestionId, startDateISO, endDateISO) {\r\n    return `energy:${customerIngestionId}:${startDateISO}:${endDateISO}`;\r\n  }\r\n\r\n  function invalidateCache(domain = 'all') {\r\n    LogHelper.log(`[Orchestrator] Invalidating ${domain} cache`);\r\n\r\n    if (domain === 'energy' || domain === 'all') {\r\n      energyCache.clear();\r\n    }\r\n    if (domain === 'water' || domain === 'all') {\r\n      waterCache.clear();\r\n    }\r\n\r\n    // Reseta o estado compartilhado\r\n    lastFetchParams = null;\r\n    lastFetchTimestamp = null;\r\n  }\r\n\r\n  async function fetchEnergyData(customerIngestionId, startDateISO, endDateISO) {\r\n    // RFC-0093: Guard against undefined myIOAuth (widget destroyed or not initialized)\r\n    if (!myIOAuth || typeof myIOAuth.getToken !== 'function') {\r\n      LogHelper.warn('[MAIN] fetchEnergyData: myIOAuth not available, skipping');\r\n      return energyCache;\r\n    }\r\n\r\n    const key = cacheKey(customerIngestionId, startDateISO, endDateISO);\r\n\r\n    // RFC-0057: Check for duplicate fetches\r\n    if (isFetching && lastFetchParams === key) {\r\n      LogHelper.log('[MAIN] [Orchestrator] Fetch already in progress, skipping...');\r\n      return energyCache;\r\n    }\r\n\r\n    // RFC-0057: Check memory cache (no localStorage)\r\n    if (energyCache.size > 0 && lastFetchParams === key) {\r\n      const cacheAge = lastFetchTimestamp ? Date.now() - lastFetchTimestamp : 0;\r\n      const cacheTTL = 5 * 60 * 1000; // 5 minutes\r\n\r\n      if (cacheAge < cacheTTL) {\r\n        LogHelper.log(\r\n          `[MAIN] [Orchestrator] Using cached data from memory (${\r\n            energyCache.size\r\n          } devices, age: ${Math.round(cacheAge / 1000)}s)`\r\n        );\r\n\r\n        // Emit event with cached data\r\n        window.dispatchEvent(\r\n          new CustomEvent('myio:energy-data-ready', {\r\n            detail: {\r\n              cache: energyCache,\r\n              totalDevices: energyCache.size,\r\n              startDate: startDateISO,\r\n              endDate: endDateISO,\r\n              timestamp: lastFetchTimestamp,\r\n              fromCache: true,\r\n            },\r\n          })\r\n        );\r\n\r\n        return energyCache;\r\n      } else {\r\n        LogHelper.log(\r\n          `[MAIN] [Orchestrator] Cache expired (age: ${Math.round(cacheAge / 1000)}s), fetching fresh data...`\r\n        );\r\n      }\r\n    }\r\n\r\n    isFetching = true;\r\n    lastFetchParams = key;\r\n    LogHelper.log('[MAIN] [Orchestrator] Fetching energy data from API...', {\r\n      customerIngestionId,\r\n      startDateISO,\r\n      endDateISO,\r\n    });\r\n\r\n    // Show global busy modal\r\n    showGlobalBusy('energy', 'Carregando dados de energia...');\r\n\r\n    try {\r\n      // Get token from MyIO auth component\r\n      const TOKEN_INGESTION = await myIOAuth.getToken();\r\n\r\n      const apiUrl = `${getDataApiHost()}/api/v1/telemetry/customers/${customerIngestionId}/energy/devices/totals?startTime=${encodeURIComponent(\r\n        startDateISO\r\n      )}&endTime=${encodeURIComponent(endDateISO)}&deep=1`;\r\n      LogHelper.log('[MAIN] [Orchestrator] üåê API URL:', apiUrl);\r\n\r\n      const response = await fetch(apiUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          Authorization: `Bearer ${TOKEN_INGESTION}`,\r\n          'Content-Type': 'application/json',\r\n        },\r\n      });\r\n\r\n      LogHelper.log(`[MAIN] [Orchestrator] üì° API Status: ${response.status} ${response.statusText}`);\r\n\r\n      if (!response.ok) {\r\n        console.warn(`[MAIN] [Orchestrator] ‚ùå Failed to fetch energy: HTTP ${response.status}`);\r\n        return energyCache;\r\n      }\r\n\r\n      const data = await response.json();\r\n      LogHelper.log('[MAIN] [Orchestrator] üì¶ API Response:', data);\r\n\r\n      // Log summary if available\r\n      if (data.summary) {\r\n        LogHelper.log('[MAIN] [Orchestrator] üìä API Summary:', data.summary);\r\n      }\r\n\r\n      // API returns { data: [...] }\r\n      const devicesList = Array.isArray(data) ? data : data.data || [];\r\n      LogHelper.log('[MAIN] [Orchestrator] üìã Devices list extracted:', devicesList.length, 'devices');\r\n\r\n      // Log first device if available for debugging\r\n      if (devicesList.length > 0) {\r\n        LogHelper.log('[MAIN] [Orchestrator] üîç First device sample:', devicesList[0]);\r\n      } else {\r\n        console.warn(\r\n          '[MAIN] [Orchestrator] ‚ö†Ô∏è API returned ZERO devices! Check if data exists for this period.'\r\n        );\r\n      }\r\n\r\n      // Clear and repopulate cache\r\n      energyCache.clear();\r\n      let count = 0;\r\n      devicesList.forEach((device) => {\r\n        if (device.id) {\r\n          // Debug: check all possible customerId fields\r\n          const customerId = device.customerId || device.customer_id || device.ownerId || null;\r\n\r\n          if (count === 0) {\r\n            // Log first device to see full structure\r\n            LogHelper.log(\r\n              '[MAIN] [Orchestrator] üîç Full first device structure:',\r\n              JSON.stringify(device, null, 2)\r\n            );\r\n            LogHelper.log('[MAIN] [Orchestrator] üîç Extracted customerId:', customerId);\r\n          }\r\n\r\n          const cachedData = {\r\n            ingestionId: device.id,\r\n            customerId: customerId, // Shopping ingestionId\r\n            customerName: device.customerName || device.customer_name || null, // Shopping friendly name\r\n            name: device.name,\r\n            deviceType: device.deviceType || device.device_type || '',\r\n            deviceProfile: device.deviceProfile || device.device_profile || '',\r\n            label: device.label || device.name || '',\r\n            entityLabel: device.entityLabel || device.entity_label || device.label || device.name || '',\r\n            entityName: device.entityName || device.entity_name || device.name || '',\r\n            total_value: device.total_value || 0,\r\n            timestamp: Date.now(),\r\n            // RFC-0102: Additional fields from API for STORES widget\r\n            slaveId: device.slaveId || null,\r\n            gatewayId: device.gatewayId || null,\r\n            assetId: device.assetId || null,\r\n            assetName: device.assetName || null, // Can be used as identifier proxy\r\n            identifier: device.identifier || device.assetName || null, // Explicit identifier if API provides\r\n          };\r\n\r\n          energyCache.set(device.id, cachedData);\r\n          count++;\r\n\r\n          // Log first cached device to verify data structure\r\n          if (count === 1) {\r\n            LogHelper.log('[MAIN] [Orchestrator] üîç First cached device data:', cachedData);\r\n            LogHelper.log('[MAIN] [Orchestrator] üîç customerName extracted:', cachedData.customerName);\r\n          }\r\n          //LogHelper.log(`[MAIN] [Orchestrator] Cached device: ${device.name} (${device.id}) = ${device.total_value} kWh`);\r\n          // TODO Implementar uma fun√ß√£o que\r\n        }\r\n      });\r\n\r\n      LogHelper.log(`[MAIN] [Orchestrator] Energy cache updated: ${energyCache.size} devices`);\r\n\r\n      // RFC-0057: Update timestamp for memory cache\r\n      lastFetchTimestamp = Date.now();\r\n\r\n      // Emit event with cached data\r\n      window.dispatchEvent(\r\n        new CustomEvent('myio:energy-data-ready', {\r\n          detail: {\r\n            cache: energyCache,\r\n            totalDevices: energyCache.size,\r\n            startDate: startDateISO,\r\n            endDate: endDateISO,\r\n            timestamp: Date.now(),\r\n            fromCache: false,\r\n          },\r\n        })\r\n      );\r\n      // Se j√° temos o total do cliente, emita tamb√©m o resumo para o ENERGY\r\n      LogHelper.log('[MAIN] [Orchestrator] dispatchEnergySummaryIfReady >>> fetchEnergyData 001');\r\n      dispatchEnergySummaryIfReady('fetchEnergyData');\r\n\r\n      return energyCache;\r\n    } catch (err) {\r\n      console.error('[MAIN] [Orchestrator] Fatal error fetching energy data:', err);\r\n      return energyCache;\r\n    } finally {\r\n      isFetching = false;\r\n      // Hide global busy modal\r\n      hideGlobalBusy();\r\n    }\r\n  }\r\n\r\n  async function fetchWaterData(customerIngestionId, startDateISO, endDateISO) {\r\n    // RFC-0093: Guard against undefined myIOAuth (widget destroyed or not initialized)\r\n    if (!myIOAuth || typeof myIOAuth.getToken !== 'function') {\r\n      LogHelper.warn('[MAIN] fetchWaterData: myIOAuth not available, skipping');\r\n      return waterCache;\r\n    }\r\n\r\n    // 1. A key de cache para √ÅGUA.\r\n    // (Note que estamos \"re-implementando\" a l√≥gica da cacheKey aqui\r\n    // para n√£o ter que alterar a fun√ß√£o original)\r\n    const key = `water:${customerIngestionId}:${startDateISO}:${endDateISO}`;\r\n    const cache = waterCache; // Usa o cache de √ÅGUA\r\n\r\n    // O resto √© o \"esqueleto\" compartilhado\r\n    if (isFetching && lastFetchParams === key) {\r\n      LogHelper.log('[MAIN] [Orchestrator] Fetch (water) already in progress, skipping...');\r\n      return cache;\r\n    }\r\n\r\n    if (cache.size > 0 && lastFetchParams === key) {\r\n      const cacheAge = lastFetchTimestamp ? Date.now() - lastFetchTimestamp : 0;\r\n      const cacheTTL = 5 * 60 * 1000;\r\n\r\n      if (cacheAge < cacheTTL) {\r\n        LogHelper.log(\r\n          `[MAIN] [Orchestrator] Using cached (water) data (${cache.size} devices, age: ${Math.round(\r\n            cacheAge / 1000\r\n          )}s)`\r\n        );\r\n\r\n        window.dispatchEvent(\r\n          new CustomEvent('myio:water-data-ready', {\r\n            detail: {\r\n              cache: cache,\r\n              totalDevices: cache.size,\r\n              startDate: startDateISO,\r\n              endDate: endDateISO,\r\n              timestamp: lastFetchTimestamp,\r\n              fromCache: true,\r\n            },\r\n          })\r\n        );\r\n        return cache;\r\n      } else {\r\n        LogHelper.log(`[MAIN] [Orchestrator] Water cache expired, fetching...`);\r\n      }\r\n    }\r\n\r\n    isFetching = true;\r\n    lastFetchParams = key;\r\n    LogHelper.log('[MAIN] [Orchestrator] Fetching water data from API...');\r\n\r\n    showGlobalBusy('water', 'Carregando dados de √°gua...');\r\n\r\n    try {\r\n      const TOKEN_INGESTION = await myIOAuth.getToken();\r\n\r\n      // Endpoint da API de √ÅGUA\r\n      const apiUrl = `${getDataApiHost()}/api/v1/telemetry/customers/${customerIngestionId}/water/devices/totals?startTime=${encodeURIComponent(\r\n        startDateISO\r\n      )}&endTime=${encodeURIComponent(endDateISO)}&deep=1`;\r\n\r\n      LogHelper.log('[MAIN] [Orchestrator] üåê API URL (Water):', apiUrl);\r\n\r\n      const response = await fetch(apiUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          Authorization: `Bearer ${TOKEN_INGESTION}`,\r\n          'Content-Type': 'application/json',\r\n        },\r\n      });\r\n\r\n      LogHelper.log(`[MAIN] [Orchestrator] üì° API Status (Water): ${response.status} ${response.statusText}`);\r\n\r\n      if (!response.ok) {\r\n        console.warn(`[MAIN] [Orchestrator] ‚ùå Failed to fetch water: HTTP ${response.status}`);\r\n        return cache;\r\n      }\r\n\r\n      const data = await response.json();\r\n      const devicesList = Array.isArray(data) ? data : data.data || [];\r\n\r\n      cache.clear(); // Limpa e repopula o cache de √ÅGUA\r\n      devicesList.forEach((device) => {\r\n        if (device.id) {\r\n          cache.set(device.id, {\r\n            ingestionId: device.id,\r\n            name: device.name,\r\n            total_value: device.total_value || 0,\r\n            customerId: device.customerId || device.customer_id || null, // For filtering by shopping\r\n            timestamp: Date.now(),\r\n          });\r\n        }\r\n      });\r\n\r\n      LogHelper.log(`[MAIN] [Orchestrator] Water cache updated: ${cache.size} devices`);\r\n\r\n      lastFetchTimestamp = Date.now();\r\n\r\n      // Recalcular totais de √°gua agora que o cache foi preenchido\r\n      // Os IDs v√°lidos j√° foram registrados por processWaterDatasourcesFromTB()\r\n      recalculateWaterTotals();\r\n\r\n      // Dispara o evento de √ÅGUA\r\n      window.dispatchEvent(\r\n        new CustomEvent('myio:water-data-ready', {\r\n          detail: {\r\n            cache: cache,\r\n            totalDevices: cache.size,\r\n            startDate: startDateISO,\r\n            endDate: endDateISO,\r\n            timestamp: Date.now(),\r\n            fromCache: false,\r\n          },\r\n        })\r\n      );\r\n\r\n      return cache;\r\n    } catch (err) {\r\n      console.error('[MAIN] [Orchestrator] Fatal error fetching water data:', err);\r\n      return cache;\r\n    } finally {\r\n      isFetching = false;\r\n      hideGlobalBusy();\r\n    }\r\n  }\r\n\r\n  function getCache(domain = 'energy') {\r\n    if (domain === 'water') {\r\n      return waterCache;\r\n    }\r\n    return energyCache;\r\n  }\r\n\r\n  function getCachedDevice(ingestionId, domain = 'energy') {\r\n    const cache = domain === 'water' ? waterCache : energyCache;\r\n    return cache.get(ingestionId) || null;\r\n  }\r\n  // RFC-0057: invalidateCache already defined above (line 280), no duplicate needed\r\n\r\n  /**\r\n   * Calcula o total de consumo de EQUIPAMENTOS no cache\r\n   * Usa equipmentsIngestionIds (do EQUIPMENTS) se dispon√≠vel, sen√£o exclui lojas\r\n   * Considera filtro de shoppings se aplicado\r\n   * @returns {number} - Total em kWh\r\n   */\r\n  function getTotalEquipmentsConsumption() {\r\n    let total = 0;\r\n    energyCache.forEach((device, ingestionId) => {\r\n      // Se temos a lista de equipamentos, usa ela (mais preciso)\r\n      // Sen√£o, usa o fallback de excluir lojas\r\n      const isEquipment =\r\n        equipmentsIngestionIds.size > 0\r\n          ? equipmentsIngestionIds.has(ingestionId)\r\n          : !lojasIngestionIds.has(ingestionId);\r\n\r\n      if (isEquipment) {\r\n        // Apply shopping filter\r\n        if (shouldIncludeDevice(device)) {\r\n          total += device.total_value || 0;\r\n        }\r\n      }\r\n    });\r\n\r\n    return total;\r\n  }\r\n\r\n  /**\r\n   * Calcula o total de consumo de LOJAS no cache (apenas 3F_MEDIDOR)\r\n   * Considera filtro de shoppings se aplicado\r\n   * @returns {number} - Total em kWh\r\n   */\r\n  function getTotalLojasConsumption() {\r\n    let total = 0;\r\n\r\n    energyCache.forEach((device, ingestionId) => {\r\n      // Only lojas (3F_MEDIDOR)\r\n      if (lojasIngestionIds.has(ingestionId)) {\r\n        // Apply shopping filter\r\n        if (shouldIncludeDevice(device)) {\r\n          total += device.total_value || 0;\r\n        }\r\n      }\r\n    });\r\n    /*\r\n    LogHelper.log(\r\n      `[MAIN] [Orchestrator] Total LOJAS consumption (3F_MEDIDOR only): ${total} kWh (${count} devices, ${filtered} filtered out by shopping filter)`\r\n    );\r\n    */\r\n    return total;\r\n  }\r\n\r\n  /**\r\n   * Agrega consumo de energia por shopping (customerId)\r\n   * Retorna array de { name, equipamentos, lojas } para cada shopping\r\n   * Considera filtro de shoppings se aplicado\r\n   * @returns {Array<{name: string, equipamentos: number, lojas: number}>}\r\n   */\r\n  function getEnergyByShoppings() {\r\n    // Map<customerId, { name, equipamentos, lojas }>\r\n    const shoppingMap = new Map();\r\n\r\n    // Helper para obter nome do shopping pelo customerId\r\n    function getShoppingName(customerId) {\r\n      if (window.custumersSelected && Array.isArray(window.custumersSelected)) {\r\n        const shopping = window.custumersSelected.find((c) => c.value === customerId);\r\n        if (shopping) return shopping.name;\r\n      }\r\n      // Fallback: primeiros 8 caracteres do ID\r\n      if (customerId) {\r\n        return `Shopping ${customerId.substring(0, 8)}...`;\r\n      }\r\n      return 'Desconhecido';\r\n    }\r\n\r\n    // Itera pelo cache de energia\r\n    energyCache.forEach((device, ingestionId) => {\r\n      // Aplica filtro de shopping se ativo\r\n      if (!shouldIncludeDevice(device)) return;\r\n\r\n      // Obt√©m customerId (shopping)\r\n      let customerId = device.customerId;\r\n      if (!customerId && window.myioDeviceToShoppingMap) {\r\n        customerId = window.myioDeviceToShoppingMap.get(device.ingestionId);\r\n      }\r\n      if (!customerId) return; // Ignora dispositivos sem shopping\r\n\r\n      // Inicializa entrada do shopping se n√£o existir\r\n      if (!shoppingMap.has(customerId)) {\r\n        shoppingMap.set(customerId, {\r\n          name: getShoppingName(customerId),\r\n          equipamentos: 0,\r\n          lojas: 0,\r\n        });\r\n      }\r\n\r\n      const entry = shoppingMap.get(customerId);\r\n      const value = device.total_value || 0;\r\n\r\n      // Classifica como equipamento ou loja\r\n      if (lojasIngestionIds.has(ingestionId)) {\r\n        entry.lojas += value;\r\n      } else if (equipmentsIngestionIds.size > 0 ? equipmentsIngestionIds.has(ingestionId) : true) {\r\n        entry.equipamentos += value;\r\n      }\r\n    });\r\n\r\n    // Converte Map para Array\r\n    const result = Array.from(shoppingMap.values());\r\n    LogHelper.log('[MAIN] [Orchestrator] Energy by shoppings:', result.length, 'shoppings');\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Calcula o total GERAL de consumo (EQUIPAMENTOS + LOJAS)\r\n   * Se temos IDs identificados, soma apenas esses dispositivos\r\n   * Sen√£o, soma todos os dispositivos da API\r\n   * Considera filtro de shoppings se aplicado\r\n   * @returns {number} - Total em kWh\r\n   */\r\n  function getTotalConsumption() {\r\n    // Se temos dispositivos identificados, usar soma precisa\r\n    const hasIdentifiedDevices = equipmentsIngestionIds.size > 0 || lojasIngestionIds.size > 0;\r\n\r\n    if (hasIdentifiedDevices) {\r\n      // Soma apenas equipamentos + lojas identificados\r\n      return getTotalEquipmentsConsumption() + getTotalLojasConsumption();\r\n    }\r\n\r\n    // Fallback: soma todos da API (comportamento antigo)\r\n    let total = 0;\r\n    energyCache.forEach((device) => {\r\n      if (shouldIncludeDevice(device)) {\r\n        total += device.total_value || 0;\r\n      }\r\n    });\r\n    return total;\r\n  }\r\n\r\n  /**\r\n   * Calcula o total GERAL de consumo de ENERGIA SEM FILTRO de shopping\r\n   * Se temos IDs identificados, soma apenas esses dispositivos (sem filtro de shopping)\r\n   * @returns {number} - Total em kWh\r\n   */\r\n  function getUnfilteredTotalConsumption() {\r\n    // Se temos dispositivos identificados, somar apenas eles (mas sem filtro de shopping)\r\n    const hasIdentifiedDevices = equipmentsIngestionIds.size > 0 || lojasIngestionIds.size > 0;\r\n\r\n    if (hasIdentifiedDevices) {\r\n      let total = 0;\r\n      // Equipamentos identificados (sem filtro de shopping)\r\n      energyCache.forEach((device, ingestionId) => {\r\n        if (equipmentsIngestionIds.has(ingestionId)) {\r\n          total += device.total_value || 0;\r\n        }\r\n      });\r\n      // Lojas identificadas (sem filtro de shopping)\r\n      energyCache.forEach((device, ingestionId) => {\r\n        if (lojasIngestionIds.has(ingestionId)) {\r\n          total += device.total_value || 0;\r\n        }\r\n      });\r\n      return total;\r\n    }\r\n\r\n    // Fallback: soma todos da API\r\n    let total = 0;\r\n    energyCache.forEach((device) => {\r\n      total += device.total_value || 0;\r\n    });\r\n    return total;\r\n  }\r\n\r\n  /**\r\n   * Calcula o total GERAL de consumo de √ÅGUA COM FILTRO aplicado\r\n   * @returns {number} - Total em m¬≥\r\n   */\r\n  function getTotalWaterConsumption() {\r\n    let total = 0;\r\n    waterCache.forEach((device) => {\r\n      if (shouldIncludeDevice(device)) {\r\n        total += device.total_value || 0;\r\n      }\r\n    });\r\n    return total;\r\n  }\r\n\r\n  /**\r\n   * Calcula o total GERAL de consumo de √ÅGUA SEM FILTRO (todos os devices)\r\n   * Considera apenas IDs v√°lidos (dos Aliases TB)\r\n   * @returns {number} - Total em m¬≥\r\n   */\r\n  function getUnfilteredTotalWaterConsumption() {\r\n    let total = 0;\r\n    waterCache.forEach((device, id) => {\r\n      // Apenas IDs v√°lidos (area comum ou lojas)\r\n      if (waterValidIds.commonArea.has(id) || waterValidIds.stores.has(id)) {\r\n        total += device.total_value || 0;\r\n      }\r\n    });\r\n    return total;\r\n  }\r\n\r\n  /**\r\n   * Calcula o total de consumo de √ÅGUA COM FILTRO aplicado\r\n   * Considera apenas IDs v√°lidos (dos Aliases TB)\r\n   * @returns {number} - Total em m¬≥\r\n   */\r\n  function getFilteredTotalWaterConsumption() {\r\n    let total = 0;\r\n    waterCache.forEach((device, id) => {\r\n      // Apenas IDs v√°lidos (area comum ou lojas)\r\n      if (!waterValidIds.commonArea.has(id) && !waterValidIds.stores.has(id)) {\r\n        return;\r\n      }\r\n      // Aplica filtro de shopping\r\n      if (shouldIncludeDevice(device)) {\r\n        total += device.total_value || 0;\r\n      }\r\n    });\r\n    return total;\r\n  }\r\n\r\n  /**\r\n   * Agrega consumo de √°gua por shopping (customerId)\r\n   * Retorna array de { name, areaComum, lojas } para cada shopping\r\n   * Considera filtro de shoppings se aplicado\r\n   * @returns {Array<{name: string, areaComum: number, lojas: number}>}\r\n   */\r\n  function getWaterByShoppings() {\r\n    // Map<customerId, { name, areaComum, lojas }>\r\n    const shoppingMap = new Map();\r\n\r\n    // Helper para obter nome do shopping pelo customerId\r\n    function getShoppingName(customerId) {\r\n      if (window.custumersSelected && Array.isArray(window.custumersSelected)) {\r\n        const shopping = window.custumersSelected.find((c) => c.value === customerId);\r\n        if (shopping) return shopping.name;\r\n      }\r\n      // Fallback: primeiros 8 caracteres do ID\r\n      if (customerId) {\r\n        return `Shopping ${customerId.substring(0, 8)}...`;\r\n      }\r\n      return 'Desconhecido';\r\n    }\r\n\r\n    // Itera pelo cache de √°gua\r\n    waterCache.forEach((device, ingestionId) => {\r\n      // Apenas IDs v√°lidos (area comum ou lojas)\r\n      const isCommonArea = waterValidIds.commonArea.has(ingestionId);\r\n      const isStore = waterValidIds.stores.has(ingestionId);\r\n      if (!isCommonArea && !isStore) return;\r\n\r\n      // Aplica filtro de shopping se ativo\r\n      if (!shouldIncludeDevice(device)) return;\r\n\r\n      // Obt√©m customerId (shopping)\r\n      let customerId = device.customerId;\r\n      if (!customerId && window.myioDeviceToShoppingMap) {\r\n        customerId = window.myioDeviceToShoppingMap.get(device.ingestionId);\r\n      }\r\n      if (!customerId) return; // Ignora dispositivos sem shopping\r\n\r\n      // Inicializa entrada do shopping se n√£o existir\r\n      if (!shoppingMap.has(customerId)) {\r\n        shoppingMap.set(customerId, {\r\n          name: getShoppingName(customerId),\r\n          areaComum: 0,\r\n          lojas: 0,\r\n        });\r\n      }\r\n\r\n      const entry = shoppingMap.get(customerId);\r\n      const value = device.total_value || 0;\r\n\r\n      // Classifica como √°rea comum ou loja\r\n      if (isCommonArea) {\r\n        entry.areaComum += value;\r\n      } else if (isStore) {\r\n        entry.lojas += value;\r\n      }\r\n    });\r\n\r\n    // Converte Map para Array\r\n    const result = Array.from(shoppingMap.values());\r\n    LogHelper.log('[MAIN] [Orchestrator] Water by shoppings:', result.length, 'shoppings');\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Obt√©m dados agregados para o widget WATER\r\n   * @returns {object} - { filteredTotal, unfilteredTotal, commonArea, stores, isFiltered, shoppingsWater }\r\n   */\r\n  function getWaterWidgetData() {\r\n    const filteredTotal = getFilteredTotalWaterConsumption();\r\n    const unfilteredTotal = getUnfilteredTotalWaterConsumption();\r\n    const filtered = isFilterActive();\r\n\r\n    // Totais por categoria (com filtro)\r\n    let commonAreaFiltered = 0;\r\n    let storesFiltered = 0;\r\n    waterCache.forEach((device, id) => {\r\n      if (!shouldIncludeDevice(device)) return;\r\n      const value = device.total_value || 0;\r\n      if (waterValidIds.commonArea.has(id)) {\r\n        commonAreaFiltered += value;\r\n      } else if (waterValidIds.stores.has(id)) {\r\n        storesFiltered += value;\r\n      }\r\n    });\r\n\r\n    // Agrega√ß√£o por shopping para tooltip\r\n    const shoppingsWater = getWaterByShoppings();\r\n\r\n    const result = {\r\n      filteredTotal: Number(filteredTotal) || 0,\r\n      unfilteredTotal: Number(unfilteredTotal) || 0,\r\n      commonArea: Number(commonAreaFiltered) || 0,\r\n      stores: Number(storesFiltered) || 0,\r\n      deviceCount: waterCache.size,\r\n      isFiltered: filtered,\r\n      shoppingsWater: shoppingsWater,\r\n    };\r\n\r\n    LogHelper.log(`[MAIN] [Orchestrator] Water widget data:`, result);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Verifica se h√° filtro de shoppings ativo\r\n   * Considera que \"todos selecionados\" = sem filtro\r\n   * @returns {boolean} - True se h√° filtro aplicado (subconjunto selecionado)\r\n   */\r\n  function isFilterActive() {\r\n    // Se nenhum shopping selecionado, sem filtro\r\n    if (!selectedShoppingIds || selectedShoppingIds.length === 0) {\r\n      return false;\r\n    }\r\n    // Se todos os shoppings est√£o selecionados, tamb√©m √© \"sem filtro\"\r\n    if (totalShoppings > 0 && selectedShoppingIds.length >= totalShoppings) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Obt√©m dados agregados para o widget ENERGY\r\n   * @param {number} totalConsumption - Consumo TOTAL (Equipamentos + Lojas) vindo do HEADER (fallback)\r\n   * @returns {object} - { customerTotal, unfilteredTotal, equipmentsTotal, lojasTotal, percentage, isFiltered, shoppingsEnergy }\r\n   */\r\n  function getEnergyWidgetData(totalConsumption = 0) {\r\n    const equipmentsTotal = getTotalEquipmentsConsumption();\r\n    const lojasTotal = getTotalLojasConsumption();\r\n\r\n    // Total calculado = soma de equipamentos + lojas (dispositivos conhecidos)\r\n    const calculatedTotal = equipmentsTotal + lojasTotal;\r\n\r\n    // Se temos listas de IDs identificadas, usar o total calculado\r\n    // Sen√£o, usar o total vindo do HEADER (API completa)\r\n    const hasIdentifiedDevices = equipmentsIngestionIds.size > 0 || lojasIngestionIds.size > 0;\r\n    const effectiveTotal = hasIdentifiedDevices ? calculatedTotal : totalConsumption || calculatedTotal;\r\n\r\n    // RFC-0093: Get unfiltered total for comparison display\r\n    const unfilteredTotal = getUnfilteredTotalConsumption();\r\n    const filtered = isFilterActive();\r\n\r\n    // ‚úÖ Equipamentos como % do total\r\n    const percentage = effectiveTotal > 0 ? (equipmentsTotal / effectiveTotal) * 100 : 0;\r\n\r\n    // Agrega√ß√£o por shopping para tooltip\r\n    const shoppingsEnergy = getEnergyByShoppings();\r\n\r\n    const result = {\r\n      customerTotal: Number(effectiveTotal) || 0,\r\n      unfilteredTotal: Number(unfilteredTotal) || 0, // RFC-0093: Total without filter for comparison\r\n      equipmentsTotal: Number(equipmentsTotal) || 0,\r\n      lojasTotal: Number(lojasTotal) || 0,\r\n      difference: Number(lojasTotal) || 0, // Mant√©m compatibilidade (lojas = difference)\r\n      percentage: Number(percentage) || 0,\r\n      deviceCount: energyCache.size,\r\n      isFiltered: filtered, // RFC-0093: Flag indicating filter is active\r\n      shoppingsEnergy: shoppingsEnergy, // Array de { name, equipamentos, lojas } por shopping\r\n    };\r\n\r\n    LogHelper.log(`[MAIN] [Orchestrator] Energy widget data:`, {\r\n      ...result,\r\n      calculatedTotal,\r\n      hasIdentifiedDevices,\r\n      apiTotal: totalConsumption,\r\n    });\r\n    return result;\r\n  }\r\n\r\n  return {\r\n    fetchEnergyData,\r\n    fetchWaterData,\r\n    getCache,\r\n    getEnergyCache: getCache, // Alias for ENERGY widget compatibility\r\n    getWaterCache: () => getCache('water'), // Alias for WATER widget compatibility\r\n    getCachedDevice,\r\n    invalidateCache,\r\n    // RFC-0057: Removed clearStorageCache - no longer using localStorage\r\n    showGlobalBusy,\r\n    hideGlobalBusy,\r\n    getBusyState: () => ({ ...globalBusyState }),\r\n    getTotalEquipmentsConsumption,\r\n    getTotalLojasConsumption,\r\n    getTotalConsumption,\r\n    getTotalWaterConsumption,\r\n    getUnfilteredTotalConsumption,\r\n    getUnfilteredTotalWaterConsumption,\r\n    getFilteredTotalWaterConsumption,\r\n    isFilterActive,\r\n    getEnergyWidgetData,\r\n    getEnergyByShoppings,\r\n    getWaterWidgetData,\r\n    getWaterByShoppings,\r\n    getLastFetchTimestamp: () => lastFetchTimestamp, // RFC: Expor timestamp para deduplica√ß√£o\r\n    requestSummary() {\r\n      // Responde imediatamente com o que tiver no momento\r\n      const total = haveCustomerTotal() ? customerTotalConsumption : 0;\r\n      const summary = getEnergyWidgetData(total);\r\n      window.dispatchEvent(new CustomEvent('myio:energy-summary-ready', { detail: summary }));\r\n      LogHelper.log('[MAIN] [Orchestrator] ‚ñ∂ requestSummary() dispatched', summary);\r\n      return summary;\r\n    },\r\n    requestWaterSummary() {\r\n      // Responde imediatamente com dados de √°gua\r\n      const summary = getWaterWidgetData();\r\n      window.dispatchEvent(new CustomEvent('myio:water-summary-ready', { detail: summary }));\r\n      LogHelper.log('[MAIN] [Orchestrator] ‚ñ∂ requestWaterSummary() dispatched', summary);\r\n      return summary;\r\n    },\r\n\r\n    setCustomerTotal(total) {\r\n      const n = Number(total);\r\n      if (!Number.isFinite(n)) {\r\n        console.warn('[MAIN] [Orchestrator] setCustomerTotal ignorado (valor inv√°lido):', total);\r\n        return;\r\n      }\r\n      customerTotalConsumption = n;\r\n      LogHelper.log('[MAIN] [Orchestrator] customerTotalConsumption set to', n);\r\n      dispatchEnergySummaryIfReady('setCustomerTotal');\r\n    },\r\n\r\n    setLojasIngestionIds(ids) {\r\n      lojasIngestionIds = new Set(ids || []);\r\n      LogHelper.log('[MAIN] [Orchestrator] lojasIngestionIds set:', lojasIngestionIds.size, 'lojas');\r\n      // Recalculate and dispatch summary if ready\r\n      dispatchEnergySummaryIfReady('setLojasIngestionIds');\r\n    },\r\n\r\n    getLojasIngestionIds() {\r\n      return lojasIngestionIds;\r\n    },\r\n\r\n    setEquipmentsIngestionIds(ids) {\r\n      equipmentsIngestionIds = new Set(ids || []);\r\n      LogHelper.log(\r\n        '[MAIN] [Orchestrator] equipmentsIngestionIds set:',\r\n        equipmentsIngestionIds.size,\r\n        'equipments'\r\n      );\r\n      // Recalculate and dispatch summary if ready\r\n      dispatchEnergySummaryIfReady('setEquipmentsIngestionIds');\r\n    },\r\n\r\n    getEquipmentsIngestionIds() {\r\n      return equipmentsIngestionIds;\r\n    },\r\n\r\n    /**\r\n     * Define o total de shoppings dispon√≠veis (para determinar \"todos selecionados\")\r\n     * @param {number} total - Total de shoppings\r\n     */\r\n    setTotalShoppings(total) {\r\n      totalShoppings = Number(total) || 0;\r\n      LogHelper.log('[MAIN] [Orchestrator] Total shoppings set to:', totalShoppings);\r\n    },\r\n\r\n    /**\r\n     * Aplica filtro de shoppings selecionados\r\n     * @param {Array<string>} shoppingIds - Array de ingestionIds dos shoppings\r\n     */\r\n    setSelectedShoppings(shoppingIds) {\r\n      selectedShoppingIds = Array.isArray(shoppingIds) ? shoppingIds : [];\r\n\r\n      // Auto-detect totalShoppings from ctx.data customers if not set\r\n      if (totalShoppings === 0) {\r\n        // Try to get from extracted shoppings\r\n        const extractedShoppings = getShoppings();\r\n        if (extractedShoppings && extractedShoppings.length > 0) {\r\n          totalShoppings = extractedShoppings.length;\r\n          LogHelper.log('[MAIN] [Orchestrator] Auto-detected totalShoppings from extracted:', totalShoppings);\r\n        }\r\n      }\r\n\r\n      const isFiltered = isFilterActive();\r\n      LogHelper.log(\r\n        '[MAIN] [Orchestrator] Shopping filter applied:',\r\n        !isFiltered ? 'ALL (no filter)' : `${selectedShoppingIds.length}/${totalShoppings} shoppings selected`\r\n      );\r\n      if (selectedShoppingIds.length > 0) {\r\n        LogHelper.log('[MAIN] [Orchestrator] Selected shopping IDs:', selectedShoppingIds);\r\n      }\r\n      // Recalculate and dispatch summary with filter applied\r\n      dispatchEnergySummaryIfReady('setSelectedShoppings');\r\n\r\n      // RFC: Also dispatch water summary when filter changes\r\n      if (typeof getWaterWidgetData === 'function') {\r\n        const waterSummary = getWaterWidgetData();\r\n        window.dispatchEvent(new CustomEvent('myio:water-summary-ready', { detail: waterSummary }));\r\n        LogHelper.log(\r\n          '[MAIN] [Orchestrator] üîî water-summary-ready dispatched (setSelectedShoppings)',\r\n          waterSummary\r\n        );\r\n      }\r\n\r\n      // Notify HEADER and other widgets that filter was updated in orchestrator\r\n      window.dispatchEvent(\r\n        new CustomEvent('myio:orchestrator-filter-updated', {\r\n          detail: {\r\n            selectedShoppingIds,\r\n            isFiltered: isFiltered,\r\n            totalShoppings: totalShoppings,\r\n          },\r\n        })\r\n      );\r\n      LogHelper.log('[MAIN] [Orchestrator] ‚úÖ Dispatched myio:orchestrator-filter-updated');\r\n    },\r\n\r\n    // ===== WATER: Fun√ß√µes para registro de IDs v√°lidos =====\r\n    registerWaterDeviceIds,\r\n    getWaterTotals,\r\n    getWaterValidIds,\r\n    recalculateWaterTotals,\r\n\r\n    // ===== ENERGY: Fun√ß√µes para registro de IDs v√°lidos =====\r\n    registerEnergyDeviceIds,\r\n    getEnergyValidIds,\r\n\r\n    // ===== RFC-0102: ENERGY DEVICES METADATA + CLASSIFICATION =====\r\n    extractEnergyDevicesMetadata,\r\n    getLojasDevices,\r\n    getEquipmentDevices,\r\n    getAllEnergyDevices,\r\n    getEnergyDevice,\r\n    isDevicesClassified: () => classifiedDevices.all.length > 0,\r\n\r\n    // ===== RFC-0100: TEMPERATURE functions =====\r\n    fetchTemperatureData,\r\n    fetchTemperatureDayAverages,\r\n    getTemperatureCache,\r\n    getTemperatureRanges,\r\n    getTemperatureAverages,\r\n    recalculateTemperatureFiltered,\r\n\r\n    // ===== RFC-0100: SHOPPING functions =====\r\n    extractShoppings,\r\n    getShoppings,\r\n    dispatchShoppingsData,\r\n  };\r\n})();\r\n\r\n// Expose globally\r\nwindow.MyIOOrchestrator = MyIOOrchestrator;\r\n\r\n// ===== WATER: Processar datasources TB e registrar IDs v√°lidos =====\r\n// Esta fun√ß√£o deve ser chamada quando os dados do TB estiverem dispon√≠veis (onDataUpdated)\r\n\r\n// Cache global dos dados de √°gua do TB para acesso direto pelos widgets\r\nlet waterTbDataCache = {\r\n  commonArea: { datasources: [], data: [], ids: [] },\r\n  stores: { datasources: [], data: [], ids: [] },\r\n  loaded: false,\r\n};\r\n\r\nfunction processWaterDatasourcesFromTB() {\r\n  const datasources = self.ctx?.datasources || [];\r\n  const data = self.ctx?.data || [];\r\n\r\n  if (datasources.length === 0) {\r\n    LogHelper.log('[MAIN] processWaterDatasourcesFromTB: No datasources available yet');\r\n    return;\r\n  }\r\n\r\n  // Extrair IDs do alias 'HidrometrosAreaComum'\r\n  const commonAreaDatasources = datasources.filter((ds) => ds.aliasName === 'HidrometrosAreaComum');\r\n  const commonAreaData = data.filter((d) => d?.datasource?.aliasName === 'HidrometrosAreaComum');\r\n  const commonAreaIds = extractIngestionIdsFromTBData(commonAreaDatasources, commonAreaData);\r\n\r\n  // Extrair IDs do alias 'Todos Hidrometros Lojas'\r\n  const storesDatasources = datasources.filter((ds) => ds.aliasName === 'Todos Hidrometros Lojas');\r\n  const storesData = data.filter((d) => d?.datasource?.aliasName === 'Todos Hidrometros Lojas');\r\n  const storesIds = extractIngestionIdsFromTBData(storesDatasources, storesData);\r\n\r\n  LogHelper.log(\r\n    `[MAIN] Water datasources from TB: commonArea=${commonAreaIds.length}, stores=${storesIds.length}`\r\n  );\r\n\r\n  // Atualizar cache global para acesso direto\r\n  waterTbDataCache = {\r\n    commonArea: { datasources: commonAreaDatasources, data: commonAreaData, ids: commonAreaIds },\r\n    stores: { datasources: storesDatasources, data: storesData, ids: storesIds },\r\n    loaded: commonAreaIds.length > 0 || storesIds.length > 0,\r\n  };\r\n\r\n  // Registrar no Orchestrator\r\n  if (commonAreaIds.length > 0 && window.MyIOOrchestrator?.registerWaterDeviceIds) {\r\n    window.MyIOOrchestrator.registerWaterDeviceIds('commonArea', commonAreaIds);\r\n  }\r\n  if (storesIds.length > 0 && window.MyIOOrchestrator?.registerWaterDeviceIds) {\r\n    window.MyIOOrchestrator.registerWaterDeviceIds('stores', storesIds);\r\n  }\r\n\r\n  // Disponibilizar dados completos para widgets via evento\r\n  if (commonAreaIds.length > 0 || storesIds.length > 0) {\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:water-tb-data-ready', {\r\n        detail: {\r\n          commonArea: { datasources: commonAreaDatasources, data: commonAreaData, ids: commonAreaIds },\r\n          stores: { datasources: storesDatasources, data: storesData, ids: storesIds },\r\n          timestamp: Date.now(),\r\n        },\r\n      })\r\n    );\r\n    LogHelper.log('[MAIN] Dispatched myio:water-tb-data-ready');\r\n  }\r\n}\r\n\r\n/**\r\n * Retorna os dados de √°gua do TB para widgets que inicializam depois do evento\r\n */\r\nfunction getWaterTbData() {\r\n  return waterTbDataCache;\r\n}\r\n\r\n// Expor getWaterTbData globalmente via MyIOUtils\r\nwindow.MyIOUtils = window.MyIOUtils || {};\r\nwindow.MyIOUtils.getWaterTbData = getWaterTbData;\r\n\r\n// ===== ENERGY: Processar datasources TB e registrar IDs v√°lidos =====\r\n// Esta fun√ß√£o deve ser chamada quando os dados do TB estiverem dispon√≠veis (onDataUpdated)\r\n\r\n// Cache global dos dados de energia do TB para acesso direto pelos widgets\r\nlet energyTbDataCache = {\r\n  devices: { datasources: [], data: [], ids: [] },\r\n  loaded: false,\r\n};\r\n\r\nfunction processEnergyDatasourcesFromTB() {\r\n  const datasources = self.ctx?.datasources || [];\r\n  const data = self.ctx?.data || [];\r\n\r\n  if (datasources.length === 0) {\r\n    LogHelper.log('[MAIN] processEnergyDatasourcesFromTB: No datasources available yet');\r\n    return;\r\n  }\r\n\r\n  // Extrair IDs do alias 'Equipamentos e Lojas'\r\n  const energyDatasources = datasources.filter((ds) => ds.aliasName === 'Equipamentos e Lojas');\r\n  const energyData = data.filter((d) => d?.datasource?.aliasName === 'Equipamentos e Lojas');\r\n  const energyIds = extractIngestionIdsFromTBData(energyDatasources, energyData);\r\n\r\n  LogHelper.log(`[MAIN] Energy datasources from TB: devices=${energyIds.length}`);\r\n\r\n  // Atualizar cache global para acesso direto\r\n  energyTbDataCache = {\r\n    devices: { datasources: energyDatasources, data: energyData, ids: energyIds },\r\n    loaded: energyIds.length > 0,\r\n  };\r\n\r\n  // Registrar no Orchestrator\r\n  if (energyIds.length > 0 && window.MyIOOrchestrator?.registerEnergyDeviceIds) {\r\n    window.MyIOOrchestrator.registerEnergyDeviceIds(energyIds);\r\n  }\r\n\r\n  // Disponibilizar dados completos para widgets via evento\r\n  if (energyIds.length > 0) {\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:energy-tb-data-ready', {\r\n        detail: {\r\n          devices: { datasources: energyDatasources, data: energyData, ids: energyIds },\r\n          timestamp: Date.now(),\r\n        },\r\n      })\r\n    );\r\n    LogHelper.log('[MAIN] Dispatched myio:energy-tb-data-ready');\r\n  }\r\n\r\n  // RFC-0102: Extract full TB metadata and classify devices (lojas vs equipments)\r\n  if (window.MyIOOrchestrator?.extractEnergyDevicesMetadata) {\r\n    window.MyIOOrchestrator.extractEnergyDevicesMetadata();\r\n    LogHelper.log('[MAIN] processEnergyDatasourcesFromTB: Called extractEnergyDevicesMetadata()');\r\n  }\r\n}\r\n\r\n/**\r\n * Retorna os dados de energia do TB para widgets que inicializam depois do evento\r\n */\r\nfunction getEnergyTbData() {\r\n  return energyTbDataCache;\r\n}\r\n\r\n// Expor getEnergyTbData globalmente via MyIOUtils\r\nwindow.MyIOUtils.getEnergyTbData = getEnergyTbData;\r\n\r\n/**\r\n * Extrai ingestionIds dos dados do ThingsBoard\r\n * Busca pelo atributo 'ingestionid' nos dados\r\n */\r\nfunction extractIngestionIdsFromTBData(datasources, data) {\r\n  const ids = new Set();\r\n\r\n  // M√©todo 1: Usar MyIO.buildListItemsThingsboardByUniqueDatasource se dispon√≠vel\r\n  if (typeof MyIOLibrary?.buildListItemsThingsboardByUniqueDatasource === 'function') {\r\n    const items = MyIOLibrary.buildListItemsThingsboardByUniqueDatasource(datasources, data) || [];\r\n    items.forEach((item) => {\r\n      if (item?.id) ids.add(item.id);\r\n    });\r\n  }\r\n\r\n  // M√©todo 2: Extrair diretamente dos dados (fallback)\r\n  if (ids.size === 0) {\r\n    data.forEach((row) => {\r\n      const key = String(row?.dataKey?.name || '').toLowerCase();\r\n      const val = row?.data?.[0]?.[1];\r\n      if (key === 'ingestionid' && val) {\r\n        ids.add(String(val));\r\n      }\r\n    });\r\n  }\r\n\r\n  return Array.from(ids);\r\n}\r\n// HEADER ‚Üí informa total do cliente (use o evento que seu HEADER emitir)\r\nwindow.addEventListener('myio:header-summary-ready', (ev) => {\r\n  // Tenta chaves comuns\r\n  const d = ev.detail || {};\r\n  const candidate = d.customerTotal ?? d.total ?? d.totalConsumption ?? d.kwh ?? d.value;\r\n  LogHelper.log('[MAIN] heard myio:header-summary-ready:', d, 'candidate=', candidate);\r\n  if (typeof window.MyIOOrchestrator?.setCustomerTotal === 'function') {\r\n    window.MyIOOrchestrator.setCustomerTotal(candidate);\r\n  }\r\n});\r\n\r\n// Alternativa caso o HEADER use outro nome de evento\r\nwindow.addEventListener('myio:customer-total-ready', (ev) => {\r\n  const n = ev.detail?.total;\r\n  LogHelper.log('[MAIN] heard myio:customer-total-ready:', ev.detail);\r\n  if (typeof window.MyIOOrchestrator?.setCustomerTotal === 'function') {\r\n    window.MyIOOrchestrator.setCustomerTotal(n);\r\n  }\r\n});\r\n\r\n// ‚úÖ HEADER emite myio:customer-total-consumption\r\nwindow.addEventListener('myio:customer-total-consumption', (ev) => {\r\n  const n = ev.detail?.customerTotal;\r\n  LogHelper.log('[MAIN] heard myio:customer-total-consumption:', ev.detail, 'customerTotal=', n);\r\n  if (typeof window.MyIOOrchestrator?.setCustomerTotal === 'function') {\r\n    window.MyIOOrchestrator.setCustomerTotal(n);\r\n  }\r\n});\r\n\r\n// ‚úÖ MENU emite myio:filter-applied com shoppings selecionados\r\nwindow.addEventListener('myio:filter-applied', (ev) => {\r\n  LogHelper.log('[MAIN] heard myio:filter-applied:', ev.detail);\r\n\r\n  // Extract shopping IDs from selection\r\n  // ev.detail.selection is an array of { name, value } where value is the ingestionId\r\n  const selection = ev.detail?.selection || [];\r\n  LogHelper.log('selection', selection);\r\n\r\n  const shoppingIds = selection.map((s) => s.value).filter((v) => v);\r\n\r\n  LogHelper.log('[MAIN] Applying shopping filter:', shoppingIds.length === 0 ? 'ALL' : shoppingIds);\r\n\r\n  if (typeof window.MyIOOrchestrator?.setSelectedShoppings === 'function') {\r\n    window.MyIOOrchestrator.setSelectedShoppings(shoppingIds);\r\n  }\r\n});\r\n\r\n// ENERGY ‚Üí pode pedir o resumo explicitamente\r\nwindow.addEventListener('myio:request-energy-summary', () => {\r\n  if (typeof window.MyIOOrchestrator?.requestSummary === 'function') {\r\n    window.MyIOOrchestrator.requestSummary();\r\n  }\r\n});\r\n\r\n// ‚úÖ WATER widget ‚Üí solicita dados de √°gua do cache ou busca na API\r\nwindow.addEventListener('myio:request-water-data', async (ev) => {\r\n  LogHelper.log('[MAIN] Received myio:request-water-data from:', ev.detail?.requestor);\r\n\r\n  // Check if orchestrator and auth are ready\r\n  if (!window.MyIOOrchestrator || !CUSTOMER_INGESTION_ID) {\r\n    LogHelper.warn('[MAIN] Orchestrator or credentials not ready for water data request');\r\n    return;\r\n  }\r\n\r\n  // Get current period from global state\r\n  const startDate = window.__MYIO_CURRENT_START_DATE__;\r\n  const endDate = window.__MYIO_CURRENT_END_DATE__;\r\n\r\n  if (!startDate || !endDate) {\r\n    LogHelper.warn('[MAIN] No date range set for water data request');\r\n    return;\r\n  }\r\n\r\n  try {\r\n    // Fetch water data (will use cache if available)\r\n    const waterCache = await window.MyIOOrchestrator.fetchWaterData(\r\n      CUSTOMER_INGESTION_ID,\r\n      startDate,\r\n      endDate\r\n    );\r\n\r\n    LogHelper.log('[MAIN] Water data fetched/cached:', waterCache?.size || 0, 'devices');\r\n\r\n    // Event is already dispatched by fetchWaterData, but dispatch again for late subscribers\r\n    if (waterCache && waterCache.size > 0) {\r\n      window.dispatchEvent(\r\n        new CustomEvent('myio:water-data-ready', {\r\n          detail: {\r\n            cache: waterCache,\r\n            totalDevices: waterCache.size,\r\n            startDate,\r\n            endDate,\r\n            timestamp: Date.now(),\r\n            fromCache: true,\r\n          },\r\n        })\r\n      );\r\n    }\r\n  } catch (err) {\r\n    LogHelper.error('[MAIN] Error fetching water data:', err);\r\n  }\r\n});\r\n\r\n// ‚úÖ EQUIPMENTS ‚Üí informa quais devices s√£o lojas (3F_MEDIDOR)\r\nwindow.addEventListener('myio:lojas-identified', (ev) => {\r\n  const ids = ev.detail?.lojasIngestionIds || [];\r\n  LogHelper.log('[MAIN] heard myio:lojas-identified:', ev.detail);\r\n  if (typeof window.MyIOOrchestrator?.setLojasIngestionIds === 'function') {\r\n    window.MyIOOrchestrator.setLojasIngestionIds(ids);\r\n  }\r\n});\r\n\r\n// ‚úÖ EQUIPMENTS ‚Üí informa quais devices s√£o equipamentos\r\nwindow.addEventListener('myio:equipments-identified', (ev) => {\r\n  const ids = ev.detail?.equipmentsIngestionIds || [];\r\n  LogHelper.log('[MAIN] heard myio:equipments-identified:', ev.detail);\r\n  if (typeof window.MyIOOrchestrator?.setEquipmentsIngestionIds === 'function') {\r\n    window.MyIOOrchestrator.setEquipmentsIngestionIds(ids);\r\n  }\r\n});\r\n\r\nwindow.addEventListener('myio:customers-ready', async (_ev) => {\r\n  // TODO: implementar C√°lculo de temperatura por customer\r\n  // LogHelper.log(\"[MAIN] heard myio:customers-ready<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<:\", ev.detail);\r\n  // const devicesList = extractDevicesWithDetails(ctx.data);\r\n  // const customersList = ev.detail?.customersList || [];\r\n  // const TemperatureMap = getTemperatureReportByCustomer(devicesList, customersList);\r\n});\r\n\r\n// ===== RFC-0100: TEMPERATURE event listeners =====\r\n\r\n// Request temperature data from HEADER or other widgets\r\nwindow.addEventListener('myio:request-temperature-data', async (ev) => {\r\n  LogHelper.log('[MAIN] RFC-0100: Received myio:request-temperature-data', ev.detail);\r\n\r\n  // Get date range from global state or event detail\r\n  let startTs = ev.detail?.startTs;\r\n  let endTs = ev.detail?.endTs;\r\n\r\n  if (!startTs || !endTs) {\r\n    // Fallback to global date state\r\n    startTs = window.__MYIO_CURRENT_START_DATE__\r\n      ? new Date(window.__MYIO_CURRENT_START_DATE__).getTime()\r\n      : Date.now() - 30 * 24 * 60 * 60 * 1000; // Default: last 30 days\r\n    endTs = window.__MYIO_CURRENT_END_DATE__\r\n      ? new Date(window.__MYIO_CURRENT_END_DATE__).getTime()\r\n      : Date.now();\r\n  }\r\n\r\n  if (typeof window.MyIOOrchestrator?.fetchTemperatureData === 'function') {\r\n    await window.MyIOOrchestrator.fetchTemperatureData(startTs, endTs);\r\n  }\r\n});\r\n\r\n// Recalculate temperature data when filter is applied (no API call - reuse cached data)\r\nwindow.addEventListener('myio:filter-applied', (ev) => {\r\n  // Temperature data will be recalculated from cache with new filter\r\n  const tempCache = window.MyIOOrchestrator?.getTemperatureCache?.();\r\n  if (tempCache && tempCache.averages) {\r\n    LogHelper.log('[MAIN] RFC-0100: Recalculating temperature data after filter change (no API call)');\r\n    window.MyIOOrchestrator.recalculateTemperatureFiltered();\r\n  }\r\n});\r\n\r\n// Refresh temperature data when date range changes\r\nwindow.addEventListener('myio:update-date', async (ev) => {\r\n  const { startDate, endDate } = ev.detail || {};\r\n  if (startDate && endDate) {\r\n    const startTs = new Date(startDate).getTime();\r\n    const endTs = new Date(endDate).getTime();\r\n    LogHelper.log('[MAIN] RFC-0100: Refreshing temperature data after date change');\r\n    await window.MyIOOrchestrator.fetchTemperatureData(startTs, endTs);\r\n  }\r\n});\r\n\r\n// ===== RFC-0100: SHOPPING event listeners =====\r\n\r\n// Request shopping data from HEADER or other widgets\r\nwindow.addEventListener('myio:request-shoppings-data', () => {\r\n  LogHelper.log('[MAIN] RFC-0100: Received myio:request-shoppings-data');\r\n  if (typeof window.MyIOOrchestrator?.dispatchShoppingsData === 'function') {\r\n    window.MyIOOrchestrator.dispatchShoppingsData();\r\n  }\r\n});\r\n\r\nLogHelper.log('[MyIOOrchestrator] Initialized');\r\n\r\n// ‚úÖ Check if filter was already applied before MAIN initialized\r\nif (\r\n  window.custumersSelected &&\r\n  Array.isArray(window.custumersSelected) &&\r\n  window.custumersSelected.length > 0\r\n) {\r\n  LogHelper.log('[MAIN] üîÑ Applying pre-existing filter:', window.custumersSelected.length, 'shoppings');\r\n  const shoppingIds = window.custumersSelected.map((s) => s.value).filter((v) => v);\r\n  if (typeof window.MyIOOrchestrator?.setSelectedShoppings === 'function') {\r\n    window.MyIOOrchestrator.setSelectedShoppings(shoppingIds);\r\n  }\r\n}\r\n\r\n// ===== RFC: updateTotalConsumption moved from MENU =====\r\n/**\r\n * Atualiza o card de energia total com consumo dos customers selecionados\r\n * @param {Array} customersArray - Array de customers {name, value}\r\n * @param {string} startDateISO - Data in√≠cio ISO\r\n * @param {string} endDateISO - Data fim ISO\r\n */\r\nasync function updateTotalConsumption(customersArray, startDateISO, endDateISO) {\r\n  // RFC-0093: Guard against undefined myIOAuth (widget destroyed or not initialized)\r\n  if (!myIOAuth || typeof myIOAuth.getToken !== 'function') {\r\n    //LogHelper.warn('[MAIN] updateTotalConsumption: myIOAuth not available, skipping');\r\n    return;\r\n  }\r\n\r\n  const energyTotal = document.getElementById('energy-kpi');\r\n  if (!energyTotal) {\r\n    LogHelper.warn('[MAIN] energy-kpi element not found');\r\n    return;\r\n  }\r\n\r\n  energyTotal.innerHTML = `\r\n    <svg style=\"width:28px; height:28px; animation: spin 1s linear infinite;\" viewBox=\"0 0 50 50\">\r\n      <circle cx=\"25\" cy=\"25\" r=\"20\" fill=\"none\" stroke=\"#6c2fbf\" stroke-width=\"5\" stroke-linecap=\"round\"\r\n              stroke-dasharray=\"90,150\" stroke-dashoffset=\"0\">\r\n      </circle>\r\n    </svg>\r\n  `;\r\n\r\n  let totalConsumption = 0;\r\n\r\n  for (const c of customersArray) {\r\n    if (!c.value) continue;\r\n\r\n    try {\r\n      const TOKEN_INGESTION = await myIOAuth.getToken();\r\n\r\n      const response = await fetch(\r\n        `${getDataApiHost()}/api/v1/telemetry/customers/${\r\n          c.value\r\n        }/energy/total?startTime=${encodeURIComponent(startDateISO)}&endTime=${encodeURIComponent(\r\n          endDateISO\r\n        )}`,\r\n        {\r\n          method: 'GET',\r\n          headers: {\r\n            Authorization: `Bearer ${TOKEN_INGESTION}`,\r\n            'Content-Type': 'application/json',\r\n          },\r\n        }\r\n      );\r\n\r\n      if (!response.ok) throw new Error(`Erro na API: ${response.status}`);\r\n      const data = await response.json();\r\n\r\n      totalConsumption += data.total_value;\r\n    } catch (err) {\r\n      console.error(`Falha ao buscar dados do customer ${c.value}:`, err);\r\n    }\r\n  }\r\n\r\n  const percentDiference = document.getElementById('energy-trend');\r\n\r\n  energyTotal.innerText = `${MyIOLibrary.formatEnergy(totalConsumption)}`;\r\n  if (percentDiference) {\r\n    percentDiference.innerText = `‚Üë 100%`;\r\n    percentDiference.style.color = 'red';\r\n  }\r\n\r\n  //LogHelper.log('[MAIN] updateTotalConsumption completed:', totalConsumption);\r\n}\r\n\r\n// ===== RFC: Listen for request to update total consumption from MENU =====\r\nwindow.addEventListener('myio:request-total-consumption', async (ev) => {\r\n  //LogHelper.log('[MAIN] Received myio:request-total-consumption:', ev.detail);\r\n\r\n  const { customersArray, startDateISO, endDateISO } = ev.detail || {};\r\n\r\n  if (!customersArray || !startDateISO || !endDateISO) {\r\n    LogHelper.warn('[MAIN] Invalid parameters for updateTotalConsumption');\r\n    return;\r\n  }\r\n\r\n  await updateTotalConsumption(customersArray, startDateISO, endDateISO);\r\n});\r\n\r\n// ===== RFC: updateTotalWaterConsumption moved from HEADER =====\r\n/**\r\n * Atualiza o card de √°gua total com consumo dos customers selecionados\r\n * @param {Array} customersArray - Array de customers {name, value}\r\n * @param {string} startDateISO - Data in√≠cio ISO\r\n * @param {string} endDateISO - Data fim ISO\r\n */\r\nasync function updateTotalWaterConsumption(customersArray, startDateISO, endDateISO) {\r\n  // RFC-0093: Guard against undefined myIOAuth (widget destroyed or not initialized)\r\n  if (!myIOAuth || typeof myIOAuth.getToken !== 'function') {\r\n    //LogHelper.warn('[MAIN] updateTotalWaterConsumption: myIOAuth not available, skipping');\r\n    return;\r\n  }\r\n\r\n  const waterTotal = document.getElementById('water-kpi');\r\n  if (!waterTotal) {\r\n    LogHelper.warn('[MAIN] water-kpi element not found');\r\n    return;\r\n  }\r\n\r\n  waterTotal.innerHTML = `\r\n    <svg style=\"width:28px; height:28px; animation: spin 1s linear infinite;\" viewBox=\"0 0 50 50\">\r\n      <circle cx=\"25\" cy=\"25\" r=\"20\" fill=\"none\" stroke=\"#6c2fbf\" stroke-width=\"5\" stroke-linecap=\"round\"\r\n              stroke-dasharray=\"90,150\" stroke-dashoffset=\"0\">\r\n      </circle>\r\n    </svg>\r\n  `;\r\n\r\n  let totalConsumption = 0;\r\n\r\n  for (const c of customersArray) {\r\n    if (!c.value) continue;\r\n\r\n    try {\r\n      const TOKEN_INGESTION = await myIOAuth.getToken();\r\n\r\n      const response = await fetch(\r\n        `${getDataApiHost()}/api/v1/telemetry/customers/${c.value}/water/total?startTime=${encodeURIComponent(\r\n          startDateISO\r\n        )}&endTime=${encodeURIComponent(endDateISO)}`,\r\n        {\r\n          method: 'GET',\r\n          headers: {\r\n            Authorization: `Bearer ${TOKEN_INGESTION}`,\r\n            'Content-Type': 'application/json',\r\n          },\r\n        }\r\n      );\r\n\r\n      if (!response.ok) throw new Error(`Erro na API: ${response.status}`);\r\n      const data = await response.json();\r\n\r\n      totalConsumption += data.total_value;\r\n    } catch (err) {\r\n      console.error(`Falha ao buscar dados de √°gua do customer ${c.value}:`, err);\r\n    }\r\n  }\r\n\r\n  waterTotal.innerText = `${MyIOLibrary.formatWaterVolumeM3(totalConsumption)}`;\r\n\r\n  // RFC-0087: Dispatch water data to water widgets\r\n  // Note: In the future, this should be split by common area vs stores\r\n  window.dispatchEvent(\r\n    new CustomEvent('myio:water-data-ready', {\r\n      detail: {\r\n        source: 'WATER_COMMON_AREA',\r\n        data: {\r\n          totalDevices: customersArray.length,\r\n          totalConsumption: totalConsumption * 0.4, // Placeholder split - adjust based on actual API\r\n          onlineDevices: customersArray.length,\r\n          offlineDevices: 0,\r\n        },\r\n      },\r\n    })\r\n  );\r\n\r\n  window.dispatchEvent(\r\n    new CustomEvent('myio:water-data-ready', {\r\n      detail: {\r\n        source: 'WATER_STORES',\r\n        data: {\r\n          totalDevices: customersArray.length,\r\n          totalConsumption: totalConsumption * 0.6, // Placeholder split - adjust based on actual API\r\n          onlineDevices: customersArray.length,\r\n          offlineDevices: 0,\r\n        },\r\n      },\r\n    })\r\n  );\r\n\r\n  //LogHelper.log('[MAIN] RFC-0087: Water data dispatched to widgets, total:', totalConsumption);\r\n}\r\n\r\n// ===== RFC: Listen for request to update water consumption =====\r\nwindow.addEventListener('myio:request-total-water-consumption', async (ev) => {\r\n  //LogHelper.log('[MAIN] Received myio:request-total-water-consumption:', ev.detail);\r\n\r\n  const { customersArray, startDateISO, endDateISO } = ev.detail || {};\r\n\r\n  if (!customersArray || !startDateISO || !endDateISO) {\r\n    LogHelper.warn('[MAIN] Invalid parameters for updateTotalWaterConsumption');\r\n    return;\r\n  }\r\n\r\n  await updateTotalWaterConsumption(customersArray, startDateISO, endDateISO);\r\n});\r\n\r\nself.onInit = async function () {\r\n  // ===== STEP 1: Get ThingsBoard Customer ID and fetch credentials =====\r\n  CUSTOMER_ID_TB = self.ctx.settings.customerId;\r\n  self.ctx.$scope.mainContentStateId = 'content_equipments';\r\n\r\n  // RFC-0086: Get DATA_API_HOST from settings and expose globally\r\n  const dataApiHost = self.ctx.settings.dataApiHost;\r\n  if (!dataApiHost) {\r\n    LogHelper.error('[MAIN] [RFC-0086] dataApiHost not found in settings');\r\n  } else {\r\n    window.__MYIO_DATA_API_HOST__ = dataApiHost;\r\n    LogHelper.log('[MAIN] [RFC-0086] DATA_API_HOST set:', dataApiHost);\r\n  }\r\n\r\n  // RFC-0091: Get delayTimeConnectionInMins from settings (required - no fallback)\r\n  const delayTimeConnectionInMins = self.ctx.settings.delayTimeConnectionInMins;\r\n  if (delayTimeConnectionInMins === undefined || delayTimeConnectionInMins === null) {\r\n    LogHelper.error(\r\n      '[MAIN] [RFC-0091] delayTimeConnectionInMins n√£o informado em settings. Configure o valor nas configura√ß√µes do widget.'\r\n    );\r\n  }\r\n  window.__MYIO_DELAY_TIME_CONNECTION_MINS__ = delayTimeConnectionInMins;\r\n  LogHelper.log('[MAIN] [RFC-0091] delayTimeConnectionInMins:', delayTimeConnectionInMins);\r\n\r\n  if (!CUSTOMER_ID_TB) {\r\n    console.error('[MAIN] [Orchestrator] customerId n√£o encontrado em settings');\r\n    return;\r\n  }\r\n\r\n  // Expor customerId globalmente para outros widgets (ex: MENU)\r\n  window.myioHoldingCustomerId = CUSTOMER_ID_TB;\r\n\r\n  LogHelper.log('[MAIN] [Orchestrator] ThingsBoard Customer ID:', CUSTOMER_ID_TB);\r\n\r\n  // Fetch customer attributes from ThingsBoard\r\n  const customerAttrs = await fetchCustomerServerScopeAttrs(CUSTOMER_ID_TB);\r\n\r\n  CUSTOMER_INGESTION_ID = customerAttrs.customerIngestionId || customerAttrs.ingestionId;\r\n  CLIENT_ID_INGESTION = customerAttrs.clientIdIngestion || customerAttrs.client_id;\r\n  CLIENT_SECRET_INGESTION = customerAttrs.clientSecretIngestion || customerAttrs.client_secret;\r\n\r\n  if (!CUSTOMER_INGESTION_ID || !CLIENT_ID_INGESTION || !CLIENT_SECRET_INGESTION) {\r\n    console.error('[MAIN] [Orchestrator] Credenciais de Ingestion n√£o encontradas:', {\r\n      customerIngestionId: CUSTOMER_INGESTION_ID,\r\n      hasClientId: !!CLIENT_ID_INGESTION,\r\n      hasClientSecret: !!CLIENT_SECRET_INGESTION,\r\n    });\r\n    return;\r\n  }\r\n\r\n  LogHelper.log('[MAIN] [Orchestrator] Ingestion credentials loaded:', {\r\n    customerIngestionId: CUSTOMER_INGESTION_ID,\r\n    clientId: CLIENT_ID_INGESTION,\r\n  });\r\n\r\n  // RFC-0058: Expose credentials globally for FOOTER widget\r\n  window.__MYIO_CLIENT_ID__ = CLIENT_ID_INGESTION;\r\n  window.__MYIO_CLIENT_SECRET__ = CLIENT_SECRET_INGESTION;\r\n  window.__MYIO_CUSTOMER_INGESTION_ID__ = CUSTOMER_INGESTION_ID;\r\n  // RFC-0086: DATA_API_HOST now comes from WELCOME widget\r\n\r\n  // ===== STEP 2: Initialize MyIO Auth Component =====\r\n  // Check if MyIOLibrary is available\r\n  if (typeof MyIOLibrary === 'undefined' || !MyIOLibrary.buildMyioIngestionAuth) {\r\n    console.error(\r\n      '[MAIN] [Orchestrator] MyIOLibrary n√£o est√° dispon√≠vel. Verifique se a biblioteca foi carregada corretamente.'\r\n    );\r\n    return;\r\n  }\r\n\r\n  myIOAuth = MyIOLibrary.buildMyioIngestionAuth({\r\n    dataApiHost: getDataApiHost(),\r\n    clientId: CLIENT_ID_INGESTION,\r\n    clientSecret: CLIENT_SECRET_INGESTION,\r\n  });\r\n\r\n  LogHelper.log('[MAIN] [Orchestrator] MyIO Auth initialized');\r\n\r\n  // -- util: aplica no $scope e roda digest\r\n  function applyParams(p) {\r\n    self.ctx.$scope.startDateISO = p?.globalStartDateFilter || null;\r\n    self.ctx.$scope.endDateISO = p?.globalEndDateFilter || null;\r\n    if (self.ctx?.$scope?.$applyAsync) self.ctx.$scope.$applyAsync();\r\n  }\r\n\r\n  // -- util: espera at√© ter datas (evento + polling), sem bloquear\r\n  function waitForDateParams({ pollMs = 300, timeoutMs = 15000 } = {}) {\r\n    return new Promise((resolve) => {\r\n      let resolved = false;\r\n      let poller = null;\r\n      let timer = null;\r\n\r\n      const tryResolve = (p) => {\r\n        const s = p?.globalStartDateFilter || null;\r\n        const e = p?.globalEndDateFilter || null;\r\n        if (s && e) {\r\n          resolved = true;\r\n          cleanup();\r\n          applyParams(p);\r\n          resolve({ start: s, end: e, from: 'state/event' });\r\n          return true;\r\n        }\r\n        return false;\r\n      };\r\n\r\n      const onEvt = (ev) => {\r\n        LogHelper.log('[MAIN] DATE-PARAMS', ev);\r\n        tryResolve(ev.detail);\r\n      };\r\n\r\n      const cleanup = () => {\r\n        window.removeEventListener('myio:date-params', onEvt);\r\n        if (poller) clearInterval(poller);\r\n        if (timer) clearTimeout(timer);\r\n      };\r\n\r\n      // 1) escuta evento do pai\r\n      window.addEventListener('myio:date-params', onEvt);\r\n\r\n      // 2) tenta estado atual imediatamente\r\n      if (tryResolve(window.myioStateParams || {})) return;\r\n\r\n      // 3) solicita explicitamente ao pai\r\n      window.dispatchEvent(new CustomEvent('myio:request-date-params'));\r\n\r\n      // 4) polling leve a cada 300ms\r\n      poller = setInterval(() => {\r\n        tryResolve(window.myioStateParams || {});\r\n      }, pollMs);\r\n\r\n      // 5) timeout de seguran√ßa -> usa fallback (√∫ltimos 7 dias)\r\n      timer = setTimeout(() => {\r\n        if (!resolved) {\r\n          cleanup();\r\n          // RFC: Fix - Usar in√≠cio do dia (00:00:00) e fim do dia (23:59:59)\r\n          const end = new Date();\r\n          end.setHours(23, 59, 59, 999); // Fim do dia de hoje\r\n\r\n          const start = new Date(end.getTime() - 7 * 24 * 60 * 60 * 1000);\r\n          start.setHours(0, 0, 0, 0); // In√≠cio do dia 7 dias atr√°s\r\n\r\n          const startISO = start.toISOString();\r\n          const endISO = end.toISOString();\r\n          applyParams({\r\n            globalStartDateFilter: startISO,\r\n            globalEndDateFilter: endISO,\r\n          });\r\n          resolve({ start: startISO, end: endISO, from: 'fallback-7d' });\r\n        }\r\n      }, timeoutMs);\r\n    });\r\n  }\r\n\r\n  // ===== ORCHESTRATOR: Listen for date updates from MENU =====\r\n  window.addEventListener('myio:update-date', async (ev) => {\r\n    LogHelper.log('[MAIN] [Orchestrator] Date update received:', ev.detail);\r\n    const { startDate, endDate } = ev.detail;\r\n\r\n    if (startDate && endDate) {\r\n      // Store dates globally for other widgets (WATER, etc.) to access\r\n      window.__MYIO_CURRENT_START_DATE__ = startDate;\r\n      window.__MYIO_CURRENT_END_DATE__ = endDate;\r\n\r\n      // Update scope\r\n      applyParams({\r\n        globalStartDateFilter: startDate,\r\n        globalEndDateFilter: endDate,\r\n      });\r\n\r\n      // RFC: Deduplica√ß√£o - s√≥ busca se n√£o houver cache v√°lido recente\r\n      // Evita chamadas duplicadas quando MENU dispara evento E MAIN j√° fez fetch inicial\r\n      if (CUSTOMER_INGESTION_ID) {\r\n        const lastTimestamp = MyIOOrchestrator.getLastFetchTimestamp();\r\n        const cacheAge = lastTimestamp ? Date.now() - lastTimestamp : Infinity;\r\n        const CACHE_FRESHNESS_MS = 5000; // 5 segundos\r\n\r\n        if (cacheAge > CACHE_FRESHNESS_MS) {\r\n          LogHelper.log('[MAIN] [Orchestrator] Cache stale or missing, fetching data...');\r\n          // Chamadas em sequ√™ncia\r\n          await MyIOOrchestrator.fetchEnergyData(CUSTOMER_INGESTION_ID, startDate, endDate);\r\n          await MyIOOrchestrator.fetchWaterData(CUSTOMER_INGESTION_ID, startDate, endDate);\r\n        } else {\r\n          LogHelper.log(`[MAIN] [Orchestrator] Skipping fetch - cache is fresh (age: ${cacheAge}ms)`);\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  window.addEventListener('myio:filter-params', (ev) => {\r\n    LogHelper.log('[EQUIPAMENTS]filtro', ev.detail);\r\n  });\r\n\r\n  // RFC-0079: Listen for state switch requests from widgets (MENU, EQUIPMENTS sub-menu, etc.)\r\n  window.addEventListener('myio:switch-main-state', (ev) => {\r\n    LogHelper.log(`[MAIN] [RFC-0079] üîî Received myio:switch-main-state event:`, ev.detail);\r\n\r\n    const targetStateId = ev.detail?.targetStateId;\r\n    const source = ev.detail?.source || 'unknown';\r\n\r\n    LogHelper.log(`[MAIN] [RFC-0079] State switch requested: ${targetStateId} (source: ${source})`);\r\n\r\n    if (!targetStateId) {\r\n      console.warn('[MAIN] [RFC-0079] ‚ùå No targetStateId provided in switch event');\r\n      return;\r\n    }\r\n\r\n    const mainView = document.getElementById('mainView');\r\n    if (!mainView) {\r\n      console.error('[MAIN] [RFC-0079] ‚ùå mainView element not found');\r\n      return;\r\n    }\r\n\r\n    LogHelper.log(`[MAIN] [RFC-0079] üìã Found mainView element:`, mainView);\r\n\r\n    // Hide all states\r\n    const allStates = mainView.querySelectorAll('[data-content-state]');\r\n    LogHelper.log(\r\n      `[MAIN] [RFC-0079] üîç Found ${allStates.length} content states:`,\r\n      Array.from(allStates).map((s) => s.getAttribute('data-content-state'))\r\n    );\r\n\r\n    allStates.forEach((stateDiv) => {\r\n      const stateName = stateDiv.getAttribute('data-content-state');\r\n      stateDiv.style.display = 'none';\r\n      LogHelper.log(`[MAIN] [RFC-0079] üëÅÔ∏è Hiding state: ${stateName}`);\r\n    });\r\n\r\n    // Show target state\r\n    const targetState = mainView.querySelector(`[data-content-state=\"${targetStateId}\"]`);\r\n    LogHelper.log(\r\n      `[MAIN] [RFC-0079] üéØ Looking for state: ${targetStateId}`,\r\n      targetState ? 'FOUND' : 'NOT FOUND'\r\n    );\r\n\r\n    if (targetState) {\r\n      targetState.style.display = 'block';\r\n      LogHelper.log(\r\n        `[MAIN] [RFC-0079] ‚úÖ Switched to state: ${targetStateId} (display: ${targetState.style.display})`\r\n      );\r\n\r\n      // Update scope if needed\r\n      if (self.ctx?.$scope) {\r\n        self.ctx.$scope.mainContentStateId = targetStateId;\r\n        if (self.ctx.$scope.$applyAsync) {\r\n          self.ctx.$scope.$applyAsync();\r\n        }\r\n        LogHelper.log(`[MAIN] [RFC-0079] üìù Updated scope.mainContentStateId to: ${targetStateId}`);\r\n      }\r\n    } else {\r\n      console.error(`[MAIN] [RFC-0079] ‚ùå Target state \"${targetStateId}\" not found in DOM`);\r\n      LogHelper.log(\r\n        `[MAIN] [RFC-0079] Available states:`,\r\n        Array.from(allStates).map((s) => s.getAttribute('data-content-state'))\r\n      );\r\n    }\r\n  });\r\n\r\n  // ====== fluxo do widget ======\r\n  // tenta aplicar o que j√° existir (n√£o bloqueia)\r\n  applyParams(window.myioStateParams || {});\r\n\r\n  // garante sincroniza√ß√£o inicial antes de continuar\r\n  const datesFromParent = await waitForDateParams({\r\n    pollMs: 300,\r\n    timeoutMs: 15000,\r\n  });\r\n\r\n  LogHelper.log('[EQUIPMENTS] date params ready:', datesFromParent);\r\n\r\n  // Store dates globally for other widgets (WATER, etc.) to access\r\n  if (self.ctx.$scope.startDateISO && self.ctx.$scope.endDateISO) {\r\n    window.__MYIO_CURRENT_START_DATE__ = self.ctx.$scope.startDateISO;\r\n    window.__MYIO_CURRENT_END_DATE__ = self.ctx.$scope.endDateISO;\r\n    LogHelper.log(\r\n      '[MAIN] Global dates initialized:',\r\n      window.__MYIO_CURRENT_START_DATE__,\r\n      window.__MYIO_CURRENT_END_DATE__\r\n    );\r\n  }\r\n\r\n  // agora j√° pode carregar dados / inicializar UI dependente de datas\r\n  if (typeof self.loadData === 'function') {\r\n    await self.loadData(self.ctx.$scope.startDateISO, self.ctx.$scope.endDateISO);\r\n  }\r\n\r\n  //LogHelper.log(\"[EQUIPAMENTS] scope\", scope.ctx)\r\n\r\n  // mant√©m sincronizado em updates futuros do pai/irm√£o A\r\n  self._onDateParams = (ev) => {\r\n    applyParams(ev.detail);\r\n\r\n    if (typeof self.loadData === 'function') {\r\n      self.loadData(self.ctx.$scope.startDateISO, self.ctx.$scope.endDateISO);\r\n    }\r\n  };\r\n  window.addEventListener('myio:date-params', self._onDateParams);\r\n\r\n  // ===== ORCHESTRATOR: Initial setup =====\r\n  LogHelper.log('[MAIN] [Orchestrator] Initial setup with Ingestion Customer ID:', CUSTOMER_INGESTION_ID);\r\n  LogHelper.log('[MAIN] [Orchestrator] Date range:', {\r\n    start: datesFromParent.start,\r\n    end: datesFromParent.end,\r\n  });\r\n\r\n  // RFC: Check if MENU already dispatched myio:update-date before we were ready\r\n  // This handles the race condition where MENU fires the event before MAIN registers the listener\r\n  if (window.myioDateRange && window.myioDateRange.startDate && window.myioDateRange.endDate) {\r\n    LogHelper.log(\r\n      '[MAIN] [Orchestrator] Found existing date range from MENU, triggering initial fetch:',\r\n      window.myioDateRange\r\n    );\r\n    // Dispatch internal event to trigger fetch via existing listener\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:update-date', {\r\n        detail: {\r\n          startDate: window.myioDateRange.startDate,\r\n          endDate: window.myioDateRange.endDate,\r\n        },\r\n      })\r\n    );\r\n  } else {\r\n    LogHelper.log('[MAIN] [Orchestrator] Waiting for myio:update-date event from MENU to fetch data...');\r\n  }\r\n\r\n  // Processar datasources de √°gua do TB para registrar IDs v√°lidos no Orchestrator\r\n  processWaterDatasourcesFromTB();\r\n\r\n  // Processar datasources de energia do TB para registrar IDs v√°lidos no Orchestrator\r\n  processEnergyDatasourcesFromTB();\r\n};\r\n\r\nself.onDataUpdated = function () {\r\n  // Reprocessar datasources de √°gua quando os dados do TB forem atualizados\r\n  //processWaterDatasourcesFromTB();\r\n};\r\n\r\nself.onDestroy = function () {\r\n  if (self._onDateParams) {\r\n    window.removeEventListener('myio:date-params', self._onDateParams);\r\n  }\r\n};\r\n",
      "settingsSchema": "{\r\n  \"schema\": {\r\n    \"type\": \"object\",\r\n    \"title\": \"Settings\",\r\n    \"properties\": {\r\n      \"customerId\": {\r\n        \"type\": \"string\",\r\n        \"title\": \"customerId\"\r\n      },\r\n      \"dataApiHost\": {\r\n        \"type\": \"string\",\r\n        \"title\": \"Data API Host\",\r\n        \"default\": \"https://api.data.apps.myio-bas.com\",\r\n        \"description\": \"RFC-0086: Base URL for the MyIO Data API. Used by all widgets for API calls.\"\r\n      },\r\n      \"delayTimeConnectionInMins\": {\r\n        \"type\": \"number\",\r\n        \"title\": \"Delay Time Connection (minutes)\",\r\n        \"default\": 60,\r\n        \"description\": \"RFC-0091: Delay time in minutes for connection status probation period. Devices connected for less than this time are considered offline.\"\r\n      }\r\n    },\r\n    \"required\": [\"customerId\", \"dataApiHost\"]\r\n  }\r\n}\r\n",
      "dataKeySettingsSchema": "{}\n",
      "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Widget Head Office - MAIN - v.5.2.0\",\"decimals\":null}"
    },
    "externalId": null,
    "resources": null,
    "id": {
      "entityType": "WIDGET_TYPE",
      "id": "9034dc80-c977-11f0-84a2-1f4ed3957b2a"
    },
    "scada": false,
    "tags": null
  },
  "relations": [],
  "attributes": {
    "SERVER_SCOPE": []
  }
}