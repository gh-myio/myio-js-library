{
  "entityType": "WIDGET_TYPE",
  "entity": {
    "fqn": "widget_head_office_stores_v_5_2_0",
    "name": "Widget Head Office - STORES  - v.5.2.0",
    "deprecated": false,
    "image": null,
    "description": null,
    "descriptor": {
      "type": "latest",
      "sizeX": 7.5,
      "sizeY": 3,
      "resources": [
        {
          "url": "https://graphs.staging.apps.myio-bas.com/sdk/energy-chart-sdk.umd.js"
        },
        {
          "url": "https://unpkg.com/myio-js-library@0.1.180/dist/myio-js-library.umd.min.js"
        },
        {
          "url": "https://cdn.jsdelivr.net/npm/chart.js"
        }
      ],
      "templateHtml": "<section class=\"shops-root\" id=\"storesWrap\">\r\n  <!-- RFC-0079: Sub-menu removed - now controlled by MENU widget -->\r\n\r\n  <div class=\"toolbar-zoom\">\r\n    <div class=\"shopping-filter-chips\" id=\"storesShoppingFilterChips\"></div>\r\n  </div>\r\n\r\n  <!-- RFC-0093: Header injected dynamically via buildHeaderDevicesGrid -->\r\n  <div id=\"storesHeaderContainer\"></div>\r\n\r\n  <section id=\"shopsList\" class=\"shops-list\"></section>\r\n\r\n  <!-- RFC-0090: Filter Modal injected dynamically via createFilterModal -->\r\n</section>\r\n",
      "templateCss": "/* ====== TOKENS (escopo no wrap) - matching EQUIPMENTS ====== */\r\n.shops-root {\r\n  /* escala global de fontes (ajustada via JS) */\r\n  --fs: 0.94;\r\n\r\n  /* cores e layout */\r\n  --card-grad: linear-gradient(180deg, #ffffff 0%, #f7fbff 100%);\r\n  --card-bd: #dde7f1;\r\n  --ink-1: #1c2743;\r\n  --ink-2: #6b7a90;\r\n  --blue: #1f6fb5;\r\n  --accent: #9fc131;\r\n  --danger: #e54848;\r\n  --shadow: 0 8px 24px rgba(31, 116, 164, 0.08);\r\n  --shadow-hover: 0 14px 36px rgba(31, 116, 164, 0.16);\r\n  --radius: 20px;\r\n  --brand: #3e1a7d;\r\n  --brand-ghost: rgba(62, 26, 125, 0.08);\r\n\r\n  /* tipografia derivada da escala */\r\n  --fs-2xs: calc(11px * var(--fs));\r\n  --fs-xs: calc(12px * var(--fs));\r\n  --fs-sm: calc(13px * var(--fs));\r\n  --fs-md: calc(14px * var(--fs));\r\n  --fs-lg: calc(16px * var(--fs));\r\n  --fs-xl: calc(20px * var(--fs));\r\n  --fs-xxl: calc(28px * var(--fs));\r\n\r\n  /* padding para n√£o \"encostar\" no contorno do widget */\r\n  position: relative;\r\n  box-sizing: border-box;\r\n  padding: 12px;\r\n  width: 100%;\r\n  height: 100%;\r\n  overflow: auto;\r\n  background: transparent;\r\n}\r\n\r\n/* ====== RFC-0079: SUB-MENU NAVIGATION ====== */\r\n.shops-root .equipments-submenu {\r\n  display: flex;\r\n  gap: 8px;\r\n  padding: 12px 16px;\r\n  background: linear-gradient(to bottom, #f8f9fa, #ffffff);\r\n  border-bottom: 2px solid #e0e0e0;\r\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\r\n  margin: -12px -12px 16px -12px;\r\n}\r\n\r\n.shops-root .submenu-tab {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n  padding: 10px 20px;\r\n  background: #ffffff;\r\n  border: 1px solid #d0d0d0;\r\n  border-radius: 6px;\r\n  color: #424242;\r\n  font-size: var(--fs-md);\r\n  font-weight: 500;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n  outline: none;\r\n}\r\n\r\n.shops-root .submenu-tab:hover {\r\n  background: #f5f5f5;\r\n  border-color: var(--brand);\r\n  color: var(--brand);\r\n}\r\n\r\n.shops-root .submenu-tab.is-active {\r\n  background: linear-gradient(135deg, #7a2ff7, #5a1fd1);\r\n  color: #ffffff;\r\n  border-color: #7a2ff7;\r\n  box-shadow: 0 2px 8px rgba(122, 47, 247, 0.3);\r\n}\r\n\r\n.shops-root .submenu-tab .ico {\r\n  font-size: var(--fs-lg);\r\n  line-height: 1;\r\n}\r\n\r\n/* RFC-0093: Header CSS now injected from MAIN via injectHeaderAndModalCSS() */\r\n\r\n/* ====== CONTROLES DE ZOOM ====== */\r\n.shops-root .toolbar-zoom {\r\n  position: sticky;\r\n  top: 6px;\r\n  z-index: 2;\r\n  display: flex;\r\n  gap: 6px;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  margin-bottom: 8px;\r\n}\r\n\r\n.shops-root .toolbar-zoom button {\r\n  border: 1px solid var(--card-bd);\r\n  background: #fff;\r\n  border-radius: 10px;\r\n  padding: 4px 10px;\r\n  font-size: var(--fs-lg);\r\n  color: var(--ink-1);\r\n  cursor: pointer;\r\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);\r\n}\r\n\r\n.shops-root .toolbar-zoom button:hover {\r\n  background: #f3f8fc;\r\n}\r\n\r\n/* ====== SHOPPING FILTER CHIPS ====== */\r\n.shops-root .shopping-filter-chips {\r\n  display: flex;\r\n  gap: 6px;\r\n  flex-wrap: wrap;\r\n  align-items: center;\r\n  flex: 1;\r\n  margin-right: 12px;\r\n}\r\n\r\n.shops-root .shopping-filter-chips .filter-chip {\r\n  display: inline-flex;\r\n  align-items: center;\r\n  gap: 6px;\r\n  background: linear-gradient(135deg, #e0f2fe 0%, #dbeafe 100%);\r\n  border: 1px solid #bae6fd;\r\n  border-radius: 8px;\r\n  padding: 3px 8px;\r\n  font-size: var(--fs-xs);\r\n  color: #0c4a6e;\r\n  font-weight: 500;\r\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);\r\n  white-space: nowrap;\r\n}\r\n\r\n.shops-root .shopping-filter-chips .filter-chip-icon {\r\n  font-size: 10px;\r\n  opacity: 0.7;\r\n}\r\n\r\n/* ====== CARDS GRID (matching EQUIPMENTS) ====== */\r\n.shops-root .shops-list {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\r\n  gap: 16px;\r\n  margin-top: 24px;\r\n  padding-bottom: 100px;\r\n}\r\n\r\n.shops-root .shops-list > * {\r\n  min-width: 0;\r\n  width: auto;\r\n  box-sizing: border-box;\r\n}\r\n\r\n/* Responsive grid - matching EQUIPMENTS */\r\n@media (min-width: 1920px) {\r\n  .shops-root .shops-list {\r\n    grid-template-columns: repeat(6, 1fr);\r\n    gap: 14px;\r\n  }\r\n}\r\n\r\n@media (min-width: 1600px) and (max-width: 1919px) {\r\n  .shops-root .shops-list {\r\n    grid-template-columns: repeat(5, 1fr);\r\n    gap: 15px;\r\n  }\r\n}\r\n\r\n@media (min-width: 1280px) and (max-width: 1599px) {\r\n  .shops-root .shops-list {\r\n    grid-template-columns: repeat(5, 1fr);\r\n    gap: 14px;\r\n  }\r\n}\r\n\r\n@media (min-width: 1024px) and (max-width: 1279px) {\r\n  .shops-root .shops-list {\r\n    grid-template-columns: repeat(4, 1fr);\r\n    gap: 16px;\r\n  }\r\n}\r\n\r\n@media (max-width: 1023px) {\r\n  .shops-root .shops-list {\r\n    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\r\n    gap: 12px;\r\n  }\r\n}\r\n\r\n/* RFC-0093: Filter actions, search, modal, and button styles now injected from MAIN via injectHeaderAndModalCSS() */\r\n\r\n/* ====== LOADING OVERLAY ====== */\r\n.shops-root .stores-loading-overlay {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  background: rgba(255, 255, 255, 0.95);\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  z-index: 1000;\r\n  backdrop-filter: blur(4px);\r\n}\r\n\r\n.shops-root .loading-spinner {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  gap: 16px;\r\n}\r\n\r\n.shops-root .loading-spinner p {\r\n  font-size: var(--fs-md);\r\n  font-weight: 600;\r\n  color: var(--ink-1);\r\n  margin: 0;\r\n}\r\n\r\n/* ====== SCROLLBAR ====== */\r\n.shops-root .shops-list::-webkit-scrollbar {\r\n  width: 8px;\r\n}\r\n\r\n.shops-root .shops-list::-webkit-scrollbar-thumb {\r\n  background: #c9d4e2;\r\n  border-radius: 6px;\r\n}\r\n\r\n/* ====== CARD ACTIONS (side buttons) ====== */\r\n.shops-root .device-card-centered .card-actions {\r\n  top: 50% !important;\r\n  transform: translateY(-50%) !important;\r\n  left: 12px !important;\r\n  gap: 10px !important;\r\n}\r\n\r\n.shops-root .device-card-centered .card-action {\r\n  width: 38px !important;\r\n  height: 38px !important;\r\n  min-width: 38px;\r\n  min-height: 38px;\r\n  border-radius: 12px !important;\r\n}\r\n\r\n.shops-root .device-card-centered .card-action img {\r\n  width: 20px !important;\r\n  height: 20px !important;\r\n}\r\n\r\n/* ====== ANIMATIONS ====== */\r\n@keyframes fadeIn {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n@keyframes spin {\r\n  0% {\r\n    transform: rotate(0deg);\r\n  }\r\n  100% {\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n\r\n/* RFC-0093: Modal styling now injected from MAIN via injectHeaderAndModalCSS() */\r\n\r\n/* Responsive: Stack tabs vertically on mobile */\r\n@media (max-width: 768px) {\r\n  .shops-root .equipments-submenu {\r\n    flex-direction: column;\r\n    gap: 6px;\r\n    padding: 10px 12px;\r\n  }\r\n\r\n  .shops-root .submenu-tab {\r\n    width: 100%;\r\n    justify-content: flex-start;\r\n    padding: 12px 16px;\r\n  }\r\n}\r\n",
      "controllerScript": "/* =========================================================================\r\n * ThingsBoard Widget: Device Cards with Totals & Percentages (MyIO)\r\n * - Datas obrigat√≥rias: startDateISO / endDateISO\r\n * - Se ausentes no onInit: usa \"current month so far\" (1¬∫ dia 00:00 ‚Üí hoje 23:59)\r\n * - Modal premium (busy) no widget durante carregamentos\r\n * - Modal premium global (fora do widget) para sucesso, com contador e reload\r\n * - onDataUpdated: no-op\r\n * - Evento (myio:update-date): mostra modal + atualiza\r\n * =========================================================================*/\r\n\r\n/* eslint-disable no-undef, no-unused-vars */\r\n\r\n// ============================================\r\n// SHARED UTILITIES (from MAIN via window.MyIOUtils)\r\n// ============================================\r\nconst LogHelper = window.MyIOUtils?.LogHelper || {\r\n  log: (...args) => console.log(...args),\r\n  warn: (...args) => console.warn(...args),\r\n  error: (...args) => console.error(...args),\r\n};\r\n\r\nconst getDataApiHost = () => {\r\n  const host = window.MyIOUtils?.DATA_API_HOST;\r\n  if (!host) {\r\n    console.error('[STORES] DATA_API_HOST not available - MAIN widget not loaded');\r\n  }\r\n  return host || '';\r\n};\r\n\r\n// RFC-0071: Device Profile functions (from MAIN)\r\nconst fetchDeviceProfiles =\r\n  window.MyIOUtils?.fetchDeviceProfiles ||\r\n  (() => {\r\n    console.error('[STORES] fetchDeviceProfiles not available - MAIN widget not loaded');\r\n    return Promise.resolve(new Map());\r\n  });\r\n\r\nconst fetchDeviceDetails =\r\n  window.MyIOUtils?.fetchDeviceDetails ||\r\n  (() => {\r\n    console.error('[STORES] fetchDeviceDetails not available - MAIN widget not loaded');\r\n    return Promise.resolve({});\r\n  });\r\n\r\nconst addDeviceProfileAttribute =\r\n  window.MyIOUtils?.addDeviceProfileAttribute ||\r\n  (() => {\r\n    console.error('[STORES] addDeviceProfileAttribute not available - MAIN widget not loaded');\r\n    return Promise.resolve({ ok: false, status: 0, data: null });\r\n  });\r\n\r\nconst syncDeviceProfileAttributes =\r\n  window.MyIOUtils?.syncDeviceProfileAttributes ||\r\n  (() => {\r\n    console.error('[STORES] syncDeviceProfileAttributes not available - MAIN widget not loaded');\r\n    return Promise.resolve({ synced: 0, skipped: 0, errors: 0 });\r\n  });\r\n\r\n// RFC-0090: UI Helper from MAIN (replaces local getCustomerNameForDevice)\r\nconst getCustomerNameForDevice =\r\n  window.MyIOUtils?.getCustomerNameForDevice ||\r\n  ((device) => {\r\n    console.error('[STORES] getCustomerNameForDevice not available - MAIN widget not loaded');\r\n    return device?.customerId ? `ID: ${device.customerId.substring(0, 8)}...` : 'N/A';\r\n  });\r\n\r\n// RFC-0091: Device status calculation functions from MAIN\r\nconst getConsumptionRangesHierarchical = window.MyIOUtils?.getConsumptionRangesHierarchical;\r\nconst mapConnectionStatus = window.MyIOUtils?.mapConnectionStatus || ((status) => status || 'offline');\r\n\r\n// RFC-0091: formatarDuracao for operationHours calculation (from MAIN)\r\nconst formatarDuracao = window.MyIOUtils?.formatarDuracao || ((ms) => `${Math.round(ms / 1000)}s`);\r\n\r\n// RFC-0091: Global MAP_INSTANTANEOUS_POWER (will be loaded from settings if available)\r\nlet MAP_INSTANTANEOUS_POWER = null;\r\n\r\nLogHelper.log('üöÄ [STORES] Controller loaded - VERSION WITH ORCHESTRATOR SUPPORT');\r\n\r\nconst MAX_FIRST_HYDRATES = 1;\r\n\r\nlet __deviceProfileSyncComplete = false;\r\n\r\n// RFC-0093: Centralized header controller\r\nlet storesHeaderController = null;\r\n\r\n// RFC-0090: getData REMOVED - was defined but never used in STORES\r\n\r\nlet dateUpdateHandler = null;\r\nlet dataProvideHandler = null; // RFC-0042: Orchestrator data listener\r\n//let DEVICE_TYPE = \"energy\";\r\nlet MyIO = null;\r\nlet hasRequestedInitialData = false; // Flag to prevent duplicate initial requests\r\nlet lastProcessedPeriodKey = null; // Track last processed periodKey to prevent duplicate processing\r\nlet busyTimeoutId = null; // Timeout ID for busy fallback\r\n\r\n// RFC-0042: Widget configuration (from settings)\r\nlet WIDGET_DOMAIN = 'energy'; // Will be set in onInit\r\n\r\n// RFC-0063: Classification mode configuration\r\nlet USE_IDENTIFIER_CLASSIFICATION = false; // Flag to enable identifier-based classification\r\nlet USE_HYBRID_CLASSIFICATION = false; // Flag to enable hybrid mode (identifier + labels)\r\n\r\n// Card rendering options (from settings, with defaults)\r\nlet USE_NEW_COMPONENTS = true;\r\nlet ENABLE_SELECTION = true;\r\nlet ENABLE_DRAG_DROP = true;\r\nlet HIDE_INFO_MENU_ITEM = true;\r\nlet DEBUG_ACTIVE = false;\r\nlet ACTIVE_TOOLTIP_DEBUG = false;\r\n\r\n/** ===================== STATE ===================== **/\r\nlet CLIENT_ID = '';\r\nlet CLIENT_SECRET = '';\r\nlet CUSTOMER_ING_ID = '';\r\nlet MyIOAuth = null;\r\n\r\nconst STATE = {\r\n  itemsBase: [], // lista autoritativa (TB)\r\n  itemsEnriched: [], // lista com totals + perc\r\n  searchActive: false,\r\n  searchTerm: '',\r\n  selectedIds: /** @type {Set<string> | null} */ (null),\r\n  sortMode: /** @type {'cons_desc'|'cons_asc'|'alpha_asc'|'alpha_desc'} */ ('cons_desc'),\r\n  firstHydrates: 0,\r\n  selectedShoppingIds: [], // RFC-0093: Shopping filter from MENU\r\n};\r\n\r\nlet hydrating = false;\r\n\r\n/** ===================== HELPERS (DOM) ===================== **/\r\nconst $root = () => $(self.ctx.$container[0]);\r\nconst $list = () => $root().find('#shopsList');\r\nconst $count = () => $root().find('#shopsCount');\r\nconst $total = () => $root().find('#shopsTotal');\r\nconst $modal = () => $root().find('#filterModal');\r\n\r\n/** ===================== BUSY MODAL (no widget) ===================== **/\r\nconst BUSY_ID = 'myio-busy-modal';\r\nfunction ensureBusyModalDOM() {\r\n  let $m = $root().find(`#${BUSY_ID}`);\r\n  if ($m.length) return $m;\r\n\r\n  const html = `\r\n  <div id=\"${BUSY_ID}\" style=\"\r\n      position:absolute; inset:0; display:none;\r\n      background: rgba(150,132,181,0.45); /* #9684B5 com transpar√™ncia */\r\n      backdrop-filter: blur(5px);\r\n      z-index:9999; align-items:center; justify-content:center;\r\n      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;\">\r\n    <div style=\"\r\n        background:#2d1458; color:#fff;\r\n        border:1px solid rgba(255,255,255,0.10);\r\n        box-shadow:0 12px 40px rgba(0,0,0,.35);\r\n        border-radius:18px; padding:22px 26px; min-width:320px;\">\r\n      <div style=\"display:flex; align-items:center; gap:12px;\">\r\n        <div class=\"spinner\" style=\"\r\n            width:22px;height:22px;border-radius:50%;\r\n            border:3px solid rgba(255,255,255,.25);\r\n            border-top-color:#ffffff; animation:spin .9s linear infinite;\"></div>\r\n        <div id=\"${BUSY_ID}-msg\" style=\"font-weight:600; font-size:14px; letter-spacing:.2px;\">\r\n          aguarde.. carregando os dados...\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <style>\r\n    @keyframes spin { from{transform:rotate(0)} to{transform:rotate(360deg)} }\r\n  </style>`;\r\n  $root().css('position', 'relative'); // garante overlay correto\r\n  $root().append(html);\r\n  return $root().find(`#${BUSY_ID}`);\r\n}\r\n// RFC-0044: Use centralized busy management\r\nfunction showBusy(message, timeoutMs = 35000) {\r\n  LogHelper.log(`[TELEMETRY] üîÑ showBusy() called with message: \"${message || 'default'}\"`);\r\n\r\n  // Prevent multiple simultaneous busy calls\r\n  if (window.busyInProgress) {\r\n    LogHelper.log(`[TELEMETRY] ‚è≠Ô∏è Skipping duplicate showBusy() call`);\r\n    return;\r\n  }\r\n\r\n  window.busyInProgress = true;\r\n\r\n  // Centralized busy with enhanced synchronization\r\n  const safeShowBusy = () => {\r\n    try {\r\n      if (window.MyIOOrchestrator && typeof window.MyIOOrchestrator.showGlobalBusy === 'function') {\r\n        const text = (message && String(message).trim()) || 'Carregando dados...';\r\n        window.MyIOOrchestrator.showGlobalBusy(WIDGET_DOMAIN, text, timeoutMs);\r\n        LogHelper.log(`[TELEMETRY] ‚úÖ Using centralized busy for domain: ${WIDGET_DOMAIN}`);\r\n      } else {\r\n        LogHelper.warn(`[TELEMETRY] ‚ö†Ô∏è Orchestrator not available, using fallback busy`);\r\n        const $m = ensureBusyModalDOM();\r\n        const text = (message && String(message).trim()) || 'aguarde.. carregando os dados...';\r\n        $m.find(`#${BUSY_ID}-msg`).text(text);\r\n        $m.css('display', 'flex');\r\n      }\r\n    } catch (err) {\r\n      LogHelper.error(`[TELEMETRY] ‚ùå Error in showBusy:`, err);\r\n    } finally {\r\n      // Always reset busy flag after a short delay\r\n      setTimeout(() => {\r\n        window.busyInProgress = false;\r\n      }, 500);\r\n    }\r\n  };\r\n}\r\n\r\nfunction hideBusy() {\r\n  LogHelper.log(`[TELEMETRY] ‚è∏Ô∏è hideBusy() called`);\r\n\r\n  const safeHideBusy = () => {\r\n    try {\r\n      if (window.MyIOOrchestrator && typeof window.MyIOOrchestrator.hideGlobalBusy === 'function') {\r\n        window.MyIOOrchestrator.hideGlobalBusy();\r\n        LogHelper.log(`[TELEMETRY] ‚úÖ Using centralized hideBusy`);\r\n      } else {\r\n        LogHelper.warn(`[TELEMETRY] ‚ö†Ô∏è Orchestrator not available, using fallback hideBusy`);\r\n        $root().find(`#${BUSY_ID}`).css('display', 'none');\r\n      }\r\n    } catch (err) {\r\n      LogHelper.error(`[TELEMETRY] ‚ùå Error in hideBusy:`, err);\r\n    } finally {\r\n      window.busyInProgress = false;\r\n    }\r\n  };\r\n\r\n  // RFC-0051.3: Check if orchestrator exists and is ready\r\n  const checkOrchestratorReady = async () => {\r\n    // First, check if orchestrator exists and is ready\r\n    if (window.MyIOOrchestrator?.isReady) {\r\n      safeHideBusy();\r\n      return;\r\n    }\r\n\r\n    // Wait for orchestrator ready event (with timeout)\r\n    const ready = await new Promise((resolve) => {\r\n      let timeout;\r\n      let interval;\r\n\r\n      // Listen for ready event\r\n      const handler = () => {\r\n        clearTimeout(timeout);\r\n        clearInterval(interval);\r\n        window.removeEventListener('myio:orchestrator:ready', handler);\r\n        resolve(true);\r\n      };\r\n\r\n      window.addEventListener('myio:orchestrator:ready', handler);\r\n\r\n      // Timeout after 5 seconds\r\n      timeout = setTimeout(() => {\r\n        clearInterval(interval);\r\n        window.removeEventListener('myio:orchestrator:ready', handler);\r\n        LogHelper.warn('[TELEMETRY] ‚ö†Ô∏è Orchestrator ready timeout after 5s, using fallback');\r\n        resolve(false);\r\n      }, 5000);\r\n\r\n      // Also poll isReady flag (fallback if event is missed)\r\n      interval = setInterval(() => {\r\n        if (window.MyIOOrchestrator?.isReady) {\r\n          clearInterval(interval);\r\n          clearTimeout(timeout);\r\n          window.removeEventListener('myio:orchestrator:ready', handler);\r\n          resolve(true);\r\n        }\r\n      }, 100);\r\n    });\r\n\r\n    safeHideBusy();\r\n  };\r\n\r\n  checkOrchestratorReady();\r\n}\r\n\r\n// RFC-0090: findValue REMOVED - was defined but never used in STORES\r\n\r\n/** ===================== GLOBAL SUCCESS MODAL (fora do widget) ===================== **/\r\nconst G_SUCCESS_ID = 'myio-global-success-modal';\r\nlet gSuccessTimer = null;\r\n\r\nfunction ensureGlobalSuccessModalDOM() {\r\n  let el = document.getElementById(G_SUCCESS_ID);\r\n  if (el) return el;\r\n\r\n  const wrapper = document.createElement('div');\r\n  wrapper.id = G_SUCCESS_ID;\r\n  wrapper.setAttribute(\r\n    'style',\r\n    `\r\n    position: fixed; inset: 0; display: none;\r\n    z-index: 999999; \r\n    background: rgba(150,132,181,0.45); /* #9684B5 com transpar√™ncia */\r\n    backdrop-filter: blur(6px);\r\n    -webkit-backdrop-filter: blur(6px);\r\n  `\r\n  );\r\n\r\n  // container central\r\n  const center = document.createElement('div');\r\n  center.setAttribute(\r\n    'style',\r\n    `\r\n    position: absolute; top: 50%; left: 50%;\r\n    transform: translate(-50%, -50%);\r\n    background: #2d1458; color: #fff;\r\n    border-radius: 20px; padding: 26px 30px; min-width: 360px;\r\n    border: 1px solid rgba(255,255,255,0.12);\r\n    box-shadow: 0 14px 44px rgba(0,0,0,.35);\r\n    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;\r\n    text-align: center;\r\n  `\r\n  );\r\n\r\n  const icon = document.createElement('div');\r\n  icon.innerHTML = `\r\n    <div style=\"\r\n      width:56px;height:56px;margin:0 auto 10px auto;border-radius:50%;\r\n      background: rgba(255,255,255,.12); display:flex;align-items:center;justify-content:center;\r\n      \">\r\n      <svg width=\"28\" height=\"28\" viewBox=\"0 0 24 24\" fill=\"none\">\r\n        <path d=\"M20 6L9 17L4 12\" stroke=\"#FFFFFF\" stroke-width=\"2.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\r\n      </svg>\r\n    </div>\r\n  `;\r\n\r\n  const title = document.createElement('div');\r\n  title.id = `${G_SUCCESS_ID}-title`;\r\n  title.textContent = 'os dados foram salvos com sucesso';\r\n  title.setAttribute('style', `font-size:16px;font-weight:700;letter-spacing:.2px;margin-bottom:6px;`);\r\n\r\n  const sub = document.createElement('div');\r\n  sub.id = `${G_SUCCESS_ID}-sub`;\r\n  sub.innerHTML = `recarregando em <b id=\"${G_SUCCESS_ID}-count\">6</b>s...`;\r\n  sub.setAttribute('style', `opacity:.9;font-size:13px;`);\r\n\r\n  center.appendChild(icon);\r\n  center.appendChild(title);\r\n  center.appendChild(sub);\r\n  wrapper.appendChild(center);\r\n  document.body.appendChild(wrapper);\r\n  return wrapper;\r\n}\r\n\r\nfunction showGlobalSuccessModal(seconds = 6) {\r\n  const el = ensureGlobalSuccessModalDOM();\r\n  // reset contador\r\n  const countEl = el.querySelector(`#${G_SUCCESS_ID}-count`);\r\n  if (countEl) countEl.textContent = String(seconds);\r\n\r\n  el.style.display = 'block';\r\n\r\n  if (gSuccessTimer) {\r\n    clearInterval(gSuccessTimer);\r\n    gSuccessTimer = null;\r\n  }\r\n\r\n  let left = seconds;\r\n  gSuccessTimer = setInterval(() => {\r\n    left -= 1;\r\n    if (countEl) countEl.textContent = String(left);\r\n    if (left <= 0) {\r\n      clearInterval(gSuccessTimer);\r\n      gSuccessTimer = null;\r\n      try {\r\n        window.location.reload();\r\n      } catch (_e) {\r\n        /* ignore reload errors */\r\n      }\r\n    }\r\n  }, 1000);\r\n}\r\n\r\nfunction hideGlobalSuccessModal() {\r\n  const el = document.getElementById(G_SUCCESS_ID);\r\n  if (el) el.style.display = 'none';\r\n  if (gSuccessTimer) {\r\n    clearInterval(gSuccessTimer);\r\n    gSuccessTimer = null;\r\n  }\r\n}\r\n\r\n/** ===================== UTILS ===================== **/\r\n// RFC-0090: escapeHtml REMOVED - was defined but never used in STORES\r\n// RFC-0090: toSpOffsetNoMs REMOVED - was defined but never used in STORES (no longer calling fetchApiTotals)\r\n\r\nfunction isValidUUID(v) {\r\n  if (!v || typeof v !== 'string') return false;\r\n  return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(v);\r\n}\r\n\r\nfunction mustGetDateRange() {\r\n  const s = self.ctx?.scope?.startDateISO;\r\n  const e = self.ctx?.scope?.endDateISO;\r\n\r\n  if (s && e) return { startISO: s, endISO: e };\r\n  throw new Error('DATE_RANGE_REQUIRED');\r\n}\r\n\r\nconst isAuthReady = () => !!(MyIOAuth && typeof MyIOAuth.getToken === 'function');\r\nasync function ensureAuthReady(maxMs = 6000, stepMs = 150) {\r\n  const start = Date.now();\r\n\r\n  while (!isAuthReady()) {\r\n    if (Date.now() - start > maxMs) return false;\r\n    await new Promise((r) => setTimeout(r, stepMs));\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/** ===================== TB INDEXES ===================== **/\r\nfunction buildTbAttrIndex() {\r\n  // RFC-0091: Extended to include deviceMapInstaneousPower, lastDisconnectTime, customerId, connectionStatus\r\n  const byTbId = new Map(); // tbId -> { slaveId, centralId, deviceType, centralName, lastConnectTime, lastActivityTime, ... }\r\n  const rows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\r\n\r\n  for (const row of rows) {\r\n    const key = String(row?.dataKey?.name || '').toLowerCase();\r\n    const tbId = row?.datasource?.entityId?.id || row?.datasource?.entityId || null;\r\n    const val = row?.data?.[0]?.[1];\r\n\r\n    if (!tbId || val == null) continue;\r\n    if (!byTbId.has(tbId))\r\n      byTbId.set(tbId, {\r\n        slaveId: null,\r\n        centralId: null,\r\n        deviceType: null,\r\n        deviceProfile: null,\r\n        centralName: null,\r\n        lastConnectTime: null,\r\n        lastActivityTime: null,\r\n        // RFC-0091: Added for proper deviceStatus calculation\r\n        lastDisconnectTime: null,\r\n        deviceMapInstaneousPower: null,\r\n        customerId: null,\r\n        connectionStatus: null,\r\n        consumption_power: null, // Instantaneous power\r\n      });\r\n\r\n    const slot = byTbId.get(tbId);\r\n\r\n    if (key === 'slaveid') slot.slaveId = val;\r\n    if (key === 'centralid') slot.centralId = val;\r\n    if (key === 'devicetype') slot.deviceType = val;\r\n    if (key === 'deviceprofile') slot.deviceProfile = val;\r\n    if (key === 'centralname') slot.centralName = val;\r\n    if (key === 'lastconnecttime') slot.lastConnectTime = val;\r\n    if (key === 'lastactivitytime') slot.lastActivityTime = val;\r\n    // RFC-0091: New attributes for proper deviceStatus calculation\r\n    if (key === 'lastdisconnecttime') slot.lastDisconnectTime = val;\r\n    if (key === 'devicemapinstaneouspower') slot.deviceMapInstaneousPower = val;\r\n    if (key === 'customerid') slot.customerId = val;\r\n    if (key === 'connectionstatus') slot.connectionStatus = val;\r\n    // RFC-0093: 'consumption' from ThingsBoard is renamed to 'consumption_power' (same as EQUIPMENTS)\r\n    if (key === 'consumption_power' || key === 'consumption') slot.consumption_power = val;\r\n  }\r\n  return byTbId;\r\n}\r\nfunction buildTbIdIndexes() {\r\n  const byIdentifier = new Map(); // identifier -> tbId\r\n  const byIngestion = new Map(); // ingestionId -> tbId\r\n\r\n  const rows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\r\n  for (const row of rows) {\r\n    const key = String(row?.dataKey?.name || '').toLowerCase();\r\n    const tbId = row?.datasource?.entityId?.id || row?.datasource?.entityId || null;\r\n    const val = row?.data?.[0]?.[1];\r\n\r\n    if (!tbId || val == null) continue;\r\n    if (key === 'identifier') byIdentifier.set(String(val), tbId);\r\n    if (key === 'ingestionid') byIngestion.set(String(val), tbId);\r\n  }\r\n  return { byIdentifier, byIngestion };\r\n}\r\n\r\n/** ===================== CORE: DATA PIPELINE ===================== **/\r\nfunction buildAuthoritativeItems() {\r\n  // items da LIB: [{ id: ingestionId, identifier, label }, ...]\r\n  const base = MyIO.buildListItemsThingsboardByUniqueDatasource(self.ctx.datasources, self.ctx.data) || [];\r\n  const ok = Array.isArray(base) ? base.filter((x) => x && x.id) : [];\r\n  const tbIdIdx = buildTbIdIndexes(); // { byIdentifier, byIngestion }\r\n  const attrsByTb = buildTbAttrIndex(); // tbId -> { slaveId, centralId, deviceType }\r\n\r\n  const mapped = ok.map((r) => {\r\n    const ingestionId = r.id;\r\n    const tbFromIngestion = ingestionId ? tbIdIdx.byIngestion.get(ingestionId) : null;\r\n    const tbFromIdentifier = r.identifier ? tbIdIdx.byIdentifier.get(r.identifier) : null;\r\n\r\n    let tbId = tbFromIngestion || tbFromIdentifier || null;\r\n    if (tbFromIngestion && tbFromIdentifier && tbFromIngestion !== tbFromIdentifier) {\r\n      tbId = tbFromIngestion;\r\n    }\r\n\r\n    const attrs = tbId ? attrsByTb.get(tbId) || {} : {};\r\n    const deviceProfile = attrs.deviceProfile || 'N/D';\r\n    let deviceTypeToDisplay = attrs.deviceType || '3F_MEDIDOR';\r\n\r\n    if (deviceTypeToDisplay === '3F_MEDIDOR' && deviceProfile !== 'N/D') {\r\n      deviceTypeToDisplay = deviceProfile;\r\n    }\r\n\r\n    // RFC-0093: Get customerId with fallback to global map or Orchestrator cache\r\n    let customerId = attrs.customerId ?? null;\r\n\r\n    // Fallback 1: Try global device-to-shopping map (populated by EQUIPMENTS)\r\n    if (!customerId && ingestionId && window.myioDeviceToShoppingMap) {\r\n      customerId = window.myioDeviceToShoppingMap.get(ingestionId) || null;\r\n    }\r\n\r\n    // Fallback 2: Try Orchestrator energy cache\r\n    if (!customerId && ingestionId && window.MyIOOrchestrator?.getEnergyCache) {\r\n      const energyCache = window.MyIOOrchestrator.getEnergyCache();\r\n      if (energyCache && energyCache.has(ingestionId)) {\r\n        customerId = energyCache.get(ingestionId).customerId || null;\r\n      }\r\n    }\r\n\r\n    // Populate global map for other widgets to use\r\n    if (ingestionId && customerId) {\r\n      if (!window.myioDeviceToShoppingMap) {\r\n        window.myioDeviceToShoppingMap = new Map();\r\n      }\r\n      window.myioDeviceToShoppingMap.set(ingestionId, customerId);\r\n    }\r\n\r\n    return {\r\n      id: tbId || ingestionId, // para sele√ß√£o/toggle\r\n      tbId, // ThingsBoard deviceId (Settings)\r\n      ingestionId, // join key API (totals/Report)\r\n      identifier: r.identifier,\r\n      label: r.label,\r\n      slaveId: attrs.slaveId ?? null,\r\n      centralId: attrs.centralId ?? null,\r\n      centralName: attrs.centralName ?? null,\r\n      deviceType: deviceTypeToDisplay,\r\n      deviceProfile: deviceProfile, // RFC-0091: Added for Settings\r\n      updatedIdentifiers: {},\r\n      connectionStatusTime: attrs.lastConnectTime ?? null,\r\n      timeVal: attrs.lastActivityTime ?? null,\r\n      // RFC-0091: Added for proper deviceStatus calculation and Settings\r\n      lastDisconnectTime: attrs.lastDisconnectTime ?? null,\r\n      lastConnectTime: attrs.lastConnectTime ?? null,\r\n      deviceMapInstaneousPower: attrs.deviceMapInstaneousPower ?? null,\r\n      customerId: customerId, // RFC-0093: With fallback from global map or Orchestrator\r\n      connectionStatus: attrs.connectionStatus ?? 'offline',\r\n      consumption_power: attrs.consumption_power ?? null, // Instantaneous power\r\n    };\r\n  });\r\n\r\n  return mapped;\r\n}\r\n\r\n// RFC-0090: fetchApiTotals REMOVED - now using Orchestrator cache\r\n// The Orchestrator already fetches data once for all widgets,\r\n// so STORES just uses the cached data instead of making redundant API calls\r\n\r\nfunction enrichItemsWithTotals(items, apiMap) {\r\n  return items.map((it) => {\r\n    let raw = 0;\r\n\r\n    if (it.ingestionId && isValidUUID(it.ingestionId)) {\r\n      const row = apiMap.get(String(it.ingestionId));\r\n      raw = Number(row?.total_value ?? 0);\r\n    }\r\n\r\n    const value = Number(raw || 0);\r\n\r\n    return { ...it, value, perc: 0 };\r\n  });\r\n}\r\n\r\n/** ===================== FILTERS / SORT / PERC ===================== **/\r\nfunction applyFilters(enriched, searchTerm, selectedIds, sortMode) {\r\n  let v = enriched.slice();\r\n\r\n  // RFC-0093: Apply shopping filter (from MENU) - same logic as EQUIPMENTS\r\n  if (STATE.selectedShoppingIds && STATE.selectedShoppingIds.length > 0) {\r\n    const before = v.length;\r\n    v = v.filter((x) => {\r\n      // If device has no customerId, include it (safety)\r\n      if (!x.customerId) return true;\r\n      // Check if device's customerId is in the selected shoppings\r\n      return STATE.selectedShoppingIds.includes(x.customerId);\r\n    });\r\n    LogHelper.log(\r\n      `[STORES] Shopping filter applied: ${before} -> ${v.length} stores (${before - v.length} filtered out)`\r\n    );\r\n  }\r\n\r\n  if (selectedIds && selectedIds.size) {\r\n    v = v.filter((x) => selectedIds.has(String(x.id)));\r\n  }\r\n\r\n  const q = (searchTerm || '').trim().toLowerCase();\r\n  if (q) {\r\n    v = v.filter(\r\n      (x) =>\r\n        (x.label || '').toLowerCase().includes(q) ||\r\n        String(x.identifier || '')\r\n          .toLowerCase()\r\n          .includes(q)\r\n    );\r\n  }\r\n\r\n  v.sort((a, b) => {\r\n    if (sortMode === 'cons_desc') {\r\n      if (a.value !== b.value) return b.value - a.value;\r\n      return (a.label || '').localeCompare(b.label || '', 'pt-BR', {\r\n        sensitivity: 'base',\r\n      });\r\n    }\r\n    if (sortMode === 'cons_asc') {\r\n      if (a.value !== b.value) return a.value - b.value;\r\n      return (a.label || '').localeCompare(b.label || '', 'pt-BR', {\r\n        sensitivity: 'base',\r\n      });\r\n    }\r\n    if (sortMode === 'alpha_desc') {\r\n      return (\r\n        (b.label || '').localeCompare(a.label || '', 'pt-BR', {\r\n          sensitivity: 'base',\r\n        }) || b.value - a.value\r\n      );\r\n    }\r\n    // RFC-0095: Status sorting\r\n    if (sortMode === 'status_asc') {\r\n      const statusA = (a.connectionStatus || 'offline').toLowerCase();\r\n      const statusB = (b.connectionStatus || 'offline').toLowerCase();\r\n      const cmp = statusA.localeCompare(statusB, 'pt-BR', { sensitivity: 'base' });\r\n      return cmp !== 0 ? cmp : (a.label || '').localeCompare(b.label || '', 'pt-BR', { sensitivity: 'base' });\r\n    }\r\n    if (sortMode === 'status_desc') {\r\n      const statusA = (a.connectionStatus || 'offline').toLowerCase();\r\n      const statusB = (b.connectionStatus || 'offline').toLowerCase();\r\n      const cmp = statusB.localeCompare(statusA, 'pt-BR', { sensitivity: 'base' });\r\n      return cmp !== 0 ? cmp : (a.label || '').localeCompare(b.label || '', 'pt-BR', { sensitivity: 'base' });\r\n    }\r\n    // RFC-0095: Shopping sorting\r\n    if (sortMode === 'shopping_asc') {\r\n      const shopA = getCustomerNameForDevice(a) || '';\r\n      const shopB = getCustomerNameForDevice(b) || '';\r\n      const cmp = shopA.localeCompare(shopB, 'pt-BR', { sensitivity: 'base' });\r\n      return cmp !== 0 ? cmp : (a.label || '').localeCompare(b.label || '', 'pt-BR', { sensitivity: 'base' });\r\n    }\r\n    if (sortMode === 'shopping_desc') {\r\n      const shopA = getCustomerNameForDevice(a) || '';\r\n      const shopB = getCustomerNameForDevice(b) || '';\r\n      const cmp = shopB.localeCompare(shopA, 'pt-BR', { sensitivity: 'base' });\r\n      return cmp !== 0 ? cmp : (a.label || '').localeCompare(b.label || '', 'pt-BR', { sensitivity: 'base' });\r\n    }\r\n    // Default: alpha_asc\r\n    return (\r\n      (a.label || '').localeCompare(b.label || '', 'pt-BR', {\r\n        sensitivity: 'base',\r\n      }) || a.value - b.value\r\n    );\r\n  });\r\n\r\n  return v;\r\n}\r\n\r\nfunction recomputePercentages(visible) {\r\n  const groupSum = visible.reduce((acc, x) => acc + (x.value || 0), 0);\r\n  const updated = visible.map((x) => ({\r\n    ...x,\r\n    perc: groupSum > 0 ? (x.value / groupSum) * 100 : 0,\r\n  }));\r\n  return { visible: updated, groupSum };\r\n}\r\n\r\n// RFC-0090: getCustomerNameForDevice REMOVED - now using getCustomerNameForDevice from MAIN\r\n\r\n/** ===================== RENDER ===================== **/\r\n\r\n/**\r\n * Update stores statistics header (Conectividade, Total de Lojas, etc)\r\n * RFC-0093: Aligned with EQUIPMENTS/MAIN logic for consistent stats\r\n * @param {Array} stores - Array of store items to calculate stats from\r\n */\r\nfunction updateStoresStats(stores) {\r\n  // Use $root() to find elements within widget scope (not document.getElementById)\r\n  const $widget = $root();\r\n  const connectivityEl = $widget.find('#storesStatsConnectivity')[0];\r\n  const totalEl = $widget.find('#storesStatsTotal')[0];\r\n  const consumptionEl = $widget.find('#storesStatsConsumption')[0];\r\n  const zeroEl = $widget.find('#storesStatsZero')[0];\r\n\r\n  if (!connectivityEl || !totalEl || !consumptionEl || !zeroEl) {\r\n    LogHelper.warn('[STORES] Stats header elements not found in widget scope');\r\n    return;\r\n  }\r\n\r\n  // RFC-0093: Calculate connectivity from connectionStatus (same as EQUIPMENTS)\r\n  let onlineCount = 0;\r\n  let totalWithStatus = 0;\r\n  let totalConsumption = 0;\r\n  let zeroConsumptionCount = 0;\r\n\r\n  stores.forEach((store) => {\r\n    // Connectivity: based on connectionStatus, not consumption\r\n    const status = (store.connectionStatus || '').toLowerCase();\r\n    if (status) {\r\n      totalWithStatus++;\r\n      if (status === 'online') {\r\n        onlineCount++;\r\n      }\r\n    }\r\n\r\n    // Consumption calculation\r\n    const consumption = Number(store.value) || Number(store.val) || 0;\r\n    totalConsumption += consumption;\r\n\r\n    if (consumption === 0) {\r\n      zeroConsumptionCount++;\r\n    }\r\n  });\r\n\r\n  // If no connectionStatus available, fallback to total count\r\n  if (totalWithStatus === 0) {\r\n    totalWithStatus = stores.length;\r\n  }\r\n\r\n  // Calculate connectivity percentage\r\n  const connectivityPercentage =\r\n    totalWithStatus > 0 ? ((onlineCount / totalWithStatus) * 100).toFixed(1) : '0.0';\r\n\r\n  // Update UI\r\n  connectivityEl.textContent = `${onlineCount}/${totalWithStatus} (${connectivityPercentage}%)`;\r\n  totalEl.textContent = stores.length.toString();\r\n  consumptionEl.textContent =\r\n    WIDGET_DOMAIN === 'energy' ? MyIO.formatEnergy(totalConsumption) : totalConsumption.toFixed(2);\r\n  zeroEl.textContent = zeroConsumptionCount.toString();\r\n\r\n  LogHelper.log('[STORES] Stats updated:', {\r\n    connectivity: `${onlineCount}/${totalWithStatus} (${connectivityPercentage}%)`,\r\n    total: stores.length,\r\n    consumption: totalConsumption,\r\n    zeroCount: zeroConsumptionCount,\r\n  });\r\n}\r\n\r\nfunction renderHeader(count, groupSum) {\r\n  $count().text(`(${count})`);\r\n\r\n  // Format based on widget domain\r\n  let formattedTotal = groupSum.toFixed(2);\r\n  if (WIDGET_DOMAIN === 'energy') {\r\n    formattedTotal = MyIO.formatEnergy(groupSum);\r\n  } else if (WIDGET_DOMAIN === 'water') {\r\n    formattedTotal = MyIO.formatWaterVolumeM3(groupSum);\r\n  } else if (WIDGET_DOMAIN === 'tank') {\r\n    formattedTotal = MyIO.formatTankHeadFromCm(groupSum);\r\n  }\r\n\r\n  $total().text(formattedTotal);\r\n}\r\n\r\nasync function renderList(visible) {\r\n  const listElement = $list()[0];\r\n  if (!listElement) {\r\n    console.error('[STORES] shopsList element not found via $list()');\r\n    return;\r\n  }\r\n\r\n  listElement.innerHTML = '';\r\n\r\n  // 1. Carrega √≠ndices para garantir UUID do ThingsBoard\r\n  const idx = buildTbIdIndexes();\r\n\r\n  // RFC-0091: Process items with async deviceStatus calculation\r\n  for (const it of visible) {\r\n    const container = document.createElement('div');\r\n    listElement.appendChild(container);\r\n\r\n    const valNum = Number(it.value || 0);\r\n\r\n    // RFC-0091: Proper connectionStatus mapping using MAIN utility\r\n    const rawConnectionStatus = it.connectionStatus || 'offline';\r\n    const mappedConnectionStatus = mapConnectionStatus(rawConnectionStatus);\r\n\r\n    // ... (l√≥gica de identifier mantida igual) ...\r\n    let deviceIdentifierToDisplay = 'N/A';\r\n    if (it.identifier) {\r\n      if (String(it.identifier).includes('Sem Identificador identificado')) {\r\n        const label = String(it.label || '').toLowerCase();\r\n        deviceIdentifierToDisplay = label.includes('fancoil') ? 'FANCOIL' : 'CAG';\r\n      } else {\r\n        deviceIdentifierToDisplay = it.identifier;\r\n      }\r\n    } else {\r\n      const label = String(it.label || '').toLowerCase();\r\n      if (label.includes('fancoil')) {\r\n        deviceIdentifierToDisplay = 'FANCOIL';\r\n      } else if (label.includes('cag')) {\r\n        deviceIdentifierToDisplay = 'CAG';\r\n      } else if (label.includes('elevador') || label.includes('elv')) {\r\n        deviceIdentifierToDisplay = 'ELV';\r\n      } else if (label.includes('escada')) {\r\n        deviceIdentifierToDisplay = 'ESC';\r\n      } else {\r\n        deviceIdentifierToDisplay = 'N/A';\r\n      }\r\n    }\r\n\r\n    const customerName = getCustomerNameForDevice(it);\r\n\r\n    // 2. Resolu√ß√£o Robusta do UUID (TB ID)\r\n    let resolvedTbId = it.tbId;\r\n    if (!resolvedTbId || !isValidUUID(resolvedTbId)) {\r\n      resolvedTbId =\r\n        (it.ingestionId && idx.byIngestion.get(it.ingestionId)) ||\r\n        (it.identifier && idx.byIdentifier.get(it.identifier)) ||\r\n        it.id;\r\n    }\r\n\r\n    const deviceType = it.label.includes('dministra') ? '3F_MEDIDOR' : it.deviceType;\r\n\r\n    // RFC-0091: Calculate deviceStatus using hierarchical ranges (same as EQUIPMENTS)\r\n    let deviceStatus = mappedConnectionStatus === 'online' ? 'power_on' : 'power_off';\r\n\r\n    // Parse deviceMapInstaneousPower if available (TIER 0 - highest priority)\r\n    let deviceMapLimits = null;\r\n    if (it.deviceMapInstaneousPower && typeof it.deviceMapInstaneousPower === 'string') {\r\n      try {\r\n        deviceMapLimits = JSON.parse(it.deviceMapInstaneousPower);\r\n        //LogHelper.log(`[RFC-0091] ‚úÖ Found deviceMapInstaneousPower in ctx.data for ${resolvedTbId}`);\r\n      } catch (e) {\r\n        LogHelper.warn(`[RFC-0091] Failed to parse deviceMapInstaneousPower for ${resolvedTbId}:`, e.message);\r\n      }\r\n    }\r\n\r\n    // Get instantaneous power from item data\r\n    const instantaneousPower = Number(it.consumption_power) || null;\r\n\r\n    // RFC-0091: Calculate operationHours (same as EQUIPMENTS)\r\n    let operationHoursFormatted = '0s';\r\n    const lastConnectTimestamp = it.lastConnectTime ? Number(it.lastConnectTime) : null;\r\n    if (lastConnectTimestamp) {\r\n      const nowMs = Date.now();\r\n      const durationMs = nowMs - lastConnectTimestamp;\r\n      operationHoursFormatted = formatarDuracao(durationMs > 0 ? durationMs : 0);\r\n    }\r\n\r\n    // Calculate deviceStatus using ranges if available\r\n    let rangesWithSource = null;\r\n    if (\r\n      getConsumptionRangesHierarchical &&\r\n      typeof MyIOLibrary.calculateDeviceStatusWithRanges === 'function'\r\n    ) {\r\n      try {\r\n        rangesWithSource = await getConsumptionRangesHierarchical(\r\n          resolvedTbId,\r\n          deviceType,\r\n          deviceMapLimits || window.__customerConsumptionLimits, // TIER 0 (deviceMap) > TIER 2 (customer)\r\n          'consumption',\r\n          null\r\n        );\r\n\r\n        // If deviceMapLimits was used, update the source to reflect it\r\n        if (deviceMapLimits && rangesWithSource.source === 'customer') {\r\n          rangesWithSource.source = 'deviceMap';\r\n          rangesWithSource.tier = 0;\r\n          LogHelper.log(`[RFC-0091] Using deviceMapInstaneousPower (TIER 0) for ${resolvedTbId}`);\r\n        }\r\n\r\n        // Calculate device status using range-based calculation\r\n        const parsedInstantaneousPower = Number(instantaneousPower);\r\n        const lastConsumptionValue = Number.isNaN(parsedInstantaneousPower)\r\n          ? null\r\n          : parsedInstantaneousPower;\r\n        \r\n            deviceStatus = MyIOLibrary.calculateDeviceStatusWithRanges({\r\n          connectionStatus: mappedConnectionStatus,\r\n          lastConsumptionValue,\r\n          ranges: {\r\n            standbyRange: rangesWithSource.standbyRange,\r\n            normalRange: rangesWithSource.normalRange,\r\n            alertRange: rangesWithSource.alertRange,\r\n            failureRange: rangesWithSource.failureRange,\r\n          },\r\n        });\r\n      } catch (e) {\r\n        LogHelper.warn(`[RFC-0091] Failed to calculate deviceStatus for ${resolvedTbId}:`, e.message);\r\n      }\r\n    }\r\n\r\n    // 3. Montagem do Objeto id√™ntico ao widget de Equipamentos\r\n    const entityObject = {\r\n      // Identificadores\r\n      entityId: resolvedTbId,\r\n      id: resolvedTbId, // Crucial para o DragDrop\r\n\r\n      // Labels e Nomes\r\n      labelOrName: it.label,\r\n      name: it.label,\r\n      customerName: customerName,\r\n      centralName: it.centralName || 'N/A',\r\n      deviceIdentifier: deviceIdentifierToDisplay,\r\n\r\n      // Valores e Tipos\r\n      val: valNum,\r\n      value: valNum,\r\n      lastValue: valNum,\r\n      valType: 'power_kw', // <--- DIFEREN√áA 1: Adicionado (igual Equipamentos)\r\n      unit: 'kWh',\r\n      icon: 'energy',\r\n      domain: 'energy',\r\n\r\n      // Metadados\r\n      deviceType: deviceType,\r\n      deviceProfile: it.deviceProfile || 'N/D', // RFC-0091: Added for Settings\r\n      deviceStatus: deviceStatus, // RFC-0091: Now properly calculated\r\n      perc: it.perc ?? 0,\r\n\r\n      // IDs secund√°rios\r\n      slaveId: it.slaveId || 'N/A',\r\n      ingestionId: it.ingestionId || 'N/A',\r\n      centralId: it.centralId || 'N/A',\r\n      customerId: it.customerId || null, // RFC-0091: Added for Settings\r\n\r\n      updatedIdentifiers: it.updatedIdentifiers || {},\r\n      connectionStatusTime: it.connectionStatusTime || Date.now(),\r\n      timeVal: it.timeVal || Date.now(),\r\n\r\n      // RFC-0091: Additional data for Settings modal and card display\r\n      lastDisconnectTime: it.lastDisconnectTime || 0,\r\n      lastConnectTime: it.lastConnectTime || 0,\r\n      lastActivityTime: it.timeVal || null,\r\n      instantaneousPower: instantaneousPower, // Pot√™ncia instant√¢nea (kW)\r\n      operationHours: operationHoursFormatted, // Tempo em opera√ß√£o (formatado)\r\n      temperatureC: 0, // Temperatura (n√£o dispon√≠vel para lojas)\r\n      mapInstantaneousPower: MAP_INSTANTANEOUS_POWER, // Global map from settings\r\n      deviceMapInstaneousPower: it.deviceMapInstaneousPower || null, // Device-specific map\r\n      // Power ranges for tooltip visualization (uses rangesWithSource from deviceStatus calculation)\r\n      powerRanges: rangesWithSource ? {\r\n        standbyRange: rangesWithSource.standbyRange,\r\n        normalRange: rangesWithSource.normalRange,\r\n        alertRange: rangesWithSource.alertRange,\r\n        failureRange: rangesWithSource.failureRange,\r\n        source: rangesWithSource.source,\r\n        tier: rangesWithSource.tier,\r\n      } : null,\r\n    };\r\n\r\n    // RFC-0091: delayTimeConnectionInMins - configurable via MAIN settings (default 60 minutes)\r\n    const handle = MyIOLibrary.renderCardComponentHeadOffice(container, {\r\n      entityObject: entityObject,\r\n      debugActive: DEBUG_ACTIVE,\r\n      activeTooltipDebug: ACTIVE_TOOLTIP_DEBUG,\r\n      delayTimeConnectionInMins: window.MyIOUtils?.getDelayTimeConnectionInMins?.() ?? 60,\r\n\r\n      // --- DIFEREN√áA 2: Callback de clique (mesmo que apenas logue) ---\r\n      // Isso muitas vezes ativa o wrapper interativo do card\r\n      handleClickCard: (ev, entity) => {\r\n        console.log(`[STORES] Card clicked: ${entity.name}`);\r\n      },\r\n\r\n      handleActionDashboard: async () => {\r\n        // ... (seu c√≥digo existente do dashboard mantido igual)\r\n        console.log('[STORES] [RFC-0072] Opening energy dashboard for:', entityObject.entityId);\r\n        try {\r\n          if (typeof MyIOLibrary.openDashboardPopupEnergy !== 'function') {\r\n            alert('Dashboard component n√£o dispon√≠vel');\r\n            return;\r\n          }\r\n          const startDate = self.ctx.scope?.startDateISO;\r\n          const endDate = self.ctx.scope?.endDateISO;\r\n          if (!startDate || !endDate) {\r\n            alert('Per√≠odo de datas n√£o definido.');\r\n            return;\r\n          }\r\n          // RFC-0093: Guard against undefined MyIOAuth\r\n          if (!MyIOAuth || typeof MyIOAuth.getToken !== 'function') {\r\n            LogHelper.error('[STORES] MyIOAuth not available');\r\n            alert('Autentica√ß√£o n√£o dispon√≠vel. Recarregue a p√°gina.');\r\n            return;\r\n          }\r\n          const tokenIngestionDashBoard = await MyIOAuth.getToken();\r\n          const myTbTokenDashBoard = localStorage.getItem('jwt_token');\r\n\r\n          MyIOLibrary.openDashboardPopupEnergy({\r\n            deviceId: entityObject.entityId,\r\n            readingType: 'energy',\r\n            startDate,\r\n            endDate,\r\n            tbJwtToken: myTbTokenDashBoard,\r\n            ingestionToken: tokenIngestionDashBoard,\r\n            clientId: CLIENT_ID,\r\n            clientSecret: CLIENT_SECRET,\r\n            onClose: () => {\r\n              const o = document.querySelector('.myio-modal-overlay');\r\n              if (o) o.remove();\r\n            },\r\n          });\r\n        } catch (err) {\r\n          console.error(err);\r\n          alert('Erro ao abrir dashboard');\r\n        }\r\n      },\r\n\r\n      handleActionReport: async () => {\r\n        // ... (seu c√≥digo existente do report mantido igual)\r\n        try {\r\n          // RFC-0093: Guard against undefined MyIOAuth\r\n          if (!MyIOAuth || typeof MyIOAuth.getToken !== 'function') {\r\n            LogHelper.error('[STORES] MyIOAuth not available for report');\r\n            alert('Autentica√ß√£o n√£o dispon√≠vel. Recarregue a p√°gina.');\r\n            return;\r\n          }\r\n          const ingestionToken = await MyIOAuth.getToken();\r\n          await MyIOLibrary.openDashboardPopupReport({\r\n            ingestionId: it.ingestionId,\r\n            identifier: it.identifier,\r\n            label: it.label,\r\n            domain: 'energy',\r\n            api: {\r\n              dataApiBaseUrl: getDataApiHost(),\r\n              clientId: CLIENT_ID,\r\n              clientSecret: CLIENT_SECRET,\r\n              ingestionToken,\r\n            },\r\n          });\r\n        } catch (err) {\r\n          alert('Erro ao abrir relat√≥rio');\r\n        }\r\n      },\r\n\r\n      handleActionSettings: async () => {\r\n        // RFC-0091: Standardized settings handler following EQUIPMENTS pattern\r\n        const jwt = localStorage.getItem('jwt_token');\r\n\r\n        if (!jwt) {\r\n          LogHelper.error('[STORES] [RFC-0091] JWT token not found');\r\n          window.alert('Token de autentica√ß√£o n√£o encontrado');\r\n          return;\r\n        }\r\n\r\n        const tbId = entityObject.entityId;\r\n        if (!tbId || tbId === it.ingestionId) {\r\n          alert('ID inv√°lido');\r\n          return;\r\n        }\r\n\r\n        try {\r\n          // RFC-0091: Following exact EQUIPMENTS pattern with all parameters\r\n          await MyIOLibrary.openDashboardPopupSettings({\r\n            deviceId: tbId, // TB deviceId\r\n            label: it.label,\r\n            jwtToken: jwt,\r\n            domain: WIDGET_DOMAIN, // Same as EQUIPMENTS\r\n            deviceType: entityObject.deviceType, // RFC-0091: Pass deviceType for Power Limits feature\r\n            deviceProfile: entityObject.deviceProfile, // RFC-0091: Pass deviceProfile for 3F_MEDIDOR fallback\r\n            customerName: entityObject.customerName, // RFC-0091: Pass shopping name\r\n            connectionData: {\r\n              centralName: entityObject.centralName,\r\n              connectionStatusTime: entityObject.connectionStatusTime,\r\n              timeVal: entityObject.timeVal || new Date('1970-01-01').getTime(),\r\n              deviceStatus:\r\n                entityObject.deviceStatus !== 'power_off' && entityObject.deviceStatus !== 'not_installed'\r\n                  ? 'power_on'\r\n                  : 'power_off',\r\n              lastDisconnectTime: entityObject.lastDisconnectTime || 0,\r\n            },\r\n            ui: { title: 'Configura√ß√µes', width: 900 },\r\n            mapInstantaneousPower: entityObject.mapInstantaneousPower, // RFC-0091: Pass global map if available\r\n            onSaved: (payload) => {\r\n              LogHelper.log('[STORES] [RFC-0091] Settings saved:', payload);\r\n              showGlobalSuccessModal(6);\r\n            },\r\n            onClose: () => {\r\n              $('.myio-settings-modal-overlay').remove();\r\n              const overlay = document.querySelector('.myio-modal-overlay');\r\n              if (overlay) {\r\n                overlay.remove();\r\n              }\r\n              LogHelper.log('[STORES] [RFC-0091] Settings modal closed');\r\n            },\r\n          });\r\n        } catch (e) {\r\n          LogHelper.error('[STORES] [RFC-0091] Error opening settings:', e);\r\n          window.alert('Erro ao abrir configura√ß√µes');\r\n        }\r\n      },\r\n\r\n      handleSelect: (checked, entity) => {\r\n        const MyIOSelectionStore = window.MyIOLibrary?.MyIOSelectionStore || window.MyIOSelectionStore;\r\n        if (MyIOSelectionStore) {\r\n          if (checked) {\r\n            if (MyIOSelectionStore.registerEntity) MyIOSelectionStore.registerEntity(entity);\r\n            MyIOSelectionStore.add(entity.entityId || entity.id);\r\n          } else {\r\n            MyIOSelectionStore.remove(entity.entityId || entity.id);\r\n          }\r\n        }\r\n      },\r\n\r\n      useNewComponents: USE_NEW_COMPONENTS,\r\n      enableSelection: ENABLE_SELECTION,\r\n      enableDragDrop: ENABLE_DRAG_DROP,\r\n      hideInfoMenuItem: HIDE_INFO_MENU_ITEM,\r\n    });\r\n  }\r\n\r\n  console.log(`[STORES] Rendered ${visible.length} store cards`);\r\n}\r\n\r\n/** ===================== UI BINDINGS ===================== **/\r\n/**\r\n * RFC-0093: Search and filter button events are now handled by buildHeaderDevicesGrid\r\n * This function is kept for backwards compatibility but the main logic is in the header controller\r\n */\r\nfunction bindHeader() {\r\n  // RFC-0093: Events are now managed by storesHeaderController in onInit\r\n  LogHelper.log('[STORES] bindHeader - events managed by header controller');\r\n}\r\n\r\n// ============================================\r\n// RFC-0090: STORES FILTER MODAL (using shared factory from MAIN)\r\n// ============================================\r\n\r\n// Helper function to get store consumption value\r\nfunction getStoreConsumption(store) {\r\n  return Number(store.value) || Number(store.consumption) || Number(store.val) || 0;\r\n}\r\n\r\n// Filter modal instance (lazy initialized)\r\nlet storesFilterModal = null;\r\n\r\n/**\r\n * RFC-0090: Initialize filter modal using shared factory from MAIN\r\n */\r\nfunction initFilterModal() {\r\n  const createFilterModal = window.MyIOUtils?.createFilterModal;\r\n\r\n  if (!createFilterModal) {\r\n    LogHelper.error('[STORES] createFilterModal not available from MAIN');\r\n    return null;\r\n  }\r\n\r\n  return createFilterModal({\r\n    widgetName: 'STORES',\r\n    containerId: 'storesFilterModalGlobal',\r\n    modalClass: 'shops-modal',\r\n    primaryColor: '#3E1A7D',\r\n    itemIdAttr: 'data-entity',\r\n\r\n    // Filter tabs configuration - specific for STORES (simpler than EQUIPMENTS)\r\n    filterTabs: [\r\n      { id: 'all', label: 'Todos', filter: () => true },\r\n      { id: 'online', label: 'Online', filter: (s) => getStoreConsumption(s) > 0 },\r\n      { id: 'offline', label: 'Offline', filter: (s) => getStoreConsumption(s) === 0 },\r\n      { id: 'withConsumption', label: 'Com Consumo', filter: (s) => getStoreConsumption(s) > 0 },\r\n      { id: 'noConsumption', label: 'Sem Consumo', filter: (s) => getStoreConsumption(s) === 0 },\r\n    ],\r\n\r\n    // Data accessors\r\n    getItemId: (store) => store.id,\r\n    getItemLabel: (store) => store.label || store.identifier || store.id,\r\n    getItemValue: getStoreConsumption,\r\n    getItemSubLabel: (store) => getCustomerNameForDevice(store),\r\n    formatValue: (val) => (WIDGET_DOMAIN === 'energy' ? MyIO.formatEnergy(val) : val.toFixed(2)),\r\n\r\n    // Callbacks\r\n    onApply: ({ selectedIds, sortMode }) => {\r\n      STATE.selectedIds = selectedIds;\r\n      STATE.sortMode = sortMode;\r\n      reflowFromState();\r\n      LogHelper.log('[STORES] [RFC-0090] Filters applied via shared modal');\r\n    },\r\n\r\n    onReset: () => {\r\n      STATE.selectedIds = null;\r\n      STATE.sortMode = 'cons_desc';\r\n      STATE.searchTerm = '';\r\n      STATE.searchActive = false;\r\n\r\n      // RFC-0093: Reset UI via header controller\r\n      if (storesHeaderController) {\r\n        const searchInput = storesHeaderController.getSearchInput();\r\n        if (searchInput) searchInput.value = '';\r\n        storesHeaderController.toggleSearch(false);\r\n      }\r\n\r\n      reflowFromState();\r\n      LogHelper.log('[STORES] [RFC-0090] Filters reset via shared modal');\r\n    },\r\n\r\n    onClose: () => {\r\n      LogHelper.log('[STORES] [RFC-0090] Filter modal closed');\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * RFC-0090: Open filter modal\r\n */\r\nfunction openFilterModal() {\r\n  // Lazy initialize modal\r\n  if (!storesFilterModal) {\r\n    storesFilterModal = initFilterModal();\r\n  }\r\n\r\n  if (!storesFilterModal) {\r\n    LogHelper.error('[STORES] Failed to initialize filter modal');\r\n    window.alert('Erro ao inicializar modal de filtros. Verifique se o widget MAIN foi carregado.');\r\n    return;\r\n  }\r\n\r\n  // Use itemsEnriched if available (has consumption values), otherwise itemsBase\r\n  const items =\r\n    STATE.itemsEnriched && STATE.itemsEnriched.length > 0 ? STATE.itemsEnriched : STATE.itemsBase || [];\r\n\r\n  // Open with current stores and state\r\n  storesFilterModal.open(items, {\r\n    selectedIds: STATE.selectedIds,\r\n    sortMode: STATE.sortMode,\r\n  });\r\n}\r\n\r\n/**\r\n * RFC-0090: Close filter modal (for backward compatibility)\r\n */\r\nfunction closeFilterModal() {\r\n  if (storesFilterModal) {\r\n    storesFilterModal.close();\r\n  }\r\n}\r\n\r\nfunction bindModal() {\r\n  // RFC-0090: Modal is now handled by shared factory, but keep legacy bindings for fallback\r\n  $root().on('click', '#closeFilter', closeFilterModal);\r\n\r\n  $root().on('click', '#selectAll', (ev) => {\r\n    ev.preventDefault();\r\n    $modal().find('.check-item input[type=\"checkbox\"]').prop('checked', true);\r\n    syncChecklistSelectionVisual();\r\n  });\r\n\r\n  $root().on('click', '#clearAll', (ev) => {\r\n    ev.preventDefault();\r\n    $modal().find('.check-item input[type=\"checkbox\"]').prop('checked', false);\r\n    syncChecklistSelectionVisual();\r\n  });\r\n\r\n  $root().on('click', '#resetFilters', (ev) => {\r\n    ev.preventDefault();\r\n    STATE.selectedIds = null;\r\n    STATE.sortMode = 'cons_desc';\r\n    $modal().find('.check-item input[type=\"checkbox\"]').prop('checked', true);\r\n    $modal().find('input[name=\"sortMode\"][value=\"cons_desc\"]').prop('checked', true);\r\n    syncChecklistSelectionVisual();\r\n    reflowFromState();\r\n  });\r\n\r\n  $root().on('click', '#applyFilters', (ev) => {\r\n    ev.preventDefault();\r\n    const set = new Set();\r\n    $modal()\r\n      .find('.check-item input[type=\"checkbox\"]:checked')\r\n      .each((_, el) => {\r\n        const id = $(el).data('entity');\r\n        if (id) set.add(id);\r\n      });\r\n\r\n    STATE.selectedIds = set.size === 0 || set.size === STATE.itemsBase.length ? null : set;\r\n    STATE.sortMode = String($modal().find('input[name=\"sortMode\"]:checked').val() || 'cons_desc');\r\n\r\n    reflowFromState();\r\n    closeFilterModal();\r\n  });\r\n\r\n  $root().on('input', '#filterDeviceSearch', (ev) => {\r\n    const q = (ev.target.value || '').trim().toLowerCase();\r\n    $modal()\r\n      .find('.check-item')\r\n      .each((_, node) => {\r\n        const txt = $(node).text().trim().toLowerCase();\r\n        $(node).toggle(txt.includes(q));\r\n      });\r\n  });\r\n\r\n  $root().on('click', '#filterDeviceClear', (ev) => {\r\n    ev.preventDefault();\r\n    const $inp = $modal().find('#filterDeviceSearch');\r\n    $inp.val('');\r\n    $modal().find('.check-item').show();\r\n    $inp.trigger('focus');\r\n  });\r\n\r\n  $root().on('click', '#deviceChecklist .check-item', function (ev) {\r\n    if (ev.target && ev.target.tagName && ev.target.tagName.toLowerCase() === 'input') return;\r\n    ev.preventDefault();\r\n    ev.stopPropagation();\r\n    const $chk = $(this).find('input[type=\"checkbox\"]');\r\n    $chk.prop('checked', !$chk.prop('checked')).trigger('change');\r\n  });\r\n\r\n  $root().on('change', '#deviceChecklist input[type=\"checkbox\"]', function () {\r\n    const $wrap = $(this).closest('.check-item');\r\n    const on = this.checked;\r\n    $wrap.toggleClass('selected', on).attr('data-checked', on ? 'true' : 'false');\r\n    $wrap.css(\r\n      on\r\n        ? {\r\n            background: 'rgba(62,26,125,.08)',\r\n            borderColor: '#3E1A7D',\r\n            boxShadow: '0 8px 18px rgba(62,26,125,.15)',\r\n          }\r\n        : {\r\n            background: '#fff',\r\n            borderColor: '#D6E1EC',\r\n            boxShadow: '0 6px 14px rgba(0,0,0,.05)',\r\n          }\r\n    );\r\n  });\r\n}\r\n\r\nfunction syncChecklistSelectionVisual() {\r\n  $modal()\r\n    .find('.check-item')\r\n    .each(function () {\r\n      const $el = $(this);\r\n      const on = $el.find('input[type=\"checkbox\"]').prop('checked');\r\n      $el.toggleClass('selected', on).attr('data-checked', on ? 'true' : 'false');\r\n      $el.css(\r\n        on\r\n          ? {\r\n              background: 'rgba(62,26,125,.08)',\r\n              borderColor: '#3E1A7D',\r\n              boxShadow: '0 8px 18px rgba(62,26,125,.15)',\r\n            }\r\n          : {\r\n              background: '#fff',\r\n              borderColor: '#D6E1EC',\r\n              boxShadow: '0 6px 14px rgba(0,0,0,.05)',\r\n            }\r\n      );\r\n    });\r\n}\r\n\r\n/** ===================== RFC-0056 FIX v1.1: EMISSION ===================== **/\r\n\r\n/**\r\n * Normaliza valor de kWh para MWh com 2 decimais\r\n * @param {number} kWhValue - valor em kWh\r\n * @returns {number} valor em MWh arredondado\r\n */\r\nfunction normalizeToMWh(kWhValue) {\r\n  if (typeof kWhValue !== 'number' || isNaN(kWhValue)) return 0;\r\n  return Math.round((kWhValue / 1000) * 100) / 100;\r\n}\r\n\r\n/**\r\n * Normaliza label de dispositivo para classifica√ß√£o consistente\r\n * @param {string} str - label do dispositivo\r\n * @returns {string} label normalizado\r\n */\r\nfunction normalizeLabel(str) {\r\n  if (!str) return '';\r\n  return str\r\n    .toLowerCase()\r\n    .trim()\r\n    .normalize('NFD')\r\n    .replace(/[\\u0300-\\u036f]/g, '');\r\n}\r\n\r\n/**\r\n * Dispatcher: determina tipo de widget e emite evento apropriado\r\n * RFC-0056 FIX v1.1: Consolida√ß√£o em myio:telemetry:update\r\n */\r\nfunction emitTelemetryUpdate() {\r\n  try {\r\n    // Determinar tipo de widget pelo datasource alias\r\n    const widgetType = detectWidgetType();\r\n\r\n    if (!widgetType) {\r\n      LogHelper.log('[RFC-0056] Widget type not detected - skipping emission');\r\n      return;\r\n    }\r\n\r\n    // Construir periodKey a partir do filtro atual\r\n    const periodKey = buildPeriodKey();\r\n\r\n    // RFC-0002: Domain-specific emission\r\n    if (WIDGET_DOMAIN === 'water') {\r\n      emitWaterTelemetry(widgetType, periodKey);\r\n    } else {\r\n      // Default: energy domain\r\n      if (widgetType === 'lojas') {\r\n        emitLojasTotal(periodKey);\r\n      } else if (widgetType === 'areacomum') {\r\n        emitAreaComumBreakdown(periodKey);\r\n      }\r\n    }\r\n  } catch (err) {\r\n    LogHelper.error('[RFC-0056] Error in emitTelemetryUpdate:', err);\r\n  }\r\n}\r\n\r\n/**\r\n * Detecta tipo de widget baseado no datasource alias\r\n * RFC-0002: Added 'entrada' detection for water domain\r\n * @returns {'lojas'|'areacomum'|'entrada'|null}\r\n */\r\nfunction detectWidgetType() {\r\n  try {\r\n    LogHelper.log('üîç [detectWidgetType] Iniciando detec√ß√£o de tipo de widget...');\r\n\r\n    const datasources = ctx.datasources || [];\r\n    LogHelper.log(`[detectWidgetType] Total de datasources detectados: ${datasources.length}`);\r\n\r\n    if (!datasources.length) {\r\n      LogHelper.warn('[detectWidgetType] Nenhum datasource encontrado em ctx.datasources!');\r\n      return null;\r\n    }\r\n\r\n    // Percorrer todos os datasources\r\n    for (let i = 0; i < datasources.length; i++) {\r\n      const ds = datasources[i];\r\n      const alias = (ds.aliasName || '').toString().toLowerCase().trim();\r\n\r\n      LogHelper.log(`üî∏ [detectWidgetType] Verificando datasource[${i}]`);\r\n      LogHelper.log(`    ‚Ü≥ aliasName:     ${ds.aliasName || '(vazio)'}`);\r\n      LogHelper.log(`    ‚Ü≥ entityName:    ${ds.entityName || '(vazio)'}`);\r\n      LogHelper.log(`    ‚Ü≥ alias normalizado: \"${alias}\"`);\r\n\r\n      if (!alias) {\r\n        LogHelper.warn(`[detectWidgetType] ‚ö†Ô∏è Alias vazio ou indefinido no datasource[${i}].`);\r\n        continue;\r\n      }\r\n\r\n      // RFC-0002: Check for entrada (water domain)\r\n      // Use word boundary matching to avoid false positives like \"bomba entrada\"\r\n      if (/\\bentrada\\b/.test(alias) || alias === 'entrada' || alias.includes('entrada')) {\r\n        LogHelper.log(`‚úÖ [detectWidgetType] Tipo detectado: \"entrada\" (com base no alias \"${alias}\")`);\r\n        return 'entrada';\r\n      }\r\n\r\n      // Match \"lojas\" as standalone word or at end of alias\r\n      // AVOID false positives like \"Bomba Lojas\", \"Subesta√ß√£o Lojas\"\r\n      // ACCEPT: \"lojas\", \"widget-lojas\", \"telemetry-lojas\", \"consumidores lojas\"\r\n      if (/\\blojas\\b/.test(alias) && !/bomba|subesta|entrada|chiller|elevador|escada/i.test(alias)) {\r\n        LogHelper.log(`‚úÖ [detectWidgetType] Tipo detectado: \"lojas\" (com base no alias \"${alias}\")`);\r\n        return 'lojas';\r\n      }\r\n\r\n      // Match area comum with flexible separators\r\n      if (/\\barea\\s*comum\\b/.test(alias) || alias.includes('areacomum') || alias.includes('area_comum')) {\r\n        LogHelper.log(`‚úÖ [detectWidgetType] Tipo detectado: \"areacomum\" (com base no alias \"${alias}\")`);\r\n        return 'areacomum';\r\n      }\r\n    }\r\n\r\n    LogHelper.warn('[detectWidgetType] ‚ö†Ô∏è Nenhum tipo de widget correspondente encontrado.');\r\n    return null;\r\n  } catch (err) {\r\n    LogHelper.error('[detectWidgetType] ‚ùå Erro durante detec√ß√£o de tipo de widget:', err);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Constr√≥i periodKey do filtro atual\r\n * Formato: \"YYYY-MM-DD_YYYY-MM-DD\" ou \"realtime\"\r\n */\r\nfunction buildPeriodKey() {\r\n  const timewindow = ctx.defaultSubscription?.subscriptionTimewindow;\r\n\r\n  if (!timewindow || timewindow.realtimeWindowMs) {\r\n    return 'realtime';\r\n  }\r\n\r\n  const startMs = timewindow.fixedWindow?.startTimeMs || Date.now() - 86400000;\r\n  const endMs = timewindow.fixedWindow?.endTimeMs || Date.now();\r\n\r\n  const startDate = new Date(startMs).toISOString().split('T')[0];\r\n  const endDate = new Date(endMs).toISOString().split('T')[0];\r\n\r\n  return `${startDate}_${endDate}`;\r\n}\r\n\r\n/**\r\n * Emite evento lojas_total\r\n * RFC-0056 FIX v1.1: TELEMETRY (Lojas) ‚Üí TELEMETRY_INFO\r\n */\r\nfunction emitLojasTotal(periodKey) {\r\n  try {\r\n    // Calcular total de Lojas a partir dos itens enriquecidos\r\n    const lojasTotal = STATE.itemsEnriched.reduce((sum, item) => {\r\n      return sum + (item.value || 0);\r\n    }, 0);\r\n\r\n    const totalMWh = normalizeToMWh(lojasTotal);\r\n\r\n    const payload = {\r\n      type: 'lojas_total',\r\n      domain: 'energy',\r\n      periodKey: periodKey,\r\n      timestamp: Date.now(),\r\n      source: 'TELEMETRY_Lojas',\r\n      data: {\r\n        total_kWh: lojasTotal,\r\n        total_MWh: totalMWh,\r\n        device_count: STATE.itemsEnriched.length,\r\n      },\r\n    };\r\n\r\n    // Cache em sessionStorage\r\n    const cacheKey = `myio:telemetry:lojas_${periodKey}`;\r\n    try {\r\n      sessionStorage.setItem(cacheKey, JSON.stringify(payload));\r\n    } catch (e) {\r\n      LogHelper.warn('[RFC-0056] sessionStorage write failed:', e);\r\n    }\r\n\r\n    // Dispatch consolidated event\r\n    const event = new CustomEvent('myio:telemetry:update', {\r\n      detail: payload,\r\n      bubbles: true,\r\n      cancelable: false,\r\n    });\r\n\r\n    window.dispatchEvent(event);\r\n    LogHelper.log(\r\n      `[RFC-0056] ‚úÖ Emitted lojas_total: ${totalMWh} MWh (${STATE.itemsEnriched.length} devices)`\r\n    );\r\n  } catch (err) {\r\n    LogHelper.error('[RFC-0056] Error in emitLojasTotal:', err);\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0063: Classify device by identifier attribute\r\n * @param {string} identifier - Device identifier (e.g., \"CAG\", \"Fancoil\", \"ELV\", etc.)\r\n * @returns {'climatizacao'|'elevadores'|'escadas_rolantes'|'outros'|null}\r\n */\r\nfunction classifyDeviceByIdentifier(identifier = '') {\r\n  // RFC-0063: Safe guard against null/undefined/empty\r\n  if (!identifier || identifier === 'N/A' || identifier === 'null' || identifier === 'undefined') {\r\n    return null;\r\n  }\r\n\r\n  const id = String(identifier).trim().toUpperCase();\r\n\r\n  // Ignore \"Sem Identificador identificado\" marker\r\n  if (id.includes('SEM IDENTIFICADOR')) {\r\n    return null;\r\n  }\r\n\r\n  // Climatiza√ß√£o: CAG, Fancoil\r\n  if (id === 'CAG' || id === 'FANCOIL' || id.startsWith('CAG-') || id.startsWith('FANCOIL-')) {\r\n    return 'climatizacao';\r\n  }\r\n\r\n  // Elevadores: ELV, Elevador\r\n  if (id === 'ELV' || id === 'ELEVADOR' || id.startsWith('ELV-') || id.startsWith('ELEVADOR-')) {\r\n    return 'elevadores';\r\n  }\r\n\r\n  // Escadas Rolantes: ESC, Escada\r\n  if (id === 'ESC' || id === 'ESCADA' || id.startsWith('ESC-') || id.startsWith('ESCADA')) {\r\n    return 'escadas_rolantes';\r\n  }\r\n\r\n  // Outros: qualquer outro identifier n√£o reconhecido\r\n  return 'outros';\r\n}\r\n\r\n/**\r\n * RFC-0063: Classify device by label (legacy method)\r\n * @param {string} label - Device label/name\r\n * @returns {'climatizacao'|'elevadores'|'escadas_rolantes'|'outros'}\r\n */\r\nfunction classifyDeviceByLabel(label = '') {\r\n  // RFC-0063: Safe guard against null/undefined\r\n  if (!label) {\r\n    return 'outros';\r\n  }\r\n\r\n  const normalized = normalizeLabel(label);\r\n\r\n  // Climatiza√ß√£o patterns\r\n  if (\r\n    normalized.includes('climatizacao') ||\r\n    normalized.includes('hvac') ||\r\n    normalized.includes('ar condicionado') ||\r\n    normalized.includes('chiller') ||\r\n    normalized.includes('bomba cag') ||\r\n    normalized.includes('fancoil') ||\r\n    normalized.includes('casa de m√°quina ar') ||\r\n    normalized.includes('bomba primaria') ||\r\n    normalized.includes('bomba secundaria') ||\r\n    normalized.includes('bombas condensadoras') ||\r\n    normalized.includes('bombas condensadora') ||\r\n    normalized.includes('bomba condensadora') ||\r\n    normalized.includes('bombas primarias') ||\r\n    normalized.includes('bombas secundarias')\r\n  ) {\r\n    return 'climatizacao';\r\n  }\r\n\r\n  // Elevadores patterns\r\n  if (normalized.includes('elevador')) {\r\n    return 'elevadores';\r\n  }\r\n\r\n  // Escadas Rolantes patterns\r\n  if (normalized.includes('escada') && normalized.includes('rolante')) {\r\n    return 'escadas_rolantes';\r\n  }\r\n\r\n  // Default: outros\r\n  return 'outros';\r\n}\r\n\r\n/**\r\n * RFC-0063: Classify device using configured mode\r\n * @param {Object} item - Device item with identifier and label\r\n * @returns {'climatizacao'|'elevadores'|'escadas_rolantes'|'outros'}\r\n */\r\nfunction classifyDevice(item) {\r\n  // RFC-0063: Safe guard - ensure item exists\r\n  if (!item) {\r\n    LogHelper.warn('[RFC-0063] classifyDevice called with null/undefined item');\r\n    return 'outros';\r\n  }\r\n\r\n  // Mode 1: Identifier only (new method)\r\n  if (\r\n    (USE_IDENTIFIER_CLASSIFICATION && !USE_HYBRID_CLASSIFICATION) ||\r\n    item.identifier === 'ESCADASROLANTES'\r\n  ) {\r\n    const category = classifyDeviceByIdentifier(item.identifier);\r\n    if (category) {\r\n      LogHelper.log(`[RFC-0063] Device classified by identifier: \"${item.identifier}\" ‚Üí ${category}`);\r\n      return category;\r\n    }\r\n    // Fallback to 'outros' if identifier doesn't match any category\r\n    const reason = !item.identifier\r\n      ? 'no identifier attribute'\r\n      : `identifier \"${item.identifier}\" not recognized`;\r\n    LogHelper.log(`[RFC-0063] Device ${reason} ‚Üí outros`);\r\n    return 'outros';\r\n  }\r\n\r\n  // Mode 2: Hybrid (identifier with label fallback)\r\n  if (USE_IDENTIFIER_CLASSIFICATION && USE_HYBRID_CLASSIFICATION) {\r\n    const categoryByIdentifier = classifyDeviceByIdentifier(item.identifier);\r\n    if (categoryByIdentifier && categoryByIdentifier !== 'outros') {\r\n      LogHelper.log(\r\n        `[RFC-0063 Hybrid] Device classified by identifier: \"${item.identifier}\" ‚Üí ${categoryByIdentifier}`\r\n      );\r\n      return categoryByIdentifier;\r\n    }\r\n    // Fallback to label classification\r\n    const categoryByLabel = classifyDeviceByLabel(item.label || item.name);\r\n    const fallbackReason = !item.identifier\r\n      ? 'no identifier'\r\n      : `identifier \"${item.identifier}\" not recognized`;\r\n    LogHelper.log(\r\n      `[RFC-0063 Hybrid] Device (${fallbackReason}) classified by label fallback: \"${item.label}\" ‚Üí ${categoryByLabel}`\r\n    );\r\n    return categoryByLabel;\r\n  }\r\n\r\n  // Mode 3: Legacy (label only - default)\r\n  return classifyDeviceByLabel(item.label || item.name);\r\n}\r\n\r\n/**\r\n * Emite evento areacomum_breakdown\r\n * RFC-0056 FIX v1.1: TELEMETRY (AreaComum) ‚Üí TELEMETRY_INFO\r\n * RFC-0063: Enhanced with identifier-based classification\r\n */\r\nfunction emitAreaComumBreakdown(periodKey) {\r\n  try {\r\n    LogHelper.log(\r\n      `[RFC-0063] emitAreaComumBreakdown: mode=${\r\n        USE_IDENTIFIER_CLASSIFICATION ? (USE_HYBRID_CLASSIFICATION ? 'HYBRID' : 'IDENTIFIER') : 'LEGACY'\r\n      }`\r\n    );\r\n\r\n    // Classificar dispositivos por categoria\r\n    const breakdown = {\r\n      climatizacao: 0,\r\n      elevadores: 0,\r\n      escadas_rolantes: 0,\r\n      outros: 0,\r\n    };\r\n\r\n    STATE.itemsEnriched.forEach((item) => {\r\n      const energia = item.value || 0;\r\n      const category = classifyDevice(item);\r\n\r\n      breakdown[category] += energia;\r\n\r\n      // Debug log for first 5 items\r\n      if (STATE.itemsEnriched.indexOf(item) < 5) {\r\n        LogHelper.log(\r\n          `[RFC-0063] Item classified: id=\"${item.identifier}\", label=\"${\r\n            item.label\r\n          }\" ‚Üí ${category} (${energia.toFixed(2)} kWh)`\r\n        );\r\n      }\r\n    });\r\n\r\n    const payload = {\r\n      type: 'areacomum_breakdown',\r\n      domain: 'energy',\r\n      periodKey: periodKey,\r\n      timestamp: Date.now(),\r\n      source: 'TELEMETRY_AreaComum',\r\n      data: {\r\n        climatizacao_kWh: breakdown.climatizacao,\r\n        climatizacao_MWh: normalizeToMWh(breakdown.climatizacao),\r\n        elevadores_kWh: breakdown.elevadores,\r\n        elevadores_MWh: normalizeToMWh(breakdown.elevadores),\r\n        escadas_rolantes_kWh: breakdown.escadas_rolantes,\r\n        escadas_rolantes_MWh: normalizeToMWh(breakdown.escadas_rolantes),\r\n        outros_kWh: breakdown.outros,\r\n        outros_MWh: normalizeToMWh(breakdown.outros),\r\n        device_count: STATE.itemsEnriched.length,\r\n      },\r\n    };\r\n\r\n    // Cache em sessionStorage\r\n    const cacheKey = `myio:telemetry:areacomum_${periodKey}`;\r\n    try {\r\n      sessionStorage.setItem(cacheKey, JSON.stringify(payload));\r\n    } catch (e) {\r\n      LogHelper.warn('[RFC-0056] sessionStorage write failed:', e);\r\n    }\r\n\r\n    // Dispatch consolidated event\r\n    const event = new CustomEvent('myio:telemetry:update', {\r\n      detail: payload,\r\n      bubbles: true,\r\n      cancelable: false,\r\n    });\r\n\r\n    window.dispatchEvent(event);\r\n\r\n    const totalMWh = normalizeToMWh(\r\n      breakdown.climatizacao + breakdown.elevadores + breakdown.escadas_rolantes + breakdown.outros\r\n    );\r\n    LogHelper.log(\r\n      `[RFC-0056] ‚úÖ Emitted areacomum_breakdown: ${totalMWh} MWh (${STATE.itemsEnriched.length} devices)`\r\n    );\r\n  } catch (err) {\r\n    LogHelper.error('[RFC-0056] Error in emitAreaComumBreakdown:', err);\r\n  }\r\n}\r\n\r\n/**\r\n * RFC-0002: Emit water telemetry data\r\n * Emits myio:telemetry:provide-water for TELEMETRY_INFO to consume\r\n * @param {string} widgetType - 'entrada', 'lojas', or 'areacomum' (detected from alias)\r\n * @param {string} periodKey - Period identifier\r\n */\r\nfunction emitWaterTelemetry(widgetType, periodKey) {\r\n  try {\r\n    // Map widgetType to water context (direct mapping)\r\n    let context = null;\r\n    if (widgetType === 'entrada') {\r\n      context = 'entrada';\r\n    } else if (widgetType === 'lojas') {\r\n      context = 'lojas';\r\n    } else if (widgetType === 'areacomum') {\r\n      context = 'areaComum';\r\n    }\r\n\r\n    if (!context) {\r\n      LogHelper.warn(`[RFC-0002 Water] Unknown widget type: ${widgetType}`);\r\n      return;\r\n    }\r\n\r\n    // Calculate total in m¬≥\r\n    const totalM3 = STATE.itemsEnriched.reduce((sum, item) => sum + (item.value || 0), 0);\r\n\r\n    // Build device list\r\n    const devices = STATE.itemsEnriched.map((item) => ({\r\n      id: item.id || item.entityId || '',\r\n      label: item.label || item.name || '',\r\n      value: item.value || 0,\r\n      deviceType: item.deviceType || 'HIDROMETRO',\r\n    }));\r\n\r\n    const payload = {\r\n      context: context,\r\n      domain: 'water',\r\n      total: totalM3,\r\n      devices: devices,\r\n      periodKey: periodKey,\r\n      timestamp: new Date().toISOString(),\r\n    };\r\n\r\n    // Dispatch water event\r\n    const event = new CustomEvent('myio:telemetry:provide-water', {\r\n      detail: payload,\r\n      bubbles: true,\r\n      cancelable: false,\r\n    });\r\n\r\n    window.dispatchEvent(event);\r\n\r\n    LogHelper.log(\r\n      `[RFC-0002 Water] ‚úÖ Emitted water telemetry: context=${context}, total=${totalM3.toFixed(\r\n        2\r\n      )} m¬≥, devices=${devices.length}`\r\n    );\r\n  } catch (err) {\r\n    LogHelper.error('[RFC-0002 Water] Error in emitWaterTelemetry:', err);\r\n  }\r\n}\r\n\r\n/** ===================== RECOMPUTE (local only) ===================== **/\r\nasync function reflowFromState() {\r\n  const visible = applyFilters(STATE.itemsEnriched, STATE.searchTerm, STATE.selectedIds, STATE.sortMode);\r\n  const { visible: withPerc, groupSum } = recomputePercentages(visible);\r\n  renderHeader(withPerc.length, groupSum);\r\n  await renderList(withPerc); // RFC-0091: renderList is now async\r\n\r\n  // RFC-0093: Update stats header via centralized controller\r\n  // Use all enriched items for stats, not just visible/filtered ones\r\n  if (STATE.itemsEnriched && STATE.itemsEnriched.length > 0) {\r\n    if (storesHeaderController) {\r\n      storesHeaderController.updateFromDevices(STATE.itemsEnriched, {});\r\n    } else {\r\n      // Fallback to old function if header controller not available\r\n      updateStoresStats(STATE.itemsEnriched);\r\n    }\r\n  }\r\n}\r\n\r\n/** ===================== HYDRATE (end-to-end) ===================== **/\r\nasync function hydrateAndRender() {\r\n  if (hydrating) return;\r\n  hydrating = true;\r\n\r\n  // Mostra modal durante todo o processo (mensagem fixa)\r\n  showBusy();\r\n\r\n  try {\r\n    // 0) Datas: obrigat√≥rias\r\n    let range;\r\n    try {\r\n      range = mustGetDateRange();\r\n    } catch (_e) {\r\n      LogHelper.warn('[STORES] Aguardando intervalo de datas (startDateISO/endDateISO).');\r\n      return;\r\n    }\r\n\r\n    // 1) Auth\r\n    const okAuth = await ensureAuthReady(6000, 150);\r\n    if (!okAuth) {\r\n      LogHelper.warn('[STORES] Auth not ready; adiando hidrata√ß√£o.');\r\n      return;\r\n    }\r\n\r\n    // 2) Lista autoritativa\r\n    STATE.itemsBase = buildAuthoritativeItems();\r\n\r\n    // 3) RFC-0090: Use Orchestrator cache instead of direct API fetch\r\n    // The Orchestrator already fetches data for all widgets, so we just use its cache\r\n    let apiMap = new Map();\r\n    const orchestrator = window.MyIOOrchestrator || window.parent?.MyIOOrchestrator;\r\n\r\n    if (orchestrator && typeof orchestrator.getCache === 'function') {\r\n      const energyCache = orchestrator.getCache(WIDGET_DOMAIN);\r\n      if (energyCache && energyCache.size > 0) {\r\n        // Convert cache to apiMap format expected by enrichItemsWithTotals\r\n        energyCache.forEach((item, ingestionId) => {\r\n          apiMap.set(ingestionId, {\r\n            id: ingestionId,\r\n            total_value: item.total_value || item.value || 0,\r\n            ...item,\r\n          });\r\n        });\r\n        LogHelper.log(`[STORES] Using ${apiMap.size} items from Orchestrator cache`);\r\n      } else {\r\n        LogHelper.warn('[STORES] Orchestrator cache is empty, waiting for data...');\r\n        // RFC-0093: Show toast to reload page after a delay if still no data\r\n        setTimeout(() => {\r\n          if (apiMap.size === 0) {\r\n            const MyIOToast = MyIOLibrary?.MyIOToast || window.MyIOToast;\r\n            if (MyIOToast) {\r\n              MyIOToast.warning('Dados n√£o carregados. Por favor, recarregue a p√°gina.', { duration: 8000 });\r\n            }\r\n          }\r\n        }, 5000); // Wait 5 seconds before showing toast\r\n      }\r\n    } else {\r\n      LogHelper.warn('[STORES] Orchestrator not available, data will come via provide-data event');\r\n    }\r\n\r\n    // 4) Enrich + render\r\n    STATE.itemsEnriched = enrichItemsWithTotals(STATE.itemsBase, apiMap);\r\n\r\n    // 5) Sanitiza sele√ß√£o\r\n    if (STATE.selectedIds && STATE.selectedIds.size) {\r\n      const valid = new Set(STATE.itemsBase.map((x) => String(x.id)));\r\n      const next = new Set([...STATE.selectedIds].filter((id) => valid.has(String(id))));\r\n      STATE.selectedIds = next.size ? next : null;\r\n    }\r\n\r\n    reflowFromState();\r\n  } finally {\r\n    hydrating = false;\r\n    hideBusy();\r\n  }\r\n}\r\n\r\n/** ===================== TB LIFE CYCLE ===================== **/\r\nself.onInit = async function () {\r\n  $(self.ctx.$container).css({\r\n    height: '100%',\r\n    overflow: 'auto', // RFC-0093: Changed from 'hidden' to allow vertical scroll\r\n    display: 'flex',\r\n    flexDirection: 'column',\r\n    position: 'relative',\r\n  });\r\n\r\n  MyIO = (typeof MyIOLibrary !== 'undefined' && MyIOLibrary) ||\r\n    (typeof window !== 'undefined' && window.MyIOLibrary) || {\r\n      showAlert: function () {\r\n        alert('A Bliblioteca Myio n√£o foi carregada corretamente!');\r\n      },\r\n    };\r\n\r\n  $root().find('#labelWidgetId').text(self.ctx.settings?.labelWidget);\r\n\r\n  // RFC-0042: Set widget configuration from settings FIRST\r\n  WIDGET_DOMAIN = self.ctx.settings?.DOMAIN || 'energy';\r\n  USE_NEW_COMPONENTS = self.ctx.settings?.useNewComponents ?? true;\r\n  ENABLE_SELECTION = self.ctx.settings?.enableSelection ?? true;\r\n  ENABLE_DRAG_DROP = self.ctx.settings?.enableDragDrop ?? true;\r\n  HIDE_INFO_MENU_ITEM = self.ctx.settings?.hideInfoMenuItem ?? true;\r\n  DEBUG_ACTIVE = self.ctx.settings?.debugActive ?? false;\r\n  ACTIVE_TOOLTIP_DEBUG = self.ctx.settings?.activeTooltipDebug ?? false;\r\n  LogHelper.log(`[TELEMETRY] Configured EARLY: domain=${WIDGET_DOMAIN}, debugActive=${DEBUG_ACTIVE}, activeTooltipDebug=${ACTIVE_TOOLTIP_DEBUG}`);\r\n\r\n  // RFC-0093: Build centralized header via buildHeaderDevicesGrid\r\n  const buildHeaderDevicesGrid = window.MyIOUtils?.buildHeaderDevicesGrid;\r\n  if (buildHeaderDevicesGrid) {\r\n    storesHeaderController = buildHeaderDevicesGrid({\r\n      container: '#storesHeaderContainer',\r\n      domain: 'stores',\r\n      idPrefix: 'stores',\r\n      labels: {\r\n        total: 'Total de Lojas',\r\n        consumption: 'Consumo Total de Todas Lojas',\r\n      },\r\n      includeSearch: true,\r\n      includeFilter: true,\r\n      onSearchClick: () => {\r\n        STATE.searchActive = !STATE.searchActive;\r\n        if (STATE.searchActive) {\r\n          const input = storesHeaderController?.getSearchInput();\r\n          if (input) setTimeout(() => input.focus(), 100);\r\n        }\r\n      },\r\n      onFilterClick: () => {\r\n        openFilterModal();\r\n      },\r\n    });\r\n\r\n    // Setup search input listener\r\n    const searchInput = storesHeaderController?.getSearchInput();\r\n    if (searchInput) {\r\n      searchInput.addEventListener('input', (e) => {\r\n        STATE.searchTerm = e.target.value || '';\r\n        reflowFromState();\r\n      });\r\n    }\r\n\r\n    LogHelper.log('[STORES] RFC-0093: Header built via buildHeaderDevicesGrid');\r\n  } else {\r\n    LogHelper.warn('[STORES] RFC-0093: buildHeaderDevicesGrid not available');\r\n  }\r\n\r\n  // RFC-0063: Load classification mode configuration\r\n  USE_IDENTIFIER_CLASSIFICATION = self.ctx.settings?.USE_IDENTIFIER_CLASSIFICATION || false;\r\n  USE_HYBRID_CLASSIFICATION = self.ctx.settings?.USE_HYBRID_CLASSIFICATION || false;\r\n  LogHelper.log(\r\n    `[RFC-0063] Classification mode: ${\r\n      USE_IDENTIFIER_CLASSIFICATION\r\n        ? USE_HYBRID_CLASSIFICATION\r\n          ? 'HYBRID (identifier + label fallback)'\r\n          : 'IDENTIFIER ONLY'\r\n        : 'LEGACY (label only)'\r\n    }`\r\n  );\r\n\r\n  // RFC-0042: Request data from orchestrator (defined early for use in handlers)\r\n  function requestDataFromOrchestrator() {\r\n    if (!self.ctx.scope?.startDateISO || !self.ctx.scope?.endDateISO) {\r\n      LogHelper.warn('[TELEMETRY] No date range set, cannot request data');\r\n      return;\r\n    }\r\n\r\n    const period = {\r\n      startISO: self.ctx.scope.startDateISO,\r\n      endISO: self.ctx.scope.endDateISO,\r\n      granularity: window.calcGranularity\r\n        ? window.calcGranularity(self.ctx.scope.startDateISO, self.ctx.scope.endDateISO)\r\n        : 'day',\r\n      tz: 'America/Sao_Paulo',\r\n    };\r\n\r\n    LogHelper.log(`[TELEMETRY] Requesting data for domain=${WIDGET_DOMAIN}, period:`, period);\r\n\r\n    // RFC-0053: Single window context - emit to current window only\r\n    window.dispatchEvent(\r\n      new CustomEvent('myio:telemetry:request-data', {\r\n        detail: { domain: WIDGET_DOMAIN, period },\r\n      })\r\n    );\r\n  }\r\n\r\n  dateUpdateHandler = function (ev) {\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ DATE UPDATE EVENT RECEIVED!`, ev.detail);\r\n\r\n    try {\r\n      // Pega as datas do evento (formato antigo ou novo)\r\n      let startISO, endISO;\r\n      if (ev.detail?.period) {\r\n        startISO = ev.detail.period.startISO;\r\n        endISO = ev.detail.period.endISO;\r\n      } else {\r\n        // Fallback para formato antigo\r\n        const { startDate, endDate } = ev.detail || {};\r\n        startISO = new Date(startDate).toISOString();\r\n        endISO = new Date(endDate).toISOString();\r\n      }\r\n\r\n      LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] Date range updated:`, startISO, endISO);\r\n\r\n      // Atualiza o scope\r\n      self.ctx.scope = self.ctx.scope || {};\r\n      self.ctx.scope.startDateISO = startISO;\r\n      self.ctx.scope.endDateISO = endISO;\r\n\r\n      // CHAMA A FUN√á√ÉO DE FETCH LOCAL (a que j√° existe neste widget)\r\n      // Em vez de chamar o orquestrador.\r\n      hydrateAndRender();\r\n    } catch (err) {\r\n      LogHelper.error(`[TELEMETRY ${WIDGET_DOMAIN}] dateUpdateHandler error:`, err);\r\n      hideBusy();\r\n    }\r\n  };\r\n\r\n  LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] üì° Registering myio:update-date listener...`);\r\n  window.addEventListener('myio:update-date', dateUpdateHandler);\r\n  LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ myio:update-date listener registered!`);\r\n\r\n  // RFC-0042: Listen for clear event from HEADER (when user clicks \"Limpar\" button)\r\n  window.addEventListener('myio:telemetry:clear', (ev) => {\r\n    const { domain } = ev.detail;\r\n\r\n    // Only clear if it's for my domain\r\n    if (domain !== WIDGET_DOMAIN) {\r\n      LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] Ignoring clear event for domain: ${domain}`);\r\n      return;\r\n    }\r\n\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] üßπ Received clear event - clearing visual content`);\r\n\r\n    try {\r\n      // Clear the items list\r\n      STATE.itemsBase = [];\r\n      STATE.itemsEnriched = [];\r\n      STATE.selectedIds = null;\r\n\r\n      // IMPORTANT: Use $root() to get elements within THIS widget's scope\r\n      const $widget = $root();\r\n\r\n      // Clear the visual list\r\n      const $shopsList = $widget.find('#shopsList');\r\n      if ($shopsList.length > 0) {\r\n        $shopsList.empty();\r\n        LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ shopsList cleared`);\r\n      }\r\n\r\n      // Reset counts to 0\r\n      const $shopsCount = $widget.find('#shopsCount');\r\n      const $shopsTotal = $widget.find('#shopsTotal');\r\n\r\n      if ($shopsCount.length > 0) {\r\n        $shopsCount.text('(0)');\r\n        LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ shopsCount reset to 0`);\r\n      }\r\n\r\n      if ($shopsTotal.length > 0) {\r\n        $shopsTotal.text('0,00');\r\n        LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ shopsTotal reset to 0,00`);\r\n      }\r\n\r\n      LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] üßπ Clear completed successfully`);\r\n    } catch (err) {\r\n      LogHelper.error(`[TELEMETRY ${WIDGET_DOMAIN}] ‚ùå Error during clear:`, err);\r\n    }\r\n  });\r\n\r\n  // RFC-0093: Function to render shopping filter chips in toolbar (same as EQUIPMENTS)\r\n  function renderShoppingFilterChips(selection) {\r\n    const chipsContainer = document.getElementById('storesShoppingFilterChips');\r\n    if (!chipsContainer) return;\r\n\r\n    chipsContainer.innerHTML = '';\r\n\r\n    if (!selection || selection.length === 0) {\r\n      return; // No filter applied, hide chips\r\n    }\r\n\r\n    selection.forEach((shopping) => {\r\n      const chip = document.createElement('span');\r\n      chip.className = 'filter-chip';\r\n      chip.innerHTML = `<span class=\"filter-chip-icon\">üè¨</span><span>${shopping.name}</span>`;\r\n      chipsContainer.appendChild(chip);\r\n    });\r\n\r\n    LogHelper.log('[STORES] üìç Rendered', selection.length, 'shopping filter chips');\r\n  }\r\n\r\n  // RFC-0093: Listen for shopping filter changes\r\n  window.addEventListener('myio:filter-applied', (ev) => {\r\n    const selection = ev.detail?.selection || [];\r\n    LogHelper.log('[STORES] üî• heard myio:filter-applied:', selection.length, 'shoppings');\r\n\r\n    // Extract shopping IDs (ingestionIds) from selection\r\n    const shoppingIds = selection.map((s) => s.value).filter((v) => v);\r\n\r\n    LogHelper.log(\r\n      '[STORES] Applying shopping filter:',\r\n      shoppingIds.length === 0 ? 'ALL' : `${shoppingIds.length} shoppings`\r\n    );\r\n\r\n    // Update STATE and reflow cards\r\n    STATE.selectedShoppingIds = shoppingIds;\r\n\r\n    // Render shopping filter chips\r\n    renderShoppingFilterChips(selection);\r\n\r\n    // Reflow to apply filter\r\n    reflowFromState();\r\n  });\r\n\r\n  // RFC-0093: Check for pre-existing filter when STORES initializes\r\n  // This handles the case where user filtered in MENU, then navigated to STORES\r\n  if (\r\n    window.custumersSelected &&\r\n    Array.isArray(window.custumersSelected) &&\r\n    window.custumersSelected.length > 0\r\n  ) {\r\n    LogHelper.log('[STORES] üîÑ Applying pre-existing filter:', window.custumersSelected.length, 'shoppings');\r\n    const shoppingIds = window.custumersSelected.map((s) => s.value).filter((v) => v);\r\n    STATE.selectedShoppingIds = shoppingIds;\r\n    renderShoppingFilterChips(window.custumersSelected);\r\n    // Note: reflowFromState will be called later when data is loaded\r\n  }\r\n\r\n  // Test if listener is working\r\n  setTimeout(() => {\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] üß™ Testing listener registration...`);\r\n    const testEvent = new CustomEvent('myio:update-date', {\r\n      detail: {\r\n        period: {\r\n          startISO: '2025-09-26T00:00:00-03:00',\r\n          endISO: '2025-10-02T23:59:59-03:00',\r\n          granularity: 'day',\r\n          tz: 'America/Sao_Paulo',\r\n        },\r\n      },\r\n    });\r\n    // Don't dispatch, just check if handler exists\r\n    if (typeof dateUpdateHandler === 'function') {\r\n      LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] ‚úÖ dateUpdateHandler is defined and ready`);\r\n    } else {\r\n      LogHelper.error(`[TELEMETRY ${WIDGET_DOMAIN}] ‚ùå dateUpdateHandler is NOT defined!`);\r\n    }\r\n  }, 100);\r\n\r\n  // RFC-0045 FIX: Store pending provide-data events that arrive before update-date\r\n  let pendingProvideData = null;\r\n\r\n  // RFC-0042: Listen for data provision from orchestrator\r\n  dataProvideHandler = function (ev) {\r\n    LogHelper.log(\r\n      `[TELEMETRY ${WIDGET_DOMAIN}] üì¶ Received provide-data event for domain ${\r\n        ev.detail.domain\r\n      }, periodKey: ${ev.detail.periodKey}, items: ${ev.detail.items?.length || 0}`\r\n    );\r\n    const { domain, periodKey, items } = ev.detail;\r\n\r\n    // Only process if it's for my domain\r\n    if (domain !== WIDGET_DOMAIN) {\r\n      LogHelper.log(\r\n        `[TELEMETRY ${WIDGET_DOMAIN}] ‚è≠Ô∏è Ignoring event for domain ${domain}, my domain is ${WIDGET_DOMAIN}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    // IMPORTANT: Prevent duplicate processing of the same periodKey\r\n    // The Orchestrator retries emission after 1s, so we need to deduplicate\r\n    if (lastProcessedPeriodKey === periodKey) {\r\n      LogHelper.log(`[TELEMETRY] ‚è≠Ô∏è Skipping duplicate provide-data for periodKey: ${periodKey}`);\r\n      return;\r\n    }\r\n\r\n    // Validate current period matches\r\n    const myPeriod = {\r\n      startISO: self.ctx.scope?.startDateISO,\r\n      endISO: self.ctx.scope?.endDateISO,\r\n    };\r\n\r\n    // RFC-0045 FIX: If period not set yet, STORE the event and wait for myio:update-date\r\n    if (!myPeriod.startISO || !myPeriod.endISO) {\r\n      LogHelper.warn(`[TELEMETRY] ‚è∏Ô∏è Period not set yet, storing provide-data event for later processing`);\r\n      pendingProvideData = { domain, periodKey, items };\r\n      // DON'T call hideBusy() here - wait for update-date to process the data\r\n      return;\r\n    }\r\n\r\n    // Mark this periodKey as processed ONLY when actually processing\r\n    lastProcessedPeriodKey = periodKey;\r\n\r\n    // IMPORTANT: Do NOT call showBusy() here - it was already called in dateUpdateHandler\r\n    // Calling it again creates a NEW timeout that won't be properly cancelled\r\n    LogHelper.log(`[TELEMETRY] üîÑ Processing data from orchestrator...`);\r\n    LogHelper.log(`[TELEMETRY] Received ${items.length} items from orchestrator for domain ${domain}`);\r\n\r\n    // Extract my datasource IDs\r\n    const myDatasourceIds = extractDatasourceIds(self.ctx.datasources);\r\n\r\n    // RFC-0042: Filter items by datasource IDs\r\n    // ThingsBoard datasource entityId should match API item id (ingestionId)\r\n    const datasourceIdSet = new Set(myDatasourceIds);\r\n    let filtered = items.filter((item) => {\r\n      // Check if item.id (from API) matches any datasource entityId\r\n      return datasourceIdSet.has(item.id) || datasourceIdSet.has(item.tbId);\r\n    });\r\n\r\n    LogHelper.log(\r\n      `[TELEMETRY] Filtered ${items.length} items down to ${filtered.length} items matching datasources`\r\n    );\r\n\r\n    // If no matches, log warning and use all items (temporary fallback)\r\n    if (filtered.length === 0) {\r\n      LogHelper.warn(`[TELEMETRY] No items match datasource IDs! Using all items as fallback.`);\r\n      LogHelper.warn(`[TELEMETRY] Sample datasource ID:`, myDatasourceIds[0]);\r\n      LogHelper.warn(`[TELEMETRY] Sample API item ID:`, items[0]?.id);\r\n      filtered = items;\r\n    }\r\n\r\n    // Convert orchestrator items to TELEMETRY widget format\r\n    filtered = filtered.map((item) => ({\r\n      id: item.tbId || item.id,\r\n      tbId: item.tbId || item.id,\r\n      ingestionId: item.ingestionId || item.id,\r\n      identifier: item.identifier || item.id,\r\n      label: item.label || item.identifier || item.id,\r\n      value: Number(item.value || 0),\r\n      perc: 0,\r\n      deviceType: item.deviceType || 'energy',\r\n      slaveId: item.slaveId || null,\r\n      centralId: item.centralId || null,\r\n      updatedIdentifiers: {},\r\n    }));\r\n\r\n    // DEBUG: Log sample item with value\r\n    if (filtered.length > 0 && filtered[0].value > 0) {\r\n      LogHelper.log(`[TELEMETRY] üîç Sample orchestrator item after mapping:`, {\r\n        ingestionId: filtered[0].ingestionId,\r\n        label: filtered[0].label,\r\n        value: filtered[0].value,\r\n      });\r\n    }\r\n\r\n    LogHelper.log(`[TELEMETRY] Using ${filtered.length} items after processing`);\r\n\r\n    // IMPORTANT: Merge orchestrator data with existing TB data\r\n    // Keep original labels/identifiers from TB, only update values from orchestrator\r\n    if (!STATE.itemsBase || STATE.itemsBase.length === 0) {\r\n      // First load: build from TB data\r\n      LogHelper.log(`[TELEMETRY] Building itemsBase from TB data...`);\r\n      STATE.itemsBase = buildAuthoritativeItems();\r\n      LogHelper.log(`[TELEMETRY] Built ${STATE.itemsBase.length} items from TB`);\r\n    }\r\n\r\n    // Create map of orchestrator values by ingestionId\r\n    const orchestratorValues = new Map();\r\n    filtered.forEach((item) => {\r\n      if (item.ingestionId) {\r\n        const value = Number(item.value || 0);\r\n        orchestratorValues.set(item.ingestionId, value);\r\n      }\r\n    });\r\n    LogHelper.log(`[TELEMETRY] Orchestrator values map size: ${orchestratorValues.size}`);\r\n\r\n    // Update values in existing items\r\n    STATE.itemsEnriched = STATE.itemsBase.map((tbItem) => {\r\n      const orchestratorValue = orchestratorValues.get(tbItem.ingestionId);\r\n\r\n      return {\r\n        ...tbItem,\r\n        value: orchestratorValue !== undefined ? orchestratorValue : tbItem.value || 0,\r\n        perc: 0,\r\n      };\r\n    });\r\n\r\n    LogHelper.log(`[TELEMETRY] Enriched ${STATE.itemsEnriched.length} items with orchestrator values`);\r\n\r\n    // RFC-0056 FIX v1.1: Emit telemetry update after enrichment\r\n    emitTelemetryUpdate();\r\n\r\n    // Sanitize selection\r\n    if (STATE.selectedIds && STATE.selectedIds.size) {\r\n      const valid = new Set(STATE.itemsBase.map((x) => String(x.id)));\r\n      const next = new Set([...STATE.selectedIds].filter((id) => valid.has(String(id))));\r\n      STATE.selectedIds = next.size ? next : null;\r\n    }\r\n\r\n    reflowFromState();\r\n\r\n    // RFC-0044: ALWAYS hide busy when data is provided, regardless of source\r\n    LogHelper.log(`[TELEMETRY] üèÅ Data processed successfully - ensuring busy is hidden`);\r\n\r\n    // Force hide busy with minimal delay to ensure UI update\r\n    setTimeout(() => {\r\n      hideBusy();\r\n      // Double-check: if orchestrator busy is still showing, force hide it\r\n      if (window.MyIOOrchestrator && window.MyIOOrchestrator.getBusyState) {\r\n        const busyState = window.MyIOOrchestrator.getBusyState();\r\n        if (busyState.isVisible) {\r\n          LogHelper.warn(\r\n            `[TELEMETRY] ‚ö†Ô∏è Orchestrator busy still visible after data processing - force hiding`\r\n          );\r\n          window.MyIOOrchestrator.hideGlobalBusy();\r\n        }\r\n      }\r\n    }, 100); // Reduced to 100ms for faster response\r\n  };\r\n\r\n  /**\r\n   * Extracts ingestionIds from ThingsBoard ctx.data (not datasource entityIds).\r\n   * Each device has 6 keys (slaveId, centralId, ingestionId, connectionStatus, deviceType, identifier).\r\n   * We need to extract the ingestionId values to match with API data.\r\n   */\r\n  function extractDatasourceIds(datasources) {\r\n    // Build index from ctx.data to get ingestionId for each device\r\n    const ingestionIds = new Set();\r\n    const rows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\r\n\r\n    for (const row of rows) {\r\n      const key = String(row?.dataKey?.name || '').toLowerCase();\r\n      const val = row?.data?.[0]?.[1];\r\n\r\n      if (key === 'ingestionid' && val && isValidUUID(String(val))) {\r\n        ingestionIds.add(String(val));\r\n      }\r\n    }\r\n\r\n    return Array.from(ingestionIds);\r\n  }\r\n\r\n  window.addEventListener('myio:telemetry:provide-data', dataProvideHandler);\r\n\r\n  // RFC-0056 FIX v1.1: Listen for request_refresh from TELEMETRY_INFO\r\n  let requestRefreshHandler = function (ev) {\r\n    const { type, domain, periodKey } = ev.detail || {};\r\n\r\n    if (type !== 'request_refresh') return;\r\n    if (domain !== WIDGET_DOMAIN) return;\r\n\r\n    LogHelper.log(`[RFC-0056] Received request_refresh for domain ${domain}, periodKey ${periodKey}`);\r\n\r\n    // Re-emit telemetry data\r\n    const currentPeriodKey = buildPeriodKey();\r\n    if (currentPeriodKey === periodKey) {\r\n      LogHelper.log(`[RFC-0056] Re-emitting data for current period`);\r\n      emitTelemetryUpdate();\r\n    } else {\r\n      LogHelper.warn(`[RFC-0056] Period mismatch: requested ${periodKey}, current ${currentPeriodKey}`);\r\n    }\r\n  };\r\n\r\n  window.addEventListener('myio:telemetry:update', requestRefreshHandler);\r\n\r\n  // RFC-0091: Use credentials from MAIN via MyIOUtils (already fetched by MAIN)\r\n  const jwt = localStorage.getItem('jwt_token');\r\n\r\n  // Try to get credentials from MAIN first\r\n  const mainCredentials = window.MyIOUtils?.getCredentials?.();\r\n  if (mainCredentials?.clientId && mainCredentials?.clientSecret) {\r\n    CLIENT_ID = mainCredentials.clientId;\r\n    CLIENT_SECRET = mainCredentials.clientSecret;\r\n    CUSTOMER_ING_ID = mainCredentials.customerIngestionId || '';\r\n    LogHelper.log('[STORES] Using credentials from MAIN (MyIOUtils)');\r\n  } else {\r\n    // Fallback: fetch credentials directly if MAIN not ready\r\n    LogHelper.log('[STORES] MAIN credentials not available, fetching directly...');\r\n    const customerTB_ID = window.MyIOUtils?.getCustomerId?.() || window.myioHoldingCustomerId || '';\r\n\r\n    if (!customerTB_ID) {\r\n      LogHelper.error(\r\n        '[STORES] ‚ùå customerTB_ID not found - MAIN has not initialized window.myioHoldingCustomerId'\r\n      );\r\n    }\r\n\r\n    try {\r\n      const attrs = await MyIO.fetchThingsboardCustomerAttrsFromStorage(customerTB_ID, jwt);\r\n      CLIENT_ID = attrs?.client_id || '';\r\n      CLIENT_SECRET = attrs?.client_secret || '';\r\n      CUSTOMER_ING_ID = attrs?.ingestionId || '';\r\n    } catch (err) {\r\n      LogHelper.error('[STORES] Failed to fetch credentials:', err);\r\n    }\r\n  }\r\n\r\n  // Initialize auth if we have credentials\r\n  if (CLIENT_ID && CLIENT_SECRET) {\r\n    try {\r\n      MyIOAuth = MyIO.buildMyioIngestionAuth({\r\n        dataApiHost: getDataApiHost(),\r\n        clientId: CLIENT_ID,\r\n        clientSecret: CLIENT_SECRET,\r\n      });\r\n\r\n      LogHelper.log('[STORES] Auth init OK');\r\n      try {\r\n        await MyIOAuth.getToken();\r\n      } catch (_e) {\r\n        /* ignore token errors */\r\n      }\r\n    } catch (err) {\r\n      LogHelper.error('[STORES] Auth init FAIL', err);\r\n    }\r\n  } else {\r\n    LogHelper.warn('[STORES] No credentials available for auth initialization');\r\n  }\r\n\r\n  // Bind UI\r\n  bindHeader();\r\n  bindModal();\r\n\r\n  // ---------- Datas iniciais: \"Current Month So Far\" ----------\r\n  if (!self.ctx?.scope?.startDateISO || !self.ctx?.scope?.endDateISO) {\r\n    const now = new Date();\r\n    const start = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0); // 1¬∫ dia 00:00\r\n    const end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 0); // hoje 23:59:59\r\n    self.ctx.scope = self.ctx.scope || {};\r\n    self.ctx.scope.startDateISO = start.toISOString();\r\n    self.ctx.scope.endDateISO = end.toISOString();\r\n  }\r\n  // ------------------------------------------------------------\r\n\r\n  const hasData = Array.isArray(self.ctx.data) && self.ctx.data.length > 0;\r\n  // RFC-0042: Removed direct API fetch - now using orchestrator\r\n  LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] onInit - Waiting for orchestrator data...`);\r\n\r\n  // Build initial itemsBase from ThingsBoard data\r\n  if (hasData && (!STATE.itemsBase || STATE.itemsBase.length === 0)) {\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] Building itemsBase from TB data in onInit...`);\r\n    STATE.itemsBase = buildAuthoritativeItems();\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] Built ${STATE.itemsBase.length} items from TB`);\r\n\r\n    // Initial render with zero values (will be updated by orchestrator)\r\n    STATE.itemsEnriched = STATE.itemsBase.map((item) => ({\r\n      ...item,\r\n      value: 0,\r\n      perc: 0,\r\n    }));\r\n    reflowFromState();\r\n  }\r\n\r\n  // Only show busy if we have a date range defined\r\n  if (self.ctx?.scope?.startDateISO && self.ctx?.scope?.endDateISO) {\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] Initial period defined, showing busy...`);\r\n    showBusy();\r\n  } else {\r\n    LogHelper.log(`[TELEMETRY ${WIDGET_DOMAIN}] No initial period, waiting for myio:update-date event...`);\r\n  }\r\n\r\n  // RFC-0042: OLD CODE - Direct API fetch (now handled by orchestrator)\r\n  if (hasData) {\r\n    STATE.firstHydrates++;\r\n    if (STATE.firstHydrates <= MAX_FIRST_HYDRATES) {\r\n      await hydrateAndRender();\r\n    }\r\n  } else {\r\n    // Aguardar datasource chegar\r\n    const waiter = setInterval(async () => {\r\n      if (Array.isArray(self.ctx.data) && self.ctx.data.length > 0) {\r\n        clearInterval(waiter);\r\n        STATE.firstHydrates++;\r\n        if (STATE.firstHydrates <= MAX_FIRST_HYDRATES) await hydrateAndRender();\r\n      }\r\n    }, 200);\r\n  }\r\n};\r\n\r\n// onDataUpdated removido (no-op por ora)\r\nself.onDataUpdated = function () {\r\n  /* no-op */\r\n};\r\n\r\nself.onResize = function () {};\r\nself.onDestroy = function () {\r\n  if (dateUpdateHandler) {\r\n    window.removeEventListener('myio:update-date', dateUpdateHandler);\r\n    LogHelper.log(\"[DeviceCards] Event listener 'myio:update-date' removido.\");\r\n  }\r\n  if (dataProvideHandler) {\r\n    window.removeEventListener('myio:telemetry:provide-data', dataProvideHandler);\r\n    LogHelper.log(\"[DeviceCards] Event listener 'myio:telemetry:provide-data' removido.\");\r\n  }\r\n  // RFC-0056 FIX v1.1: Remove request_refresh listener\r\n  if (requestRefreshHandler) {\r\n    window.removeEventListener('myio:telemetry:update', requestRefreshHandler);\r\n    LogHelper.log(\"[RFC-0056] Event listener 'myio:telemetry:update' removido.\");\r\n  }\r\n\r\n  // RFC-0093: Cleanup header controller\r\n  if (storesHeaderController) {\r\n    storesHeaderController.destroy();\r\n    storesHeaderController = null;\r\n    LogHelper.log('[STORES] [RFC-0093] Header controller destroyed');\r\n  }\r\n\r\n  // RFC-0090: Cleanup filter modal using shared factory\r\n  if (storesFilterModal) {\r\n    storesFilterModal.destroy();\r\n    storesFilterModal = null;\r\n    LogHelper.log('[STORES] [RFC-0090] Filter modal destroyed');\r\n  }\r\n\r\n  try {\r\n    $root().off();\r\n  } catch (_e) {\r\n    /* ignore cleanup errors */\r\n  }\r\n  hideBusy();\r\n  hideGlobalSuccessModal();\r\n};\r\n",
      "settingsSchema": "{\r\n  \"schema\": {\r\n    \"type\": \"object\",\r\n    \"title\": \"Telemetry Widget Settings\",\r\n    \"properties\": {\r\n        \"labelWidget\":{\r\n            \"type\":\"string\",\r\n            \"title\": \"Widget Label\",\r\n            \"default\": \"Devices\"\r\n        },\r\n        \"DOMAIN\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Domain\",\r\n            \"enum\": [\"energy\", \"water\", \"temperature\"],\r\n            \"default\": \"energy\",\r\n            \"description\": \"Data domain for this widget (energy, water, or temperature)\"\r\n        },\r\n        \"useNewComponents\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Use New Components\",\r\n            \"default\": true\r\n        },\r\n        \"enableSelection\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Enable Selection\",\r\n            \"default\": true\r\n        },\r\n        \"enableDragDrop\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Enable Drag Drop\",\r\n            \"default\": true\r\n        },\r\n        \"hideInfoMenuItem\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Hide Info Menu Item\",\r\n            \"default\": true\r\n        },\r\n        \"debugActive\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Debug Active\",\r\n            \"default\": false\r\n        },\r\n        \"activeTooltipDebug\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Active Tooltip Debug\",\r\n            \"default\": false\r\n        }\r\n    },\r\n    \"required\": [\"DOMAIN\"]\r\n  },\r\n  \"form\": [\r\n    \"labelWidget\",\r\n    \"DOMAIN\",\r\n    \"useNewComponents\",\r\n    \"enableSelection\",\r\n    \"enableDragDrop\",\r\n    \"hideInfoMenuItem\",\r\n    \"debugActive\",\r\n    \"activeTooltipDebug\"\r\n  ]\r\n}\r\n",
      "dataKeySettingsSchema": "{}\n",
      "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Widget Head Office - STORES  - v.5.2.0\",\"decimals\":null}"
    },
    "externalId": null,
    "resources": null,
    "id": {
      "entityType": "WIDGET_TYPE",
      "id": "ed487ff0-c97a-11f0-84a2-1f4ed3957b2a"
    },
    "scada": false,
    "tags": null
  },
  "relations": [],
  "attributes": {
    "SERVER_SCOPE": []
  }
}