{
  "entityType": "WIDGET_TYPE",
  "entity": {
    "fqn": "widget_head_office_water_common_area_v_5_2_0",
    "name": "Widget Head Office - WATER COMMON AREA- v.5.2.0",
    "deprecated": false,
    "image": null,
    "description": null,
    "descriptor": {
      "type": "latest",
      "sizeX": 7.5,
      "sizeY": 3,
      "resources": [
        {
          "url": "https://graphs.staging.apps.myio-bas.com/sdk/energy-chart-sdk.umd.js"
        },
        {
          "url": "https://unpkg.com/myio-js-library@0.1.180/dist/myio-js-library.umd.min.js"
        }
      ],
      "templateHtml": "<!-- RFC-0094: WATER_COMMON_AREA - Simplified template following WATER_STORES pattern -->\r\n<!-- Header is dynamically injected by buildHeaderDevicesGrid in controller.js -->\r\n<section class=\"water-common-area-wrap\" id=\"waterCommonAreaWrap\">\r\n  <div class=\"toolbar-zoom\">\r\n    <div class=\"shopping-filter-chips\" id=\"waterCommonAreaShoppingFilterChips\"></div>\r\n  </div>\r\n\r\n  <div id=\"waterCommonAreaHeaderContainer\"></div>\r\n  <section id=\"waterCommonAreaList\" class=\"cards-grid\"></section>\r\n</section>\r\n",
      "templateCss": "/* ====== TOKENS (escopo no wrap) ====== */\r\n/* RFC-0087: WATER_COMMON_AREA widget - based on EQUIPMENTS */\r\n.water-common-area-wrap {\r\n  /* escala global de fontes (ajustada via JS) */\r\n  --fs: 0.94;\r\n\r\n  /* cores e layout - tema Ã¡gua (azul) */\r\n  --card-grad: linear-gradient(180deg, #ffffff 0%, #f0f9ff 100%);\r\n  --card-bd: #bae6fd;\r\n  --ink-1: #0c4a6e;\r\n  --ink-2: #64748b;\r\n  --blue: #0288d1;\r\n  --accent: #06b6d4;\r\n  --danger: #e54848;\r\n  --shadow: 0 8px 24px rgba(2, 136, 209, 0.08);\r\n  --shadow-hover: 0 14px 36px rgba(2, 136, 209, 0.16);\r\n  --radius: 20px;\r\n\r\n  /* tipografia derivada da escala */\r\n  --fs-2xs: calc(11px * var(--fs));\r\n  --fs-xs: calc(12px * var(--fs));\r\n  --fs-sm: calc(13px * var(--fs));\r\n  --fs-md: calc(14px * var(--fs));\r\n  --fs-lg: calc(16px * var(--fs));\r\n  --fs-xl: calc(20px * var(--fs));\r\n  --fs-xxl: calc(28px * var(--fs));\r\n\r\n  /* padding para nÃ£o \"encostar\" no contorno do widget */\r\n  position: relative;\r\n  box-sizing: border-box;\r\n  padding: 12px;\r\n  width: 100%;\r\n  height: 100%;\r\n  overflow: auto; /* FIX: Same as STORES - allows vertical scroll */\r\n  background: transparent;\r\n}\r\n\r\n/* ====== RFC-0087: SUB-MENU NAVIGATION (Water) ====== */\r\n.water-submenu {\r\n  display: flex;\r\n  gap: 8px;\r\n  padding: 12px 16px;\r\n  background: linear-gradient(to bottom, #f0f9ff, #ffffff);\r\n  border-bottom: 2px solid #bae6fd;\r\n  box-shadow: 0 2px 4px rgba(2, 136, 209, 0.05);\r\n  margin: -12px -12px 16px -12px; /* Negative margin to extend to widget edges */\r\n}\r\n\r\n.submenu-tab {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n  padding: 10px 20px;\r\n  background: #ffffff;\r\n  border: 1px solid #d0d0d0;\r\n  border-radius: 6px;\r\n  color: #424242;\r\n  font-size: 14px;\r\n  font-weight: 500;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n  outline: none;\r\n}\r\n\r\n.submenu-tab:hover {\r\n  background: #f5f5f5;\r\n  border-color: #7a2ff7;\r\n  color: #7a2ff7;\r\n}\r\n\r\n.submenu-tab.is-active {\r\n  background: linear-gradient(135deg, #0288d1, #0277bd);\r\n  color: #ffffff;\r\n  border-color: #0288d1;\r\n  box-shadow: 0 2px 8px rgba(2, 136, 209, 0.3);\r\n}\r\n\r\n.submenu-tab .ico {\r\n  font-size: 16px;\r\n  line-height: 1;\r\n}\r\n\r\n.submenu-tab:focus-visible {\r\n  outline: 2px solid #7a2ff7;\r\n  outline-offset: 2px;\r\n}\r\n\r\n/* RFC-0079: Sub-menu controls MAIN widget states */\r\n/* No view containers needed in EQUIPMENTS - all controlled via MAIN */\r\n\r\n/* Responsive: Stack tabs vertically on mobile */\r\n@media (max-width: 768px) {\r\n  .water-submenu {\r\n    flex-direction: column;\r\n    gap: 6px;\r\n    padding: 10px 12px;\r\n  }\r\n\r\n  .submenu-tab {\r\n    width: 100%;\r\n    justify-content: flex-start;\r\n    padding: 12px 16px;\r\n  }\r\n}\r\n\r\n/* ====== WATER STATISTICS HEADER ====== */\r\n.water-common-area-wrap > .water-stats-header,\r\n#waterStatsHeader {\r\n  display: flex !important;\r\n  flex-direction: row !important;\r\n  flex-wrap: nowrap !important;\r\n  gap: 16px;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);\r\n  border: 1px solid #bae6fd;\r\n  border-radius: 12px;\r\n  padding: 10px 16px;\r\n  margin-bottom: 32px;\r\n  padding-bottom: 16px;\r\n  border-bottom: 3px solid #7dd3fc;\r\n  box-shadow: 0 4px 12px rgba(2, 136, 209, 0.06);\r\n  width: 100%;\r\n}\r\n\r\n.water-common-area-wrap > .water-stats-header .stat-item,\r\n#waterStatsHeader .stat-item {\r\n  display: flex !important;\r\n  flex-direction: column !important;\r\n  gap: 2px;\r\n  flex: 1;\r\n  min-width: 0;\r\n  text-align: center;\r\n}\r\n\r\n.water-stats-header .stat-item.highlight {\r\n  background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);\r\n  border-radius: 8px;\r\n  padding: 6px 12px;\r\n  border: 1px solid #7dd3fc;\r\n}\r\n\r\n.water-stats-header .stat-label {\r\n  font-size: var(--fs-xs);\r\n  color: var(--ink-2);\r\n  font-weight: 500;\r\n  text-transform: uppercase;\r\n  letter-spacing: 0.5px;\r\n}\r\n\r\n.water-stats-header .stat-value {\r\n  font-size: var(--fs-lg);\r\n  color: var(--ink-1);\r\n  font-weight: 700;\r\n}\r\n\r\n.water-stats-header .stat-item.highlight .stat-value {\r\n  color: #0284c7;\r\n  font-size: var(--fs-xl);\r\n}\r\n\r\n/* ====== CONTROLES DE ZOOM ====== */\r\n.toolbar-zoom {\r\n  position: sticky;\r\n  top: 6px;\r\n  z-index: 2;\r\n  display: flex;\r\n  gap: 6px;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  margin-bottom: 8px;\r\n}\r\n\r\n.toolbar-zoom button {\r\n  border: 1px solid var(--card-bd);\r\n  background: #fff;\r\n  border-radius: 10px;\r\n  padding: 4px 10px;\r\n  font-size: var(--fs-lg);\r\n  color: var(--ink-1);\r\n  cursor: pointer;\r\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);\r\n}\r\n\r\n.toolbar-zoom button:hover {\r\n  background: #f3f8fc;\r\n}\r\n\r\n/* ====== SHOPPING FILTER CHIPS ====== */\r\n.shopping-filter-chips {\r\n  display: flex;\r\n  gap: 6px;\r\n  flex-wrap: wrap;\r\n  align-items: center;\r\n  flex: 1;\r\n  margin-right: 12px;\r\n}\r\n\r\n.shopping-filter-chips .filter-chip {\r\n  display: inline-flex;\r\n  align-items: center;\r\n  gap: 6px;\r\n  background: linear-gradient(135deg, #e0f2fe 0%, #dbeafe 100%);\r\n  border: 1px solid #bae6fd;\r\n  border-radius: 8px;\r\n  padding: 3px 8px;\r\n  font-size: var(--fs-xs);\r\n  color: #0c4a6e;\r\n  font-weight: 500;\r\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);\r\n  white-space: nowrap;\r\n}\r\n\r\n.shopping-filter-chips .filter-chip-icon {\r\n  font-size: 10px;\r\n  opacity: 0.7;\r\n}\r\n\r\n.cards-grid {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\r\n  /* responsivo: 4 a 6 cards por linha */\r\n  gap: 16px;\r\n  /* espaÃ§o entre os cards */\r\n  margin-top: 24px;\r\n  /* RFC-0079: espaÃ§o adicional entre cabeÃ§alho e grid */\r\n  padding-bottom: 100px;\r\n}\r\n\r\n.cards-grid > * {\r\n  min-width: 0;\r\n  width: auto;\r\n  box-sizing: border-box;\r\n}\r\n\r\n/* Responsividade da grid: 4 a 6 cards por linha */\r\n@media (min-width: 1920px) {\r\n  .cards-grid {\r\n    grid-template-columns: repeat(6, 1fr);\r\n    /* 6 cards em telas muito grandes (â‰¥1920px) */\r\n    gap: 14px;\r\n  }\r\n}\r\n\r\n@media (min-width: 1600px) and (max-width: 1919px) {\r\n  .cards-grid {\r\n    grid-template-columns: repeat(5, 1fr);\r\n    /* 5 cards em telas grandes (1600-1919px) */\r\n    gap: 15px;\r\n  }\r\n}\r\n\r\n@media (min-width: 1280px) and (max-width: 1599px) {\r\n  .cards-grid {\r\n    grid-template-columns: repeat(5, 1fr);\r\n    /* 5 cards em telas mÃ©dias (1280-1599px) */\r\n    gap: 14px;\r\n  }\r\n}\r\n\r\n@media (min-width: 1024px) and (max-width: 1279px) {\r\n  .cards-grid {\r\n    grid-template-columns: repeat(4, 1fr);\r\n    /* 4 cards em telas menores (1024-1279px) */\r\n    gap: 16px;\r\n  }\r\n}\r\n\r\n@media (max-width: 1023px) {\r\n  .cards-grid {\r\n    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\r\n    /* responsivo em telas pequenas (<1024px) */\r\n    gap: 12px;\r\n  }\r\n}\r\n\r\n/* ====== CARD ====== */\r\n.water-card {\r\n  position: relative;\r\n  background-color: #fff;\r\n  /* fallback */\r\n  background-image: var(--card-grad) !important;\r\n  /* gradiente garantido */\r\n  border: 1px solid var(--card-bd);\r\n  border-radius: var(--radius);\r\n  box-shadow: var(--shadow);\r\n  color: var(--ink-1);\r\n  padding: 16px 18px 14px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 14px;\r\n  transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;\r\n  background-clip: padding-box;\r\n  /*overflow: hidden;*/\r\n  /* clip do anel animado */\r\n}\r\n\r\n.water-card:hover {\r\n  transform: translateY(-2px);\r\n  box-shadow: var(--shadow-hover);\r\n  border-color: #7dd3fc;\r\n}\r\n\r\n@keyframes ringBlink {\r\n  0%,\r\n  100% {\r\n    opacity: 0.25;\r\n  }\r\n\r\n  50% {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* ====== TIPOS E BLOCOS ====== */\r\n.water-hd {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n}\r\n\r\n.water-id {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 12px;\r\n}\r\n\r\n.water-icon {\r\n  width: 36px;\r\n  height: 36px;\r\n  border-radius: 12px;\r\n  background: #bae6fd;\r\n  color: #0369a1;\r\n  display: grid;\r\n  place-items: center;\r\n  font-weight: 700;\r\n  font-size: var(--fs-md);\r\n}\r\n\r\n.water-title {\r\n  font-weight: 600;\r\n  line-height: 1.15;\r\n  font-size: var(--fs-lg);\r\n}\r\n\r\n.water-code {\r\n  font-size: var(--fs-xs);\r\n  color: var(--ink-2);\r\n  margin-top: 2px;\r\n  letter-spacing: 0.2px;\r\n}\r\n\r\n.tb-dashboard-toolbar {\r\n  display: none !important;\r\n}\r\n\r\n.water-menu {\r\n  border: 0;\r\n  background: transparent;\r\n  color: var(--ink-2);\r\n  font-size: var(--fs-xl);\r\n  cursor: pointer;\r\n  padding: 4px 6px;\r\n  border-radius: 8px;\r\n}\r\n\r\n.water-menu:hover {\r\n  background: #e0f2fe;\r\n  color: var(--ink-1);\r\n}\r\n\r\n.water-status {\r\n  margin-top: 2px;\r\n}\r\n\r\n.chip {\r\n  display: inline-flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n  font-size: var(--fs-sm);\r\n  padding: 6px 10px;\r\n  border-radius: 999px;\r\n  font-weight: 600;\r\n  color: var(--blue);\r\n  background: #e8f0f6;\r\n}\r\n\r\n.chip .dot {\r\n  width: 8px;\r\n  height: 8px;\r\n  border-radius: 50%;\r\n  background: #6be39a;\r\n  box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.25) inset;\r\n}\r\n\r\n.chip.warn {\r\n  background: #d97706;\r\n}\r\n\r\n.chip.err {\r\n  background: #c2410c;\r\n}\r\n\r\n.chip.offline {\r\n  color: var(--ink-2);\r\n  /* Cor do texto cinza (usando sua variÃ¡vel) */\r\n  background: #f3f4f6;\r\n  /* Fundo cinza bem claro */\r\n  border-color: #e5e7eb;\r\n  /* Borda sutil para definir melhor */\r\n  border-color: #d1d5db;\r\n  /* Borda cinza, como solicitado */\r\n}\r\n\r\n.water-consumption {\r\n  display: flex;\r\n  align-items: flex-end;\r\n  gap: 6px;\r\n  justify-content: flex-end;\r\n}\r\n\r\n.power {\r\n  font-size: var(--fs-xxl);\r\n  font-weight: 700;\r\n  letter-spacing: 0.2px;\r\n}\r\n\r\n.unit {\r\n  font-size: var(--fs-lg);\r\n  font-weight: 600;\r\n  color: var(--ink-1);\r\n}\r\n\r\n.sub {\r\n  width: 100%;\r\n  text-align: right;\r\n  color: var(--ink-2);\r\n  font-size: var(--fs-xs);\r\n  margin-top: -2px;\r\n}\r\n\r\n.water-eff {\r\n  display: grid;\r\n  grid-template-columns: auto 1fr auto;\r\n  gap: 10px;\r\n  align-items: center;\r\n}\r\n\r\n.water-eff .label {\r\n  color: var(--ink-2);\r\n  font-size: var(--fs-md);\r\n}\r\n\r\n.water-eff .bar {\r\n  position: relative;\r\n  overflow: hidden;\r\n  height: 8px;\r\n  background: #0c4a6e;\r\n  border-radius: 999px;\r\n}\r\n\r\n.water-eff .fill {\r\n  position: absolute;\r\n  inset: 0 auto 0 0;\r\n  width: 0%;\r\n  background: linear-gradient(90deg, #0288d1 0%, #0288d1 70%, var(--accent) 70%, var(--accent) 100%);\r\n  border-radius: 999px;\r\n}\r\n\r\n.water-eff .pct {\r\n  font-weight: 700;\r\n  font-size: var(--fs-md);\r\n}\r\n\r\n.water-ft {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  gap: 18px;\r\n  border-top: 1px solid #bae6fd;\r\n  padding-top: 10px;\r\n}\r\n\r\n.ft-item {\r\n  display: flex;\r\n  gap: 8px;\r\n  align-items: center;\r\n}\r\n\r\n.ft-item .ico {\r\n  font-size: var(--fs-md);\r\n  line-height: 1;\r\n  width: 22px;\r\n  text-align: center;\r\n}\r\n\r\n.ft-item .k {\r\n  color: var(--ink-2);\r\n  font-size: var(--fs-xs);\r\n}\r\n\r\n.ft-item .v {\r\n  font-weight: 600;\r\n  margin-top: 2px;\r\n  font-size: var(--fs-md);\r\n}\r\n\r\n/* === CARD COMPACTO: menor altura e consumo Ã  direita === */\r\n.water-card.compact {\r\n  padding: 12px 14px !important;\r\n  gap: 10px !important;\r\n  min-height: 150px;\r\n  display: grid !important;\r\n  grid-template-columns: 1fr auto;\r\n  grid-template-rows: auto auto auto auto;\r\n  grid-template-areas:\r\n    'hd     consumption'\r\n    'status consumption'\r\n    'eff    eff'\r\n    'ft     ft';\r\n}\r\n\r\n.water-hd {\r\n  grid-area: hd;\r\n}\r\n\r\n.water-status {\r\n  grid-area: status;\r\n}\r\n\r\n.water-eff {\r\n  grid-area: eff;\r\n}\r\n\r\n.water-ft {\r\n  grid-area: ft;\r\n  margin-top: 2px;\r\n}\r\n\r\n/* consumo (mÂ³) no topo Ã  direita ocupando duas linhas */\r\n.water-consumption {\r\n  grid-area: consumption;\r\n  align-self: center;\r\n  text-align: right;\r\n  margin-left: 16px;\r\n}\r\n\r\n/* reduÃ§Ã£o sutil de elementos para caber 5 cards */\r\n.water-icon {\r\n  width: 30px !important;\r\n  height: 30px !important;\r\n  border-radius: 10px !important;\r\n}\r\n\r\n.water-title {\r\n  font-size: var(--fs-md) !important;\r\n}\r\n\r\n.water-code {\r\n  font-size: var(--fs-2xs) !important;\r\n}\r\n\r\n.water-eff .bar {\r\n  height: 6px !important;\r\n}\r\n\r\n.water-ft {\r\n  gap: 14px !important;\r\n  padding-top: 8px !important;\r\n}\r\n\r\n/* ---- Fix: consumo colado na direita no modo compacto ---- */\r\n.water-card.compact {\r\n  /* 1Âª coluna livre, 2Âª com largura mÃ­nima e elÃ¡stica */\r\n  grid-template-columns: 1fr minmax(160px, 1fr) !important;\r\n}\r\n\r\n.water-card.compact .water-consumption {\r\n  grid-area: consumption;\r\n  /* joga o grid item para a borda direita da coluna */\r\n  justify-self: end !important;\r\n  align-self: center !important;\r\n\r\n  /* e dentro dele, tudo alinhado Ã  direita */\r\n  width: 100% !important;\r\n  display: flex !important;\r\n  justify-content: flex-end !important;\r\n  align-items: baseline !important;\r\n  /* nÃºmero e \"mÂ³\" na mesma linha base */\r\n  text-align: right !important;\r\n  gap: 6px;\r\n}\r\n\r\n.water-card.compact .water-consumption .power,\r\n.water-card.compact .water-consumption .unit,\r\n.water-card.compact .water-consumption .sub {\r\n  text-align: right !important;\r\n}\r\n\r\n@keyframes ringBlink {\r\n  0%,\r\n  100% {\r\n    opacity: 0.25;\r\n  }\r\n\r\n  50% {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* ====== LOADING OVERLAY ====== */\r\n.water-loading-overlay {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  background: rgba(240, 249, 255, 0.95);\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  z-index: 1000;\r\n  backdrop-filter: blur(4px);\r\n}\r\n\r\n.loading-spinner {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  gap: 16px;\r\n}\r\n\r\n.loading-spinner p {\r\n  font-size: var(--fs-md);\r\n  font-weight: 600;\r\n  color: var(--ink-1);\r\n  margin: 0;\r\n}\r\n\r\n@keyframes spin {\r\n  0% {\r\n    transform: rotate(0deg);\r\n  }\r\n  100% {\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n\r\n/* ====== FILTER ACTIONS ====== */\r\n.filter-actions {\r\n  display: flex;\r\n  gap: 8px;\r\n  align-items: center;\r\n  margin-left: auto;\r\n}\r\n\r\n.search-wrap {\r\n  position: relative;\r\n  width: 0;\r\n  overflow: hidden;\r\n  transition: width 0.3s ease;\r\n}\r\n\r\n.search-wrap.active {\r\n  width: 200px;\r\n}\r\n\r\n.search-wrap input {\r\n  width: 100%;\r\n  padding: 6px 12px;\r\n  border: 1px solid var(--card-bd);\r\n  border-radius: 8px;\r\n  font-size: var(--fs-sm);\r\n  outline: none;\r\n}\r\n\r\n.search-wrap input:focus {\r\n  border-color: var(--blue);\r\n  box-shadow: 0 0 0 2px rgba(31, 111, 181, 0.1);\r\n}\r\n\r\n.icon-btn {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  width: 36px;\r\n  height: 36px;\r\n  border: 1px solid var(--card-bd);\r\n  background: #fff;\r\n  border-radius: 8px;\r\n  cursor: pointer;\r\n  transition: all 0.2s;\r\n}\r\n\r\n.icon-btn:hover {\r\n  background: #f8f9fa;\r\n  border-color: var(--blue);\r\n}\r\n\r\n.icon-btn svg {\r\n  fill: var(--ink-1);\r\n}\r\n\r\n/* ====== FILTER MODAL (RFC-0087: Full-Screen for Water) ====== */\r\n.water-modal {\r\n  position: fixed;\r\n  inset: 0;\r\n  background: rgba(12, 74, 110, 0.6);\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  z-index: 999999;\r\n  backdrop-filter: blur(4px);\r\n  left: 0 !important;\r\n  top: 0 !important;\r\n  right: 0 !important;\r\n  bottom: 0 !important;\r\n  width: 100vw !important;\r\n  height: 100vh !important;\r\n  animation: fadeIn 0.2s ease-in;\r\n}\r\n\r\n.water-modal.hidden {\r\n  display: none;\r\n}\r\n\r\n/* RFC-0087: Full-screen modal card for water widget */\r\n.water-modal-card {\r\n  background: #fff;\r\n  border-radius: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  max-width: 100%;\r\n  max-height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  box-shadow: none;\r\n  overflow: hidden;\r\n}\r\n\r\n/* Responsive: On larger screens, show as centered card */\r\n@media (min-width: 768px) {\r\n  .water-modal-card {\r\n    border-radius: 16px;\r\n    width: 90%;\r\n    max-width: 900px;\r\n    height: auto;\r\n    max-height: 90vh;\r\n    box-shadow: 0 20px 60px rgba(2, 136, 209, 0.3);\r\n  }\r\n}\r\n\r\n.water-modal-header {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  padding: 16px 20px;\r\n  border-bottom: 1px solid var(--card-bd);\r\n  background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);\r\n}\r\n\r\n.water-modal-header h3 {\r\n  margin: 0;\r\n  font-size: var(--fs-lg);\r\n  font-weight: 700;\r\n  color: var(--ink-1);\r\n}\r\n\r\n.water-modal-body {\r\n  flex: 1;\r\n  overflow-y: auto;\r\n  padding: 20px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 20px;\r\n}\r\n\r\n.water-modal-footer {\r\n  display: flex;\r\n  gap: 12px;\r\n  justify-content: flex-end;\r\n  padding: 16px 20px;\r\n  border-top: 1px solid var(--card-bd);\r\n}\r\n\r\n/* Filter Blocks */\r\n.filter-block {\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 12px;\r\n}\r\n\r\n.block-label {\r\n  font-size: var(--fs-md);\r\n  font-weight: 600;\r\n  color: var(--ink-1);\r\n}\r\n\r\n.inline-actions {\r\n  display: flex;\r\n  gap: 8px;\r\n}\r\n\r\n.tiny-btn {\r\n  padding: 4px 12px;\r\n  font-size: var(--fs-xs);\r\n  border: 1px solid var(--card-bd);\r\n  background: #fff;\r\n  border-radius: 6px;\r\n  cursor: pointer;\r\n  transition: all 0.2s;\r\n}\r\n\r\n.tiny-btn:hover {\r\n  background: #f8f9fa;\r\n  border-color: var(--blue);\r\n}\r\n\r\n.filter-search {\r\n  position: relative;\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n  border: 1px solid var(--card-bd);\r\n  border-radius: 8px;\r\n  padding: 8px 12px;\r\n}\r\n\r\n.filter-search svg {\r\n  width: 18px;\r\n  height: 18px;\r\n  fill: var(--ink-2);\r\n}\r\n\r\n.filter-search input {\r\n  flex: 1;\r\n  border: none;\r\n  outline: none;\r\n  font-size: var(--fs-sm);\r\n}\r\n\r\n.filter-search .clear-x {\r\n  border: none;\r\n  background: transparent;\r\n  cursor: pointer;\r\n  padding: 0;\r\n  display: flex;\r\n  align-items: center;\r\n  opacity: 0.5;\r\n  transition: opacity 0.2s;\r\n}\r\n\r\n.filter-search .clear-x:hover {\r\n  opacity: 1;\r\n}\r\n\r\n.filter-search .clear-x svg {\r\n  fill: var(--ink-1);\r\n}\r\n\r\n/* Checklist */\r\n.checklist {\r\n  max-height: 300px;\r\n  overflow-y: auto;\r\n  border: 1px solid var(--card-bd);\r\n  border-radius: 8px;\r\n  padding: 8px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 4px;\r\n}\r\n\r\n.check-item {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n  padding: 8px;\r\n  border-radius: 6px;\r\n  cursor: pointer;\r\n  transition: background 0.2s;\r\n}\r\n\r\n.check-item:hover {\r\n  background: #f8f9fa;\r\n}\r\n\r\n.check-item input[type='checkbox'] {\r\n  width: 18px;\r\n  height: 18px;\r\n  cursor: pointer;\r\n}\r\n\r\n.check-item label {\r\n  flex: 1;\r\n  cursor: pointer;\r\n  font-size: var(--fs-sm);\r\n  color: var(--ink-1);\r\n}\r\n\r\n/* Radio Grid */\r\n.radio-grid {\r\n  display: grid;\r\n  grid-template-columns: repeat(2, 1fr);\r\n  gap: 8px;\r\n}\r\n\r\n.radio-grid label {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 8px;\r\n  padding: 8px;\r\n  border: 1px solid var(--card-bd);\r\n  border-radius: 8px;\r\n  cursor: pointer;\r\n  transition: all 0.2s;\r\n  font-size: var(--fs-sm);\r\n}\r\n\r\n.radio-grid label:hover {\r\n  background: #f8f9fa;\r\n  border-color: var(--blue);\r\n}\r\n\r\n.radio-grid input[type='radio'] {\r\n  width: 16px;\r\n  height: 16px;\r\n  cursor: pointer;\r\n}\r\n\r\n.muted {\r\n  font-size: var(--fs-xs);\r\n  color: var(--ink-2);\r\n  margin: 0;\r\n}\r\n\r\n/* Buttons */\r\n.btn {\r\n  padding: 10px 20px;\r\n  border: 1px solid var(--card-bd);\r\n  background: #fff;\r\n  border-radius: 8px;\r\n  font-size: var(--fs-md);\r\n  font-weight: 600;\r\n  cursor: pointer;\r\n  transition: all 0.2s;\r\n}\r\n\r\n.btn:hover {\r\n  background: #f8f9fa;\r\n}\r\n\r\n.btn.primary {\r\n  background: var(--blue);\r\n  color: #fff;\r\n  border-color: var(--blue);\r\n}\r\n\r\n.btn.primary:hover {\r\n  background: #1a5a8f;\r\n  border-color: #1a5a8f;\r\n}\r\n\r\n/* ====== RFC-0072: MODAL STYLING TO PREVENT CORRUPTION ====== */\r\n\r\n/* Ensure energy dashboard modal always renders correctly */\r\n.energy-dashboard-modal,\r\n.dashboard-popup {\r\n  position: fixed !important;\r\n  top: 50% !important;\r\n  left: 50% !important;\r\n  transform: translate(-50%, -50%) !important;\r\n  z-index: 9999 !important;\r\n  background: #ffffff !important;\r\n  border-radius: 12px !important;\r\n  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3) !important;\r\n  max-width: 90vw !important;\r\n  max-height: 90vh !important;\r\n  overflow: hidden !important;\r\n}\r\n\r\n.dashboard-modal-backdrop {\r\n  pointer-events: all !important;\r\n}\r\n\r\n@keyframes fadeIn {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Prevent body scroll when modal is open */\r\nbody.modal-open {\r\n  overflow: hidden !important;\r\n}\r\n\r\n/* RFC-0072: Hide \"More Information\" menu item (redundant with card click) */\r\n.card-menu-item[data-action='info'],\r\n.card-menu-item[aria-label*='InformaÃ§Ãµes'],\r\n.card-menu-item[aria-label*='Information'],\r\n.myio-card-action-info {\r\n  display: none !important;\r\n}\r\n\r\n/* ====== END RFC-0072 MODAL STYLING ======  */\r\n",
      "controllerScript": "/* global self, window, document, localStorage, MyIOLibrary, $ */\r\n\r\n/* =========================================================================\r\n * ThingsBoard Widget: Water Common Area - Device Cards for Water Meters (MyIO)\r\n * RFC-0094: Aligned with WATER_STORES pattern using buildHeaderDevicesGrid and createFilterModal\r\n * - Filters devices by aliasName = 'HidrometrosAreaComum'\r\n * - Uses domain='water' for MÂ³ formatting\r\n * - Datas obrigatÃ³rias: startDateISO / endDateISO\r\n * - Se ausentes no onInit: usa \"current month so far\" (1Âº dia 00:00 â†’ hoje 23:59)\r\n * - Modal premium (busy) no widget durante carregamentos\r\n * - Modal premium global (fora do widget) para sucesso, com contador e reload\r\n * - onDataUpdated: no-op\r\n * - Evento (myio:update-date): mostra modal + atualiza\r\n * =========================================================================*/\r\n\r\n// ============================================\r\n// SHARED UTILITIES (from MAIN via window.MyIOUtils)\r\n// ============================================\r\nconst LogHelper = window.MyIOUtils?.LogHelper || {\r\n  log: (...args) => console.log(...args),\r\n  warn: (...args) => console.warn(...args),\r\n  error: (...args) => console.error(...args),\r\n};\r\n\r\nconst getDataApiHost = () => {\r\n  const host = window.MyIOUtils?.DATA_API_HOST;\r\n  if (!host) {\r\n    console.error('[WATER_COMMON_AREA] DATA_API_HOST not available - MAIN widget not loaded');\r\n  }\r\n  return host || '';\r\n};\r\n\r\n// RFC-0071: Device Profile functions (from MAIN)\r\n\r\n// RFC-0094: UI Helper from MAIN (replaces local getCustomerNameForDevice)\r\nconst getCustomerNameForDevice =\r\n  window.MyIOUtils?.getCustomerNameForDevice ||\r\n  ((device) => {\r\n    console.error('[WATER_COMMON_AREA] getCustomerNameForDevice not available - MAIN widget not loaded');\r\n    return device?.customerId ? `ID: ${device.customerId.substring(0, 8)}...` : 'N/A';\r\n  });\r\n\r\n// RFC-0094: Device status calculation functions from MAIN\r\nconst mapConnectionStatus = window.MyIOUtils?.mapConnectionStatus || ((status) => status || 'offline');\r\n\r\n// RFC-0094: formatarDuracao for operationHours calculation (from MAIN)\r\nconst formatarDuracao = window.MyIOUtils?.formatarDuracao || ((ms) => `${Math.round(ms / 1000)}s`);\r\n\r\n// RFC-0094: Global MAP_INSTANTANEOUS_POWER (will be loaded from settings if available)\r\nlet MAP_INSTANTANEOUS_POWER = null;\r\n\r\nLogHelper.log('ðŸš€ [WATER_COMMON_AREA] Controller loaded - VERSION WITH RFC-0094 PATTERN');\r\n\r\nconst MAX_FIRST_HYDRATES = 1;\r\n\r\n// RFC-0094: Centralized header controller\r\nlet waterCommonAreaHeaderController = null;\r\n\r\nlet dateUpdateHandler = null;\r\nlet dataProvideHandler = null; // RFC-0042: Orchestrator data listener\r\nlet waterDataReadyHandler = null; // FIX: Handler for myio:water-data-ready from MAIN\r\nlet waterTbDataHandler = null; // Handler for myio:water-tb-data-ready from MAIN (centralized datasources)\r\nlet MyIO = null;\r\n\r\n// Cache para dados recebidos do MAIN (datasources centralizados)\r\nlet mainWaterData = {\r\n  datasources: [],\r\n  data: [],\r\n  ids: [],\r\n  loaded: false,\r\n};\r\n\r\nlet lastProcessedPeriodKey = null; // Track last processed periodKey to prevent duplicate processing\r\n\r\n// RFC-0094: Widget configuration (from settings) - WATER DOMAIN\r\nlet WIDGET_DOMAIN = 'water';\r\n\r\n// Card rendering options (from settings, with defaults)\r\nlet USE_NEW_COMPONENTS = true;\r\nlet ENABLE_SELECTION = true;\r\nlet ENABLE_DRAG_DROP = true;\r\nlet HIDE_INFO_MENU_ITEM = true;\r\nlet DEBUG_ACTIVE = false;\r\nlet ACTIVE_TOOLTIP_DEBUG = false;\r\n\r\n/** ===================== STATE ===================== **/\r\nlet CLIENT_ID = '';\r\nlet CLIENT_SECRET = '';\r\nlet CUSTOMER_ING_ID = '';\r\nlet MyIOAuth = null;\r\n\r\nconst STATE = {\r\n  itemsBase: [], // lista autoritativa (TB)\r\n  itemsEnriched: [], // lista com totals + perc\r\n  searchActive: false,\r\n  searchTerm: '',\r\n  selectedIds: /** @type {Set<string> | null} */ (null),\r\n  sortMode:\r\n    /** @type {'cons_desc'|'cons_asc'|'alpha_asc'|'alpha_desc'|'status_asc'|'status_desc'|'shopping_asc'|'shopping_desc'} */ (\r\n      'cons_desc'\r\n    ),\r\n  firstHydrates: 0,\r\n  selectedShoppingIds: [], // RFC-0093: Shopping filter from MENU\r\n};\r\n\r\nlet hydrating = false;\r\n\r\n/** ===================== HELPERS (DOM) ===================== **/\r\nconst $root = () => $(self.ctx.$container[0]);\r\nconst $list = () => $root().find('#waterCommonAreaList');\r\n\r\n/** ===================== BUSY MODAL (no widget) ===================== **/\r\nconst BUSY_ID = 'myio-busy-modal';\r\nfunction ensureBusyModalDOM() {\r\n  let $m = $root().find(`#${BUSY_ID}`);\r\n  if ($m.length) return $m;\r\n\r\n  const html = `\r\n  <div id=\"${BUSY_ID}\" style=\"\r\n      position:absolute; inset:0; display:none;\r\n      background: rgba(150,132,181,0.45); /* #9684B5 com transparÃªncia */\r\n      backdrop-filter: blur(5px);\r\n      z-index:9999; align-items:center; justify-content:center;\r\n      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;\">\r\n    <div style=\"\r\n        background:#2d1458; color:#fff;\r\n        border:1px solid rgba(255,255,255,0.10);\r\n        box-shadow:0 12px 40px rgba(0,0,0,.35);\r\n        border-radius:18px; padding:22px 26px; min-width:320px;\">\r\n      <div style=\"display:flex; align-items:center; gap:12px;\">\r\n        <div class=\"spinner\" style=\"\r\n            width:22px;height:22px;border-radius:50%;\r\n            border:3px solid rgba(255,255,255,.25);\r\n            border-top-color:#ffffff; animation:spin .9s linear infinite;\"></div>\r\n        <div id=\"${BUSY_ID}-msg\" style=\"font-weight:600; font-size:14px; letter-spacing:.2px;\">\r\n          aguarde.. carregando os dados...\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <style>\r\n    @keyframes spin { from{transform:rotate(0)} to{transform:rotate(360deg)} }\r\n  </style>`;\r\n  $root().css('position', 'relative'); // garante overlay correto\r\n  $root().append(html);\r\n  return $root().find(`#${BUSY_ID}`);\r\n}\r\n\r\n// RFC-0044: Use centralized busy management\r\nfunction showBusy(message, timeoutMs = 35000) {\r\n  LogHelper.log(`[WATER_COMMON_AREA] ðŸ”„ showBusy() called with message: \"${message || 'default'}\"`);\r\n\r\n  // Prevent multiple simultaneous busy calls\r\n  if (window.busyInProgress) {\r\n    LogHelper.log(`[WATER_COMMON_AREA] â­ï¸ Skipping duplicate showBusy() call`);\r\n    return;\r\n  }\r\n\r\n  window.busyInProgress = true;\r\n\r\n  // Centralized busy with enhanced synchronization\r\n  const safeShowBusy = () => {\r\n    try {\r\n      if (window.MyIOOrchestrator && typeof window.MyIOOrchestrator.showGlobalBusy === 'function') {\r\n        const text = (message && String(message).trim()) || 'Carregando dados...';\r\n        window.MyIOOrchestrator.showGlobalBusy(WIDGET_DOMAIN, text, timeoutMs);\r\n        LogHelper.log(`[WATER_COMMON_AREA] âœ… Using centralized busy for domain: ${WIDGET_DOMAIN}`);\r\n      } else {\r\n        LogHelper.warn(`[WATER_COMMON_AREA] âš ï¸ Orchestrator not available, using fallback busy`);\r\n        const $m = ensureBusyModalDOM();\r\n        const text = (message && String(message).trim()) || 'aguarde.. carregando os dados...';\r\n        $m.find(`#${BUSY_ID}-msg`).text(text);\r\n        $m.css('display', 'flex');\r\n      }\r\n    } catch (err) {\r\n      LogHelper.error(`[WATER_COMMON_AREA] âŒ Error in showBusy:`, err);\r\n    } finally {\r\n      // Always reset busy flag after a short delay\r\n      setTimeout(() => {\r\n        window.busyInProgress = false;\r\n      }, 500);\r\n    }\r\n  };\r\n\r\n  safeShowBusy();\r\n}\r\n\r\nfunction hideBusy() {\r\n  LogHelper.log(`[WATER_COMMON_AREA] âœ… hideBusy() called`);\r\n\r\n  // RFC-0044: Use centralized busy management\r\n  if (window.MyIOOrchestrator && typeof window.MyIOOrchestrator.hideGlobalBusy === 'function') {\r\n    window.MyIOOrchestrator.hideGlobalBusy(WIDGET_DOMAIN);\r\n  }\r\n\r\n  // Also hide local fallback\r\n  const $m = $root().find(`#${BUSY_ID}`);\r\n  if ($m.length) $m.css('display', 'none');\r\n}\r\n\r\n/** ===================== GLOBAL SUCCESS MODAL ===================== **/\r\nconst SUCCESS_MODAL_ID = 'myio-global-success-modal';\r\nfunction showGlobalSuccessModal(countdown = 5) {\r\n  LogHelper.log('[WATER_COMMON_AREA] showGlobalSuccessModal');\r\n  let $m = $(document.body).find(`#${SUCCESS_MODAL_ID}`);\r\n  if (!$m.length) {\r\n    const html = `\r\n    <div id=\"${SUCCESS_MODAL_ID}\" style=\"\r\n        position:fixed; inset:0; display:flex;\r\n        background:rgba(0,0,0,.5); backdrop-filter:blur(6px);\r\n        z-index:999999; align-items:center; justify-content:center;\r\n        font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif;\">\r\n      <div style=\"background:#fff;border-radius:18px;padding:28px 36px;\r\n          min-width:420px;box-shadow:0 15px 50px rgba(0,0,0,.3);text-align:center;\">\r\n        <div style=\"font-size:48px; margin-bottom:14px;\">âœ…</div>\r\n        <div style=\"font-weight:700;font-size:20px;color:#1C2743;margin-bottom:8px;\">Tudo certo!</div>\r\n        <div style=\"font-size:14px;color:#555;margin-bottom:22px;\">\r\n          ConfiguraÃ§Ãµes salvas com sucesso.<br>\r\n          Recarregando em <span id=\"${SUCCESS_MODAL_ID}-counter\">${countdown}</span>s...\r\n        </div>\r\n        <button id=\"${SUCCESS_MODAL_ID}-btn\" style=\"\r\n            padding:10px 28px; font-size:15px; font-weight:600;\r\n            border-radius:10px; border:none; cursor:pointer;\r\n            background:#3E1A7D; color:#fff;\">\r\n          Recarregar agora\r\n        </button>\r\n      </div>\r\n    </div>`;\r\n    $(document.body).append(html);\r\n    $m = $(document.body).find(`#${SUCCESS_MODAL_ID}`);\r\n    $m.find(`#${SUCCESS_MODAL_ID}-btn`).on('click', () => {\r\n      window.location.reload();\r\n    });\r\n  }\r\n  $m.css('display', 'flex');\r\n\r\n  let sec = countdown;\r\n  const $c = $m.find(`#${SUCCESS_MODAL_ID}-counter`);\r\n  const iv = setInterval(() => {\r\n    sec--;\r\n    $c.text(sec);\r\n    if (sec <= 0) {\r\n      clearInterval(iv);\r\n      window.location.reload();\r\n    }\r\n  }, 1000);\r\n}\r\n\r\nfunction hideGlobalSuccessModal() {\r\n  const $m = $(document.body).find(`#${SUCCESS_MODAL_ID}`);\r\n  if ($m.length) $m.remove();\r\n}\r\n\r\n/** ===================== HELPERS ===================== **/\r\nfunction isValidUUID(s) {\r\n  return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(String(s));\r\n}\r\n\r\nfunction toSpOffsetNoMs(iso, isEndDate = false) {\r\n  const d = new Date(iso);\r\n  if (isNaN(d)) return null;\r\n  const tzOffsetMs = -3 * 60 * 60 * 1000;\r\n  const localMs = d.getTime() + tzOffsetMs;\r\n  const localDate = new Date(localMs);\r\n  const YYYY = localDate.getUTCFullYear();\r\n  const MM = String(localDate.getUTCMonth() + 1).padStart(2, '0');\r\n  const DD = String(localDate.getUTCDate()).padStart(2, '0');\r\n  let HH, mm, ss;\r\n  if (isEndDate) {\r\n    HH = '23';\r\n    mm = '59';\r\n    ss = '59';\r\n  } else {\r\n    HH = String(localDate.getUTCHours()).padStart(2, '0');\r\n    mm = String(localDate.getUTCMinutes()).padStart(2, '0');\r\n    ss = String(localDate.getUTCSeconds()).padStart(2, '0');\r\n  }\r\n  return `${YYYY}-${MM}-${DD}T${HH}:${mm}:${ss}-03:00`;\r\n}\r\n\r\nfunction mustGetDateRange() {\r\n  const startISO = self.ctx.$scope?.startDateISO || self.ctx?.scope?.startDateISO;\r\n  const endISO = self.ctx.$scope?.endDateISO || self.ctx?.scope?.endDateISO;\r\n  if (!startISO || !endISO) {\r\n    throw new Error('Missing start/end date');\r\n  }\r\n  return { startISO, endISO };\r\n}\r\n\r\n/** ===================== TB INDEXES ===================== **/\r\nfunction buildTbAttrIndex() {\r\n  const byTbId = new Map();\r\n\r\n  // Use centralized data from MAIN if available, otherwise use local ctx.data\r\n  const rows =\r\n    mainWaterData.loaded && mainWaterData.data.length > 0\r\n      ? mainWaterData.data\r\n      : Array.isArray(self.ctx?.data)\r\n      ? self.ctx.data\r\n      : [];\r\n\r\n  for (const row of rows) {\r\n    // RFC-0094: Filter by aliasName = 'HidrometrosAreaComum'\r\n    const aliasName = row?.datasource?.aliasName || '';\r\n    if (aliasName !== 'HidrometrosAreaComum') continue;\r\n\r\n    const key = String(row?.dataKey?.name || '').toLowerCase();\r\n    const tbId = row?.datasource?.entityId?.id || row?.datasource?.entityId || null;\r\n    const val = row?.data?.[0]?.[1];\r\n    if (!tbId || val == null) continue;\r\n    if (!byTbId.has(tbId))\r\n      byTbId.set(tbId, {\r\n        slaveId: null,\r\n        centralId: null,\r\n        deviceType: null,\r\n        centralName: null,\r\n        lastConnectTime: null,\r\n        lastActivityTime: null,\r\n        lastDisconnectTime: null,\r\n        deviceMapInstaneousPower: null,\r\n        customerId: null,\r\n        connectionStatus: null,\r\n        pulses: null, // FIX: Water meters use pulses (litros), not consumption_power\r\n        ingestionId: null,\r\n        identifier: null,\r\n        label: null,\r\n        deviceProfile: null,\r\n      });\r\n    const slot = byTbId.get(tbId);\r\n    if (key === 'slaveid') slot.slaveId = val;\r\n    if (key === 'centralid') slot.centralId = val;\r\n    if (key === 'devicetype') slot.deviceType = val;\r\n    if (key === 'deviceprofile') slot.deviceProfile = val;\r\n    if (key === 'centralname') slot.centralName = val;\r\n    if (key === 'lastconnecttime') slot.lastConnectTime = val;\r\n    if (key === 'lastactivitytime') slot.lastActivityTime = val;\r\n    if (key === 'lastdisconnecttime') slot.lastDisconnectTime = val;\r\n    if (key === 'devicemapinstaneouspower') slot.deviceMapInstaneousPower = val;\r\n    if (key === 'customerid') slot.customerId = val;\r\n    if (key === 'connectionstatus') slot.connectionStatus = val;\r\n    if (key === 'pulses') slot.pulses = val; // FIX: Water meters use pulses (litros)\r\n    if (key === 'ingestionid') slot.ingestionId = val;\r\n    if (key === 'identifier') slot.identifier = val;\r\n    if (key === 'label') slot.label = val;\r\n  }\r\n  return byTbId;\r\n}\r\n\r\nfunction buildTbIdIndexes() {\r\n  const byIdentifier = new Map(); // identifier -> tbId\r\n  const byIngestion = new Map(); // ingestionId -> tbId\r\n\r\n  // Use centralized data from MAIN if available, otherwise use local ctx.data\r\n  const rows =\r\n    mainWaterData.loaded && mainWaterData.data.length > 0\r\n      ? mainWaterData.data\r\n      : Array.isArray(self.ctx?.data)\r\n      ? self.ctx.data\r\n      : [];\r\n\r\n  for (const row of rows) {\r\n    // RFC-0094: Filter by aliasName = 'HidrometrosAreaComum'\r\n    const aliasName = row?.datasource?.aliasName || '';\r\n    if (aliasName !== 'HidrometrosAreaComum') continue;\r\n\r\n    const key = String(row?.dataKey?.name || '').toLowerCase();\r\n    const tbId = row?.datasource?.entityId?.id || row?.datasource?.entityId || null;\r\n    const val = row?.data?.[0]?.[1];\r\n    if (!tbId || val == null) continue;\r\n    if (key === 'identifier') byIdentifier.set(String(val), tbId);\r\n    if (key === 'ingestionid') byIngestion.set(String(val), tbId);\r\n  }\r\n  return { byIdentifier, byIngestion };\r\n}\r\n\r\n/** ===================== CORE: DATA PIPELINE ===================== **/\r\nfunction buildAuthoritativeItems() {\r\n  // PRIORIDADE 1: Usar dados centralizados do MAIN (via evento myio:water-tb-data-ready)\r\n  let filteredDatasources = [];\r\n  let filteredData = [];\r\n\r\n  if (mainWaterData.loaded && mainWaterData.datasources.length > 0) {\r\n    // Usar dados do MAIN (datasources centralizados)\r\n    filteredDatasources = mainWaterData.datasources;\r\n    filteredData = mainWaterData.data;\r\n    LogHelper.log(\r\n      `[WATER_COMMON_AREA] Using centralized data from MAIN: ${filteredDatasources.length} datasources, ${filteredData.length} data rows`\r\n    );\r\n  } else {\r\n    // FALLBACK: Usar dados locais do widget (se ainda houver)\r\n    const allDatasources = self.ctx.datasources || [];\r\n    const allAliases = [...new Set(allDatasources.map((ds) => ds.aliasName))];\r\n    LogHelper.log(`[WATER_COMMON_AREA] DEBUG: Available aliases in widget: ${JSON.stringify(allAliases)}`);\r\n    LogHelper.log(\r\n      `[WATER_COMMON_AREA] DEBUG: Total datasources: ${allDatasources.length}, Total data rows: ${\r\n        (self.ctx.data || []).length\r\n      }`\r\n    );\r\n\r\n    // RFC-0094: Filter datasources by aliasName = 'HidrometrosAreaComum'\r\n    filteredDatasources = (self.ctx.datasources || []).filter(\r\n      (ds) => ds.aliasName === 'HidrometrosAreaComum'\r\n    );\r\n    filteredData = (self.ctx.data || []).filter((d) => d?.datasource?.aliasName === 'HidrometrosAreaComum');\r\n  }\r\n\r\n  LogHelper.log(\r\n    `[WATER_COMMON_AREA] buildAuthoritativeItems: Filtered ${filteredDatasources.length} datasources, ${filteredData.length} data rows for 'HidrometrosAreaComum'`\r\n  );\r\n\r\n  // items da LIB: [{ id: ingestionId, identifier, label }, ...]\r\n  const base = MyIO.buildListItemsThingsboardByUniqueDatasource(filteredDatasources, filteredData) || [];\r\n  const ok = Array.isArray(base) ? base.filter((x) => x && x.id) : [];\r\n\r\n  const tbIdIdx = buildTbIdIndexes(); // { byIdentifier, byIngestion }\r\n  const attrsByTb = buildTbAttrIndex(); // tbId -> { slaveId, centralId, deviceType }\r\n\r\n  const mapped = ok.map((r) => {\r\n    const ingestionId = r.id;\r\n    const tbFromIngestion = ingestionId ? tbIdIdx.byIngestion.get(ingestionId) : null;\r\n    const tbFromIdentifier = r.identifier ? tbIdIdx.byIdentifier.get(r.identifier) : null;\r\n\r\n    let tbId = tbFromIngestion || tbFromIdentifier || null;\r\n    if (tbFromIngestion && tbFromIdentifier && tbFromIngestion !== tbFromIdentifier) {\r\n      tbId = tbFromIngestion;\r\n    }\r\n\r\n    const attrs = tbId ? attrsByTb.get(tbId) || {} : {};\r\n    const deviceProfile = attrs.deviceProfile || 'HIDROMETRO';\r\n    let deviceTypeToDisplay = attrs.deviceType || 'HIDROMETRO';\r\n\r\n    if (deviceTypeToDisplay === '3F_MEDIDOR' && deviceProfile !== 'N/D') {\r\n      deviceTypeToDisplay = deviceProfile;\r\n    }\r\n\r\n    return {\r\n      id: tbId || ingestionId, // para seleÃ§Ã£o/toggle\r\n      tbId, // ThingsBoard deviceId (Settings)\r\n      ingestionId, // join key API (totals/Report)\r\n      identifier: r.identifier,\r\n      label: attrs.label || r.label,\r\n      slaveId: attrs.slaveId ?? null,\r\n      centralId: attrs.centralId ?? null,\r\n      centralName: attrs.centralName ?? null,\r\n      deviceType: deviceTypeToDisplay,\r\n      deviceProfile: deviceProfile,\r\n      updatedIdentifiers: {},\r\n      connectionStatusTime: attrs.lastConnectTime ?? null,\r\n      timeVal: attrs.lastActivityTime ?? null,\r\n      lastDisconnectTime: attrs.lastDisconnectTime ?? null,\r\n      lastConnectTime: attrs.lastConnectTime ?? null,\r\n      deviceMapInstaneousPower: attrs.deviceMapInstaneousPower ?? null,\r\n      customerId: attrs.customerId ?? null,\r\n      connectionStatus: attrs.connectionStatus ?? 'offline',\r\n      pulses: attrs.pulses ?? null, // FIX: Water meters use pulses (litros instantÃ¢neos)\r\n    };\r\n  });\r\n\r\n  LogHelper.log(`[WATER_COMMON_AREA] buildAuthoritativeItems: Built ${mapped.length} water meter items`);\r\n\r\n  // NOTA: O registro de IDs no Orchestrator agora Ã© feito pelo MAIN\r\n  // que centraliza os datasources HidrometrosAreaComum e Todos Hidrometros Lojas\r\n\r\n  return mapped;\r\n}\r\n\r\nfunction enrichItemsWithTotals(items, apiMap) {\r\n  return items.map((it) => {\r\n    let raw = 0;\r\n    let cachedCustomerId = null; // [NOVO] VariÃ¡vel para guardar o ID vindo da API\r\n\r\n    if (it.ingestionId && isValidUUID(it.ingestionId)) {\r\n      const row = apiMap.get(String(it.ingestionId));\r\n\r\n      // 1. Recupera o valor\r\n      raw = Number(row?.total_value ?? 0);\r\n\r\n      // 2. [NOVO] Tenta recuperar o customerId do cache se disponÃ­vel\r\n      // A API pode retornar como 'customerId' ou 'customer_id'\r\n      cachedCustomerId = row?.customerId || row?.customer_id || null;\r\n    }\r\n\r\n    const value = Number(raw || 0);\r\n\r\n    // 3. [NOVO] Prioriza o ID que jÃ¡ existia (TB), senÃ£o usa o do Cache (API)\r\n    const finalCustomerId = it.customerId || cachedCustomerId;\r\n\r\n    return {\r\n      ...it,\r\n      value,\r\n      perc: 0,\r\n      customerId: finalCustomerId, // [NOVO] Atualiza o objeto com o ID encontrado\r\n    };\r\n  });\r\n}\r\n\r\n/** ===================== FILTERS / SORT / PERC ===================== **/\r\nfunction applyFilters(enriched, searchTerm, selectedIds, sortMode) {\r\n  let v = enriched.slice();\r\n\r\n  // RFC-0093: Apply shopping filter (from MENU) - same logic as EQUIPMENTS/STORES\r\n  if (STATE.selectedShoppingIds && STATE.selectedShoppingIds.length > 0) {\r\n    const before = v.length;\r\n    v = v.filter((x) => {\r\n      // If device has no customerId, include it (safety)\r\n      if (!x.customerId) return true;\r\n      // Check if device's customerId is in the selected shoppings\r\n      return STATE.selectedShoppingIds.includes(x.customerId);\r\n    });\r\n    LogHelper.log(\r\n      `[WATER_COMMON_AREA] Shopping filter applied: ${before} -> ${v.length} devices (${\r\n        before - v.length\r\n      } filtered out)`\r\n    );\r\n  }\r\n\r\n  if (selectedIds && selectedIds.size) {\r\n    v = v.filter((x) => selectedIds.has(String(x.id)));\r\n  }\r\n\r\n  const q = (searchTerm || '').trim().toLowerCase();\r\n  if (q) {\r\n    v = v.filter(\r\n      (x) =>\r\n        (x.label || '').toLowerCase().includes(q) ||\r\n        String(x.identifier || '')\r\n          .toLowerCase()\r\n          .includes(q)\r\n    );\r\n  }\r\n\r\n  v.sort((a, b) => {\r\n    if (sortMode === 'cons_desc') {\r\n      if (a.value !== b.value) return b.value - a.value;\r\n      return (a.label || '').localeCompare(b.label || '', 'pt-BR', {\r\n        sensitivity: 'base',\r\n      });\r\n    }\r\n    if (sortMode === 'cons_asc') {\r\n      if (a.value !== b.value) return a.value - b.value;\r\n      return (a.label || '').localeCompare(b.label || '', 'pt-BR', {\r\n        sensitivity: 'base',\r\n      });\r\n    }\r\n    if (sortMode === 'alpha_desc') {\r\n      return (\r\n        (b.label || '').localeCompare(a.label || '', 'pt-BR', {\r\n          sensitivity: 'base',\r\n        }) || b.value - a.value\r\n      );\r\n    }\r\n    // RFC-0095: Status sorting\r\n    if (sortMode === 'status_asc') {\r\n      const statusA = (a.connectionStatus || 'offline').toLowerCase();\r\n      const statusB = (b.connectionStatus || 'offline').toLowerCase();\r\n      const cmp = statusA.localeCompare(statusB, 'pt-BR', { sensitivity: 'base' });\r\n      return cmp !== 0 ? cmp : (a.label || '').localeCompare(b.label || '', 'pt-BR', { sensitivity: 'base' });\r\n    }\r\n    if (sortMode === 'status_desc') {\r\n      const statusA = (a.connectionStatus || 'offline').toLowerCase();\r\n      const statusB = (b.connectionStatus || 'offline').toLowerCase();\r\n      const cmp = statusB.localeCompare(statusA, 'pt-BR', { sensitivity: 'base' });\r\n      return cmp !== 0 ? cmp : (a.label || '').localeCompare(b.label || '', 'pt-BR', { sensitivity: 'base' });\r\n    }\r\n    // RFC-0095: Shopping sorting\r\n    if (sortMode === 'shopping_asc') {\r\n      const shopA = getCustomerNameForDevice(a) || '';\r\n      const shopB = getCustomerNameForDevice(b) || '';\r\n      const cmp = shopA.localeCompare(shopB, 'pt-BR', { sensitivity: 'base' });\r\n      return cmp !== 0 ? cmp : (a.label || '').localeCompare(b.label || '', 'pt-BR', { sensitivity: 'base' });\r\n    }\r\n    if (sortMode === 'shopping_desc') {\r\n      const shopA = getCustomerNameForDevice(a) || '';\r\n      const shopB = getCustomerNameForDevice(b) || '';\r\n      const cmp = shopB.localeCompare(shopA, 'pt-BR', { sensitivity: 'base' });\r\n      return cmp !== 0 ? cmp : (a.label || '').localeCompare(b.label || '', 'pt-BR', { sensitivity: 'base' });\r\n    }\r\n    // Default: alpha_asc\r\n    return (\r\n      (a.label || '').localeCompare(b.label || '', 'pt-BR', {\r\n        sensitivity: 'base',\r\n      }) || a.value - b.value\r\n    );\r\n  });\r\n\r\n  return v;\r\n}\r\n\r\nfunction recomputePercentages(visible) {\r\n  const groupSum = visible.reduce((acc, x) => acc + (x.value || 0), 0);\r\n  const updated = visible.map((x) => ({\r\n    ...x,\r\n    perc: groupSum > 0 ? (x.value / groupSum) * 100 : 0,\r\n  }));\r\n  return { visible: updated, groupSum };\r\n}\r\n\r\n/** ===================== RENDER ===================== **/\r\n\r\n/**\r\n * Update water common area statistics header (Conectividade, Total, etc)\r\n * RFC-0094: Aligned with WATER_STORES logic for consistent stats\r\n * @param {Array} items - Array of water meter items to calculate stats from\r\n */\r\nfunction updateWaterCommonAreaStats(items) {\r\n  // Use $root() to find elements within widget scope (not document.getElementById)\r\n  const $widget = $root();\r\n  const connectivityEl = $widget.find('#waterCommonAreaStatsConnectivity')[0];\r\n  const totalEl = $widget.find('#waterCommonAreaStatsTotal')[0];\r\n  const consumptionEl = $widget.find('#waterCommonAreaStatsConsumption')[0];\r\n  const zeroEl = $widget.find('#waterCommonAreaStatsZero')[0];\r\n\r\n  if (!connectivityEl || !totalEl || !consumptionEl || !zeroEl) {\r\n    LogHelper.warn('[WATER_COMMON_AREA] Stats header elements not found in widget scope');\r\n    return;\r\n  }\r\n\r\n  // RFC-0094: Calculate connectivity from connectionStatus (same as WATER_STORES)\r\n  let onlineCount = 0;\r\n  let totalWithStatus = 0;\r\n  let totalConsumption = 0;\r\n  let zeroConsumptionCount = 0;\r\n\r\n  items.forEach((item) => {\r\n    // Connectivity: based on connectionStatus, not consumption\r\n    const status = (item.connectionStatus || '').toLowerCase();\r\n    if (status) {\r\n      totalWithStatus++;\r\n      if (status === 'online') {\r\n        onlineCount++;\r\n      }\r\n    }\r\n\r\n    // Consumption calculation\r\n    const consumption = Number(item.value) || Number(item.val) || 0;\r\n    totalConsumption += consumption;\r\n\r\n    if (consumption === 0) {\r\n      zeroConsumptionCount++;\r\n    }\r\n  });\r\n\r\n  // If no connectionStatus available, fallback to total count\r\n  if (totalWithStatus === 0) {\r\n    totalWithStatus = items.length;\r\n  }\r\n\r\n  // Calculate connectivity percentage\r\n  const connectivityPercentage =\r\n    totalWithStatus > 0 ? ((onlineCount / totalWithStatus) * 100).toFixed(1) : '0.0';\r\n\r\n  // Update UI - RFC-0094: Use MÂ³ formatting for water domain\r\n  connectivityEl.textContent = `${onlineCount}/${totalWithStatus} (${connectivityPercentage}%)`;\r\n  totalEl.textContent = items.length.toString();\r\n  consumptionEl.textContent = MyIO.formatWaterVolumeM3(totalConsumption);\r\n  zeroEl.textContent = zeroConsumptionCount.toString();\r\n\r\n  LogHelper.log('[WATER_COMMON_AREA] Stats updated:', {\r\n    connectivity: `${onlineCount}/${totalWithStatus} (${connectivityPercentage}%)`,\r\n    total: items.length,\r\n    consumption: totalConsumption,\r\n    zeroCount: zeroConsumptionCount,\r\n  });\r\n}\r\n\r\n/**\r\n * RFC-0094: Render list of water meter cards\r\n * Follows WATER_STORES pattern with renderCardComponentHeadOffice\r\n */\r\nasync function renderList(visible) {\r\n  const listElement = $list()[0];\r\n  if (!listElement) {\r\n    console.error('[WATER_COMMON_AREA] waterCommonAreaList element not found via $list()');\r\n    return;\r\n  }\r\n\r\n  listElement.innerHTML = '';\r\n\r\n  for (const it of visible) {\r\n    const container = document.createElement('div');\r\n    listElement.appendChild(container);\r\n\r\n    const valNum = Number(it.value || 0);\r\n\r\n    // RFC-0094: Calculate device status using WATER_STORES pattern\r\n    let deviceStatus = 'power_off';\r\n    if (it.connectionStatus) {\r\n      const status = mapConnectionStatus(it.connectionStatus);\r\n      deviceStatus = status === 'online' ? 'power_on' : 'power_off';\r\n    } else if (valNum > 0) {\r\n      deviceStatus = 'power_on';\r\n    }\r\n\r\n    // RFC-0094: Resolve TB id\r\n    let resolvedTbId = it.tbId;\r\n    if (!resolvedTbId || !isValidUUID(resolvedTbId)) {\r\n      const idx = buildTbIdIndexes();\r\n      resolvedTbId =\r\n        (it.ingestionId && idx.byIngestion.get(it.ingestionId)) ||\r\n        (it.identifier && idx.byIdentifier.get(it.identifier)) ||\r\n        null;\r\n    }\r\n\r\n    // RFC-0094: Safe identifier handling\r\n    let deviceIdentifierToDisplay = 'HIDROMETRO';\r\n    if (it.identifier) {\r\n      if (String(it.identifier).includes('Sem Identificador')) {\r\n        deviceIdentifierToDisplay = 'HIDROMETRO';\r\n      } else {\r\n        deviceIdentifierToDisplay = it.identifier;\r\n      }\r\n    }\r\n\r\n    // Get customer name for this device\r\n    const customerName = getCustomerNameForDevice(it);\r\n\r\n    // RFC-0094: Calculate operationHours based on lastConnectTime (like EQUIPMENTS)\r\n    let operationHoursFormatted = '-';\r\n    const lastConnectTimestamp = it.lastConnectTime || 0;\r\n    if (lastConnectTimestamp > 0) {\r\n      const nowMs = Date.now();\r\n      const durationMs = nowMs - lastConnectTimestamp;\r\n      operationHoursFormatted = formatarDuracao(durationMs > 0 ? durationMs : 0);\r\n    }\r\n\r\n    // RFC-0094: Build entity object following WATER_STORES pattern\r\n    const entityObject = {\r\n      // Identificadores\r\n      entityId: resolvedTbId,\r\n      id: resolvedTbId,\r\n\r\n      // Labels e Nomes\r\n      labelOrName: it.label,\r\n      name: it.label,\r\n      customerName: customerName,\r\n      centralName: it.centralName || 'N/A',\r\n      deviceIdentifier: deviceIdentifierToDisplay,\r\n\r\n      // Valores e Tipos - RFC-0094: Water domain uses MÂ³\r\n      val: valNum,\r\n      value: valNum,\r\n      lastValue: valNum,\r\n      valType: 'volume_m3',\r\n      unit: 'mÂ³',\r\n      icon: 'water',\r\n      domain: 'water',\r\n      pulses: it.pulses || 0,\r\n\r\n      // Metadados\r\n      deviceType: it.deviceType || 'HIDROMETRO',\r\n      deviceProfile: it.deviceProfile || 'HIDROMETRO',\r\n      deviceStatus: deviceStatus,\r\n      perc: it.perc ?? 0,\r\n\r\n      // IDs secundÃ¡rios\r\n      slaveId: it.slaveId || 'N/A',\r\n      ingestionId: it.ingestionId || 'N/A',\r\n      centralId: it.centralId || 'N/A',\r\n      customerId: it.customerId || null,\r\n\r\n      updatedIdentifiers: it.updatedIdentifiers || {},\r\n      connectionStatusTime: it.connectionStatusTime || Date.now(),\r\n      timeVal: it.timeVal || Date.now(),\r\n\r\n      // Additional data for Settings modal and card display\r\n      lastDisconnectTime: it.lastDisconnectTime || 0,\r\n      lastConnectTime: it.lastConnectTime || 0,\r\n      lastActivityTime: it.timeVal || null,\r\n      instantaneousPower: 0, // Not applicable for water meters\r\n      operationHours: operationHoursFormatted, // RFC-0094: Calculated from lastConnectTime\r\n      temperatureC: 0,\r\n      mapInstantaneousPower: MAP_INSTANTANEOUS_POWER,\r\n      deviceMapInstaneousPower: it.deviceMapInstaneousPower || null,\r\n    };\r\n\r\n    // RFC-0094: Use renderCardComponentHeadOffice like WATER_STORES\r\n    MyIOLibrary.renderCardComponentHeadOffice(container, {\r\n      entityObject: entityObject,\r\n      delayTimeConnectionInMins: window.MyIOUtils?.getDelayTimeConnectionInMins?.() ?? 60,\r\n\r\n      handleClickCard: (ev, entity) => {\r\n        console.log(`[WATER_COMMON_AREA] Card clicked: ${entity.name}`);\r\n      },\r\n\r\n      handleActionDashboard: async () => {\r\n        console.log('[WATER_COMMON_AREA] [RFC-0094] Opening water dashboard for:', entityObject.entityId);\r\n        try {\r\n          if (typeof MyIOLibrary.openDashboardPopupEnergy !== 'function') {\r\n            window.alert('Dashboard component nÃ£o disponÃ­vel');\r\n            return;\r\n          }\r\n          const startDate = self.ctx.scope?.startDateISO;\r\n          const endDate = self.ctx.scope?.endDateISO;\r\n          if (!startDate || !endDate) {\r\n            window.alert('PerÃ­odo de datas nÃ£o definido.');\r\n            return;\r\n          }\r\n          if (!MyIOAuth || typeof MyIOAuth.getToken !== 'function') {\r\n            LogHelper.error('[WATER_COMMON_AREA] MyIOAuth not available');\r\n            window.alert('AutenticaÃ§Ã£o nÃ£o disponÃ­vel. Recarregue a pÃ¡gina.');\r\n            return;\r\n          }\r\n          const tokenIngestionDashBoard = await MyIOAuth.getToken();\r\n          const myTbTokenDashBoard = localStorage.getItem('jwt_token');\r\n\r\n          MyIOLibrary.openDashboardPopupEnergy({\r\n            deviceId: entityObject.entityId,\r\n            readingType: 'water', // RFC-0094: Water reading type\r\n            startDate,\r\n            endDate,\r\n            tbJwtToken: myTbTokenDashBoard,\r\n            ingestionToken: tokenIngestionDashBoard,\r\n            clientId: CLIENT_ID,\r\n            clientSecret: CLIENT_SECRET,\r\n            onClose: () => {\r\n              const o = document.querySelector('.myio-modal-overlay');\r\n              if (o) o.remove();\r\n            },\r\n          });\r\n        } catch (err) {\r\n          console.error(err);\r\n          window.alert('Erro ao abrir dashboard');\r\n        }\r\n      },\r\n\r\n      handleActionReport: async () => {\r\n        try {\r\n          if (!MyIOAuth || typeof MyIOAuth.getToken !== 'function') {\r\n            LogHelper.error('[WATER_COMMON_AREA] MyIOAuth not available for report');\r\n            window.alert('AutenticaÃ§Ã£o nÃ£o disponÃ­vel. Recarregue a pÃ¡gina.');\r\n            return;\r\n          }\r\n          const ingestionToken = await MyIOAuth.getToken();\r\n          await MyIOLibrary.openDashboardPopupReport({\r\n            ingestionId: it.ingestionId,\r\n            identifier: it.identifier,\r\n            label: it.label,\r\n            domain: 'water', // RFC-0094: Water domain\r\n            api: {\r\n              dataApiBaseUrl: getDataApiHost(),\r\n              clientId: CLIENT_ID,\r\n              clientSecret: CLIENT_SECRET,\r\n              ingestionToken,\r\n            },\r\n          });\r\n        } catch (err) {\r\n          window.alert('Erro ao abrir relatÃ³rio');\r\n        }\r\n      },\r\n\r\n      handleActionSettings: async () => {\r\n        const jwt = localStorage.getItem('jwt_token');\r\n\r\n        if (!jwt) {\r\n          LogHelper.error('[WATER_COMMON_AREA] [RFC-0094] JWT token not found');\r\n          window.alert('Token de autenticaÃ§Ã£o nÃ£o encontrado');\r\n          return;\r\n        }\r\n\r\n        const tbId = entityObject.entityId;\r\n        if (!tbId || tbId === it.ingestionId) {\r\n          window.alert('ID invÃ¡lido');\r\n          return;\r\n        }\r\n\r\n        try {\r\n          await MyIOLibrary.openDashboardPopupSettings({\r\n            deviceId: tbId,\r\n            label: it.label,\r\n            jwtToken: jwt,\r\n            domain: WIDGET_DOMAIN,\r\n            deviceType: entityObject.deviceType,\r\n            deviceProfile: entityObject.deviceProfile,\r\n            customerName: entityObject.customerName,\r\n            connectionData: {\r\n              centralName: entityObject.centralName,\r\n              connectionStatusTime: entityObject.connectionStatusTime,\r\n              timeVal: entityObject.timeVal || new Date('1970-01-01').getTime(),\r\n              deviceStatus:\r\n                entityObject.deviceStatus !== 'power_off' && entityObject.deviceStatus !== 'not_installed'\r\n                  ? 'power_on'\r\n                  : 'power_off',\r\n              lastDisconnectTime: entityObject.lastDisconnectTime || 0,\r\n            },\r\n            ui: { title: 'ConfiguraÃ§Ãµes', width: 900 },\r\n            mapInstantaneousPower: entityObject.mapInstantaneousPower,\r\n            onSaved: (payload) => {\r\n              LogHelper.log('[WATER_COMMON_AREA] [RFC-0094] Settings saved:', payload);\r\n              showGlobalSuccessModal(6);\r\n            },\r\n            onClose: () => {\r\n              $('.myio-settings-modal-overlay').remove();\r\n              const overlay = document.querySelector('.myio-modal-overlay');\r\n              if (overlay) {\r\n                overlay.remove();\r\n              }\r\n              LogHelper.log('[WATER_COMMON_AREA] [RFC-0094] Settings modal closed');\r\n            },\r\n          });\r\n        } catch (e) {\r\n          LogHelper.error('[WATER_COMMON_AREA] [RFC-0094] Error opening settings:', e);\r\n          window.alert('Erro ao abrir configuraÃ§Ãµes');\r\n        }\r\n      },\r\n\r\n      handleSelect: (checked, entity) => {\r\n        const MyIOSelectionStore = window.MyIOLibrary?.MyIOSelectionStore || window.MyIOSelectionStore;\r\n        if (MyIOSelectionStore) {\r\n          if (checked) {\r\n            if (MyIOSelectionStore.registerEntity) MyIOSelectionStore.registerEntity(entity);\r\n            MyIOSelectionStore.add(entity.entityId || entity.id);\r\n          } else {\r\n            MyIOSelectionStore.remove(entity.entityId || entity.id);\r\n          }\r\n        }\r\n      },\r\n\r\n      useNewComponents: USE_NEW_COMPONENTS,\r\n      enableSelection: ENABLE_SELECTION,\r\n      enableDragDrop: ENABLE_DRAG_DROP,\r\n      hideInfoMenuItem: HIDE_INFO_MENU_ITEM,\r\n      debugActive: DEBUG_ACTIVE,\r\n      activeTooltipDebug: ACTIVE_TOOLTIP_DEBUG,\r\n    });\r\n  }\r\n\r\n  console.log(`[WATER_COMMON_AREA] Rendered ${visible.length} water meter cards`);\r\n}\r\n\r\n/** ===================== UI BINDINGS ===================== **/\r\n/**\r\n * RFC-0094: Search and filter button events are now handled by buildHeaderDevicesGrid\r\n * This function is kept for backwards compatibility but the main logic is in the header controller\r\n */\r\nfunction bindHeader() {\r\n  // RFC-0094: Events are now managed by waterCommonAreaHeaderController in onInit\r\n  LogHelper.log('[WATER_COMMON_AREA] bindHeader - events managed by header controller');\r\n}\r\n\r\n// ============================================\r\n// RFC-0094: WATER_COMMON_AREA FILTER MODAL (using shared factory from MAIN)\r\n// ============================================\r\n\r\n// Helper function to get item consumption value\r\nfunction getItemConsumption(item) {\r\n  return Number(item.value) || Number(item.consumption) || Number(item.val) || 0;\r\n}\r\n\r\n// Helper function to get item status (for filter tabs)\r\nfunction getItemStatus(item) {\r\n  return (item.deviceStatus || '').toLowerCase();\r\n}\r\n\r\n// Filter modal instance (lazy initialized)\r\nlet waterCommonAreaFilterModal = null;\r\n\r\n/**\r\n * RFC-0094: Initialize filter modal using shared factory from MAIN\r\n */\r\nfunction initFilterModal() {\r\n  const createFilterModal = window.MyIOUtils?.createFilterModal;\r\n\r\n  if (!createFilterModal) {\r\n    LogHelper.error('[WATER_COMMON_AREA] createFilterModal not available from MAIN');\r\n    return null;\r\n  }\r\n\r\n  return createFilterModal({\r\n    widgetName: 'WATER_COMMON_AREA',\r\n    containerId: 'waterCommonAreaFilterModalGlobal',\r\n    modalClass: 'water-common-area-modal',\r\n    primaryColor: '#0288D1', // Blue for water\r\n    itemIdAttr: 'data-entity',\r\n\r\n    // Filter tabs configuration - specific for WATER_COMMON_AREA\r\n    filterTabs: [\r\n      { id: 'all', label: 'Todos', filter: () => true },\r\n      { id: 'online', label: 'Online', filter: (s) => !['offline', 'no_info'].includes(getItemStatus(s)) },\r\n      { id: 'offline', label: 'Offline', filter: (s) => ['offline', 'no_info'].includes(getItemStatus(s)) },\r\n      { id: 'withConsumption', label: 'Com Consumo', filter: (s) => getItemConsumption(s) > 0 },\r\n      { id: 'noConsumption', label: 'Sem Consumo', filter: (s) => getItemConsumption(s) === 0 },\r\n    ],\r\n\r\n    // Data accessors\r\n    getItemId: (item) => item.id,\r\n    getItemLabel: (item) => item.label || item.identifier || item.id,\r\n    getItemValue: getItemConsumption,\r\n    getItemSubLabel: (item) => getCustomerNameForDevice(item),\r\n    formatValue: (val) => MyIO.formatWaterVolumeM3(val), // RFC-0094: MÂ³ formatting\r\n\r\n    // Callbacks\r\n    onApply: ({ selectedIds, sortMode }) => {\r\n      STATE.selectedIds = selectedIds;\r\n      STATE.sortMode = sortMode;\r\n      reflowFromState();\r\n      LogHelper.log('[WATER_COMMON_AREA] [RFC-0094] Filters applied via shared modal');\r\n    },\r\n\r\n    onReset: () => {\r\n      STATE.selectedIds = null;\r\n      STATE.sortMode = 'cons_desc';\r\n      STATE.searchTerm = '';\r\n      STATE.searchActive = false;\r\n\r\n      // RFC-0094: Reset UI via header controller\r\n      if (waterCommonAreaHeaderController) {\r\n        const searchInput = waterCommonAreaHeaderController.getSearchInput();\r\n        if (searchInput) searchInput.value = '';\r\n        waterCommonAreaHeaderController.toggleSearch(false);\r\n      }\r\n\r\n      reflowFromState();\r\n      LogHelper.log('[WATER_COMMON_AREA] [RFC-0094] Filters reset via shared modal');\r\n    },\r\n\r\n    onClose: () => {\r\n      LogHelper.log('[WATER_COMMON_AREA] [RFC-0094] Filter modal closed');\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * RFC-0094: Open filter modal\r\n */\r\nfunction openFilterModal() {\r\n  // Lazy initialize modal\r\n  if (!waterCommonAreaFilterModal) {\r\n    waterCommonAreaFilterModal = initFilterModal();\r\n  }\r\n\r\n  if (!waterCommonAreaFilterModal) {\r\n    LogHelper.error('[WATER_COMMON_AREA] Failed to initialize filter modal');\r\n    window.alert('Erro ao inicializar modal de filtros. Verifique se o widget MAIN foi carregado.');\r\n    return;\r\n  }\r\n\r\n  // Use itemsEnriched if available (has consumption values), otherwise itemsBase\r\n  const items =\r\n    STATE.itemsEnriched && STATE.itemsEnriched.length > 0 ? STATE.itemsEnriched : STATE.itemsBase || [];\r\n\r\n  // Open with current items and state\r\n  waterCommonAreaFilterModal.open(items, {\r\n    selectedIds: STATE.selectedIds,\r\n    sortMode: STATE.sortMode,\r\n  });\r\n}\r\n\r\n/**\r\n * RFC-0094: Close filter modal (for backward compatibility)\r\n */\r\nfunction closeFilterModal() {\r\n  if (waterCommonAreaFilterModal) {\r\n    waterCommonAreaFilterModal.close();\r\n  }\r\n}\r\n\r\nfunction bindModal() {\r\n  // RFC-0094: Modal is now handled by shared factory, but keep legacy bindings for fallback\r\n  $root().on('click', '#closeFilter', closeFilterModal);\r\n}\r\n\r\n/** ===================== RECOMPUTE (local only) ===================== **/\r\nasync function filterAndRender() {\r\n  const visible = applyFilters(STATE.itemsEnriched, STATE.searchTerm, STATE.selectedIds, STATE.sortMode);\r\n  const { visible: withPerc } = recomputePercentages(visible);\r\n  await renderList(withPerc);\r\n\r\n  // RFC-0094: Update stats header via centralized controller\r\n  if (STATE.itemsEnriched && STATE.itemsEnriched.length > 0) {\r\n    if (waterCommonAreaHeaderController) {\r\n      waterCommonAreaHeaderController.updateFromDevices(STATE.itemsEnriched, {});\r\n    } else {\r\n      updateWaterCommonAreaStats(STATE.itemsEnriched);\r\n    }\r\n  }\r\n}\r\n\r\nfunction reflowFromState() {\r\n  filterAndRender();\r\n}\r\n\r\n/** ===================== AUTH ===================== **/\r\nfunction isAuthReady() {\r\n  return !!CLIENT_ID && !!CLIENT_SECRET && !!MyIOAuth;\r\n}\r\n\r\nasync function ensureAuthReady(timeout = 5000, interval = 100) {\r\n  const start = Date.now();\r\n  while (!isAuthReady()) {\r\n    if (Date.now() - start > timeout) {\r\n      LogHelper.warn('[WATER_COMMON_AREA] Auth timeout waiting for credentials');\r\n      return false;\r\n    }\r\n    await new Promise((r) => setTimeout(r, interval));\r\n  }\r\n  return true;\r\n}\r\n\r\n/** ===================== HYDRATE (end-to-end) ===================== **/\r\nasync function fetchApiTotals(startISO, endISO) {\r\n  if (!isAuthReady()) throw new Error('Auth not ready');\r\n  const token = await MyIOAuth.getToken();\r\n  if (!token) throw new Error('No ingestion token');\r\n\r\n  // RFC-0094: Use water endpoint\r\n  const url = new URL(\r\n    `${getDataApiHost()}/api/v1/telemetry/customers/${CUSTOMER_ING_ID}/water/devices/totals`\r\n  );\r\n  url.searchParams.set('startTime', toSpOffsetNoMs(startISO));\r\n  url.searchParams.set('endTime', toSpOffsetNoMs(endISO, true));\r\n  url.searchParams.set('deep', '1');\r\n\r\n  const res = await fetch(url.toString(), {\r\n    headers: { Authorization: `Bearer ${token}` },\r\n  });\r\n  if (!res.ok) {\r\n    LogHelper.warn('[WATER_COMMON_AREA] API fetch failed:', res.status);\r\n    return new Map();\r\n  }\r\n\r\n  const json = await res.json();\r\n  const rows = Array.isArray(json) ? json : json?.data ?? [];\r\n  const map = new Map();\r\n  for (const r of rows) if (r && r.id) map.set(String(r.id), r);\r\n  return map;\r\n}\r\n\r\nasync function hydrateAndRender() {\r\n  if (hydrating) return;\r\n  hydrating = true;\r\n\r\n  showBusy();\r\n\r\n  try {\r\n    // 0) Datas: obrigatÃ³rias\r\n    let range;\r\n    try {\r\n      range = mustGetDateRange();\r\n    } catch (_e) {\r\n      LogHelper.warn('[WATER_COMMON_AREA] Aguardando intervalo de datas (startDateISO/endDateISO).');\r\n      return;\r\n    }\r\n\r\n    // 1) Auth\r\n    const okAuth = await ensureAuthReady(6000, 150);\r\n    if (!okAuth) {\r\n      LogHelper.warn('[WATER_COMMON_AREA] Auth not ready; adiando hidrataÃ§Ã£o.');\r\n      return;\r\n    }\r\n\r\n    // 2) Lista autoritativa\r\n    STATE.itemsBase = buildAuthoritativeItems();\r\n\r\n    // 3) Totais na API\r\n    let apiMap = new Map();\r\n    try {\r\n      apiMap = await fetchApiTotals(range.startISO, range.endISO);\r\n    } catch (err) {\r\n      LogHelper.error('[WATER_COMMON_AREA] API error:', err);\r\n      apiMap = new Map();\r\n    }\r\n\r\n    // 4) Enrich + render\r\n    STATE.itemsEnriched = enrichItemsWithTotals(STATE.itemsBase, apiMap);\r\n\r\n    // 5) Sanitiza seleÃ§Ã£o\r\n    if (STATE.selectedIds && STATE.selectedIds.size) {\r\n      const valid = new Set(STATE.itemsBase.map((x) => String(x.id)));\r\n      const next = new Set([...STATE.selectedIds].filter((id) => valid.has(String(id))));\r\n      STATE.selectedIds = next.size ? next : null;\r\n    }\r\n\r\n    reflowFromState();\r\n  } finally {\r\n    hydrating = false;\r\n    hideBusy();\r\n  }\r\n}\r\n\r\n/** ===================== TB LIFE CYCLE ===================== **/\r\nself.onInit = async function () {\r\n  $(self.ctx.$container).css({\r\n    height: '100%',\r\n    overflow: 'auto', // FIX: Same as STORES - allows vertical scroll\r\n    display: 'flex',\r\n    flexDirection: 'column',\r\n    position: 'relative',\r\n  });\r\n\r\n  MyIO = (typeof MyIOLibrary !== 'undefined' && MyIOLibrary) ||\r\n    (typeof window !== 'undefined' && window.MyIOLibrary) || {\r\n      showAlert: function () {\r\n        window.alert('A Biblioteca Myio nÃ£o foi carregada corretamente!');\r\n      },\r\n    };\r\n\r\n  // RFC-0094: Set widget configuration from settings FIRST - WATER DOMAIN\r\n  WIDGET_DOMAIN = self.ctx.settings?.DOMAIN || 'water';\r\n  USE_NEW_COMPONENTS = self.ctx.settings?.useNewComponents ?? true;\r\n  ENABLE_SELECTION = self.ctx.settings?.enableSelection ?? true;\r\n  ENABLE_DRAG_DROP = self.ctx.settings?.enableDragDrop ?? true;\r\n  HIDE_INFO_MENU_ITEM = self.ctx.settings?.hideInfoMenuItem ?? true;\r\n  DEBUG_ACTIVE = self.ctx.settings?.debugActive ?? false;\r\n  ACTIVE_TOOLTIP_DEBUG = self.ctx.settings?.activeTooltipDebug ?? false;\r\n  LogHelper.log(`[WATER_COMMON_AREA] Configured EARLY: domain=${WIDGET_DOMAIN}, debugActive=${DEBUG_ACTIVE}, activeTooltipDebug=${ACTIVE_TOOLTIP_DEBUG}`);\r\n\r\n  // RFC-0094: Build centralized header via buildHeaderDevicesGrid\r\n  const buildHeaderDevicesGrid = window.MyIOUtils?.buildHeaderDevicesGrid;\r\n  if (buildHeaderDevicesGrid) {\r\n    // FIX: Use $root().find() to get container within widget scope, not document.querySelector\r\n    const headerContainerEl = $root().find('#waterCommonAreaHeaderContainer')[0];\r\n    if (headerContainerEl) {\r\n      waterCommonAreaHeaderController = buildHeaderDevicesGrid({\r\n        container: headerContainerEl, // Pass element directly, not selector string\r\n        domain: 'water',\r\n        idPrefix: 'waterCommonArea',\r\n        labels: {\r\n          total: 'Total de HidrÃ´metros',\r\n          consumption: 'Consumo Total (mÂ³)',\r\n        },\r\n        includeSearch: true,\r\n        includeFilter: true,\r\n        onSearchClick: () => {\r\n          STATE.searchActive = !STATE.searchActive;\r\n          if (STATE.searchActive) {\r\n            const input = waterCommonAreaHeaderController?.getSearchInput();\r\n            if (input) setTimeout(() => input.focus(), 100);\r\n          }\r\n        },\r\n        onFilterClick: () => {\r\n          openFilterModal();\r\n        },\r\n      });\r\n\r\n      // Setup search input listener\r\n      const searchInput = waterCommonAreaHeaderController?.getSearchInput();\r\n      if (searchInput) {\r\n        searchInput.addEventListener('input', (e) => {\r\n          STATE.searchTerm = e.target.value || '';\r\n          filterAndRender();\r\n        });\r\n      }\r\n\r\n      LogHelper.log('[WATER_COMMON_AREA] [RFC-0094] Header controller initialized');\r\n    } else {\r\n      LogHelper.warn('[WATER_COMMON_AREA] Header container element not found in widget scope');\r\n    }\r\n  } else {\r\n    LogHelper.warn('[WATER_COMMON_AREA] buildHeaderDevicesGrid not available - using fallback');\r\n  }\r\n\r\n  dateUpdateHandler = function (ev) {\r\n    LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] âœ… DATE UPDATE EVENT RECEIVED!`, ev.detail);\r\n\r\n    try {\r\n      let startISO, endISO;\r\n      if (ev.detail?.period) {\r\n        startISO = ev.detail.period.startISO;\r\n        endISO = ev.detail.period.endISO;\r\n      } else {\r\n        const { startDate, endDate } = ev.detail || {};\r\n        startISO = new Date(startDate).toISOString();\r\n        endISO = new Date(endDate).toISOString();\r\n      }\r\n\r\n      LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] Date range updated:`, startISO, endISO);\r\n\r\n      self.ctx.scope = self.ctx.scope || {};\r\n      self.ctx.scope.startDateISO = startISO;\r\n      self.ctx.scope.endDateISO = endISO;\r\n\r\n      hydrateAndRender();\r\n    } catch (err) {\r\n      LogHelper.error(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] dateUpdateHandler error:`, err);\r\n      hideBusy();\r\n    }\r\n  };\r\n\r\n  LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] ðŸ“¡ Registering myio:update-date listener...`);\r\n  window.addEventListener('myio:update-date', dateUpdateHandler);\r\n  LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] âœ… myio:update-date listener registered!`);\r\n\r\n  // RFC-0042: Listen for clear event from HEADER (when user clicks \"Limpar\" button)\r\n  window.addEventListener('myio:telemetry:clear', (ev) => {\r\n    const { domain } = ev.detail;\r\n\r\n    if (domain !== WIDGET_DOMAIN) {\r\n      LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] Ignoring clear event for domain: ${domain}`);\r\n      return;\r\n    }\r\n\r\n    LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] ðŸ§¹ Received clear event - clearing visual content`);\r\n\r\n    try {\r\n      STATE.itemsBase = [];\r\n      STATE.itemsEnriched = [];\r\n      STATE.selectedIds = null;\r\n\r\n      const $widget = $root();\r\n      const $waterCommonAreaList = $widget.find('#waterCommonAreaList');\r\n      if ($waterCommonAreaList.length > 0) {\r\n        $waterCommonAreaList.empty();\r\n        LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] âœ… waterCommonAreaList cleared`);\r\n      }\r\n\r\n      LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] ðŸ§¹ Clear completed successfully`);\r\n    } catch (err) {\r\n      LogHelper.error(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] âŒ Error during clear:`, err);\r\n    }\r\n  });\r\n\r\n  // RFC-0093: Function to render shopping filter chips in toolbar (same as EQUIPMENTS/STORES)\r\n  function renderShoppingFilterChips(selection) {\r\n    const chipsContainer = document.getElementById('waterCommonAreaShoppingFilterChips');\r\n    if (!chipsContainer) return;\r\n\r\n    chipsContainer.innerHTML = '';\r\n\r\n    if (!selection || selection.length === 0) {\r\n      return; // No filter applied, hide chips\r\n    }\r\n\r\n    selection.forEach((shopping) => {\r\n      const chip = document.createElement('span');\r\n      chip.className = 'filter-chip';\r\n      chip.innerHTML = `<span class=\"filter-chip-icon\">ðŸ’§</span><span>${shopping.name}</span>`;\r\n      chipsContainer.appendChild(chip);\r\n    });\r\n\r\n    LogHelper.log('[WATER_COMMON_AREA] ðŸ“ Rendered', selection.length, 'shopping filter chips');\r\n  }\r\n\r\n  // RFC-0093: Listen for shopping filter changes\r\n  window.addEventListener('myio:filter-applied', (ev) => {\r\n    const selection = ev.detail?.selection || [];\r\n    LogHelper.log('[WATER_COMMON_AREA] ðŸ”¥ heard myio:filter-applied:', selection.length, 'shoppings');\r\n\r\n    // Extract shopping IDs (ingestionIds) from selection\r\n    const shoppingIds = selection.map((s) => s.value).filter((v) => v);\r\n\r\n    LogHelper.log(\r\n      '[WATER_COMMON_AREA] Applying shopping filter:',\r\n      shoppingIds.length === 0 ? 'ALL' : `${shoppingIds.length} shoppings`\r\n    );\r\n\r\n    // Update STATE and reflow cards\r\n    STATE.selectedShoppingIds = shoppingIds;\r\n\r\n    // Render shopping filter chips\r\n    renderShoppingFilterChips(selection);\r\n\r\n    // Reflow to apply filter\r\n    reflowFromState();\r\n  });\r\n\r\n  // RFC-0093: Check for pre-existing filter when WATER_COMMON_AREA initializes\r\n  if (\r\n    window.custumersSelected &&\r\n    Array.isArray(window.custumersSelected) &&\r\n    window.custumersSelected.length > 0\r\n  ) {\r\n    LogHelper.log(\r\n      '[WATER_COMMON_AREA] ðŸ”„ Applying pre-existing filter:',\r\n      window.custumersSelected.length,\r\n      'shoppings'\r\n    );\r\n    const shoppingIds = window.custumersSelected.map((s) => s.value).filter((v) => v);\r\n    STATE.selectedShoppingIds = shoppingIds;\r\n    renderShoppingFilterChips(window.custumersSelected);\r\n  }\r\n\r\n  // Test if listener is working\r\n  setTimeout(() => {\r\n    LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] ðŸ§ª Testing listener registration...`);\r\n    if (typeof dateUpdateHandler === 'function') {\r\n      LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] âœ… dateUpdateHandler is defined and ready`);\r\n    } else {\r\n      LogHelper.error(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] âŒ dateUpdateHandler is NOT defined!`);\r\n    }\r\n  }, 100);\r\n\r\n  dataProvideHandler = function (ev) {\r\n    LogHelper.log(\r\n      `[WATER_COMMON_AREA ${WIDGET_DOMAIN}] ðŸ“¦ Received provide-data event for domain ${\r\n        ev.detail.domain\r\n      }, periodKey: ${ev.detail.periodKey}, items: ${ev.detail.items?.length || 0}`\r\n    );\r\n    const { domain, periodKey, items } = ev.detail;\r\n\r\n    if (domain !== WIDGET_DOMAIN) {\r\n      LogHelper.log(\r\n        `[WATER_COMMON_AREA ${WIDGET_DOMAIN}] â­ï¸ Ignoring event for domain ${domain}, my domain is ${WIDGET_DOMAIN}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (lastProcessedPeriodKey === periodKey) {\r\n      LogHelper.log(`[WATER_COMMON_AREA] â­ï¸ Skipping duplicate provide-data for periodKey: ${periodKey}`);\r\n      return;\r\n    }\r\n\r\n    const myPeriod = {\r\n      startISO: self.ctx.scope?.startDateISO,\r\n      endISO: self.ctx.scope?.endDateISO,\r\n    };\r\n\r\n    if (!myPeriod.startISO || !myPeriod.endISO) {\r\n      LogHelper.warn(\r\n        `[WATER_COMMON_AREA] â¸ï¸ Period not set yet, storing provide-data event for later processing`\r\n      );\r\n      return;\r\n    }\r\n\r\n    lastProcessedPeriodKey = periodKey;\r\n\r\n    LogHelper.log(`[WATER_COMMON_AREA] ðŸ”„ Processing data from orchestrator...`);\r\n    LogHelper.log(\r\n      `[WATER_COMMON_AREA] Received ${items.length} items from orchestrator for domain ${domain}`\r\n    );\r\n\r\n    const myDatasourceIds = extractDatasourceIds(self.ctx.datasources);\r\n    const datasourceIdSet = new Set(myDatasourceIds);\r\n    let filtered = items.filter((item) => {\r\n      return datasourceIdSet.has(item.id) || datasourceIdSet.has(item.tbId);\r\n    });\r\n\r\n    LogHelper.log(\r\n      `[WATER_COMMON_AREA] Filtered ${items.length} items down to ${filtered.length} items matching datasources`\r\n    );\r\n\r\n    if (filtered.length === 0) {\r\n      LogHelper.warn(`[WATER_COMMON_AREA] No items match datasource IDs! Using all items as fallback.`);\r\n      filtered = items;\r\n    }\r\n\r\n    filtered = filtered.map((item) => ({\r\n      id: item.tbId || item.id,\r\n      tbId: item.tbId || item.id,\r\n      ingestionId: item.ingestionId || item.id,\r\n      identifier: item.identifier || item.id,\r\n      label: item.label || item.identifier || item.id,\r\n      value: Number(item.value || 0),\r\n      perc: 0,\r\n      deviceType: item.deviceType || 'HIDROMETRO',\r\n      slaveId: item.slaveId || null,\r\n      centralId: item.centralId || null,\r\n      updatedIdentifiers: {},\r\n    }));\r\n\r\n    LogHelper.log(`[WATER_COMMON_AREA] Using ${filtered.length} items after processing`);\r\n\r\n    if (!STATE.itemsBase || STATE.itemsBase.length === 0) {\r\n      LogHelper.log(`[WATER_COMMON_AREA] Building itemsBase from TB data...`);\r\n      STATE.itemsBase = buildAuthoritativeItems();\r\n      LogHelper.log(`[WATER_COMMON_AREA] Built ${STATE.itemsBase.length} items from TB`);\r\n    }\r\n\r\n    const orchestratorValues = new Map();\r\n    filtered.forEach((item) => {\r\n      if (item.ingestionId) {\r\n        const value = Number(item.value || 0);\r\n        orchestratorValues.set(item.ingestionId, value);\r\n      }\r\n    });\r\n    LogHelper.log(`[WATER_COMMON_AREA] Orchestrator values map size: ${orchestratorValues.size}`);\r\n\r\n    STATE.itemsEnriched = STATE.itemsBase.map((tbItem) => {\r\n      const orchestratorValue = orchestratorValues.get(tbItem.ingestionId);\r\n\r\n      return {\r\n        ...tbItem,\r\n        value: orchestratorValue !== undefined ? orchestratorValue : tbItem.value || 0,\r\n        perc: 0,\r\n      };\r\n    });\r\n\r\n    LogHelper.log(\r\n      `[WATER_COMMON_AREA] Enriched ${STATE.itemsEnriched.length} items with orchestrator values`\r\n    );\r\n\r\n    if (STATE.selectedIds && STATE.selectedIds.size) {\r\n      const valid = new Set(STATE.itemsBase.map((x) => String(x.id)));\r\n      const next = new Set([...STATE.selectedIds].filter((id) => valid.has(String(id))));\r\n      STATE.selectedIds = next.size ? next : null;\r\n    }\r\n\r\n    reflowFromState();\r\n\r\n    LogHelper.log(`[WATER_COMMON_AREA] ðŸ Data processed successfully - ensuring busy is hidden`);\r\n\r\n    setTimeout(() => {\r\n      hideBusy();\r\n      if (window.MyIOOrchestrator && window.MyIOOrchestrator.getBusyState) {\r\n        const busyState = window.MyIOOrchestrator.getBusyState();\r\n        if (busyState.isVisible) {\r\n          LogHelper.warn(\r\n            `[WATER_COMMON_AREA] âš ï¸ Orchestrator busy still visible after data processing - force hiding`\r\n          );\r\n          window.MyIOOrchestrator.hideGlobalBusy();\r\n        }\r\n      }\r\n    }, 100);\r\n  };\r\n\r\n  /**\r\n   * Extracts ingestionIds from ThingsBoard ctx.data\r\n   * RFC-0094: Only extracts from 'HidrometrosAreaComum' alias\r\n   */\r\n  function extractDatasourceIds(datasources) {\r\n    const ingestionIds = new Set();\r\n    const rows = Array.isArray(self.ctx?.data) ? self.ctx.data : [];\r\n\r\n    for (const row of rows) {\r\n      // RFC-0094: Filter by aliasName = 'HidrometrosAreaComum'\r\n      const aliasName = row?.datasource?.aliasName || '';\r\n      if (aliasName !== 'HidrometrosAreaComum') continue;\r\n\r\n      const key = String(row?.dataKey?.name || '').toLowerCase();\r\n      const val = row?.data?.[0]?.[1];\r\n\r\n      if (key === 'ingestionid' && val && isValidUUID(String(val))) {\r\n        ingestionIds.add(String(val));\r\n      }\r\n    }\r\n\r\n    return Array.from(ingestionIds);\r\n  }\r\n\r\n  window.addEventListener('myio:telemetry:provide-data', dataProvideHandler);\r\n\r\n  // FIX: Add handler for myio:water-data-ready from MAIN waterCache\r\n  waterDataReadyHandler = function (ev) {\r\n    const { cache, fromCache } = ev.detail || {};\r\n\r\n    // Only process if cache is a Map with data\r\n    if (!(cache instanceof Map) || cache.size === 0) {\r\n      LogHelper.log('[WATER_COMMON_AREA] Ignoring water-data-ready: no cache or empty');\r\n      return;\r\n    }\r\n\r\n    LogHelper.log(\r\n      `[WATER_COMMON_AREA] ðŸ“¦ Received water-data-ready: ${cache.size} devices (fromCache: ${fromCache})`\r\n    );\r\n\r\n    // Check if widget has items to enrich\r\n    if (!STATE.itemsBase || STATE.itemsBase.length === 0) {\r\n      LogHelper.log('[WATER_COMMON_AREA] No itemsBase yet, building...');\r\n      STATE.itemsBase = buildAuthoritativeItems();\r\n    }\r\n\r\n    if (STATE.itemsBase.length === 0) {\r\n      LogHelper.warn('[WATER_COMMON_AREA] Still no items after buildAuthoritativeItems, skipping');\r\n      return;\r\n    }\r\n\r\n    // Enrich items with data from MAIN waterCache\r\n    STATE.itemsEnriched = enrichItemsWithTotals(STATE.itemsBase, cache);\r\n    LogHelper.log(`[WATER_COMMON_AREA] Enriched ${STATE.itemsEnriched.length} items from MAIN waterCache`);\r\n\r\n    // Render\r\n    reflowFromState();\r\n  };\r\n\r\n  window.addEventListener('myio:water-data-ready', waterDataReadyHandler);\r\n\r\n  // Listener para dados TB centralizados do MAIN (datasources HidrometrosAreaComum)\r\n  waterTbDataHandler = (ev) => {\r\n    const { commonArea } = ev.detail || {};\r\n    if (commonArea && commonArea.datasources) {\r\n      mainWaterData = {\r\n        datasources: commonArea.datasources,\r\n        data: commonArea.data,\r\n        ids: commonArea.ids,\r\n        loaded: true,\r\n      };\r\n      LogHelper.log(\r\n        `[WATER_COMMON_AREA] Received TB data from MAIN: ${commonArea.datasources.length} datasources, ${commonArea.ids.length} IDs`\r\n      );\r\n\r\n      // Rebuild items with new data\r\n      STATE.itemsBase = buildAuthoritativeItems();\r\n      LogHelper.log(`[WATER_COMMON_AREA] Rebuilt ${STATE.itemsBase.length} items from MAIN data`);\r\n\r\n      // Se jÃ¡ tiver cache de Ã¡gua disponÃ­vel, enriquecer e renderizar\r\n      const waterCache = window.MyIOOrchestrator?.getWaterCache?.();\r\n      if (waterCache && waterCache.size > 0) {\r\n        STATE.itemsEnriched = enrichItemsWithTotals(STATE.itemsBase, waterCache);\r\n        reflowFromState();\r\n      }\r\n    }\r\n  };\r\n  window.addEventListener('myio:water-tb-data-ready', waterTbDataHandler);\r\n\r\n  // Verificar se os dados jÃ¡ estÃ£o disponÃ­veis (evento jÃ¡ disparado antes do widget carregar)\r\n  const cachedTbData = window.MyIOUtils?.getWaterTbData?.();\r\n  if (cachedTbData?.loaded && cachedTbData?.commonArea?.datasources?.length > 0) {\r\n    LogHelper.log('[WATER_COMMON_AREA] Found cached TB data from MAIN, loading...');\r\n    mainWaterData = {\r\n      datasources: cachedTbData.commonArea.datasources,\r\n      data: cachedTbData.commonArea.data,\r\n      ids: cachedTbData.commonArea.ids,\r\n      loaded: true,\r\n    };\r\n    STATE.itemsBase = buildAuthoritativeItems();\r\n    LogHelper.log(`[WATER_COMMON_AREA] Built ${STATE.itemsBase.length} items from cached MAIN data`);\r\n  }\r\n\r\n  // RFC-0094: Use credentials from MAIN via MyIOUtils (already fetched by MAIN)\r\n  const jwt = localStorage.getItem('jwt_token');\r\n\r\n  const mainCredentials = window.MyIOUtils?.getCredentials?.();\r\n  if (mainCredentials?.clientId && mainCredentials?.clientSecret) {\r\n    CLIENT_ID = mainCredentials.clientId;\r\n    CLIENT_SECRET = mainCredentials.clientSecret;\r\n    CUSTOMER_ING_ID = mainCredentials.customerIngestionId || '';\r\n    LogHelper.log('[WATER_COMMON_AREA] Using credentials from MAIN (MyIOUtils)');\r\n  } else {\r\n    LogHelper.log('[WATER_COMMON_AREA] MAIN credentials not available, fetching directly...');\r\n    const customerTB_ID = window.MyIOUtils?.getCustomerId?.() || self.ctx.settings?.customerTB_ID || '';\r\n\r\n    try {\r\n      const attrs = await MyIO.fetchThingsboardCustomerAttrsFromStorage(customerTB_ID, jwt);\r\n      CLIENT_ID = attrs?.client_id || '';\r\n      CLIENT_SECRET = attrs?.client_secret || '';\r\n      CUSTOMER_ING_ID = attrs?.ingestionId || '';\r\n    } catch (err) {\r\n      LogHelper.error('[WATER_COMMON_AREA] Failed to fetch credentials:', err);\r\n    }\r\n  }\r\n\r\n  // Initialize auth if we have credentials\r\n  if (CLIENT_ID && CLIENT_SECRET) {\r\n    try {\r\n      MyIOAuth = MyIO.buildMyioIngestionAuth({\r\n        dataApiHost: getDataApiHost(),\r\n        clientId: CLIENT_ID,\r\n        clientSecret: CLIENT_SECRET,\r\n      });\r\n\r\n      LogHelper.log('[WATER_COMMON_AREA] Auth init OK');\r\n      try {\r\n        await MyIOAuth.getToken();\r\n      } catch (_e) {\r\n        /* ignore token errors */\r\n      }\r\n    } catch (err) {\r\n      LogHelper.error('[WATER_COMMON_AREA] Auth init FAIL', err);\r\n    }\r\n  } else {\r\n    LogHelper.warn('[WATER_COMMON_AREA] No credentials available for auth initialization');\r\n  }\r\n\r\n  // Bind UI\r\n  bindHeader();\r\n  bindModal();\r\n\r\n  // ---------- Datas iniciais: \"Current Month So Far\" ----------\r\n  if (!self.ctx?.scope?.startDateISO || !self.ctx?.scope?.endDateISO) {\r\n    const now = new Date();\r\n    const start = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0);\r\n    const end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 0);\r\n    self.ctx.scope = self.ctx.scope || {};\r\n    self.ctx.scope.startDateISO = start.toISOString();\r\n    self.ctx.scope.endDateISO = end.toISOString();\r\n  }\r\n\r\n  const hasData = Array.isArray(self.ctx.data) && self.ctx.data.length > 0;\r\n  LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] onInit - Waiting for orchestrator data...`);\r\n\r\n  if (hasData && (!STATE.itemsBase || STATE.itemsBase.length === 0)) {\r\n    LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] Building itemsBase from TB data in onInit...`);\r\n    STATE.itemsBase = buildAuthoritativeItems();\r\n    LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] Built ${STATE.itemsBase.length} items from TB`);\r\n\r\n    STATE.itemsEnriched = STATE.itemsBase.map((item) => ({\r\n      ...item,\r\n      value: 0,\r\n      perc: 0,\r\n    }));\r\n    reflowFromState();\r\n  }\r\n\r\n  if (self.ctx?.scope?.startDateISO && self.ctx?.scope?.endDateISO) {\r\n    LogHelper.log(`[WATER_COMMON_AREA ${WIDGET_DOMAIN}] Initial period defined, showing busy...`);\r\n    showBusy();\r\n  } else {\r\n    LogHelper.log(\r\n      `[WATER_COMMON_AREA ${WIDGET_DOMAIN}] No initial period, waiting for myio:update-date event...`\r\n    );\r\n  }\r\n\r\n  if (hasData) {\r\n    STATE.firstHydrates++;\r\n    if (STATE.firstHydrates <= MAX_FIRST_HYDRATES) {\r\n      await hydrateAndRender();\r\n    }\r\n  } else {\r\n    const waiter = setInterval(async () => {\r\n      if (Array.isArray(self.ctx.data) && self.ctx.data.length > 0) {\r\n        clearInterval(waiter);\r\n        STATE.firstHydrates++;\r\n        if (STATE.firstHydrates <= MAX_FIRST_HYDRATES) await hydrateAndRender();\r\n      }\r\n    }, 200);\r\n  }\r\n};\r\n\r\nself.onDataUpdated = function () {\r\n  /* no-op */\r\n};\r\n\r\nself.onResize = function () {};\r\n\r\nself.onDestroy = function () {\r\n  if (dateUpdateHandler) {\r\n    window.removeEventListener('myio:update-date', dateUpdateHandler);\r\n    LogHelper.log(\"[WATER_COMMON_AREA] Event listener 'myio:update-date' removido.\");\r\n  }\r\n  if (dataProvideHandler) {\r\n    window.removeEventListener('myio:telemetry:provide-data', dataProvideHandler);\r\n    LogHelper.log(\"[WATER_COMMON_AREA] Event listener 'myio:telemetry:provide-data' removido.\");\r\n  }\r\n  if (waterDataReadyHandler) {\r\n    window.removeEventListener('myio:water-data-ready', waterDataReadyHandler);\r\n    LogHelper.log(\"[WATER_COMMON_AREA] Event listener 'myio:water-data-ready' removido.\");\r\n  }\r\n  if (waterTbDataHandler) {\r\n    window.removeEventListener('myio:water-tb-data-ready', waterTbDataHandler);\r\n    LogHelper.log(\"[WATER_COMMON_AREA] Event listener 'myio:water-tb-data-ready' removido.\");\r\n  }\r\n\r\n  // RFC-0094: Cleanup header controller\r\n  if (waterCommonAreaHeaderController) {\r\n    waterCommonAreaHeaderController.destroy();\r\n    waterCommonAreaHeaderController = null;\r\n    LogHelper.log('[WATER_COMMON_AREA] [RFC-0094] Header controller destroyed');\r\n  }\r\n\r\n  // RFC-0094: Cleanup filter modal using shared factory\r\n  if (waterCommonAreaFilterModal) {\r\n    waterCommonAreaFilterModal.destroy();\r\n    waterCommonAreaFilterModal = null;\r\n    LogHelper.log('[WATER_COMMON_AREA] [RFC-0094] Filter modal destroyed');\r\n  }\r\n\r\n  try {\r\n    $root().off();\r\n  } catch (_e) {\r\n    /* ignore cleanup errors */\r\n  }\r\n  hideBusy();\r\n  hideGlobalSuccessModal();\r\n};\r\n",
      "settingsSchema": "{\r\n  \"schema\": {\r\n    \"type\": \"object\",\r\n    \"title\": \"Water Common Area Widget Settings\",\r\n    \"properties\": {\r\n        \"labelWidget\":{\r\n            \"type\":\"string\",\r\n            \"title\": \"Widget Label\",\r\n            \"default\": \"HidrÃ´metros de Ãreas Comuns\"\r\n        },\r\n        \"useNewComponents\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Use New Components\",\r\n            \"default\": true\r\n        },\r\n        \"enableSelection\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Enable Selection\",\r\n            \"default\": true\r\n        },\r\n        \"enableDragDrop\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Enable Drag Drop\",\r\n            \"default\": true\r\n        },\r\n        \"hideInfoMenuItem\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Hide Info Menu Item\",\r\n            \"default\": true\r\n        },\r\n        \"debugActive\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Debug Active\",\r\n            \"default\": false\r\n        },\r\n        \"activeTooltipDebug\":{\r\n            \"type\":\"boolean\",\r\n            \"title\": \"Active Tooltip Debug\",\r\n            \"default\": false\r\n        }\r\n    }\r\n  },\r\n  \"form\": [\r\n    \"labelWidget\",\r\n    \"useNewComponents\",\r\n    \"enableSelection\",\r\n    \"enableDragDrop\",\r\n    \"hideInfoMenuItem\",\r\n    \"debugActive\",\r\n    \"activeTooltipDebug\"\r\n  ]\r\n}\r\n",
      "dataKeySettingsSchema": "{}\n",
      "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Widget Head Office - WATER COMMON AREA- v.5.2.0\",\"decimals\":null}"
    },
    "externalId": null,
    "resources": null,
    "id": {
      "entityType": "WIDGET_TYPE",
      "id": "13bec7a0-cec3-11f0-998e-25174baff087"
    },
    "scada": false,
    "tags": null
  },
  "relations": [],
  "attributes": {
    "SERVER_SCOPE": []
  }
}